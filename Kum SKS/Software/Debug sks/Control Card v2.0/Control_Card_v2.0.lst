CCS PCD C Compiler, Version 5.008, 5967               26-Kas-14 03:29

               Filename:   C:\Users\Onur Yarkýnoðlu\Desktop\Debug sks\Control Card v2.0\Control_Card_v2.0.lst

               ROM used:   7978 bytes (8%)
                           Largest free fragment is 57558
               RAM used:   342 (4%) at main() level
                           554 (7%) worst case
               Stack used: 98 locations
               Stack size: 128

*
00000:  GOTO    1D5C
*
00026:  DATA    54,08,00
*
00044:  DATA    82,08,00
.................... #INCLUDE <30f6015.h>  
.................... //////// Standard Header file for the DSPIC30F6015 device //////////////// 
.................... #device DSPIC30F6015 
*
00100:  CLR     32
00102:  MOV     #1D2,W3
00104:  SUB     W0,W3,W3
00106:  BRA     C,110
00108:  MOV     #120,W3
0010A:  ADD     W3,W0,W0
0010C:  TBLRDL  [W0],W0
0010E:  RETURN  
00110:  MOV     #120,W0
00112:  ADD     W3,W3,W3
00114:  ADD     W3,W0,W3
00116:  TBLRDH  [W3++],W0
00118:  TBLRDH  [W3],W3
0011A:  SL      W3,#8,W3
0011C:  IOR      W3,  W0,W0
0011E:  RETURN  
00120:  DATA    C4,09,82
00122:  DATA    C4,09,02
00124:  DATA    C4,09,79
00126:  DATA    C4,09,02
00128:  DATA    C3,09,6F
0012A:  DATA    C2,09,02
0012C:  DATA    C2,09,66
0012E:  DATA    C1,09,02
00130:  DATA    C0,09,5D
00132:  DATA    BE,09,02
00134:  DATA    BD,09,53
00136:  DATA    BC,09,02
00138:  DATA    BA,09,4A
0013A:  DATA    B9,09,02
0013C:  DATA    B7,09,41
0013E:  DATA    B5,09,02
00140:  DATA    B3,09,38
00142:  DATA    B1,09,02
00144:  DATA    AF,09,2F
00146:  DATA    AD,09,02
00148:  DATA    AB,09,26
0014A:  DATA    A8,09,02
0014C:  DATA    A6,09,1C
0014E:  DATA    A3,09,02
00150:  DATA    A0,09,14
00152:  DATA    9D,09,02
00154:  DATA    9A,09,0B
00156:  DATA    97,09,02
00158:  DATA    94,09,02
0015A:  DATA    91,09,02
0015C:  DATA    8D,09,F9
0015E:  DATA    8A,09,01
00160:  DATA    86,09,F0
00162:  DATA    82,09,01
00164:  DATA    7E,09,E7
00166:  DATA    7B,09,01
00168:  DATA    77,09,DF
0016A:  DATA    72,09,01
0016C:  DATA    6E,09,D6
0016E:  DATA    6A,09,01
00170:  DATA    66,09,CE
00172:  DATA    61,09,01
00174:  DATA    5D,09,C5
00176:  DATA    58,09,01
00178:  DATA    53,09,BD
0017A:  DATA    4E,09,01
0017C:  DATA    49,09,B4
0017E:  DATA    44,09,01
00180:  DATA    3F,09,AC
00182:  DATA    3A,09,01
00184:  DATA    35,09,A4
00186:  DATA    2F,09,01
00188:  DATA    2A,09,9B
0018A:  DATA    24,09,01
0018C:  DATA    1F,09,93
0018E:  DATA    19,09,01
00190:  DATA    13,09,8B
00192:  DATA    0D,09,01
00194:  DATA    07,09,83
00196:  DATA    01,09,01
00198:  DATA    FB,08,7B
0019A:  DATA    F5,08,01
0019C:  DATA    EF,08,73
0019E:  DATA    E8,08,01
001A0:  DATA    E2,08,6B
001A2:  DATA    DB,08,01
001A4:  DATA    D5,08,64
001A6:  DATA    CE,08,01
001A8:  DATA    C7,08,5C
001AA:  DATA    C0,08,01
001AC:  DATA    BA,08,54
001AE:  DATA    B3,08,01
001B0:  DATA    AC,08,4D
001B2:  DATA    A4,08,01
001B4:  DATA    9D,08,45
001B6:  DATA    96,08,01
001B8:  DATA    8F,08,3E
001BA:  DATA    87,08,01
001BC:  DATA    80,08,36
001BE:  DATA    78,08,01
001C0:  DATA    71,08,2F
001C2:  DATA    69,08,01
001C4:  DATA    61,08,28
001C6:  DATA    5A,08,01
001C8:  DATA    52,08,21
001CA:  DATA    4A,08,01
001CC:  DATA    42,08,19
001CE:  DATA    3A,08,01
001D0:  DATA    32,08,12
001D2:  DATA    2A,08,01
001D4:  DATA    21,08,0B
001D6:  DATA    19,08,01
001D8:  DATA    11,08,04
001DA:  DATA    08,08,01
001DC:  DATA    00,08,FE
001DE:  DATA    F7,07,00
001E0:  DATA    EF,07,F7
001E2:  DATA    E6,07,00
001E4:  DATA    DE,07,F0
001E6:  DATA    D5,07,00
001E8:  DATA    CC,07,EA
001EA:  DATA    C3,07,00
001EC:  DATA    BA,07,E3
001EE:  DATA    B1,07,00
001F0:  DATA    A8,07,DD
001F2:  DATA    9F,07,00
001F4:  DATA    96,07,D6
001F6:  DATA    8D,07,00
001F8:  DATA    84,07,D0
001FA:  DATA    7B,07,00
001FC:  DATA    72,07,CA
001FE:  DATA    68,07,00
00200:  DATA    5F,07,C4
00202:  DATA    56,07,00
00204:  DATA    4C,07,BE
00206:  DATA    43,07,00
00208:  DATA    39,07,B8
0020A:  DATA    30,07,00
0020C:  DATA    26,07,B2
0020E:  DATA    1C,07,00
00210:  DATA    13,07,AC
00212:  DATA    09,07,00
00214:  DATA    FF,06,A6
00216:  DATA    F5,06,00
00218:  DATA    EC,06,A1
0021A:  DATA    E2,06,00
0021C:  DATA    D8,06,9B
0021E:  DATA    CE,06,00
00220:  DATA    C4,06,96
00222:  DATA    BA,06,00
00224:  DATA    B0,06,90
00226:  DATA    A6,06,00
00228:  DATA    9C,06,8B
0022A:  DATA    92,06,00
0022C:  DATA    88,06,86
0022E:  DATA    7D,06,00
00230:  DATA    73,06,81
00232:  DATA    69,06,00
00234:  DATA    5F,06,7C
00236:  DATA    54,06,00
00238:  DATA    4A,06,77
0023A:  DATA    40,06,00
0023C:  DATA    36,06,72
0023E:  DATA    2B,06,00
00240:  DATA    21,06,6D
00242:  DATA    16,06,00
00244:  DATA    0C,06,68
00246:  DATA    01,06,00
00248:  DATA    F7,05,64
0024A:  DATA    ED,05,00
0024C:  DATA    E2,05,5F
0024E:  DATA    D8,05,00
00250:  DATA    CD,05,5B
00252:  DATA    C2,05,00
00254:  DATA    B8,05,57
00256:  DATA    AD,05,00
00258:  DATA    A3,05,53
0025A:  DATA    98,05,00
0025C:  DATA    8D,05,4E
0025E:  DATA    83,05,00
00260:  DATA    78,05,4A
00262:  DATA    6E,05,00
00264:  DATA    63,05,46
00266:  DATA    58,05,00
00268:  DATA    4E,05,43
0026A:  DATA    43,05,00
0026C:  DATA    38,05,3F
0026E:  DATA    2D,05,00
00270:  DATA    23,05,3B
00272:  DATA    18,05,00
00274:  DATA    0D,05,38
00276:  DATA    03,05,00
00278:  DATA    F8,04,34
0027A:  DATA    ED,04,00
0027C:  DATA    E2,04,31
0027E:  DATA    D8,04,00
00280:  DATA    CD,04,2E
00282:  DATA    C2,04,00
00284:  DATA    B8,04,2B
00286:  DATA    AD,04,00
00288:  DATA    A2,04,28
0028A:  DATA    98,04,00
0028C:  DATA    8D,04,25
0028E:  DATA    82,04,00
00290:  DATA    77,04,22
00292:  DATA    6D,04,00
00294:  DATA    62,04,1F
00296:  DATA    57,04,00
00298:  DATA    4D,04,1D
0029A:  DATA    42,04,00
0029C:  DATA    38,04,1A
0029E:  DATA    2D,04,00
002A0:  DATA    22,04,18
002A2:  DATA    18,04,00
002A4:  DATA    0D,04,16
002A6:  DATA    03,04,00
002A8:  DATA    F8,03,14
002AA:  DATA    ED,03,00
002AC:  DATA    E3,03,12
002AE:  DATA    D8,03,00
002B0:  DATA    CE,03,10
002B2:  DATA    C4,03,00
002B4:  DATA    B9,03,0E
002B6:  DATA    AF,03,00
002B8:  DATA    A4,03,0C
002BA:  DATA    9A,03,00
002BC:  DATA    8F,03,0B
002BE:  DATA    85,03,00
002C0:  DATA    7B,03,09
002C2:  DATA    70,03,00
002C4:  DATA    66,03,08
002C6:  DATA    5C,03,00
002C8:  DATA    52,03,07
002CA:  DATA    48,03,00
002CC:  DATA    3D,03,05
002CE:  DATA    33,03,00
002D0:  DATA    29,03,04
002D2:  DATA    1F,03,00
002D4:  DATA    15,03,03
002D6:  DATA    0B,03,00
002D8:  DATA    01,03,03
002DA:  DATA    F7,02,00
002DC:  DATA    ED,02,02
002DE:  DATA    E3,02,00
002E0:  DATA    D9,02,01
002E2:  DATA    D0,02,00
002E4:  DATA    C6,02,01
002E6:  DATA    BC,02,00
002E8:  DATA    B2,02,01
002EA:  DATA    A9,02,00
002EC:  DATA    9F,02,01
002EE:  DATA    95,02,00
002F0:  DATA    8C,02,00
002F2:  CLR     32
002F4:  MOV     #2FE,W3
002F6:  ADD     W3,W0,W0
002F8:  TBLRDL.B[W0],W0L
002FA:  CLR.B   1
002FC:  RETURN  
002FE:  DATA    0A,0D,00
00300:  DATA    09,56,00
00302:  DATA    6F,6C,00
00304:  DATA    74,61,00
00306:  DATA    67,65,00
00308:  DATA    20,44,00
0030A:  DATA    65,73,00
0030C:  DATA    69,72,00
0030E:  DATA    65,64,00
00310:  DATA    3A,20,00
00312:  DATA    25,75,00
00314:  DATA    00,00,00
00316:  CLR     32
00318:  MOV     #322,W3
0031A:  ADD     W3,W0,W0
0031C:  TBLRDL.B[W0],W0L
0031E:  CLR.B   1
00320:  RETURN  
00322:  DATA    0A,0D,00
00324:  DATA    09,54,00
00326:  DATA    61,70,00
00328:  DATA    20,44,00
0032A:  DATA    65,73,00
0032C:  DATA    69,72,00
0032E:  DATA    65,64,00
00330:  DATA    3A,20,00
00332:  DATA    25,75,00
00334:  DATA    00,00,00
00336:  CLR     32
00338:  MOV     #342,W3
0033A:  ADD     W3,W0,W0
0033C:  TBLRDL.B[W0],W0L
0033E:  CLR.B   1
00340:  RETURN  
00342:  DATA    0A,0D,00
00344:  DATA    09,56,00
00346:  DATA    6F,6C,00
00348:  DATA    74,61,00
0034A:  DATA    67,65,00
0034C:  DATA    20,43,00
0034E:  DATA    75,72,00
00350:  DATA    72,65,00
00352:  DATA    6E,74,00
00354:  DATA    3A,20,00
00356:  DATA    25,75,00
00358:  DATA    00,00,00
0035A:  CLR     32
0035C:  MOV     #366,W3
0035E:  ADD     W3,W0,W0
00360:  TBLRDL.B[W0],W0L
00362:  CLR.B   1
00364:  RETURN  
00366:  DATA    0A,0D,00
00368:  DATA    09,54,00
0036A:  DATA    61,70,00
0036C:  DATA    20,43,00
0036E:  DATA    75,72,00
00370:  DATA    72,65,00
00372:  DATA    6E,74,00
00374:  DATA    3A,20,00
00376:  DATA    25,75,00
00378:  DATA    00,00,00
0037A:  CLR     32
0037C:  MOV     #386,W3
0037E:  ADD     W3,W0,W0
00380:  TBLRDL.B[W0],W0L
00382:  CLR.B   1
00384:  RETURN  
00386:  DATA    0A,0D,00
00388:  DATA    09,56,00
0038A:  DATA    6F,6C,00
0038C:  DATA    74,61,00
0038E:  DATA    67,65,00
00390:  DATA    20,44,00
00392:  DATA    69,66,00
00394:  DATA    66,65,00
00396:  DATA    72,65,00
00398:  DATA    6E,63,00
0039A:  DATA    65,3A,00
0039C:  DATA    20,25,00
0039E:  DATA    75,00,00
003A0:  CLR     32
003A2:  MOV     #3AC,W3
003A4:  ADD     W3,W0,W0
003A6:  TBLRDL.B[W0],W0L
003A8:  CLR.B   1
003AA:  RETURN  
003AC:  DATA    0A,0D,00
003AE:  DATA    49,54,00
003B0:  DATA    45,52,00
003B2:  DATA    41,54,00
003B4:  DATA    49,4F,00
003B6:  DATA    4E,3A,00
003B8:  DATA    20,25,00
003BA:  DATA    75,00,00
003BC:  CLR     32
003BE:  MOV     #3C8,W3
003C0:  ADD     W3,W0,W0
003C2:  TBLRDL.B[W0],W0L
003C4:  CLR.B   1
003C6:  RETURN  
003C8:  DATA    0A,0D,00
003CA:  DATA    09,56,00
003CC:  DATA    6F,6C,00
003CE:  DATA    74,61,00
003D0:  DATA    67,65,00
003D2:  DATA    20,43,00
003D4:  DATA    75,72,00
003D6:  DATA    72,65,00
003D8:  DATA    6E,74,00
003DA:  DATA    20,3A,00
003DC:  DATA    20,25,00
003DE:  DATA    75,00,00
003E0:  CLR     32
003E2:  MOV     #3EC,W3
003E4:  ADD     W3,W0,W0
003E6:  TBLRDL.B[W0],W0L
003E8:  CLR.B   1
003EA:  RETURN  
003EC:  DATA    0A,0D,00
003EE:  DATA    49,74,00
003F0:  DATA    65,72,00
003F2:  DATA    61,74,00
003F4:  DATA    69,6F,00
003F6:  DATA    6E,20,00
003F8:  DATA    6C,69,00
003FA:  DATA    6D,69,00
003FC:  DATA    74,20,00
003FE:  DATA    72,65,00
00400:  DATA    61,63,00
00402:  DATA    68,65,00
00404:  DATA    64,00,00
00406:  CLR     32
00408:  MOV     #412,W3
0040A:  ADD     W3,W0,W0
0040C:  TBLRDL.B[W0],W0L
0040E:  CLR.B   1
00410:  RETURN  
00412:  DATA    0A,0D,00
00414:  DATA    46,4F,00
00416:  DATA    55,4E,00
00418:  DATA    44,21,00
0041A:  DATA    00,00,00
0041C:  CLR     32
0041E:  MOV     #428,W3
00420:  ADD     W3,W0,W0
00422:  TBLRDL.B[W0],W0L
00424:  CLR.B   1
00426:  RETURN  
00428:  DATA    0A,0D,00
0042A:  DATA    09,54,00
0042C:  DATA    61,70,00
0042E:  DATA    20,43,00
00430:  DATA    75,72,00
00432:  DATA    72,65,00
00434:  DATA    6E,74,00
00436:  DATA    20,3A,00
00438:  DATA    20,25,00
0043A:  DATA    75,00,00
0043C:  CLR     32
0043E:  MOV     #448,W3
00440:  ADD     W3,W0,W0
00442:  TBLRDL.B[W0],W0L
00444:  CLR.B   1
00446:  RETURN  
00448:  DATA    0A,0D,00
0044A:  DATA    09,50,00
0044C:  DATA    65,72,00
0044E:  DATA    63,65,00
00450:  DATA    6E,74,00
00452:  DATA    20,43,00
00454:  DATA    75,72,00
00456:  DATA    72,65,00
00458:  DATA    6E,74,00
0045A:  DATA    3A,20,00
0045C:  DATA    25,75,00
0045E:  DATA    0A,0D,00
00460:  DATA    00,00,00
00462:  CLR     32
00464:  MOV     #46E,W3
00466:  ADD     W3,W0,W0
00468:  TBLRDL.B[W0],W0L
0046A:  CLR.B   1
0046C:  RETURN  
0046E:  DATA    0A,0D,00
00470:  DATA    09,50,00
00472:  DATA    65,72,00
00474:  DATA    63,65,00
00476:  DATA    6E,74,00
00478:  DATA    20,44,00
0047A:  DATA    65,73,00
0047C:  DATA    69,72,00
0047E:  DATA    65,64,00
00480:  DATA    3A,00,00
00482:  CLR     32
00484:  MOV     #48E,W3
00486:  ADD     W3,W0,W0
00488:  TBLRDL.B[W0],W0L
0048A:  CLR.B   1
0048C:  RETURN  
0048E:  DATA    50,57,00
00490:  DATA    4D,20,00
00492:  DATA    4D,6F,00
00494:  DATA    64,75,00
00496:  DATA    6C,65,00
00498:  DATA    20,49,00
0049A:  DATA    6E,69,00
0049C:  DATA    74,69,00
0049E:  DATA    61,6C,00
004A0:  DATA    69,7A,00
004A2:  DATA    65,64,00
004A4:  DATA    0A,0A,00
004A6:  DATA    0D,00,00
004A8:  CLR     32
004AA:  MOV     #4B4,W3
004AC:  ADD     W3,W0,W0
004AE:  TBLRDL.B[W0],W0L
004B0:  CLR.B   1
004B2:  RETURN  
004B4:  DATA    50,57,00
004B6:  DATA    4D,20,00
004B8:  DATA    44,69,00
004BA:  DATA    73,61,00
004BC:  DATA    62,6C,00
004BE:  DATA    65,64,00
004C0:  DATA    0A,0D,00
004C2:  DATA    00,00,00
004C4:  CLR     32
004C6:  MOV     #4D0,W3
004C8:  ADD     W3,W0,W0
004CA:  TBLRDL.B[W0],W0L
004CC:  CLR.B   1
004CE:  RETURN  
004D0:  DATA    44,65,00
004D2:  DATA    6C,61,00
004D4:  DATA    79,3A,00
004D6:  DATA    20,25,00
004D8:  DATA    75,0A,00
004DA:  DATA    0A,0D,00
004DC:  DATA    00,00,00
004DE:  CLR     32
004E0:  MOV     #4EA,W3
004E2:  ADD     W3,W0,W0
004E4:  TBLRDL.B[W0],W0L
004E6:  CLR.B   1
004E8:  RETURN  
004EA:  DATA    44,69,00
004EC:  DATA    73,70,00
004EE:  DATA    6C,61,00
004F0:  DATA    63,65,00
004F2:  DATA    6D,65,00
004F4:  DATA    6E,74,00
004F6:  DATA    3A,20,00
004F8:  DATA    25,75,00
004FA:  DATA    20,28,00
004FC:  DATA    69,6E,00
004FE:  DATA    20,6D,00
00500:  DATA    6D,29,00
00502:  DATA    0A,0D,00
00504:  DATA    00,00,00
00506:  CLR     32
00508:  MOV     #512,W3
0050A:  ADD     W3,W0,W0
0050C:  TBLRDL.B[W0],W0L
0050E:  CLR.B   1
00510:  RETURN  
00512:  DATA    44,69,00
00514:  DATA    73,70,00
00516:  DATA    6C,61,00
00518:  DATA    63,65,00
0051A:  DATA    6D,65,00
0051C:  DATA    6E,74,00
0051E:  DATA    3A,20,00
00520:  DATA    25,75,00
00522:  DATA    20,28,00
00524:  DATA    69,6E,00
00526:  DATA    20,73,00
00528:  DATA    74,65,00
0052A:  DATA    70,73,00
0052C:  DATA    29,0A,00
0052E:  DATA    0D,00,00
00530:  CLR     32
00532:  MOV     #53C,W3
00534:  ADD     W3,W0,W0
00536:  TBLRDL.B[W0],W0L
00538:  CLR.B   1
0053A:  RETURN  
0053C:  DATA    41,63,00
0053E:  DATA    63,65,00
00540:  DATA    6C,65,00
00542:  DATA    72,61,00
00544:  DATA    74,69,00
00546:  DATA    6F,6E,00
00548:  DATA    20,4C,00
0054A:  DATA    69,6D,00
0054C:  DATA    69,74,00
0054E:  DATA    3A,20,00
00550:  DATA    25,75,00
00552:  DATA    0A,0D,00
00554:  DATA    00,00,00
00556:  CLR     32
00558:  MOV     #562,W3
0055A:  ADD     W3,W0,W0
0055C:  TBLRDL.B[W0],W0L
0055E:  CLR.B   1
00560:  RETURN  
00562:  DATA    44,65,00
00564:  DATA    63,65,00
00566:  DATA    6C,65,00
00568:  DATA    72,61,00
0056A:  DATA    74,69,00
0056C:  DATA    6F,6E,00
0056E:  DATA    20,4C,00
00570:  DATA    69,6D,00
00572:  DATA    69,74,00
00574:  DATA    3A,20,00
00576:  DATA    25,75,00
00578:  DATA    0A,0D,00
0057A:  DATA    00,00,00
0057C:  CLR     32
0057E:  MOV     #588,W3
00580:  ADD     W3,W0,W0
00582:  TBLRDL.B[W0],W0L
00584:  CLR.B   1
00586:  RETURN  
00588:  DATA    44,65,00
0058A:  DATA    63,65,00
0058C:  DATA    6C,65,00
0058E:  DATA    72,61,00
00590:  DATA    74,69,00
00592:  DATA    6F,6E,00
00594:  DATA    20,43,00
00596:  DATA    6F,75,00
00598:  DATA    6E,74,00
0059A:  DATA    3A,20,00
0059C:  DATA    25,75,00
0059E:  DATA    0A,0D,00
005A0:  DATA    00,00,00
005A2:  CLR     32
005A4:  MOV     #52,W3
005A6:  SUB     W0,W3,W3
005A8:  BRA     C,5B4
005AA:  MOV     #5BE,W3
005AC:  ADD     W3,W0,W0
005AE:  TBLRDL.B[W0],W0L
005B0:  CLR.B   1
005B2:  RETURN  
005B4:  MOV     #5BE,W0
005B6:  ADD     W3,W3,W3
005B8:  ADD     W3,W0,W3
005BA:  TBLRDH  [W3],W0
005BC:  RETURN  
005BE:  DATA    49,6E,77
005C0:  DATA    76,61,69
005C2:  DATA    6C,69,6C
005C4:  DATA    64,20,6C
005C6:  DATA    65,6E,20
005C8:  DATA    74,72,6D
005CA:  DATA    79,3A,6F
005CC:  DATA    20,53,76
005CE:  DATA    79,73,65
005D0:  DATA    74,65,20
005D2:  DATA    6D,20,74
005D4:  DATA    63,61,6F
005D6:  DATA    6E,6E,20
005D8:  DATA    6F,74,6D
005DA:  DATA    20,6D,61
005DC:  DATA    6F,76,78
005DE:  DATA    65,20,69
005E0:  DATA    74,6F,6D
005E2:  DATA    20,61,75
005E4:  DATA    20,70,6D
005E6:  DATA    6F,73,20
005E8:  DATA    69,74,70
005EA:  DATA    69,6F,6F
005EC:  DATA    6E,20,73
005EE:  DATA    62,65,73
005F0:  DATA    79,6F,69
005F2:  DATA    6E,64,62
005F4:  DATA    20,74,6C
005F6:  DATA    68,65,65
005F8:  DATA    20,6D,20
005FA:  DATA    6F,76,64
005FC:  DATA    65,6D,69
005FE:  DATA    65,6E,73
00600:  DATA    74,20,74
00602:  DATA    72,61,61
00604:  DATA    6E,67,6E
00606:  DATA    65,2E,63
00608:  DATA    20,53,65
0060A:  DATA    79,73,2E
0060C:  DATA    74,65,00
0060E:  DATA    6D,20,00
00610:  CLR     32
00612:  MOV     #61C,W3
00614:  ADD     W3,W0,W0
00616:  TBLRDL.B[W0],W0L
00618:  CLR.B   1
0061A:  RETURN  
0061C:  DATA    4D,6F,00
0061E:  DATA    76,69,00
00620:  DATA    6E,67,00
00622:  DATA    2E,2E,00
00624:  DATA    2E,0A,00
00626:  DATA    0D,00,00
00628:  CLR     32
0062A:  MOV     #634,W3
0062C:  ADD     W3,W0,W0
0062E:  TBLRDL.B[W0],W0L
00630:  CLR.B   1
00632:  RETURN  
00634:  DATA    4D,6F,00
00636:  DATA    76,69,00
00638:  DATA    6E,67,00
0063A:  DATA    20,44,00
0063C:  DATA    6F,6E,00
0063E:  DATA    65,21,00
00640:  DATA    0A,0D,00
00642:  DATA    00,00,00
00644:  CLR     32
00646:  MOV     #650,W3
00648:  ADD     W3,W0,W0
0064A:  TBLRDL.B[W0],W0L
0064C:  CLR.B   1
0064E:  RETURN  
00650:  DATA    48,6F,00
00652:  DATA    6D,69,00
00654:  DATA    6E,67,00
00656:  DATA    2E,2E,00
00658:  DATA    2E,0A,00
0065A:  DATA    0D,00,00
0065C:  CLR     32
0065E:  MOV     #668,W3
00660:  ADD     W3,W0,W0
00662:  TBLRDL.B[W0],W0L
00664:  CLR.B   1
00666:  RETURN  
00668:  DATA    48,6F,00
0066A:  DATA    6D,69,00
0066C:  DATA    6E,67,00
0066E:  DATA    20,44,00
00670:  DATA    6F,6E,00
00672:  DATA    65,21,00
00674:  DATA    0A,0D,00
00676:  DATA    00,00,00
00678:  CLR     32
0067A:  MOV     #684,W3
0067C:  ADD     W3,W0,W0
0067E:  TBLRDL.B[W0],W0L
00680:  CLR.B   1
00682:  RETURN  
00684:  DATA    53,65,00
00686:  DATA    74,20,00
00688:  DATA    43,6F,00
0068A:  DATA    6E,76,00
0068C:  DATA    65,72,00
0068E:  DATA    73,69,00
00690:  DATA    6F,6E,00
00692:  DATA    20,43,00
00694:  DATA    6F,6E,00
00696:  DATA    73,74,00
00698:  DATA    61,6E,00
0069A:  DATA    74,20,00
0069C:  DATA    54,6F,00
0069E:  DATA    28,30,00
006A0:  DATA    3C,3D,00
006A2:  DATA    58,3C,00
006A4:  DATA    3D,39,00
006A6:  DATA    39,39,00
006A8:  DATA    39,29,00
006AA:  DATA    3A,20,00
006AC:  DATA    00,00,00
006AE:  CLR     32
006B0:  MOV     #6BA,W3
006B2:  ADD     W3,W0,W0
006B4:  TBLRDL.B[W0],W0L
006B6:  CLR.B   1
006B8:  RETURN  
006BA:  DATA    44,6F,00
006BC:  DATA    6E,65,00
006BE:  DATA    21,0A,00
006C0:  DATA    0D,00,00
006C2:  CLR     32
006C4:  MOV     #6CE,W3
006C6:  ADD     W3,W0,W0
006C8:  TBLRDL.B[W0],W0L
006CA:  CLR.B   1
006CC:  RETURN  
006CE:  DATA    53,65,00
006D0:  DATA    74,20,00
006D2:  DATA    53,70,00
006D4:  DATA    65,65,00
006D6:  DATA    64,20,00
006D8:  DATA    54,6F,00
006DA:  DATA    28,30,00
006DC:  DATA    3C,3D,00
006DE:  DATA    58,3C,00
006E0:  DATA    3D,39,00
006E2:  DATA    39,39,00
006E4:  DATA    29,20,00
006E6:  DATA    28,69,00
006E8:  DATA    6E,20,00
006EA:  DATA    6D,6D,00
006EC:  DATA    2F,73,00
006EE:  DATA    29,3A,00
006F0:  DATA    20,00,00
006F2:  CLR     32
006F4:  MOV     #6FE,W3
006F6:  ADD     W3,W0,W0
006F8:  TBLRDL.B[W0],W0L
006FA:  CLR.B   1
006FC:  RETURN  
006FE:  DATA    4D,6F,00
00700:  DATA    76,65,00
00702:  DATA    20,54,00
00704:  DATA    6F,28,00
00706:  DATA    30,3C,00
00708:  DATA    3D,58,00
0070A:  DATA    3C,3D,00
0070C:  DATA    39,39,00
0070E:  DATA    39,39,00
00710:  DATA    29,3A,00
00712:  DATA    20,00,00
00714:  CLR     32
00716:  MOV     #720,W3
00718:  ADD     W3,W0,W0
0071A:  TBLRDL.B[W0],W0L
0071C:  CLR.B   1
0071E:  RETURN  
00720:  DATA    50,69,00
00722:  DATA    6E,20,00
00724:  DATA    28,78,00
00726:  DATA    2C,79,00
00728:  DATA    2C,73,00
0072A:  DATA    74,61,00
0072C:  DATA    74,65,00
0072E:  DATA    29,3A,00
00730:  DATA    20,00,00
00732:  CLR     32
00734:  MOV     #73E,W3
00736:  ADD     W3,W0,W0
00738:  TBLRDL.B[W0],W0L
0073A:  CLR.B   1
0073C:  RETURN  
0073E:  DATA    44,69,00
00740:  DATA    73,63,00
00742:  DATA    6F,6E,00
00744:  DATA    6E,65,00
00746:  DATA    63,74,00
00748:  DATA    69,6E,00
0074A:  DATA    67,20,00
0074C:  DATA    70,69,00
0074E:  DATA    6E,73,00
00750:  DATA    2E,2E,00
00752:  DATA    2E,0A,00
00754:  DATA    0D,00,00
00756:  CLR     32
00758:  MOV     #762,W3
0075A:  ADD     W3,W0,W0
0075C:  TBLRDL.B[W0],W0L
0075E:  CLR.B   1
00760:  RETURN  
00762:  DATA    43,6F,00
00764:  DATA    6E,6E,00
00766:  DATA    65,63,00
00768:  DATA    74,69,00
0076A:  DATA    6E,67,00
0076C:  DATA    20,70,00
0076E:  DATA    69,6E,00
00770:  DATA    73,2E,00
00772:  DATA    2E,2E,00
00774:  DATA    0A,0D,00
00776:  DATA    00,00,00
00778:  CLR     32
0077A:  MOV     #784,W3
0077C:  ADD     W3,W0,W0
0077E:  TBLRDL.B[W0],W0L
00780:  CLR.B   1
00782:  RETURN  
00784:  DATA    53,65,00
00786:  DATA    74,20,00
00788:  DATA    55,70,00
0078A:  DATA    20,54,00
0078C:  DATA    69,6D,00
0078E:  DATA    65,20,00
00790:  DATA    54,6F,00
00792:  DATA    28,30,00
00794:  DATA    3C,3D,00
00796:  DATA    58,3C,00
00798:  DATA    3D,39,00
0079A:  DATA    39,39,00
0079C:  DATA    39,29,00
0079E:  DATA    20,28,00
007A0:  DATA    69,6E,00
007A2:  DATA    20,6D,00
007A4:  DATA    73,29,00
007A6:  DATA    3A,20,00
007A8:  DATA    00,00,00
007AA:  CLR     32
007AC:  MOV     #7B6,W3
007AE:  ADD     W3,W0,W0
007B0:  TBLRDL.B[W0],W0L
007B2:  CLR.B   1
007B4:  RETURN  
007B6:  DATA    53,65,00
007B8:  DATA    74,20,00
007BA:  DATA    44,6F,00
007BC:  DATA    77,6E,00
007BE:  DATA    20,54,00
007C0:  DATA    69,6D,00
007C2:  DATA    65,20,00
007C4:  DATA    54,6F,00
007C6:  DATA    28,30,00
007C8:  DATA    3C,3D,00
007CA:  DATA    58,3C,00
007CC:  DATA    3D,39,00
007CE:  DATA    39,39,00
007D0:  DATA    39,29,00
007D2:  DATA    20,28,00
007D4:  DATA    69,6E,00
007D6:  DATA    20,6D,00
007D8:  DATA    73,29,00
007DA:  DATA    3A,20,00
007DC:  DATA    00,00,00
007DE:  CLR     32
007E0:  MOV     #7EA,W3
007E2:  ADD     W3,W0,W0
007E4:  TBLRDL.B[W0],W0L
007E6:  CLR.B   1
007E8:  RETURN  
007EA:  DATA    50,69,00
007EC:  DATA    6E,20,00
007EE:  DATA    53,74,00
007F0:  DATA    61,74,00
007F2:  DATA    65,20,00
007F4:  DATA    28,30,00
007F6:  DATA    3C,3D,00
007F8:  DATA    58,3C,00
007FA:  DATA    3D,36,00
007FC:  DATA    35,35,00
007FE:  DATA    33,35,00
00800:  DATA    29,3A,00
00802:  DATA    20,00,00
00804:  CLR     32
00806:  MOV     #810,W3
00808:  ADD     W3,W0,W0
0080A:  TBLRDL.B[W0],W0L
0080C:  CLR.B   1
0080E:  RETURN  
00810:  DATA    44,65,00
00812:  DATA    6D,6F,00
00814:  DATA    20,52,00
00816:  DATA    75,6E,00
00818:  DATA    2E,2E,00
0081A:  DATA    2E,00,00
0081C:  CLR     32
0081E:  MOV     #1C,W3
00820:  SUB     W0,W3,W3
00822:  BRA     C,82E
00824:  MOV     #838,W3
00826:  ADD     W3,W0,W0
00828:  TBLRDL.B[W0],W0L
0082A:  CLR.B   1
0082C:  RETURN  
0082E:  MOV     #838,W0
00830:  ADD     W3,W3,W3
00832:  ADD     W3,W0,W3
00834:  TBLRDH  [W3],W0
00836:  RETURN  
00838:  DATA    0A,0D,72
0083A:  DATA    53,4B,73
0083C:  DATA    53,20,69
0083E:  DATA    43,6F,6F
00840:  DATA    6E,74,6E
00842:  DATA    72,6F,20
00844:  DATA    6C,20,56
00846:  DATA    43,61,31
00848:  DATA    72,64,2E
0084A:  DATA    20,2D,31
0084C:  DATA    20,43,0A
0084E:  DATA    6F,64,0A
00850:  DATA    65,20,0D
00852:  DATA    56,65,00
*
00916:  MOV     W5,[W15++]
00918:  MOV     #C,W5
0091A:  REPEAT  #3
0091C:  MOV     [W5++],[W15++]
0091E:  MOV     W0,W7
00920:  MOV     W4,W9
00922:  BCLR    W4.F
00924:  CP0     W4
00926:  BRA     NZ,934
00928:  BTSC    W9.F
0092A:  BRA     930
0092C:  MOV     #0,W5
0092E:  BRA     94E
00930:  MOV     #0,W5
00932:  BRA     94E
00934:  SUB.B   W4L,#6,W5L
00936:  BRA     NC,94C
00938:  MOV     #30,W0
0093A:  BTSS    W9.F
0093C:  MOV     #20,W0
0093E:  BTSC.B  219.1
00940:  BRA     93E
00942:  MOV.B   W0L,21A
00944:  DEC     W5,W5
00946:  BRA     NN,93E
00948:  MOV     #5,W5
0094A:  BRA     94E
0094C:  MOV     W4,W5
0094E:  MOV     #6,W4
00950:  BSET    W5.E
00952:  BTSC    W9.F
00954:  BSET    W5.F
00956:  MOV     #2710,W8
00958:  REPEAT  #11
0095A:  DIV.U   W7,W8
0095C:  CALL    990
00960:  MOV     W1,W7
00962:  MOV     #3E8,W8
00964:  REPEAT  #11
00966:  DIV.U   W7,W8
00968:  CALL    990
0096C:  MOV     W1,W7
0096E:  MOV     #64,W8
00970:  REPEAT  #11
00972:  DIV.U   W7,W8
00974:  CALL    990
00978:  MOV     W1,W7
0097A:  MOV     #A,W8
0097C:  REPEAT  #11
0097E:  DIV.U   W7,W8
00980:  CALL    990
00984:  MOV     #30,W0
00986:  ADD.B   W1L,W0L,W0L
00988:  BTSC.B  219.1
0098A:  BRA     988
0098C:  MOV.B   W0L,21A
0098E:  BRA     9BE
00990:  MOV     #30,W6
00992:  CP0     W0
00994:  BRA     NZ,9B2
00996:  BTSS    W5.E
00998:  BRA     9B4
0099A:  DEC     W4,W4
0099C:  CP.B    W4L,W5L
0099E:  BRA     Z,9A4
009A0:  BTSC.B  42.0
009A2:  RETURN  
009A4:  CP0     W0
009A6:  BRA     NZ,9B2
009A8:  BTSS    W5.E
009AA:  BRA     9B4
009AC:  BTSS    W5.F
009AE:  MOV     #20,W6
009B0:  BRA     9B4
009B2:  BCLR    W5.E
009B4:  ADD.B   W6L,W0L,W0L
009B6:  BTSC.B  219.1
009B8:  BRA     9B6
009BA:  MOV.B   W0L,21A
009BC:  RETURN  
009BE:  MOV     #12,W5
009C0:  REPEAT  #3
009C2:  MOV     [--W15],[W5--]
009C4:  MOV     [--W15],W5
009C6:  RETURN  
009C8:  MOV     W5,[W15++]
009CA:  MOV     #C,W5
009CC:  REPEAT  #3
009CE:  MOV     [W5++],[W15++]
009D0:  MUL.UU  W0,W2,W4
009D2:  MUL.UU  W0,W3,W6
009D4:  BCLR.B  42.0
009D6:  ADD     W6,W5,W5
009D8:  ADDC    W7,#0,W8
009DA:  MUL.UU  W1,W2,W6
009DC:  ADDC    W6,W5,W5
009DE:  ADDC    W7,W8,W8
009E0:  MUL.UU  W1,W3,W6
009E2:  ADD     W6,W8,W8
009E4:  ADDC    #0,W7
009E6:  MOV     W7,W3
009E8:  MOV     W8,W2
009EA:  MOV     W5,W1
009EC:  MOV     W4,W0
009EE:  MOV     #12,W5
009F0:  REPEAT  #3
009F2:  MOV     [--W15],[W5--]
009F4:  MOV     [--W15],W5
009F6:  RETURN  
009F8:  MOV     W5,[W15++]
009FA:  MOV     #C,W5
009FC:  REPEAT  #3
009FE:  MOV     [W5++],[W15++]
00A00:  MOV     #0,W9
00A02:  BTSC.B  43.0
00A04:  MOV     #1,W9
00A06:  MOV     W9,[W15++]
00A08:  CLR     W4
00A0A:  CLR     W5
00A0C:  CLR     W6
00A0E:  CLR     W7
00A10:  XOR     W2,W3,W8
00A12:  BRA     Z,A36
00A14:  MOV     #20,W8
00A16:  BCLR.B  42.0
00A18:  RLC     W0,W0
00A1A:  RLC     W1,W1
00A1C:  RLC     W4,W4
00A1E:  RLC     W5,W5
00A20:  CP      W5,W3
00A22:  BRA     NZ,A26
00A24:  CPB     W4,W2
00A26:  BRA     NC,A2E
00A28:  SUB     W4,W2,W4
00A2A:  SUBB    W5,W3,W5
00A2C:  BSET.B  42.0
00A2E:  RLC     W6,W6
00A30:  RLC     W7,W7
00A32:  DEC     W8,W8
00A34:  BRA     NZ,A16
00A36:  MOV     W7,W1
00A38:  MOV     W6,W0
00A3A:  MOV     [--W15],W9
00A3C:  CP0     W9
00A3E:  BRA     Z,A42
00A40:  MOV.D   W4,W0
00A42:  MOV     #12,W5
00A44:  REPEAT  #3
00A46:  MOV     [--W15],[W5--]
00A48:  MOV     [--W15],W5
00A4A:  RETURN  
*
00F3C:  MOV     W5,[W15++]
00F3E:  MOV     #C,W5
00F40:  REPEAT  #3
00F42:  MOV     [W5++],[W15++]
00F44:  MUL.UU  W0,W2,W4
00F46:  BTSS    W3.F
00F48:  BRA     F4E
00F4A:  MUL.SS  W0,W3,W6
00F4C:  BRA     F50
00F4E:  MUL.UU  W0,W3,W6
00F50:  BCLR.B  42.0
00F52:  ADD     W6,W5,W5
00F54:  ADDC    W7,#0,W8
00F56:  BTSS    W1.F
00F58:  BRA     F5E
00F5A:  MUL.SS  W1,W2,W6
00F5C:  BRA     F60
00F5E:  MUL.UU  W1,W2,W6
00F60:  ADDC    W6,W5,W5
00F62:  ADDC    W7,W8,W8
00F64:  ADDC    #0,W9
00F66:  MUL.SS  W1,W3,W6
00F68:  ADDC    W6,W8,W8
00F6A:  ADDC    W9,W7,W7
00F6C:  MOV     W7,W3
00F6E:  MOV     W8,W2
00F70:  MOV     W5,W1
00F72:  MOV     W4,W0
00F74:  MOV     #12,W5
00F76:  REPEAT  #3
00F78:  MOV     [--W15],[W5--]
00F7A:  MOV     [--W15],W5
00F7C:  RETURN  
00F7E:  MOV     W5,[W15++]
00F80:  MOV     #C,W5
00F82:  REPEAT  #3
00F84:  MOV     [W5++],[W15++]
00F86:  MOV     #0,W9
00F88:  BTSC.B  43.0
00F8A:  MOV     #1,W9
00F8C:  MOV     W9,[W15++]
00F8E:  XOR     W1,W3,W9
00F90:  BTSS    W1.F
00F92:  BRA     F9A
00F94:  COM     W1,W1
00F96:  NEG     W0,W0
00F98:  ADDC    W1,#0,W1
00F9A:  BTSS    W3.F
00F9C:  BRA     FA4
00F9E:  COM     W3,W3
00FA0:  NEG     W2,W2
00FA2:  ADDC    W3,#0,W3
00FA4:  XOR     W2,W3,W4
00FA6:  BRA     Z,FD2
00FA8:  CLR     W4
00FAA:  CLR     W5
00FAC:  CLR     W6
00FAE:  CLR     W7
00FB0:  MOV     #20,W8
00FB2:  BCLR.B  42.0
00FB4:  RLC     W0,W0
00FB6:  RLC     W1,W1
00FB8:  RLC     W4,W4
00FBA:  RLC     W5,W5
00FBC:  CP      W5,W3
00FBE:  BRA     NZ,FC2
00FC0:  CPB     W4,W2
00FC2:  BRA     NC,FCA
00FC4:  SUB     W4,W2,W4
00FC6:  SUBB    W5,W3,W5
00FC8:  BSET.B  42.0
00FCA:  RLC     W6,W6
00FCC:  RLC     W7,W7
00FCE:  DEC     W8,W8
00FD0:  BRA     NZ,FB2
00FD2:  BTSS    W9.F
00FD4:  BRA     FE4
00FD6:  NEG     W6,W0
00FD8:  BRA     Z,FDC
00FDA:  BRA     NZ,FE0
00FDC:  NEG     W7,W1
00FDE:  BRA     FEA
00FE0:  COM     W7,W1
00FE2:  BRA     FEA
00FE4:  MOV     W7,W1
00FE6:  MOV     W6,W0
00FE8:  BRA     FEA
00FEA:  MOV     [--W15],W9
00FEC:  CP0     W9
00FEE:  BRA     Z,FF2
00FF0:  MOV.D   W4,W0
00FF2:  MOV     #12,W5
00FF4:  REPEAT  #3
00FF6:  MOV     [--W15],[W5--]
00FF8:  MOV     [--W15],W5
00FFA:  RETURN  
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10                                                    // Configures the read_adc return size as 10 bit 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                                                      // No Watch Dog Timer  
.................... #FUSES FRC                                                        // Internal Fast RC Oscillator 
.................... #FUSES NOCKSFSM                                                   // Clock Switching is disabled, fail Safe clock monitor is disabled  
.................... #FUSES NOBROWNOUT                                                 // Not reset when brownout detected  
.................... #FUSES PROTECT                                                    // Code is protected from reading  
.................... #FUSES NOWRT                                                      // Program memory not write protected  
.................... #FUSES NODEBUG                                                    // No Debug mode for ICD 
....................  
.................... #USE DELAY(clock=7370000)                                         // delay() func. adjusted for internal osc clock speed. 
*
008A6:  CP0     W0
008A8:  BTSC.B  42.1
008AA:  BRA     8B4
008AC:  REPEAT  #72D
008AE:  NOP     
008B0:  DEC     W0,W0
008B2:  BRA     NZ,8AC
008B4:  RETURN  
*
01058:  LSR     W0,#1,W0
0105A:  CP0     W0
0105C:  BTSC.B  42.1
0105E:  BRA     1066
01060:  NOP     
01062:  DEC     W0,W0
01064:  BRA     NZ,1060
01066:  RETURN  
.................... #USE RS232(stream=RS485,UART1,baud=38400,parity=N,bits=8,stop=1)  // Set UART1 as RS485 stream 
.................... #USE RS232(stream=RS232,UART2,baud=38400,parity=N,bits=8,stop=1)  // Set UART2 as RS232 stream 
....................  
.................... // Registers of the motor control PWM module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD PWM_PTCON         = 0x1C0           // PWM Time base control register 
.................... #WORD PWM_PTPER         = 0x1C4           // PWM Time base period register 
.................... #WORD PWM_PWMCON1       = 0x1C8           // PWM Control register #1 
.................... #WORD PWM_PWMCON2       = 0x1CA           // PWM Control register #2 
.................... #WORD PWM_PDC1          = 0x1D6           // PWM Duty cycle register #1 
.................... #WORD PWM_IEC2          = 0x090           // PWM Interrupt Enable Control Register 
.................... #WORD PWM_IFS2          = 0x088           // PWM Interrupt Flag Status Register 
.................... // Bits of the PTCON register 
.................... #BIT PWM_PTCON_PTEN     = PWM_PTCON.15    // PWM Time base timer enable bit 
.................... #BIT PWM_PTCON_PTOPS3   = PWM_PTCON.7     // PWM Time base output postscale select bits  
.................... #BIT PWM_PTCON_PTOPS2   = PWM_PTCON.6 
.................... #BIT PWM_PTCON_PTOPS1   = PWM_PTCON.5 
.................... #BIT PWM_PTCON_PTOPS0   = PWM_PTCON.4 
.................... #BIT PWM_PTCON_PTCKPS1  = PWM_PTCON.3     // PWM Time base input clock prescale select bits 
.................... #BIT PWM_PTCON_PTCKPS0  = PWM_PTCON.2     
.................... #BIT PWM_PTCON_PTMOD1   = PWM_PTCON.1     // PWM Time base mode select bits 
.................... #BIT PWM_PTCON_PTMOD0   = PWM_PTCON.0 
.................... // Bits of the PWMCON1 register 
.................... #BIT PWM_PWMCON1_PMOD1  = PWM_PWMCON1.8   // PWM1 I/O pin pair mode bit 
.................... #BIT PWM_PWMCON1_PEN1H  = PWM_PWMCON1.4   // PWM1H I/O pin enable bit 
.................... #BIT PWM_PWMCON1_PEN1L  = PWM_PWMCON1.0   // PWM1L I/O pin enable bit 
.................... // Bits of the PWMCON2 register   
.................... #BIT PWM_PWMCON2_IUE    = PWM_PWMCON2.2   // Immediate update enable bit 
.................... #BIT PWM_PWMCON2_OSYNC  = PWM_PWMCON2.1   // Output override synchronization bit 
.................... #BIT PWM_PWMCON2_UDIS   = PWM_PWMCON2.0   // PWM update disable bit 
.................... // Bits of the IEC2 register 
.................... #BIT PWM_IEC2_PWMIE     = PWM_IEC2.7      // PWM Interrupt enable bit  
.................... // Bits of the IFS2 register 
.................... #BIT PWM_IFS2_PWMIF     = PWM_IFS2.7      // PWM Interrupt flag status bit     
....................  
.................... // RS485 TX and RX control pins 
.................... #DEFINE TX_Enable           PIN_G3        // If high Transmit enabled. 
.................... #DEFINE RX_Disable          PIN_G2        // If low Receive enabled. 
.................... // Led pins 
.................... #DEFINE LED          PIN_B8               // Led used in debugging 
....................  
.................... // Pins used to control digital potentiometer 
.................... #DEFINE DP_CS        PIN_G9               // Digital potentiometer chip select pin assignment (active low) 
.................... #DEFINE DP_UD        PIN_G8               // Digital potentiometer up/down control pin assignment 
....................  
.................... // Pins used to control motor driver 
.................... #DEFINE MD_MS1       PIN_F0               // Step resolution select pin 1 assignment 
.................... #DEFINE MD_MS2       PIN_D7               // Step resolution select pin 2 assignment 
.................... #DEFINE MD_SR        PIN_F1               // Active mode (synchronous rectification) input pin assignment 
.................... #DEFINE MD_RESET     PIN_E0               // Reset input pin assignment (active low) 
.................... #DEFINE MD_STEP      PIN_E1               // Step input pin assignment 
.................... #DEFINE MD_ENABLE    PIN_E2               // Enable input pin assignment (active low) 
.................... #DEFINE MD_SLEEP     PIN_E3               // Sleep input pin assignment (active low) 
.................... #DEFINE MD_DIR       PIN_E4               // Direction input pin assignment 
.................... #DEFINE MD_SW        PIN_D11              // Homing switch input pin assignment 
....................  
.................... // Speed ramp states 
.................... #DEFINE HOME         0 
.................... #DEFINE ACCEL        1 
.................... #DEFINE DECEL        2 
.................... #DEFINE RUN          3 
.................... #DEFINE POS          4 
....................  
.................... // PWM module operating modes 
.................... #DEFINE FREE         0 
.................... #DEFINE SINGLE       1 
....................  
.................... // Movement direction modes 
.................... #DEFINE DOWN         0 
.................... #DEFINE UP           1 
....................  
.................... // Motor states 
.................... #DEFINE DISABLE      0 
.................... #DEFINE ENABLE       1 
....................  
.................... int1           debug_mode_dp     = 0;                 // Debug state of digital potentiometer 
.................... int1           debug_mode_md     = 0;                 // Debug state of motor driver 
.................... int1           debug_mode_pwm    = 0;                 // Debug state of motor control PWM module 
....................  
.................... unsigned int   dp_tap_limit      = 32;                // Digital potentiometer maximum tap level 
.................... unsigned int   dp_voltage_limit  = 1023;              // Digital potentiometer maximum voltage level 
....................  
.................... unsigned int   mt_voltage_limit  = 803;               // Motor torque control voltage is limited to 4V (which is defined in driver specs) 
.................... unsigned int   mt_percent_trip   = 100;               // Motor torque percent while system is moving 
....................  
.................... unsigned int   md_conv_const     = 1250;              // Constant used to convert pwm steps to actual distance in mm 
.................... unsigned int   md_move_range     = 2000;              // Movement range of the device (in 0.1 mm) 
.................... unsigned int   md_home_offset    = 100;               // Additional distance to be covered (in addition to move range) when homing the pins (in 0.1 mm) 
....................  
.................... unsigned int16 md_current_step   = 0;                 // Current step count 
.................... int            md_direction      = 1;                 // Direction variable used to increment or decrement the current step. It is 1 for upward, -1 for downward movement 
.................... unsigned int16 md_current_pos    = 0;                 // Current position 
....................  
.................... unsigned int   md_accel          = 3000;              // Acceleration of the motor (0.01 mm/s2) 
.................... unsigned int   md_decel          = 3000;              // Deceleration of the motor (0.01 mm/s2) 
.................... unsigned char  md_run_state      = 0;                 // What part of the speed ramp we are in. 
.................... unsigned int   md_decel_lim      = 0;                 // What step_pos to start decelaration 
.................... unsigned int   md_accel_lim      = 0;                 // What step_pos to end accelaration 
.................... unsigned int   md_decel_count    = 0;                 // Counter used when decelerateing to calculate step_delay. 
.................... unsigned int   md_step_count     = 0;                 // Number of PWM steps 
....................  
.................... int1           reg_md_running    = 0;                 // PWM run state flag 
.................... int1           reg_md_homing     = 0;                 // Moving to home position flag 
.................... int1           reg_demo_run      = 0;                 // Demo run flag 
.................... int1           reg_rs232_message = 0;                 // RS232 message flag 
.................... int1           reg_rs485_busy    = 0;                 // RS485 ready for communication flag 
....................  
.................... unsigned int16 reg_pin_state     = 0;                 // Register holding the pin states 
....................  
.................... unsigned int   md_min_delay                  = 1000;  // Minimum time delay (max speed) 
.................... unsigned int16 const md_max_acc_lim          = 349;   // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... unsigned int16 const delays[md_max_acc_lim]  = {2500,2500,2500,2500,2499,2498,2498,2497,2496,2494,2493,2492,2490,2489, 
.................... 2487,2485,2483,2481,2479,2477,2475,2472,2470,2467,2464,2461,2458,2455,2452,2449,2445,2442,2438,2434,2430,2427,2423,2418, 
.................... 2414,2410,2406,2401,2397,2392,2387,2382,2377,2372,2367,2362,2357,2351,2346,2340,2335,2329,2323,2317,2311,2305,2299,2293, 
.................... 2287,2280,2274,2267,2261,2254,2247,2240,2234,2227,2220,2212,2205,2198,2191,2183,2176,2168,2161,2153,2145,2138,2130,2122, 
.................... 2114,2106,2098,2090,2081,2073,2065,2056,2048,2039,2031,2022,2014,2005,1996,1987,1978,1969,1960,1951,1942,1933,1924,1915, 
.................... 1906,1896,1887,1878,1868,1859,1849,1840,1830,1820,1811,1801,1791,1781,1772,1762,1752,1742,1732,1722,1712,1702,1692,1682, 
.................... 1672,1661,1651,1641,1631,1620,1610,1600,1590,1579,1569,1558,1548,1537,1527,1517,1506,1496,1485,1474,1464,1453,1443,1432, 
.................... 1421,1411,1400,1390,1379,1368,1358,1347,1336,1325,1315,1304,1293,1283,1272,1261,1250,1240,1229,1218,1208,1197,1186,1176, 
.................... 1165,1154,1143,1133,1122,1111,1101,1090,1080,1069,1058,1048,1037,1027,1016,1005,995,984,974,964,953,943,932,922,911,901, 
.................... 891,880,870,860,850,840,829,819,809,799,789,779,769,759,749,739,729,720,710,700,690,681,671,661,652,642,633,623,614,605, 
.................... 595,586,577,568,559,550,540,532,523,514,505,496,487,479,470,462,453,445,436,428,420,411,403,395,387,379,371,363,356,348, 
.................... 340,333,325,318,310,303,296,289,281,274,267,260,254,247,240,234,227,221,214,208,202,196,190,184,178,172,166,161,155,150, 
.................... 144,139,134,129,124,119,114,109,104,100,95,91,87,83,78,74,70,67,63,59,56,52,49,46,43,40,37,34,31,29,26,24,22,20,18,16,14, 
.................... 12,11,9,8,7,5,4,3,3,2,1,1,1,1}; 
....................  
.................... // Initializes digital potentiometer 
.................... void dp_init()  
.................... { 
....................    output_high(DP_CS);                       // Chip select is active low so keep it disabled 
*
0090C:  BCLR.B  2E5.1
0090E:  BSET.B  2E9.1
....................    output_low(DP_UD);                        // Up/down control pin can be in any state 
00910:  BCLR.B  2E5.0
00912:  BCLR.B  2E9.0
00914:  RETURN  
.................... } 
.................... // Increases digital potentiometer by given tap 
.................... void dp_up(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
*
00A4C:  MOV     8B2,W0
00A4E:  MOV     8F6,W4
00A50:  CP      W4,W0
00A52:  BRA     LEU,A58
....................       tap=dp_tap_limit; 
00A54:  PUSH    8B2
00A56:  POP     8F6
....................        
....................    output_high(DP_UD);        // Set U/D to high before activating digital potentiometer 
00A58:  BCLR.B  2E5.0
00A5A:  BSET.B  2E9.0
....................    delay_us(1); 
00A5C:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
00A5E:  BCLR.B  2E5.1
00A60:  BCLR.B  2E9.1
....................    delay_us(1); 
00A62:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
00A64:  CLR     8F8
00A66:  MOV     8F8,W0
00A68:  MOV     8F6,W4
00A6A:  CP      W4,W0
00A6C:  BRA     LEU,A86
....................    { 
....................       output_low(DP_UD);      // Low part of pulse 
00A6E:  BCLR.B  2E5.0
00A70:  BCLR.B  2E9.0
....................       delay_us(1); 
00A72:  NOP     
....................       output_high(DP_UD);     // High part of pulse 
00A74:  BCLR.B  2E5.0
00A76:  BSET.B  2E9.0
....................       delay_us(1); 
00A78:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
00A7A:  BCLR.B  2E5.0
00A7C:  BCLR.B  2E9.0
....................       delay_us(1);  
00A7E:  NOP     
00A80:  INC     08F8
00A82:  GOTO    A66
....................    } 
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer   
00A86:  BCLR.B  2E5.1
00A88:  BSET.B  2E9.1
00A8A:  RETURN  
.................... } 
.................... // Decreases digital potentiometer by given tap 
.................... void dp_down(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
00A8C:  MOV     8B2,W0
00A8E:  MOV     8F6,W4
00A90:  CP      W4,W0
00A92:  BRA     LEU,A98
....................       tap=dp_tap_limit; 
00A94:  PUSH    8B2
00A96:  POP     8F6
....................        
....................    output_low(DP_UD);         // Set U/D to low before activating digital potentiometer 
00A98:  BCLR.B  2E5.0
00A9A:  BCLR.B  2E9.0
....................    delay_us(1); 
00A9C:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
00A9E:  BCLR.B  2E5.1
00AA0:  BCLR.B  2E9.1
....................    delay_us(1);             
00AA2:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
00AA4:  CLR     8F8
00AA6:  MOV     8F8,W0
00AA8:  MOV     8F6,W4
00AAA:  CP      W4,W0
00AAC:  BRA     LEU,AC0
....................    { 
....................       output_high(DP_UD);     // High part of pulse 
00AAE:  BCLR.B  2E5.0
00AB0:  BSET.B  2E9.0
....................       delay_us(1); 
00AB2:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
00AB4:  BCLR.B  2E5.0
00AB6:  BCLR.B  2E9.0
....................       delay_us(1);   
00AB8:  NOP     
00ABA:  INC     08F8
00ABC:  GOTO    AA6
....................    } 
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer 
00AC0:  BCLR.B  2E5.1
00AC2:  BSET.B  2E9.1
00AC4:  RETURN  
.................... } 
.................... // Sets digital potentiometer to given voltage 
.................... void dp_set(unsigned int voltage) 
00AC6:  MOV     W5,[W15++]
00AC8:  MOV     #3,W4
00ACA:  MOV     W4,8DE
00ACC:  CLR     8E0
00ACE:  MOV     #F,W4
00AD0:  MOV     W4,8E2
00AD2:  MOV     8DC,W4
00AD4:  MOV     8B2,W3
00AD6:  MUL.UU  W4,W3,W0
00AD8:  MOV     W0,W5
00ADA:  MOV     W5,W4
00ADC:  MOV     8B4,W3
00ADE:  REPEAT  #11
00AE0:  DIV.U   W4,W3
00AE2:  MOV     W0,8E4
00AE4:  BCLR.B  2A0.0
00AE6:  BSET.B  2A0.1
00AE8:  BTSS.B  2A0.0
00AEA:  BRA     AE8
00AEC:  PUSH    280
00AEE:  POP     8E6
00AF0:  MOV     8DC,W4
00AF2:  MOV     8E6,W3
00AF4:  SUB     W4,W3,W5
00AF6:  MOV     W5,W0
00AF8:  MOV     W5,8E8
.................... { 
....................    unsigned int iteration_limit=3;                                   // Maximum number of iterations to be performed to set voltage 
....................    unsigned int iteration=0;                                         // Number of iterations performed to set voltage 
....................    unsigned int region=15;                                           // We want the voltage to be inside this region (+/-)  
....................    unsigned int tap_desired=voltage*dp_tap_limit/dp_voltage_limit;   // Find the desired potentiometer tap 
....................    unsigned int voltage_current=read_adc();                          // Read the current voltage 
....................    unsigned int voltage_diff=abs(voltage-voltage_current);           // Find the difference between the current and desired voltage  
....................    unsigned int tap_current;                                         // Current tap value 
....................     
....................    if(debug_mode_dp) 
00AFA:  BTSS.B  8B0.0
00AFC:  BRA     BC2
....................    { 
....................       fprintf(RS232,"\n\r\tVoltage Desired: %u",voltage); 
00AFE:  MOV     #0,W1
00B00:  MOV     W1,W0
00B02:  CLR.B   1
00B04:  CALL    2F2
00B08:  INC     W1,W1
00B0A:  BTSC.B  219.1
00B0C:  BRA     B0A
00B0E:  MOV.B   W0L,21A
00B10:  MOV     #13,W0
00B12:  CPSGT   W1,W0
00B14:  BRA     B00
00B16:  MOV     8DC,W0
00B18:  MOV     #0,W4
00B1A:  CALL    916
....................       fprintf(RS232,"\n\r\tTap Desired: %u",dp_tap_limit*voltage/dp_voltage_limit); 
00B1E:  MOV     8B2,W4
00B20:  MOV     8DC,W3
00B22:  MUL.UU  W4,W3,W0
00B24:  MOV     W0,W5
00B26:  MOV     W5,W4
00B28:  MOV     8B4,W3
00B2A:  REPEAT  #11
00B2C:  DIV.U   W4,W3
00B2E:  MOV     W0,W5
00B30:  MOV     #0,W1
00B32:  MOV     W1,W0
00B34:  CLR.B   1
00B36:  CALL    316
00B3A:  INC     W1,W1
00B3C:  BTSC.B  219.1
00B3E:  BRA     B3C
00B40:  MOV.B   W0L,21A
00B42:  MOV     #F,W0
00B44:  CPSGT   W1,W0
00B46:  BRA     B32
00B48:  MOV     W5,W0
00B4A:  MOV     #0,W4
00B4C:  CALL    916
....................       fprintf(RS232,"\n\r\tVoltage Current: %u",voltage_current); 
00B50:  MOV     #0,W1
00B52:  MOV     W1,W0
00B54:  CLR.B   1
00B56:  CALL    336
00B5A:  INC     W1,W1
00B5C:  BTSC.B  219.1
00B5E:  BRA     B5C
00B60:  MOV.B   W0L,21A
00B62:  MOV     #13,W0
00B64:  CPSGT   W1,W0
00B66:  BRA     B52
00B68:  MOV     8E6,W0
00B6A:  MOV     #0,W4
00B6C:  CALL    916
....................       fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
00B70:  MOV     8B2,W4
00B72:  MOV     8E6,W3
00B74:  MUL.UU  W4,W3,W0
00B76:  MOV     W0,W5
00B78:  MOV     W5,W4
00B7A:  MOV     8B4,W3
00B7C:  REPEAT  #11
00B7E:  DIV.U   W4,W3
00B80:  MOV     W0,W5
00B82:  MOV     #0,W1
00B84:  MOV     W1,W0
00B86:  CLR.B   1
00B88:  CALL    35A
00B8C:  INC     W1,W1
00B8E:  BTSC.B  219.1
00B90:  BRA     B8E
00B92:  MOV.B   W0L,21A
00B94:  MOV     #F,W0
00B96:  CPSGT   W1,W0
00B98:  BRA     B84
00B9A:  MOV     W5,W0
00B9C:  MOV     #0,W4
00B9E:  CALL    916
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",voltage_diff); 
00BA2:  MOV     #0,W1
00BA4:  MOV     W1,W0
00BA6:  CLR.B   1
00BA8:  CALL    37A
00BAC:  INC     W1,W1
00BAE:  BTSC.B  219.1
00BB0:  BRA     BAE
00BB2:  MOV.B   W0L,21A
00BB4:  MOV     #16,W0
00BB6:  CPSGT   W1,W0
00BB8:  BRA     BA4
00BBA:  MOV     8E8,W0
00BBC:  MOV     #0,W4
00BBE:  CALL    916
....................    } 
....................     
....................    while(voltage_diff>region)                                        // Try until voltage is found 
00BC2:  MOV     8E2,W0
00BC4:  MOV     8E8,W4
00BC6:  CP      W4,W0
00BC8:  BRA     LEU,D22
....................    {                                                                 // or iteration limit is reached  
....................       if(iteration <iteration_limit)                      
00BCA:  MOV     8E0,W0
00BCC:  MOV     8DE,W4
00BCE:  CP      W4,W0
00BD0:  BRA     LEU,D00
....................       { 
....................          iteration++;                                                // Set iteration number 
00BD2:  INC     08E0
....................          tap_current=dp_tap_limit*voltage_current/dp_voltage_limit;  // Convert new voltage to tap 
00BD4:  MOV     8B2,W4
00BD6:  MOV     8E6,W3
00BD8:  MUL.UU  W4,W3,W0
00BDA:  MOV     W0,W5
00BDC:  MOV     W5,W4
00BDE:  MOV     8B4,W3
00BE0:  REPEAT  #11
00BE2:  DIV.U   W4,W3
00BE4:  MOV     W0,8EA
....................  
....................          if(tap_desired>tap_current)                                 // Set the digital potentiometer to desired tap 
00BE6:  MOV     8EA,W0
00BE8:  MOV     8E4,W4
00BEA:  CP      W4,W0
00BEC:  BRA     LEU,BFE
....................          { 
....................             dp_up(tap_desired-tap_current); 
00BEE:  MOV     8E4,W4
00BF0:  MOV     8EA,W3
00BF2:  SUB     W4,W3,W5
00BF4:  MOV     W5,8F6
00BF6:  CALL    A4C
....................          } 
00BFA:  GOTO    C32
....................          else if(tap_desired<tap_current) 
00BFE:  MOV     8E4,W0
00C00:  MOV     8EA,W4
00C02:  CP      W4,W0
00C04:  BRA     LEU,C16
....................          { 
....................             dp_down(tap_current-tap_desired); 
00C06:  MOV     8EA,W4
00C08:  MOV     8E4,W3
00C0A:  SUB     W4,W3,W5
00C0C:  MOV     W5,8F6
00C0E:  CALL    A8C
....................          } 
00C12:  GOTO    C32
....................          else                                                        // If tap level is same as the previous one and it still outside the region 
....................          {                                                           // then go one step up or down according to desired voltage 
....................             if(voltage>voltage_current) 
00C16:  MOV     8E6,W0
00C18:  MOV     8DC,W4
00C1A:  CP      W4,W0
00C1C:  BRA     LEU,C2A
....................                dp_up(1); 
00C1E:  MOV     #1,W4
00C20:  MOV     W4,8F6
00C22:  CALL    A4C
00C26:  GOTO    C32
....................             else 
....................                dp_down(1); 
00C2A:  MOV     #1,W4
00C2C:  MOV     W4,8F6
00C2E:  CALL    A8C
....................          } 
....................           
....................          delay_ms(2); 
00C32:  REPEAT  #E62
00C34:  NOP     
....................              
....................          voltage_current=read_adc();                                 // Read the new voltage 
00C36:  BCLR.B  2A0.0
00C38:  BSET.B  2A0.1
00C3A:  BTSS.B  2A0.0
00C3C:  BRA     C3A
00C3E:  PUSH    280
00C40:  POP     8E6
....................           
....................          if(voltage>voltage_current)                                 // Find the difference between the new and desired voltages for next iteration check 
00C42:  MOV     8E6,W0
00C44:  MOV     8DC,W4
00C46:  CP      W4,W0
00C48:  BRA     LEU,C56
....................             voltage_diff=voltage - voltage_current; 
00C4A:  MOV     8DC,W4
00C4C:  MOV     8E6,W3
00C4E:  SUB     W4,W3,W0
00C50:  MOV     W0,8E8
00C52:  GOTO    C5E
....................          else 
....................             voltage_diff=voltage_current - voltage; 
00C56:  MOV     8E6,W4
00C58:  MOV     8DC,W3
00C5A:  SUB     W4,W3,W0
00C5C:  MOV     W0,8E8
....................           
....................          if(debug_mode_dp) 
00C5E:  BTSS.B  8B0.0
00C60:  BRA     CFC
....................          { 
....................             fprintf(RS232,"\n\rITERATION: %u",iteration); 
00C62:  MOV     #0,W1
00C64:  MOV     W1,W0
00C66:  CLR.B   1
00C68:  CALL    3A0
00C6C:  INC     W1,W1
00C6E:  BTSC.B  219.1
00C70:  BRA     C6E
00C72:  MOV.B   W0L,21A
00C74:  MOV     #C,W0
00C76:  CPSGT   W1,W0
00C78:  BRA     C64
00C7A:  MOV     8E0,W0
00C7C:  MOV     #0,W4
00C7E:  CALL    916
....................             fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
00C82:  MOV     8B2,W4
00C84:  MOV     8E6,W3
00C86:  MUL.UU  W4,W3,W0
00C88:  MOV     W0,W5
00C8A:  MOV     W5,W4
00C8C:  MOV     8B4,W3
00C8E:  REPEAT  #11
00C90:  DIV.U   W4,W3
00C92:  MOV     W0,W5
00C94:  MOV     #0,W1
00C96:  MOV     W1,W0
00C98:  CLR.B   1
00C9A:  CALL    35A
00C9E:  INC     W1,W1
00CA0:  BTSC.B  219.1
00CA2:  BRA     CA0
00CA4:  MOV.B   W0L,21A
00CA6:  MOV     #F,W0
00CA8:  CPSGT   W1,W0
00CAA:  BRA     C96
00CAC:  MOV     W5,W0
00CAE:  MOV     #0,W4
00CB0:  CALL    916
....................             fprintf(RS232,"\n\r\tVoltage Current : %u",voltage_current); 
00CB4:  MOV     #0,W1
00CB6:  MOV     W1,W0
00CB8:  CLR.B   1
00CBA:  CALL    3BC
00CBE:  INC     W1,W1
00CC0:  BTSC.B  219.1
00CC2:  BRA     CC0
00CC4:  MOV.B   W0L,21A
00CC6:  MOV     #14,W0
00CC8:  CPSGT   W1,W0
00CCA:  BRA     CB6
00CCC:  MOV     8E6,W0
00CCE:  MOV     #0,W4
00CD0:  CALL    916
....................             fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-voltage_current)); 
00CD4:  MOV     8DC,W4
00CD6:  MOV     8E6,W3
00CD8:  SUB     W4,W3,W5
00CDA:  MOV     W5,W0
00CDC:  MOV     #0,W1
00CDE:  MOV     W1,W0
00CE0:  CLR.B   1
00CE2:  CALL    37A
00CE6:  INC     W1,W1
00CE8:  BTSC.B  219.1
00CEA:  BRA     CE8
00CEC:  MOV.B   W0L,21A
00CEE:  MOV     #16,W0
00CF0:  CPSGT   W1,W0
00CF2:  BRA     CDE
00CF4:  MOV     W5,W0
00CF6:  MOV     #0,W4
00CF8:  CALL    916
....................          } 
....................       } 
00CFC:  GOTO    D1E
....................       else 
....................       { 
....................          if(debug_mode_dp) 
00D00:  BTSS.B  8B0.0
00D02:  BRA     D1C
....................             fprintf(RS232,"\n\rIteration limit reached"); 
00D04:  MOV     #0,W1
00D06:  MOV     W1,W0
00D08:  CLR.B   1
00D0A:  CALL    3E0
00D0E:  INC     W1,W1
00D10:  BTSC.B  219.1
00D12:  BRA     D10
00D14:  MOV.B   W0L,21A
00D16:  MOV     #18,W0
00D18:  CPSGT   W1,W0
00D1A:  BRA     D06
....................          return; 
00D1C:  BRA     DCA
....................       } 
00D1E:  GOTO    BC2
....................    } 
....................     
....................    if(debug_mode_dp) 
00D22:  BTSS.B  8B0.0
00D24:  BRA     DCA
....................    { 
....................       fprintf(RS232,"\n\rFOUND!"); 
00D26:  MOV     #0,W1
00D28:  MOV     W1,W0
00D2A:  CLR.B   1
00D2C:  CALL    406
00D30:  INC     W1,W1
00D32:  BTSC.B  219.1
00D34:  BRA     D32
00D36:  MOV.B   W0L,21A
00D38:  MOV     #7,W0
00D3A:  CPSGT   W1,W0
00D3C:  BRA     D28
....................       fprintf(RS232,"\n\r\tTap Current : %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
00D3E:  MOV     8B2,W4
00D40:  MOV     8E6,W3
00D42:  MUL.UU  W4,W3,W0
00D44:  MOV     W0,W5
00D46:  MOV     W5,W4
00D48:  MOV     8B4,W3
00D4A:  REPEAT  #11
00D4C:  DIV.U   W4,W3
00D4E:  MOV     W0,W5
00D50:  MOV     #0,W1
00D52:  MOV     W1,W0
00D54:  CLR.B   1
00D56:  CALL    41C
00D5A:  INC     W1,W1
00D5C:  BTSC.B  219.1
00D5E:  BRA     D5C
00D60:  MOV.B   W0L,21A
00D62:  MOV     #10,W0
00D64:  CPSGT   W1,W0
00D66:  BRA     D52
00D68:  MOV     W5,W0
00D6A:  MOV     #0,W4
00D6C:  CALL    916
....................       fprintf(RS232,"\n\r\tVoltage Current : %u",read_adc()); 
00D70:  BCLR.B  2A0.0
00D72:  BSET.B  2A0.1
00D74:  BTSS.B  2A0.0
00D76:  BRA     D74
00D78:  MOV     280,W5
00D7A:  MOV     #0,W1
00D7C:  MOV     W1,W0
00D7E:  CLR.B   1
00D80:  CALL    3BC
00D84:  INC     W1,W1
00D86:  BTSC.B  219.1
00D88:  BRA     D86
00D8A:  MOV.B   W0L,21A
00D8C:  MOV     #14,W0
00D8E:  CPSGT   W1,W0
00D90:  BRA     D7C
00D92:  MOV     W5,W0
00D94:  MOV     #0,W4
00D96:  CALL    916
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-read_adc())); 
00D9A:  BCLR.B  2A0.0
00D9C:  BSET.B  2A0.1
00D9E:  BTSS.B  2A0.0
00DA0:  BRA     D9E
00DA2:  MOV     280,W0
00DA4:  MOV     8DC,W4
00DA6:  SUB     W4,W0,W5
00DA8:  MOV     W5,W0
00DAA:  MOV     #0,W1
00DAC:  MOV     W1,W0
00DAE:  CLR.B   1
00DB0:  CALL    37A
00DB4:  INC     W1,W1
00DB6:  BTSC.B  219.1
00DB8:  BRA     DB6
00DBA:  MOV.B   W0L,21A
00DBC:  MOV     #16,W0
00DBE:  CPSGT   W1,W0
00DC0:  BRA     DAC
00DC2:  MOV     W5,W0
00DC4:  MOV     #0,W4
00DC6:  CALL    916
....................    } 
00DCA:  MOV     [--W15],W5
00DCC:  RETURN  
.................... } 
....................  
.................... // Returns current motor torque in percent (%0-100) 
.................... unsigned int md_torque_get() 
00DCE:  MOV     W5,[W15++]
00DD0:  MOV     W6,[W15++]
00DD2:  BCLR.B  2A0.0
00DD4:  BSET.B  2A0.1
00DD6:  BTSS.B  2A0.0
00DD8:  BRA     DD6
00DDA:  PUSH    280
00DDC:  POP     8DC
00DDE:  MOV     8DC,W0
00DE0:  MOV     #0,W1
00DE2:  MOV     W0,W2
00DE4:  MOV     W1,W3
00DE6:  MOV     #64,W0
00DE8:  MOV     #0,W1
00DEA:  CALL    9C8
00DEE:  MOV     W0,W5
00DF0:  MOV     W1,W6
00DF2:  BCLR.B  43.0
00DF4:  MOV     W5,W0
00DF6:  MOV     W6,W1
00DF8:  MOV     8B6,W2
00DFA:  MOV     #0,W3
00DFC:  CALL    9F8
00E00:  MOV     W0,8DE
.................... { 
....................    unsigned int analog=read_adc();                                         // Read the voltage level 
....................    unsigned int percent=100*(unsigned int32)analog/mt_voltage_limit;       // Convert voltage to percent 
....................     
....................    if(debug_mode_dp) 
00E02:  BTSS.B  8B0.0
00E04:  BRA     E36
....................       fprintf(RS232,"\n\r\tPercent Current: %u\n\r",percent); 
00E06:  MOV     #0,W1
00E08:  MOV     W1,W0
00E0A:  CLR.B   1
00E0C:  CALL    43C
00E10:  INC     W1,W1
00E12:  BTSC.B  219.1
00E14:  BRA     E12
00E16:  MOV.B   W0L,21A
00E18:  MOV     #13,W0
00E1A:  CPSGT   W1,W0
00E1C:  BRA     E08
00E1E:  MOV     8DE,W0
00E20:  MOV     #0,W4
00E22:  CALL    916
00E26:  BTSC.B  219.1
00E28:  BRA     E26
00E2A:  MOV.B   #A,W0L
00E2C:  MOV.B   W0L,21A
00E2E:  BTSC.B  219.1
00E30:  BRA     E2E
00E32:  MOV.B   #D,W0L
00E34:  MOV.B   W0L,21A
....................        
....................    return percent;   
00E36:  PUSH    8DE
00E38:  POP     0
00E3A:  MOV     [--W15],W6
00E3C:  MOV     [--W15],W5
00E3E:  RETURN  
.................... } 
.................... // Sets motor torque approximate to desired percent and returns the actual percent (%0-100) 
.................... unsigned int md_torque_set(unsigned int percent) 
00E40:  MOV     W5,[W15++]
00E42:  MOV     W6,[W15++]
.................... { 
....................    // percent must be between 0 and 100 
....................    if(percent>100) 
00E44:  MOV     8D6,W4
00E46:  MOV     #64,W3
00E48:  CP      W3,W4
00E4A:  BRA     C,E50
....................       percent=100; 
00E4C:  MOV     #64,W4
00E4E:  MOV     W4,8D6
....................        
....................    if(debug_mode_dp) 
00E50:  BTSS.B  8B0.0
00E52:  BRA     E74
....................    { 
....................       fprintf(RS232,"\n\r\tPercent Desired:"); 
00E54:  MOV     #0,W1
00E56:  MOV     W1,W0
00E58:  CLR.B   1
00E5A:  CALL    462
00E5E:  INC     W1,W1
00E60:  BTSC.B  219.1
00E62:  BRA     E60
00E64:  MOV.B   W0L,21A
00E66:  MOV     #12,W0
00E68:  CPSGT   W1,W0
00E6A:  BRA     E56
....................       fprintf(RS232,"%u",percent); 
00E6C:  MOV     8D6,W0
00E6E:  MOV     #0,W4
00E70:  CALL    916
....................    } 
....................     
....................    unsigned int voltage=(unsigned int32)percent*mt_voltage_limit/100;      // convert percent to voltage 
00E74:  MOV     8D6,W5
00E76:  MOV     #0,W6
00E78:  MOV     W5,W0
00E7A:  MOV     W6,W1
00E7C:  MOV     8B6,W2
00E7E:  MOV     #0,W3
00E80:  CALL    9C8
00E84:  MOV     W0,W5
00E86:  MOV     W1,W6
00E88:  BCLR.B  43.0
00E8A:  MOV     W5,W0
00E8C:  MOV     W6,W1
00E8E:  MOV     #64,W2
00E90:  MOV     #0,W3
00E92:  CALL    9F8
00E96:  MOV     W0,8D8
....................    dp_set(voltage);                                      // set digital potentiometer 
00E98:  PUSH    8D8
00E9A:  POP     8DC
00E9C:  CALL    AC6
....................     
....................    return md_torque_get(); 
00EA0:  CALL    DCE
00EA4:  MOV     W0,0
00EA6:  MOV     [--W15],W6
00EA8:  MOV     [--W15],W5
00EAA:  RETURN  
.................... } 
.................... // Sets the movement direction 
.................... void md_set_dir(unsigned int mode) 
.................... { 
....................    if(mode == DOWN) 
*
00F24:  CP0     944
00F26:  BRA     NZ,F32
....................    { 
....................       output_low(MD_DIR); 
00F28:  BCLR.B  2D8.4
00F2A:  BCLR.B  2DC.4
....................       md_direction = -1; 
00F2C:  SETM    8C2
....................    } 
00F2E:  GOTO    F3A
....................    else 
....................    { 
....................       output_high(MD_DIR); 
00F32:  BCLR.B  2D8.4
00F34:  BSET.B  2DC.4
....................       md_direction = 1; 
00F36:  MOV     #1,W4
00F38:  MOV     W4,8C2
....................    } 
00F3A:  RETURN  
.................... } 
.................... // Sets the motor state 
.................... void md_set_state(unsigned int mode) 
.................... { 
....................    if(mode == DISABLE) 
*
00FFC:  CP0     950
00FFE:  BRA     NZ,1008
....................       output_high(MD_ENABLE); 
01000:  BCLR.B  2D8.2
01002:  BSET.B  2DC.2
01004:  GOTO    100C
....................    else 
....................       output_low(MD_ENABLE); 
01008:  BCLR.B  2D8.2
0100A:  BCLR.B  2DC.2
0100C:  RETURN  
.................... } 
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_torque_set(mt_percent_trip);           // Set motor torque before initialization of motor driver 
*
00EAC:  PUSH    8B8
00EAE:  POP     8D6
00EB0:  CALL    E40
....................  
....................    output_high(MD_RESET);                    // Reset is active low so keep it high 
00EB4:  BCLR.B  2D8.0
00EB6:  BSET.B  2DC.0
....................    output_high(MD_SLEEP);                    // Sleep is active low so keep it high 
00EB8:  BCLR.B  2D8.3
00EBA:  BSET.B  2DC.3
....................    output_low(MD_SR);                        // Activate synchronous rectification 
00EBC:  BCLR.B  2DE.1
00EBE:  BCLR.B  2E2.1
....................    output_high(MD_DIR);                      // Direction control pin can be in any state 
00EC0:  BCLR.B  2D8.4
00EC2:  BSET.B  2DC.4
....................    output_high(MD_MS1);                      // MS1 and MS2 high enables 8x microstepping mode 
00EC4:  BCLR.B  2DE.0
00EC6:  BSET.B  2E2.0
....................    output_high(MD_MS2); 
00EC8:  BCLR.B  2D2.7
00ECA:  BSET.B  2D6.7
....................    output_high(MD_ENABLE);                   // Enable is active so keep it low at startup 
00ECC:  BCLR.B  2D8.2
00ECE:  BSET.B  2DC.2
....................    output_low(MD_STEP);                      // A low-to-high transition advances the motor one increment so keep step input low 
00ED0:  BCLR.B  2D8.1
00ED2:  BCLR.B  2DC.1
00ED4:  RETURN  
.................... } 
....................  
.................... // Sets the bits of pin state register 
.................... unsigned int16 set_register_bits(unsigned int16 reg, unsigned int8 bit_address, unsigned int8 bit_size, unsigned int16 value) 
*
0117A:  MOV     W5,[W15++]
.................... { 
....................    // bit address must be smaller then register size (16 bit) 
....................    if(bit_address > 15) return 0; 
0117C:  MOV     962,W4
0117E:  CP.B    W4L,#F
01180:  BRA     LEU,1186
01182:  CLR     0
01184:  BRA     11E0
....................    // bit size can't be larger then the number of bits between the given address and the last bit of the register 
....................    if(bit_size > (16 - bit_address)) return 0; 
01186:  MOV     962,W4
01188:  CLR.B   9
0118A:  MOV     #10,W3
0118C:  SUB     W3,W4,W0
0118E:  MOV     962,W4
01190:  LSR     W4,#8,W4
01192:  CP      W4,W0
01194:  BRA     LEU,119A
01196:  CLR     0
01198:  BRA     11E0
....................     
....................    //fprintf(RS232,"reg: %Lu adr: %u size: %u val: %lu\n\r", reg, bit_address, bit_size, value); 
....................     
....................    // Get the bits of the "value" and set it to the corresponding bit in the given address 
....................    for(int i=0; i<bit_size; i++) 
0119A:  CLR     966
0119C:  MOV.B   963,W0L
0119E:  CLR.B   1
011A0:  MOV     966,W4
011A2:  CP      W4,W0
011A4:  BRA     GE,11DC
....................    { 
....................       if(bit_test(value, i) == 1) 
011A6:  MOV     964,W1
011A8:  MOV.B   966,W0L
011AA:  BTST.C  W1.W0
011AC:  BRA     NC,11C4
....................          bit_set(reg, bit_address + i); 
011AE:  MOV     962,W4
011B0:  CLR.B   9
011B2:  MOV     W4,W0
011B4:  ADD     966,W0
011B6:  MOV     W0,W5
011B8:  MOV     #960,W1
011BA:  MOV     W5,W0
011BC:  BCLR.B  42.1
011BE:  BSW.Z   [W1].W0
011C0:  GOTO    11D6
....................       else 
....................          bit_clear(reg, bit_address + i); 
011C4:  MOV     962,W4
011C6:  CLR.B   9
011C8:  MOV     W4,W0
011CA:  ADD     966,W0
011CC:  MOV     W0,W5
011CE:  MOV     #960,W1
011D0:  MOV     W5,W0
011D2:  BSET.B  42.1
011D4:  BSW.Z   [W1].W0
011D6:  INC     0966
011D8:  GOTO    119C
....................    } 
....................     
....................    //fprintf(RS232,"reg: %Lu\n\r", reg); 
....................     
....................    return reg; 
011DC:  PUSH    960
011DE:  POP     0
011E0:  MOV     [--W15],W5
011E2:  RETURN  
.................... } 
.................... // Sends given 16 pin states to pin control card 
.................... void send_pin_state(unsigned int16 state) 
011E4:  MOV.B   961,W0L
011E6:  MOV.B   W0L,962
011E8:  MOV.B   960,W0L
011EA:  MOV.B   W0L,963
.................... { 
....................    unsigned int8 pin_reg_high = make8(state, 1); 
....................    unsigned int8 pin_reg_low = make8(state, 0); 
....................     
....................    //fprintf(RS232,"num: %u, high: %u, low: %u\n\r" state, pin_reg_high, pin_reg_low); 
....................  
....................    reg_rs485_busy = 1; 
011EC:  BSET.B  8B0.7
....................    fputc('p', RS485); 
011EE:  MOV.B   #70,W0L
011F0:  BTSC.B  20F.1
011F2:  BRA     11F0
011F4:  MOV.B   W0L,210
011F6:  CLR.B   211
....................    while(reg_rs485_busy); 
011F8:  BTSC.B  8B0.7
011FA:  BRA     11F8
....................  
....................    reg_rs485_busy = 1; 
011FC:  BSET.B  8B0.7
....................    fputc(pin_reg_high, RS485); 
011FE:  MOV.B   962,W0L
01200:  BTSC.B  20F.1
01202:  BRA     1200
01204:  MOV.B   W0L,210
01206:  CLR.B   211
....................    while(reg_rs485_busy); 
01208:  BTSC.B  8B0.7
0120A:  BRA     1208
....................     
....................    reg_rs485_busy = 1; 
0120C:  BSET.B  8B0.7
....................    fputc(pin_reg_low, RS485); 
0120E:  MOV.B   963,W0L
01210:  BTSC.B  20F.1
01212:  BRA     1210
01214:  MOV.B   W0L,210
01216:  CLR.B   211
....................    while(reg_rs485_busy); 
01218:  BTSC.B  8B0.7
0121A:  BRA     1218
0121C:  RETURN  
.................... } 
.................... // Connects or disconnects all pins 
.................... void set_all_pins(int1 state) 
.................... { 
....................    if(state) 
*
016B4:  CP0.B   93E
016B6:  BRA     Z,16BE
....................       reg_pin_state = 65535; 
016B8:  SETM    8D2
016BA:  GOTO    16C0
....................    else 
....................       reg_pin_state = 0; 
016BE:  CLR     8D2
....................     
....................    send_pin_state(reg_pin_state); 
016C0:  PUSH    8D2
016C2:  POP     960
016C4:  CALL    11E4
016C8:  RETURN  
.................... } 
.................... // Sets the pin state by using its x and y coordinate 
.................... void set_pin(unsigned int x, unsigned int y, unsigned int state) 
*
0121E:  MOV     W5,[W15++]
01220:  MOV     954,W5
01222:  SL      W5,#2,W5
01224:  MOV     W5,W0
01226:  ADD.B   956,W0L
01228:  MOV.B   W0L,95A
.................... { 
....................    unsigned int8 pin_ID = x * 4 + y; 
....................     
....................    reg_pin_state = set_register_bits(reg_pin_state, pin_ID, 1, state); 
0122A:  MOV.B   95A,W0L
0122C:  MOV.B   W0L,962
0122E:  MOV.B   #1,W0L
01230:  MOV.B   W0L,963
01232:  PUSH    8D2
01234:  POP     960
01236:  PUSH    958
01238:  POP     964
0123A:  CALL    117A
0123E:  MOV     W0,8D2
....................    send_pin_state(reg_pin_state); 
01240:  PUSH    8D2
01242:  POP     960
01244:  CALL    11E4
01248:  MOV     [--W15],W5
0124A:  RETURN  
.................... } 
.................... // Sets time required to move a pin to its up position 
.................... void set_pin_up_time(unsigned int16 time) 
*
0173C:  MOV.B   93F,W0L
0173E:  MOV.B   W0L,940
01740:  MOV.B   93E,W0L
01742:  MOV.B   W0L,941
.................... { 
....................    unsigned int8 time_high = make8(time, 1); 
....................    unsigned int8 time_low = make8(time, 0); 
....................     
....................    reg_rs485_busy = 1; 
01744:  BSET.B  8B0.7
....................    fputc('u', RS485); 
01746:  MOV.B   #75,W0L
01748:  BTSC.B  20F.1
0174A:  BRA     1748
0174C:  MOV.B   W0L,210
0174E:  CLR.B   211
....................    while(reg_rs485_busy); 
01750:  BTSC.B  8B0.7
01752:  BRA     1750
....................     
....................    reg_rs485_busy = 1; 
01754:  BSET.B  8B0.7
....................    fputc(time_high, RS485); 
01756:  MOV.B   940,W0L
01758:  BTSC.B  20F.1
0175A:  BRA     1758
0175C:  MOV.B   W0L,210
0175E:  CLR.B   211
....................    while(reg_rs485_busy); 
01760:  BTSC.B  8B0.7
01762:  BRA     1760
....................     
....................    reg_rs485_busy = 1; 
01764:  BSET.B  8B0.7
....................    fputc(time_low, RS485); 
01766:  MOV.B   941,W0L
01768:  BTSC.B  20F.1
0176A:  BRA     1768
0176C:  MOV.B   W0L,210
0176E:  CLR.B   211
....................    while(reg_rs485_busy); 
01770:  BTSC.B  8B0.7
01772:  BRA     1770
01774:  RETURN  
.................... } 
.................... // Sets time required to move a pin to its down position 
.................... void set_pin_down_time(unsigned int16 time) 
01776:  MOV.B   93F,W0L
01778:  MOV.B   W0L,940
0177A:  MOV.B   93E,W0L
0177C:  MOV.B   W0L,941
.................... { 
....................    unsigned int8 time_high = make8(time, 1); 
....................    unsigned int8 time_low = make8(time, 0); 
....................     
....................    reg_rs485_busy = 1; 
0177E:  BSET.B  8B0.7
....................    fputc('d', RS485); 
01780:  MOV.B   #64,W0L
01782:  BTSC.B  20F.1
01784:  BRA     1782
01786:  MOV.B   W0L,210
01788:  CLR.B   211
....................    while(reg_rs485_busy); 
0178A:  BTSC.B  8B0.7
0178C:  BRA     178A
....................     
....................    reg_rs485_busy = 1; 
0178E:  BSET.B  8B0.7
....................    fputc(time_high, RS485); 
01790:  MOV.B   940,W0L
01792:  BTSC.B  20F.1
01794:  BRA     1792
01796:  MOV.B   W0L,210
01798:  CLR.B   211
....................    while(reg_rs485_busy); 
0179A:  BTSC.B  8B0.7
0179C:  BRA     179A
....................     
....................    reg_rs485_busy = 1; 
0179E:  BSET.B  8B0.7
....................    fputc(time_low, RS485); 
017A0:  MOV.B   941,W0L
017A2:  BTSC.B  20F.1
017A4:  BRA     17A2
017A6:  MOV.B   W0L,210
017A8:  CLR.B   211
....................    while(reg_rs485_busy); 
017AA:  BTSC.B  8B0.7
017AC:  BRA     17AA
017AE:  RETURN  
.................... } 
.................... // Updates pin states according to given position (in 0.1mm). This functions is called once in every motor step. 
.................... void update_pins(unsigned int16 current_position) 
.................... { 
....................    if(reg_demo_run) 
*
0124C:  BTSS.B  8B0.5
0124E:  BRA     13C4
....................    {  
....................       switch(current_position) 
01250:  MOV     950,W0
01252:  MOV     #C8,W4
01254:  CP      W0,W4
01256:  BRA     Z,12B4
01258:  MOV     #12C,W4
0125A:  CP      W0,W4
0125C:  BRA     Z,12C6
0125E:  MOV     #190,W4
01260:  CP      W0,W4
01262:  BRA     Z,12D8
01264:  MOV     #1F4,W4
01266:  CP      W0,W4
01268:  BRA     Z,12EA
0126A:  MOV     #258,W4
0126C:  CP      W0,W4
0126E:  BRA     Z,12FC
01270:  MOV     #2BC,W4
01272:  CP      W0,W4
01274:  BRA     Z,130E
01276:  MOV     #320,W4
01278:  CP      W0,W4
0127A:  BRA     Z,1320
0127C:  MOV     #384,W4
0127E:  CP      W0,W4
01280:  BRA     Z,1330
01282:  MOV     #3E8,W4
01284:  CP      W0,W4
01286:  BRA     Z,1340
01288:  MOV     #44C,W4
0128A:  CP      W0,W4
0128C:  BRA     Z,1350
0128E:  MOV     #4B0,W4
01290:  CP      W0,W4
01292:  BRA     Z,135E
01294:  MOV     #514,W4
01296:  CP      W0,W4
01298:  BRA     Z,136E
0129A:  MOV     #578,W4
0129C:  CP      W0,W4
0129E:  BRA     Z,137E
012A0:  MOV     #5DC,W4
012A2:  CP      W0,W4
012A4:  BRA     Z,138E
012A6:  MOV     #640,W4
012A8:  CP      W0,W4
012AA:  BRA     Z,13A0
012AC:  MOV     #6A4,W4
012AE:  CP      W0,W4
012B0:  BRA     Z,13B2
012B2:  BRA     13C4
....................       { 
....................          case 200:   set_pin(1, 2, 0); 
012B4:  MOV     #1,W4
012B6:  MOV     W4,954
012B8:  MOV     #2,W4
012BA:  MOV     W4,956
012BC:  CLR     958
012BE:  CALL    121E
....................                      break; 
012C2:  GOTO    13C4
....................          case 300:   set_pin(1, 1, 0); 
012C6:  MOV     #1,W4
012C8:  MOV     W4,954
012CA:  MOV     #1,W4
012CC:  MOV     W4,956
012CE:  CLR     958
012D0:  CALL    121E
....................                      break; 
012D4:  GOTO    13C4
....................          case 400:   set_pin(2, 1, 0); 
012D8:  MOV     #2,W4
012DA:  MOV     W4,954
012DC:  MOV     #1,W4
012DE:  MOV     W4,956
012E0:  CLR     958
012E2:  CALL    121E
....................                      break;  
012E6:  GOTO    13C4
....................          case 500:   set_pin(2, 2, 0); 
012EA:  MOV     #2,W4
012EC:  MOV     W4,954
012EE:  MOV     #2,W4
012F0:  MOV     W4,956
012F2:  CLR     958
012F4:  CALL    121E
....................                      break; 
012F8:  GOTO    13C4
....................          case 600:   set_pin(2, 3, 0); 
012FC:  MOV     #2,W4
012FE:  MOV     W4,954
01300:  MOV     #3,W4
01302:  MOV     W4,956
01304:  CLR     958
01306:  CALL    121E
....................                      break; 
0130A:  GOTO    13C4
....................          case 700:   set_pin(1, 3, 0); 
0130E:  MOV     #1,W4
01310:  MOV     W4,954
01312:  MOV     #3,W4
01314:  MOV     W4,956
01316:  CLR     958
01318:  CALL    121E
....................                      break; 
0131C:  GOTO    13C4
....................          case 800:   set_pin(0, 3, 0); 
01320:  CLR     954
01322:  MOV     #3,W4
01324:  MOV     W4,956
01326:  CLR     958
01328:  CALL    121E
....................                      break; 
0132C:  GOTO    13C4
....................          case 900:   set_pin(0, 2, 0); 
01330:  CLR     954
01332:  MOV     #2,W4
01334:  MOV     W4,956
01336:  CLR     958
01338:  CALL    121E
....................                      break; 
0133C:  GOTO    13C4
....................          case 1000:  set_pin(0, 1, 0); 
01340:  CLR     954
01342:  MOV     #1,W4
01344:  MOV     W4,956
01346:  CLR     958
01348:  CALL    121E
....................                      break;  
0134C:  GOTO    13C4
....................          case 1100:  set_pin(0, 0, 0); 
01350:  CLR     954
01352:  CLR     956
01354:  CLR     958
01356:  CALL    121E
....................                      break; 
0135A:  GOTO    13C4
....................          case 1200:  set_pin(1, 0, 0); 
0135E:  MOV     #1,W4
01360:  MOV     W4,954
01362:  CLR     956
01364:  CLR     958
01366:  CALL    121E
....................                      break; 
0136A:  GOTO    13C4
....................          case 1300:  set_pin(2, 0, 0); 
0136E:  MOV     #2,W4
01370:  MOV     W4,954
01372:  CLR     956
01374:  CLR     958
01376:  CALL    121E
....................                      break;      
0137A:  GOTO    13C4
....................          case 1400:  set_pin(3, 0, 0); 
0137E:  MOV     #3,W4
01380:  MOV     W4,954
01382:  CLR     956
01384:  CLR     958
01386:  CALL    121E
....................                      break;  
0138A:  GOTO    13C4
....................          case 1500:  set_pin(3, 1, 0); 
0138E:  MOV     #3,W4
01390:  MOV     W4,954
01392:  MOV     #1,W4
01394:  MOV     W4,956
01396:  CLR     958
01398:  CALL    121E
....................                      break; 
0139C:  GOTO    13C4
....................          case 1600:  set_pin(3, 2, 0); 
013A0:  MOV     #3,W4
013A2:  MOV     W4,954
013A4:  MOV     #2,W4
013A6:  MOV     W4,956
013A8:  CLR     958
013AA:  CALL    121E
....................                      break; 
013AE:  GOTO    13C4
....................          case 1700:  set_pin(3, 3, 0); 
013B2:  MOV     #3,W4
013B4:  MOV     W4,954
013B6:  MOV     #3,W4
013B8:  MOV     W4,956
013BA:  CLR     958
013BC:  CALL    121E
....................                      break;                       
013C0:  GOTO    13C4
....................       } 
....................    } 
013C4:  RETURN  
.................... } 
....................  
.................... // Sets the operating mode of the PWM module 
.................... void pwm_select_mode(unsigned int mode) 
.................... { 
....................    if(mode == FREE) 
*
008B6:  CP0     950
008B8:  BRA     NZ,8C2
....................    { 
....................       // Select free running PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
008BA:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 0; 
008BC:  BCLR.B  1C0.0
....................    } 
008BE:  GOTO    8CC
....................    else if(mode == SINGLE) 
008C2:  MOV     950,W4
008C4:  CP      W4,#1
008C6:  BRA     NZ,8CC
....................    { 
....................       // Select single event PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
008C8:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 1; 
008CA:  BSET.B  1C0.0
....................    } 
008CC:  RETURN  
.................... } 
.................... // Initializes the PWM module by using default values 
.................... void pwm_init() 
.................... { 
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN       = 0; 
008CE:  BCLR.B  1C1.7
....................     
....................    // Select 1:1 output postscale 
....................    PWM_PTCON_PTOPS3     = 0; 
008D0:  BCLR.B  1C0.7
....................    PWM_PTCON_PTOPS2     = 0; 
008D2:  BCLR.B  1C0.6
....................    PWM_PTCON_PTOPS1     = 0; 
008D4:  BCLR.B  1C0.5
....................    PWM_PTCON_PTOPS0     = 0; 
008D6:  BCLR.B  1C0.4
....................    // Select 1:1 input prescale 
....................    PWM_PTCON_PTCKPS1    = 0; 
008D8:  BCLR.B  1C0.3
....................    PWM_PTCON_PTCKPS0    = 0; 
008DA:  BCLR.B  1C0.2
....................     
....................    // Set the operating mode of PWM module 
....................    pwm_select_mode(FREE); 
008DC:  CLR     950
008DE:  CALL    8B6
....................  
....................    // Select independent output mode for PWM1 I/O pair 
....................    PWM_PWMCON1_PMOD1    = 1; 
008E2:  BSET.B  1C9.0
....................    // Set PWM1H pin as PWM output 
....................    PWM_PWMCON1_PEN1H    = 1; 
008E4:  BSET.B  1C8.4
....................     
....................    // Synchronize PDC registers to the PWM time base 
....................    PWM_PWMCON2_IUE      = 0; 
008E6:  BCLR.B  1CA.2
....................    // Enable PWM interrupt 
....................    PWM_IEC2_PWMIE       = 0; 
008E8:  BCLR.B  90.7
....................     
....................    // Set time base period value 
....................    PWM_PTPER            = 0; 
008EA:  CLR     1C4
....................    // Set time base duty cycle 
....................    PWM_PDC1             = 0; 
008EC:  CLR     1D6
....................  
....................    if(debug_mode_md) 
008EE:  BTSS.B  8B0.1
008F0:  BRA     90A
....................       fprintf(RS232,"PWM Module Initialized\n\n\r"); 
008F2:  MOV     #0,W1
008F4:  MOV     W1,W0
008F6:  CLR.B   1
008F8:  CALL    482
008FC:  INC     W1,W1
008FE:  BTSC.B  219.1
00900:  BRA     8FE
00902:  MOV.B   W0L,21A
00904:  MOV     #18,W0
00906:  CPSGT   W1,W0
00908:  BRA     8F4
0090A:  RETURN  
.................... } 
.................... // Sets PWM period time (us) 
.................... void pwm_set_period(unsigned int16 period) 
*
0100E:  MOV     W5,[W15++]
01010:  MOV     W6,[W15++]
.................... { 
....................    // PWM period 
....................    unsigned int16 pwm_period;  
....................     
....................    // Set the PWM period 
....................    if(period==0) 
01012:  CP0     954
01014:  BRA     NZ,101C
....................       pwm_period = 0; 
01016:  CLR     956
01018:  GOTO    1046
....................    else 
....................       pwm_period =  (7 * period / 400) + (3 * period / 40) + ( 7 * period / 4) - 1; 
0101C:  MOV     954,W4
0101E:  MUL.UU  W4,#7,W0
01020:  MOV     W0,W5
01022:  MOV     W5,W4
01024:  MOV     #190,W3
01026:  REPEAT  #11
01028:  DIV.U   W4,W3
0102A:  MOV     W0,W5
0102C:  MOV     954,W4
0102E:  MUL.UU  W4,#3,W6
01030:  MOV     W6,W4
01032:  MOV     #28,W3
01034:  REPEAT  #11
01036:  DIV.U   W4,W3
01038:  ADD     W0,W5,W5
0103A:  MOV     954,W4
0103C:  MUL.UU  W4,#7,W6
0103E:  LSR     W6,#2,W0
01040:  ADD     W0,W5,W5
01042:  SUB     W5,#1,W0
01044:  MOV     W0,956
....................     
....................    // Updates from duty cycle and period buffer registers are disabled 
....................    PWM_PWMCON2_UDIS = 1; 
01046:  BSET.B  1CA.0
....................    // Set time base period value 
....................    PWM_PTPER        = pwm_period; 
01048:  PUSH    956
0104A:  POP     1C4
....................    // Set time base duty cycle if PWM module is enabled (duty cycle > 0%) 
....................    PWM_PDC1         = pwm_period; 
0104C:  PUSH    956
0104E:  POP     1D6
....................    // Updates from duty cycle and period buffer registers are enabled 
....................    PWM_PWMCON2_UDIS = 0; 
01050:  BCLR.B  1CA.0
01052:  MOV     [--W15],W6
01054:  MOV     [--W15],W5
01056:  RETURN  
.................... } 
.................... // Disables PWM module 
.................... void pwm_disable() 
.................... { 
....................    // Set duty cycle to zero 
....................    PWM_PDC1=0; 
*
01068:  CLR     1D6
....................    // Wait for the last signal 
....................    delay_us(PWM_PTPER + 1 / 30); 
0106A:  MOV     1C4,W0
0106C:  CALL    1058
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN = 0; 
01070:  BCLR.B  1C1.7
....................    // Set duty cycle to its initial value 
....................    PWM_PDC1=PWM_PTPER; 
01072:  PUSH    1C4
01074:  POP     1D6
....................     
....................    if(debug_mode_pwm) 
01076:  BTSS.B  8B0.2
01078:  BRA     1092
....................       fprintf(RS232,"PWM Disabled\n\r"); 
0107A:  MOV     #0,W1
0107C:  MOV     W1,W0
0107E:  CLR.B   1
01080:  CALL    4A8
01084:  INC     W1,W1
01086:  BTSC.B  219.1
01088:  BRA     1086
0108A:  MOV.B   W0L,21A
0108C:  MOV     #D,W0
0108E:  CPSGT   W1,W0
01090:  BRA     107C
01092:  RETURN  
.................... } 
.................... // Controls the PWM cycle 
.................... void pwm_control() 
01094:  MOV     W5,[W15++]
.................... {    
....................    md_step_count++; 
01096:  INC     08D0
....................  
....................    switch(md_run_state)  
01098:  MOV.B   8B1,W0L
0109A:  CLR.B   1
0109C:  XOR     #1,W0
0109E:  BRA     Z,10AA
010A0:  XOR     #2,W0
010A2:  BRA     Z,1126
010A4:  XOR     #1,W0
010A6:  BRA     Z,114C
010A8:  BRA     1176
....................    { 
....................       case ACCEL: 
....................          // Check if we should start deceleration. 
....................          if(md_step_count >= md_accel_lim)  
010AA:  MOV     8CC,W0
010AC:  MOV     8D0,W4
010AE:  CP      W4,W0
010B0:  BRA     NC,110C
....................          { 
....................             if(md_step_count == md_decel_lim) 
010B2:  MOV     8D0,W0
010B4:  CP      8CA
010B6:  BRA     NZ,10D8
....................             { 
....................                md_decel_count--; 
010B8:  DEC     08CE
....................                pwm_set_period(delays[md_decel_count] + md_min_delay); 
010BA:  MOV     8CE,W0
010BC:  SL      W0,#1,W0
010BE:  CALL    100
010C2:  MOV     W0,W5
010C4:  MOV     W5,W0
010C6:  ADD     8D4,W0
010C8:  MOV     W0,W5
010CA:  MOV     W5,954
010CC:  CALL    100E
....................                md_run_state = DECEL; 
010D0:  MOV.B   #2,W0L
010D2:  MOV.B   W0L,8B1
....................             } 
010D4:  GOTO    1108
....................             else if(md_decel_lim - md_step_count < 2) 
010D8:  MOV     8CA,W4
010DA:  MOV     8D0,W3
010DC:  SUB     W4,W3,W5
010DE:  CP      W5,#2
010E0:  BRA     C,10FC
....................             { 
....................                pwm_set_period(delays[md_step_count] + md_min_delay); 
010E2:  MOV     8D0,W0
010E4:  SL      W0,#1,W0
010E6:  CALL    100
010EA:  MOV     W0,W5
010EC:  MOV     W5,W0
010EE:  ADD     8D4,W0
010F0:  MOV     W0,W5
010F2:  MOV     W5,954
010F4:  CALL    100E
....................             } 
010F8:  GOTO    1108
....................             else 
....................             { 
....................                pwm_set_period(md_min_delay); 
010FC:  PUSH    8D4
010FE:  POP     954
01100:  CALL    100E
....................                md_run_state = RUN; 
01104:  MOV.B   #3,W0L
01106:  MOV.B   W0L,8B1
....................             } 
....................          } 
01108:  GOTO    1122
....................          else 
....................          { 
....................             pwm_set_period(delays[md_step_count] + md_min_delay); 
0110C:  MOV     8D0,W0
0110E:  SL      W0,#1,W0
01110:  CALL    100
01114:  MOV     W0,W5
01116:  MOV     W5,W0
01118:  ADD     8D4,W0
0111A:  MOV     W0,W5
0111C:  MOV     W5,954
0111E:  CALL    100E
....................          } 
....................          break; 
01122:  GOTO    1176
....................  
....................       case RUN: 
....................          // Check if we should start decelration. 
....................          if(md_step_count == md_decel_lim)  
01126:  MOV     8D0,W0
01128:  CP      8CA
0112A:  BRA     NZ,1148
....................          { 
....................             md_decel_count--; 
0112C:  DEC     08CE
....................             pwm_set_period(delays[md_decel_count] + md_min_delay); 
0112E:  MOV     8CE,W0
01130:  SL      W0,#1,W0
01132:  CALL    100
01136:  MOV     W0,W5
01138:  MOV     W5,W0
0113A:  ADD     8D4,W0
0113C:  MOV     W0,W5
0113E:  MOV     W5,954
01140:  CALL    100E
....................             md_run_state = DECEL; 
01144:  MOV.B   #2,W0L
01146:  MOV.B   W0L,8B1
....................          } 
....................          break; 
01148:  GOTO    1176
....................  
....................       case DECEL: 
....................          // Check if we are at the last step 
....................          if(md_decel_count == 0) 
0114C:  CP0     8CE
0114E:  BRA     NZ,115A
....................          { 
....................             pwm_disable(); 
01150:  CALL    1068
....................             reg_md_running = 0; 
01154:  BCLR.B  8B0.3
....................          } 
01156:  GOTO    1172
....................          else 
....................          { 
....................             md_decel_count--; 
0115A:  DEC     08CE
....................             pwm_set_period(delays[md_decel_count] + md_min_delay); 
0115C:  MOV     8CE,W0
0115E:  SL      W0,#1,W0
01160:  CALL    100
01164:  MOV     W0,W5
01166:  MOV     W5,W0
01168:  ADD     8D4,W0
0116A:  MOV     W0,W5
0116C:  MOV     W5,954
0116E:  CALL    100E
....................          } 
....................          break; 
01172:  GOTO    1176
....................    } 
01176:  MOV     [--W15],W5
01178:  RETURN  
.................... } 
.................... // Enables the PWM cycle 
.................... void pwm_enable() 
*
013C6:  MOV     W5,[W15++]
013C8:  MOV     W6,[W15++]
.................... { 
....................    // Disable RS232 receive byte interrupt 
....................    disable_interrupts(INT_RDA2); 
013CA:  BCLR.B  8F.0
....................     
....................    // Set motion parameters 
....................    md_step_count = 0; 
013CC:  CLR     8D0
....................    md_run_state = ACCEL; 
013CE:  MOV.B   #1,W0L
013D0:  MOV.B   W0L,8B1
....................     
....................    // Set motor parameters 
....................    md_set_state(ENABLE); 
013D2:  MOV     #1,W4
013D4:  MOV     W4,950
013D6:  CALL    FFC
....................    delay_ms(100); 
013DA:  MOV     #64,W0
013DC:  CALL    8A6
....................     
....................    // Set pwm parameters 
....................    pwm_set_period(delays[0] + md_min_delay); 
013E0:  MOV     #9C4,W0
013E2:  ADD     8D4,W0
013E4:  MOV     W0,W5
013E6:  MOV     W5,954
013E8:  CALL    100E
....................    pwm_select_mode(FREE); 
013EC:  CLR     950
013EE:  CALL    8B6
....................     
....................    // Enable PWM module 
....................    PWM_PTCON_PTEN = 1; 
013F2:  BSET.B  1C1.7
....................    reg_md_running = 1; 
013F4:  BSET.B  8B0.3
....................     
....................    unsigned int16 position = 0; 
....................    unsigned int16 last_pos = 0; 
013F6:  CLR     94A
013F8:  CLR     94C
....................  
....................    while(reg_md_running) 
013FA:  BTSS.B  8B0.3
013FC:  BRA     144C
....................    { 
....................       if(PWM_IFS2_PWMIF) 
013FE:  BTSS.B  88.7
01400:  BRA     1448
....................       { 
....................          // Clear the flag register 
....................          PWM_IFS2_PWMIF = 0; 
01402:  BCLR.B  88.7
....................          pwm_control(); 
01404:  CALL    1094
....................           
....................          if(reg_md_homing == 0) 
01408:  BTSC.B  8B0.4
0140A:  BRA     1448
....................          { 
....................             md_current_step += md_direction; 
0140C:  MOV     8C0,W0
0140E:  ADD     8C2,W0
01410:  MOV     W0,8C0
....................             position = (long)md_current_step * md_conv_const / 10000; 
01412:  MOV     8C0,W5
01414:  MOV     #0,W6
01416:  MOV     W5,W0
01418:  MOV     W6,W1
0141A:  MOV     8BA,W2
0141C:  MOV     #0,W3
0141E:  CALL    F3C
01422:  MOV     W0,W5
01424:  MOV     W1,W6
01426:  BCLR.B  43.0
01428:  MOV     W5,W0
0142A:  MOV     W6,W1
0142C:  MOV     #2710,W2
0142E:  MOV     #0,W3
01430:  CALL    F7E
01434:  MOV     W0,94A
....................             if(position != last_pos) 
01436:  MOV     94A,W0
01438:  CP      94C
0143A:  BRA     Z,1448
....................             { 
....................                update_pins(position); 
0143C:  PUSH    94A
0143E:  POP     950
01440:  CALL    124C
....................                last_pos = position; 
01444:  PUSH    94A
01446:  POP     94C
....................             } 
....................          } 
....................       } 
01448:  GOTO    13FA
....................    } 
....................     
....................    delay_ms(100); 
0144C:  MOV     #64,W0
0144E:  CALL    8A6
....................    md_set_state(DISABLE); 
01452:  CLR     950
01454:  CALL    FFC
....................  
....................    // Enable RS232 receive byte interrupt 
....................    clear_interrupt(INT_RDA2); 
01458:  REPEAT  #3
0145A:  MOV     21C,W0
0145C:  BCLR.B  87.0
....................    enable_interrupts(INT_RDA2); 
0145E:  BSET.B  8F.0
....................    reg_rs232_message = 0; 
01460:  BCLR.B  8B0.6
01462:  MOV     [--W15],W6
01464:  MOV     [--W15],W5
01466:  RETURN  
.................... } 
....................  
.................... // Calculates and sets the minimum delay time by using the given linear positioning speed (in mm/s) 
.................... void set_speed(unsigned int16 speed) 
.................... { 
....................    // Number of teeths of the motor drive pulley: 27 
....................    // Number of teeths of the pin drive pulley  : 10 
....................    // Number of motor steps per revolution      : 1600 
....................    // Pitch of the linear pin                   : 6 
....................    md_min_delay = (((long)27 * 6 * 1000) / 16) / speed; 
*
00ED6:  BCLR.B  43.0
00ED8:  MOV     #278D,W0
00EDA:  MOV     #0,W1
00EDC:  MOV     93E,W2
00EDE:  MOV     #0,W3
00EE0:  CALL    9F8
00EE4:  MOV     W0,8D4
....................    if(debug_mode_pwm) 
00EE6:  BTSS.B  8B0.2
00EE8:  BRA     F22
....................       fprintf(RS232,"Delay: %u\n\n\r", md_min_delay); 
00EEA:  MOV     #0,W1
00EEC:  MOV     W1,W0
00EEE:  CLR.B   1
00EF0:  CALL    4C4
00EF4:  INC     W1,W1
00EF6:  BTSC.B  219.1
00EF8:  BRA     EF6
00EFA:  MOV.B   W0L,21A
00EFC:  MOV     #6,W0
00EFE:  CPSGT   W1,W0
00F00:  BRA     EEC
00F02:  MOV     8D4,W0
00F04:  MOV     #0,W4
00F06:  CALL    916
00F0A:  BTSC.B  219.1
00F0C:  BRA     F0A
00F0E:  MOV.B   #A,W0L
00F10:  MOV.B   W0L,21A
00F12:  BTSC.B  219.1
00F14:  BRA     F12
00F16:  MOV.B   #A,W0L
00F18:  MOV.B   W0L,21A
00F1A:  BTSC.B  219.1
00F1C:  BRA     F1A
00F1E:  MOV.B   #D,W0L
00F20:  MOV.B   W0L,21A
00F22:  RETURN  
.................... } 
....................  
.................... // Move by the given displacement 
.................... void move(unsigned int16 displacement) 
*
01468:  MOV     W5,[W15++]
0146A:  MOV     W6,[W15++]
0146C:  MOV     944,W5
0146E:  MOV     #0,W6
01470:  MOV     W5,W0
01472:  MOV     W6,W1
01474:  MOV     #2710,W2
01476:  MOV     #0,W3
01478:  CALL    F3C
0147C:  MOV     W0,W5
0147E:  MOV     W1,W6
01480:  BCLR.B  43.0
01482:  MOV     W5,W0
01484:  MOV     W6,W1
01486:  MOV     8BA,W2
01488:  MOV     #0,W3
0148A:  CALL    F7E
0148E:  MOV     W0,946
.................... { 
....................    unsigned int16 counts = (long)displacement * 10000 / md_conv_const; 
....................     
....................    if(debug_mode_pwm) 
01490:  BTSS.B  8B0.2
01492:  BRA     1504
....................    { 
....................       fprintf(RS232,"Displacement: %u (in mm)\n\r", displacement); 
01494:  MOV     #0,W1
01496:  MOV     W1,W0
01498:  CLR.B   1
0149A:  CALL    4DE
0149E:  INC     W1,W1
014A0:  BTSC.B  219.1
014A2:  BRA     14A0
014A4:  MOV.B   W0L,21A
014A6:  MOV     #D,W0
014A8:  CPSGT   W1,W0
014AA:  BRA     1496
014AC:  MOV     944,W0
014AE:  MOV     #0,W4
014B0:  CALL    916
014B4:  MOV     #10,W1
014B6:  MOV     W1,W0
014B8:  CLR.B   1
014BA:  CALL    4DE
014BE:  INC     W1,W1
014C0:  BTSC.B  219.1
014C2:  BRA     14C0
014C4:  MOV.B   W0L,21A
014C6:  MOV     #19,W0
014C8:  CPSGT   W1,W0
014CA:  BRA     14B6
....................       fprintf(RS232,"Displacement: %u (in steps)\n\r", counts); 
014CC:  MOV     #0,W1
014CE:  MOV     W1,W0
014D0:  CLR.B   1
014D2:  CALL    506
014D6:  INC     W1,W1
014D8:  BTSC.B  219.1
014DA:  BRA     14D8
014DC:  MOV.B   W0L,21A
014DE:  MOV     #D,W0
014E0:  CPSGT   W1,W0
014E2:  BRA     14CE
014E4:  MOV     946,W0
014E6:  MOV     #0,W4
014E8:  CALL    916
014EC:  MOV     #10,W1
014EE:  MOV     W1,W0
014F0:  CLR.B   1
014F2:  CALL    506
014F6:  INC     W1,W1
014F8:  BTSC.B  219.1
014FA:  BRA     14F8
014FC:  MOV.B   W0L,21A
014FE:  MOV     #1C,W0
01500:  CPSGT   W1,W0
01502:  BRA     14EE
....................    } 
....................        
....................    // Find out after how many steps we must start deceleration. 
....................    md_accel_lim = ((long)counts * md_decel) / (md_accel + md_decel); 
01504:  MOV     946,W5
01506:  MOV     #0,W6
01508:  MOV     W5,W0
0150A:  MOV     W6,W1
0150C:  MOV     8C8,W2
0150E:  MOV     #0,W3
01510:  CALL    F3C
01514:  MOV     W0,W5
01516:  MOV     W1,W6
01518:  MOV     8C6,W0
0151A:  ADD     8C8,W0
0151C:  BCLR.B  43.0
0151E:  MOV     W6,W1
01520:  MOV     W0,W2
01522:  MOV     #0,W3
01524:  MOV     W5,W0
01526:  CALL    F7E
0152A:  MOV     W0,8CC
....................    // We must accelerate at least 1 step before we can start deceleration. 
....................    if(md_accel_lim == 0) 
0152C:  CP0     8CC
0152E:  BRA     NZ,1534
....................       md_accel_lim = 1; 
01530:  MOV     #1,W4
01532:  MOV     W4,8CC
....................     
....................    // Use the limit we hit first to calc decel. 
....................    if(md_accel_lim >= md_max_acc_lim) 
01534:  MOV     8CC,W4
01536:  MOV     #15D,W3
01538:  CP      W3,W4
0153A:  BRA     GTU,156C
....................    { 
....................       md_accel_lim = md_max_acc_lim; 
0153C:  MOV     #15D,W4
0153E:  MOV     W4,8CC
....................        
....................       // Find step to start decleration. 
....................       md_decel_count = ((long)md_max_acc_lim * md_accel) / md_decel; 
01540:  MOV     #15D,W0
01542:  MOV     #0,W1
01544:  MOV     8C6,W2
01546:  MOV     #0,W3
01548:  CALL    F3C
0154C:  MOV     W0,W5
0154E:  MOV     W1,W6
01550:  BCLR.B  43.0
01552:  MOV     W5,W0
01554:  MOV     W6,W1
01556:  MOV     8C8,W2
01558:  MOV     #0,W3
0155A:  CALL    F7E
0155E:  MOV     W0,8CE
....................       md_decel_lim = counts - md_decel_count;  
01560:  MOV     946,W4
01562:  MOV     8CE,W3
01564:  SUB     W4,W3,W0
01566:  MOV     W0,8CA
....................    } 
01568:  GOTO    1578
....................    else 
....................    { 
....................       md_decel_lim = counts - md_accel_lim; 
0156C:  MOV     946,W4
0156E:  MOV     8CC,W3
01570:  SUB     W4,W3,W0
01572:  MOV     W0,8CA
....................       md_decel_count = md_accel_lim; 
01574:  PUSH    8CC
01576:  POP     8CE
....................    } 
....................     
....................    // We must decelerate at least 1 step to stop. 
....................    if(md_decel_lim == 0) 
01578:  CP0     8CA
0157A:  BRA     NZ,1580
....................       md_decel_lim = 1; 
0157C:  MOV     #1,W4
0157E:  MOV     W4,8CA
....................  
....................    if(debug_mode_pwm) 
01580:  BTSS.B  8B0.2
01582:  BRA     1614
....................    { 
....................       fprintf(RS232,"Acceleration Limit: %u\n\r", md_accel_lim); 
01584:  MOV     #0,W1
01586:  MOV     W1,W0
01588:  CLR.B   1
0158A:  CALL    530
0158E:  INC     W1,W1
01590:  BTSC.B  219.1
01592:  BRA     1590
01594:  MOV.B   W0L,21A
01596:  MOV     #13,W0
01598:  CPSGT   W1,W0
0159A:  BRA     1586
0159C:  MOV     8CC,W0
0159E:  MOV     #0,W4
015A0:  CALL    916
015A4:  BTSC.B  219.1
015A6:  BRA     15A4
015A8:  MOV.B   #A,W0L
015AA:  MOV.B   W0L,21A
015AC:  BTSC.B  219.1
015AE:  BRA     15AC
015B0:  MOV.B   #D,W0L
015B2:  MOV.B   W0L,21A
....................       fprintf(RS232,"Deceleration Limit: %u\n\r", md_decel_lim); 
015B4:  MOV     #0,W1
015B6:  MOV     W1,W0
015B8:  CLR.B   1
015BA:  CALL    556
015BE:  INC     W1,W1
015C0:  BTSC.B  219.1
015C2:  BRA     15C0
015C4:  MOV.B   W0L,21A
015C6:  MOV     #13,W0
015C8:  CPSGT   W1,W0
015CA:  BRA     15B6
015CC:  MOV     8CA,W0
015CE:  MOV     #0,W4
015D0:  CALL    916
015D4:  BTSC.B  219.1
015D6:  BRA     15D4
015D8:  MOV.B   #A,W0L
015DA:  MOV.B   W0L,21A
015DC:  BTSC.B  219.1
015DE:  BRA     15DC
015E0:  MOV.B   #D,W0L
015E2:  MOV.B   W0L,21A
....................       fprintf(RS232,"Deceleration Count: %u\n\r", md_decel_count); 
015E4:  MOV     #0,W1
015E6:  MOV     W1,W0
015E8:  CLR.B   1
015EA:  CALL    57C
015EE:  INC     W1,W1
015F0:  BTSC.B  219.1
015F2:  BRA     15F0
015F4:  MOV.B   W0L,21A
015F6:  MOV     #13,W0
015F8:  CPSGT   W1,W0
015FA:  BRA     15E6
015FC:  MOV     8CE,W0
015FE:  MOV     #0,W4
01600:  CALL    916
01604:  BTSC.B  219.1
01606:  BRA     1604
01608:  MOV.B   #A,W0L
0160A:  MOV.B   W0L,21A
0160C:  BTSC.B  219.1
0160E:  BRA     160C
01610:  MOV.B   #D,W0L
01612:  MOV.B   W0L,21A
....................    } 
....................  
....................    pwm_enable(); 
01614:  CALL    13C6
01618:  MOV     [--W15],W6
0161A:  MOV     [--W15],W5
0161C:  RETURN  
.................... } 
.................... // Move to given position (in 0.1 mm) 
.................... void move_to_pos(unsigned int16 position) 
.................... { 
....................    if(position>md_move_range) 
0161E:  MOV     8BC,W0
01620:  MOV     93E,W4
01622:  CP      W4,W0
01624:  BRA     LEU,1646
....................    { 
....................       position=md_move_range; 
01626:  PUSH    8BC
01628:  POP     93E
....................       if(debug_mode_pwm) 
0162A:  BTSS.B  8B0.2
0162C:  BRA     1646
....................          fprintf(RS232, "Invalid entry: System cannot move to a position beyond the movement range. System will move to maximum possible distance."); 
0162E:  MOV     #0,W1
01630:  MOV     W1,W0
01632:  CLR.B   1
01634:  CALL    5A2
01638:  INC     W1,W1
0163A:  BTSC.B  219.1
0163C:  BRA     163A
0163E:  MOV.B   W0L,21A
01640:  MOV     #78,W0
01642:  CPSGT   W1,W0
01644:  BRA     1630
....................    } 
....................     
....................    fprintf(RS232,"Moving...\n\r"); 
01646:  MOV     #0,W1
01648:  MOV     W1,W0
0164A:  CLR.B   1
0164C:  CALL    610
01650:  INC     W1,W1
01652:  BTSC.B  219.1
01654:  BRA     1652
01656:  MOV.B   W0L,21A
01658:  MOV     #A,W0
0165A:  CPSGT   W1,W0
0165C:  BRA     1648
....................     
....................    // Number of steps to given position 
....................    unsigned int16 displacement;     
....................     
....................    // Set direction 
....................    if(position > md_current_pos) 
0165E:  MOV     8C4,W0
01660:  MOV     93E,W4
01662:  CP      W4,W0
01664:  BRA     LEU,167A
....................    { 
....................       md_set_dir(UP); 
01666:  MOV     #1,W4
01668:  MOV     W4,944
0166A:  CALL    F24
....................       displacement = position - md_current_pos; 
0166E:  MOV     93E,W4
01670:  MOV     8C4,W3
01672:  SUB     W4,W3,W0
01674:  MOV     W0,940
....................    } 
01676:  GOTO    1688
....................    else 
....................    { 
....................       md_set_dir(DOWN); 
0167A:  CLR     944
0167C:  CALL    F24
....................       displacement = md_current_pos - position; 
01680:  MOV     8C4,W4
01682:  MOV     93E,W3
01684:  SUB     W4,W3,W0
01686:  MOV     W0,940
....................    } 
....................    
....................    // If displacement is zero than no need to move 
....................    if(displacement == 0) return; 
01688:  CP0     940
0168A:  BRA     NZ,168E
0168C:  BRA     16B2
....................     
....................    // Move to given position 
....................    move(displacement); 
0168E:  PUSH    940
01690:  POP     944
01692:  CALL    1468
....................     
....................    // Set the current position 
....................    md_current_pos = position; 
01696:  PUSH    93E
01698:  POP     8C4
....................     
....................    fprintf(RS232,"Moving Done!\n\r"); 
0169A:  MOV     #0,W1
0169C:  MOV     W1,W0
0169E:  CLR.B   1
016A0:  CALL    628
016A4:  INC     W1,W1
016A6:  BTSC.B  219.1
016A8:  BRA     16A6
016AA:  MOV.B   W0L,21A
016AC:  MOV     #D,W0
016AE:  CPSGT   W1,W0
016B0:  BRA     169C
016B2:  RETURN  
.................... } 
.................... // Homing Function 
.................... void move_to_home() 
*
016CA:  MOV     W5,[W15++]
.................... { 
....................    fprintf(RS232,"Homing...\n\r");    
016CC:  MOV     #0,W1
016CE:  MOV     W1,W0
016D0:  CLR.B   1
016D2:  CALL    644
016D6:  INC     W1,W1
016D8:  BTSC.B  219.1
016DA:  BRA     16D8
016DC:  MOV.B   W0L,21A
016DE:  MOV     #A,W0
016E0:  CPSGT   W1,W0
016E2:  BRA     16CE
....................     
....................    set_all_pins(1); 
016E4:  MOV.B   #1,W0L
016E6:  MOV.B   W0L,93E
016E8:  CALL    16B4
....................    delay_ms(1500); 
016EC:  MOV     #5DC,W0
016EE:  CALL    8A6
....................     
....................    reg_md_homing = 1; 
016F2:  BSET.B  8B0.4
....................     
....................    // Send all pins to the home position 
....................    md_set_dir(DOWN); 
016F4:  CLR     944
016F6:  CALL    F24
....................    if(md_current_pos == 0) 
016FA:  CP0     8C4
016FC:  BRA     NZ,170E
....................       move(md_move_range + md_home_offset); 
016FE:  MOV     8BC,W0
01700:  ADD     8BE,W0
01702:  MOV     W0,W5
01704:  MOV     W5,944
01706:  CALL    1468
0170A:  GOTO    171A
....................    else 
....................       move(md_current_pos + md_home_offset); 
0170E:  MOV     8C4,W0
01710:  ADD     8BE,W0
01712:  MOV     W0,W5
01714:  MOV     W5,944
01716:  CALL    1468
....................     
....................    // Set the current position and step 
....................    md_current_pos = 0; 
0171A:  CLR     8C4
....................    md_current_step = 0; 
0171C:  CLR     8C0
....................     
....................    reg_md_homing = 0; 
0171E:  BCLR.B  8B0.4
....................      
....................    fprintf(RS232,"Homing Done!\n\r"); 
01720:  MOV     #0,W1
01722:  MOV     W1,W0
01724:  CLR.B   1
01726:  CALL    65C
0172A:  INC     W1,W1
0172C:  BTSC.B  219.1
0172E:  BRA     172C
01730:  MOV.B   W0L,21A
01732:  MOV     #D,W0
01734:  CPSGT   W1,W0
01736:  BRA     1722
01738:  MOV     [--W15],W5
0173A:  RETURN  
.................... } 
....................  
.................... // Demo run of the system 
.................... void demo_run() 
.................... { 
....................    reg_demo_run = 1; 
*
017B0:  BSET.B  8B0.5
....................     
....................    //move_to_home(); 
....................    delay_ms(2000); 
017B2:  MOV     #7D0,W0
017B4:  CALL    8A6
....................    move_to_pos(2000); 
017B8:  MOV     #7D0,W4
017BA:  MOV     W4,93E
017BC:  CALL    161E
....................    delay_ms(100); 
017C0:  MOV     #64,W0
017C2:  CALL    8A6
....................    set_all_pins(0); 
017C6:  CLR.B   93E
017C8:  CALL    16B4
....................    delay_ms(1500); 
017CC:  MOV     #5DC,W0
017CE:  CALL    8A6
....................     
....................    reg_demo_run = 0; 
017D2:  BCLR.B  8B0.5
017D4:  RETURN  
.................... } 
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
017D6:  MOV     W5,[W15++]
017D8:  MOV     W6,[W15++]
017DA:  BTSS.B  218.0
017DC:  BRA     17DA
017DE:  MOV     21C,W0
017E0:  MOV.B   W0L,8D6
017E2:  CLR     8D8
.................... { 
....................    char input=fgetc(RS232); 
....................    unsigned int i=0; 
....................     
....................    switch (input) 
017E4:  MOV.B   8D6,W0L
017E6:  CLR.B   1
017E8:  XOR     #61,W0
017EA:  BRA     Z,1816
017EC:  XOR     #12,W0
017EE:  BRA     Z,18C0
017F0:  XOR     #B,W0
017F2:  BRA     Z,1962
017F4:  XOR     #10,W0
017F6:  BRA     Z,1A04
017F8:  XOR     #18,W0
017FA:  BRA     Z,1A0C
017FC:  XOR     #14,W0
017FE:  BRA     Z,1ABA
01800:  XOR     #7,W0
01802:  BRA     Z,1AF4
01804:  XOR     #16,W0
01806:  BRA     Z,1B30
01808:  XOR     #1,W0
0180A:  BRA     Z,1BD2
0180C:  XOR     #16,W0
0180E:  BRA     Z,1C74
01810:  XOR     #10,W0
01812:  BRA     Z,1D1E
01814:  BRA     1D56
....................    { 
....................       case 'a':   fprintf(RS232,"Set Conversion Constant To(0<=X<=9999): "); 
01816:  MOV     #0,W1
01818:  MOV     W1,W0
0181A:  CLR.B   1
0181C:  CALL    678
01820:  INC     W1,W1
01822:  BTSC.B  219.1
01824:  BRA     1822
01826:  MOV.B   W0L,21A
01828:  MOV     #27,W0
0182A:  CPSGT   W1,W0
0182C:  BRA     1818
....................                   unsigned int input_const[4]; 
....................                    
....................                   for(i=0;i<4;i++){ 
0182E:  CLR     8D8
01830:  MOV     8D8,W4
01832:  CP      W4,#4
01834:  BRA     C,1868
....................                      input_const[i]=(unsigned)(fgetc(RS232)-48); 
01836:  MOV     8D8,W0
01838:  SL      W0,#1,W0
0183A:  MOV     #8DA,W4
0183C:  ADD     W0,W4,W5
0183E:  BTSS.B  218.0
01840:  BRA     183E
01842:  MOV     21C,W0
01844:  ZE      W0,W0
01846:  CLR.B   1
01848:  SUB     #30,W0
0184A:  MOV     W0,[W5]
....................                      fputc(input_const[i]+48,RS232); 
0184C:  MOV     8D8,W0
0184E:  SL      W0,#1,W0
01850:  MOV     #8DA,W4
01852:  ADD     W0,W4,W0
01854:  MOV     [W0],W5
01856:  ADD     #30,W5
01858:  MOV.B   W5L,W0L
0185A:  BTSC.B  219.1
0185C:  BRA     185A
0185E:  MOV.B   W0L,21A
01860:  CLR.B   21B
01862:  INC     08D8
01864:  GOTO    1830
....................                   } 
....................                   fprintf(RS232,"\n\r"); 
01868:  BTSC.B  219.1
0186A:  BRA     1868
0186C:  MOV.B   #A,W0L
0186E:  MOV.B   W0L,21A
01870:  BTSC.B  219.1
01872:  BRA     1870
01874:  MOV.B   #D,W0L
01876:  MOV.B   W0L,21A
....................                    
....................                   unsigned int16 conv_const=1000*input_const[0]+100*input_const[1]+10*input_const[2]+1*input_const[3]; 
01878:  MOV     #3E8,W4
0187A:  MOV     8DA,W3
0187C:  MUL.UU  W4,W3,W0
0187E:  MOV     W0,W5
01880:  MOV     #64,W4
01882:  MOV     8DC,W3
01884:  MUL.UU  W4,W3,W0
01886:  ADD     W0,W5,W5
01888:  MOV     8DE,W4
0188A:  MUL.UU  W4,#A,W0
0188C:  ADD     W0,W5,W5
0188E:  MOV     W5,W0
01890:  ADD     8E0,W0
01892:  MOV     W0,8E2
....................                    
....................                   if(conv_const == 0) 
01894:  CP0     8E2
01896:  BRA     NZ,18A0
....................                      md_conv_const = 1; 
01898:  MOV     #1,W4
0189A:  MOV     W4,8BA
0189C:  GOTO    18A4
....................                   else 
....................                      md_conv_const = conv_const; 
018A0:  PUSH    8E2
018A2:  POP     8BA
....................                   fprintf(RS232,"Done!\n\r"); 
018A4:  MOV     #0,W1
018A6:  MOV     W1,W0
018A8:  CLR.B   1
018AA:  CALL    6AE
018AE:  INC     W1,W1
018B0:  BTSC.B  219.1
018B2:  BRA     18B0
018B4:  MOV.B   W0L,21A
018B6:  MOV     #6,W0
018B8:  CPSGT   W1,W0
018BA:  BRA     18A6
....................                   break; 
018BC:  GOTO    1D56
....................       case 's':   fprintf(RS232,"Set Speed To(0<=X<=999) (in mm/s): "); 
018C0:  MOV     #0,W1
018C2:  MOV     W1,W0
018C4:  CLR.B   1
018C6:  CALL    6C2
018CA:  INC     W1,W1
018CC:  BTSC.B  219.1
018CE:  BRA     18CC
018D0:  MOV.B   W0L,21A
018D2:  MOV     #22,W0
018D4:  CPSGT   W1,W0
018D6:  BRA     18C2
....................                   unsigned int input_speed[3]; 
....................                    
....................                   for(i=0;i<3;i++){ 
018D8:  CLR     8D8
018DA:  MOV     8D8,W4
018DC:  CP      W4,#3
018DE:  BRA     C,1912
....................                      input_speed[i]=(unsigned)(fgetc(RS232)-48); 
018E0:  MOV     8D8,W0
018E2:  SL      W0,#1,W0
018E4:  MOV     #8E4,W4
018E6:  ADD     W0,W4,W5
018E8:  BTSS.B  218.0
018EA:  BRA     18E8
018EC:  MOV     21C,W0
018EE:  ZE      W0,W0
018F0:  CLR.B   1
018F2:  SUB     #30,W0
018F4:  MOV     W0,[W5]
....................                      fputc(input_speed[i]+48,RS232); 
018F6:  MOV     8D8,W0
018F8:  SL      W0,#1,W0
018FA:  MOV     #8E4,W4
018FC:  ADD     W0,W4,W0
018FE:  MOV     [W0],W5
01900:  ADD     #30,W5
01902:  MOV.B   W5L,W0L
01904:  BTSC.B  219.1
01906:  BRA     1904
01908:  MOV.B   W0L,21A
0190A:  CLR.B   21B
0190C:  INC     08D8
0190E:  GOTO    18DA
....................                   } 
....................                   fprintf(RS232,"\n\r"); 
01912:  BTSC.B  219.1
01914:  BRA     1912
01916:  MOV.B   #A,W0L
01918:  MOV.B   W0L,21A
0191A:  BTSC.B  219.1
0191C:  BRA     191A
0191E:  MOV.B   #D,W0L
01920:  MOV.B   W0L,21A
....................                    
....................                   unsigned int16 speed=100*input_speed[0]+10*input_speed[1]+1*input_speed[2]; 
01922:  MOV     #64,W4
01924:  MOV     8E4,W3
01926:  MUL.UU  W4,W3,W0
01928:  MOV     W0,W5
0192A:  MOV     8E6,W4
0192C:  MUL.UU  W4,#A,W0
0192E:  ADD     W0,W5,W5
01930:  MOV     W5,W0
01932:  ADD     8E8,W0
01934:  MOV     W0,8EA
....................                   if(speed == 0) 
01936:  CP0     8EA
01938:  BRA     NZ,193E
....................                      speed = 1; 
0193A:  MOV     #1,W4
0193C:  MOV     W4,8EA
....................                   set_speed(speed); 
0193E:  PUSH    8EA
01940:  POP     93E
01942:  CALL    ED6
....................                   fprintf(RS232,"Done!\n\r"); 
01946:  MOV     #0,W1
01948:  MOV     W1,W0
0194A:  CLR.B   1
0194C:  CALL    6AE
01950:  INC     W1,W1
01952:  BTSC.B  219.1
01954:  BRA     1952
01956:  MOV.B   W0L,21A
01958:  MOV     #6,W0
0195A:  CPSGT   W1,W0
0195C:  BRA     1948
....................                   break; 
0195E:  GOTO    1D56
....................       case 'x':   fprintf(RS232,"Move To(0<=X<=9999): "); 
01962:  MOV     #0,W1
01964:  MOV     W1,W0
01966:  CLR.B   1
01968:  CALL    6F2
0196C:  INC     W1,W1
0196E:  BTSC.B  219.1
01970:  BRA     196E
01972:  MOV.B   W0L,21A
01974:  MOV     #14,W0
01976:  CPSGT   W1,W0
01978:  BRA     1964
....................                   unsigned int input_pos[4]; 
....................                    
....................                   for(i=0;i<4;i++){ 
0197A:  CLR     8D8
0197C:  MOV     8D8,W4
0197E:  CP      W4,#4
01980:  BRA     C,19B4
....................                      input_pos[i]=(unsigned)(fgetc(RS232)-48); 
01982:  MOV     8D8,W0
01984:  SL      W0,#1,W0
01986:  MOV     #8EC,W4
01988:  ADD     W0,W4,W5
0198A:  BTSS.B  218.0
0198C:  BRA     198A
0198E:  MOV     21C,W0
01990:  ZE      W0,W0
01992:  CLR.B   1
01994:  SUB     #30,W0
01996:  MOV     W0,[W5]
....................                      fputc(input_pos[i]+48,RS232); 
01998:  MOV     8D8,W0
0199A:  SL      W0,#1,W0
0199C:  MOV     #8EC,W4
0199E:  ADD     W0,W4,W0
019A0:  MOV     [W0],W5
019A2:  ADD     #30,W5
019A4:  MOV.B   W5L,W0L
019A6:  BTSC.B  219.1
019A8:  BRA     19A6
019AA:  MOV.B   W0L,21A
019AC:  CLR.B   21B
019AE:  INC     08D8
019B0:  GOTO    197C
....................                   } 
....................                   fprintf(RS232,"\n\r"); 
019B4:  BTSC.B  219.1
019B6:  BRA     19B4
019B8:  MOV.B   #A,W0L
019BA:  MOV.B   W0L,21A
019BC:  BTSC.B  219.1
019BE:  BRA     19BC
019C0:  MOV.B   #D,W0L
019C2:  MOV.B   W0L,21A
....................                    
....................                   unsigned int16 position=1000*input_pos[0]+100*input_pos[1]+10*input_pos[2]+1*input_pos[3]; 
019C4:  MOV     #3E8,W4
019C6:  MOV     8EC,W3
019C8:  MUL.UU  W4,W3,W0
019CA:  MOV     W0,W5
019CC:  MOV     #64,W4
019CE:  MOV     8EE,W3
019D0:  MUL.UU  W4,W3,W0
019D2:  ADD     W0,W5,W5
019D4:  MOV     8F0,W4
019D6:  MUL.UU  W4,#A,W0
019D8:  ADD     W0,W5,W5
019DA:  MOV     W5,W0
019DC:  ADD     8F2,W0
019DE:  MOV     W0,8F4
....................                    
....................                   move_to_pos(position); 
019E0:  PUSH    8F4
019E2:  POP     93E
019E4:  CALL    161E
....................                   fprintf(RS232,"Done!\n\r"); 
019E8:  MOV     #0,W1
019EA:  MOV     W1,W0
019EC:  CLR.B   1
019EE:  CALL    6AE
019F2:  INC     W1,W1
019F4:  BTSC.B  219.1
019F6:  BRA     19F4
019F8:  MOV.B   W0L,21A
019FA:  MOV     #6,W0
019FC:  CPSGT   W1,W0
019FE:  BRA     19EA
....................                   break; 
01A00:  GOTO    1D56
....................       case 'h':   move_to_home(); 
01A04:  CALL    16CA
....................                   break; 
01A08:  GOTO    1D56
....................       case 'p':   fprintf(RS232,"Pin (x,y,state): "); 
01A0C:  MOV     #0,W1
01A0E:  MOV     W1,W0
01A10:  CLR.B   1
01A12:  CALL    714
01A16:  INC     W1,W1
01A18:  BTSC.B  219.1
01A1A:  BRA     1A18
01A1C:  MOV.B   W0L,21A
01A1E:  MOV     #10,W0
01A20:  CPSGT   W1,W0
01A22:  BRA     1A0E
....................                   unsigned int x = (unsigned)(fgetc(RS232)-48); 
01A24:  BTSS.B  218.0
01A26:  BRA     1A24
01A28:  MOV     21C,W0
01A2A:  ZE      W0,W0
01A2C:  CLR.B   1
01A2E:  SUB     #30,W0
01A30:  MOV     W0,8F6
....................                   fputc(x+48,RS232); 
01A32:  MOV     #30,W4
01A34:  MOV     8F6,W3
01A36:  ADD     W3,W4,W5
01A38:  MOV.B   W5L,W0L
01A3A:  BTSC.B  219.1
01A3C:  BRA     1A3A
01A3E:  MOV.B   W0L,21A
01A40:  CLR.B   21B
....................                   unsigned int y = (unsigned)(fgetc(RS232)-48); 
01A42:  BTSS.B  218.0
01A44:  BRA     1A42
01A46:  MOV     21C,W0
01A48:  ZE      W0,W0
01A4A:  CLR.B   1
01A4C:  SUB     #30,W0
01A4E:  MOV     W0,8F8
....................                   fputc(y+48,RS232); 
01A50:  MOV     #30,W4
01A52:  MOV     8F8,W3
01A54:  ADD     W3,W4,W5
01A56:  MOV.B   W5L,W0L
01A58:  BTSC.B  219.1
01A5A:  BRA     1A58
01A5C:  MOV.B   W0L,21A
01A5E:  CLR.B   21B
....................                   unsigned int state = (unsigned)(fgetc(RS232)-48); 
01A60:  BTSS.B  218.0
01A62:  BRA     1A60
01A64:  MOV     21C,W0
01A66:  ZE      W0,W0
01A68:  CLR.B   1
01A6A:  SUB     #30,W0
01A6C:  MOV     W0,8FA
....................                   fputc(state+48,RS232); 
01A6E:  MOV     #30,W4
01A70:  MOV     8FA,W3
01A72:  ADD     W3,W4,W5
01A74:  MOV.B   W5L,W0L
01A76:  BTSC.B  219.1
01A78:  BRA     1A76
01A7A:  MOV.B   W0L,21A
01A7C:  CLR.B   21B
....................                   fprintf(RS232,"\n\r"); 
01A7E:  BTSC.B  219.1
01A80:  BRA     1A7E
01A82:  MOV.B   #A,W0L
01A84:  MOV.B   W0L,21A
01A86:  BTSC.B  219.1
01A88:  BRA     1A86
01A8A:  MOV.B   #D,W0L
01A8C:  MOV.B   W0L,21A
....................                    
....................                   set_pin(x, y, state); 
01A8E:  PUSH    8F6
01A90:  POP     954
01A92:  PUSH    8F8
01A94:  POP     956
01A96:  PUSH    8FA
01A98:  POP     958
01A9A:  CALL    121E
....................                   fprintf(RS232,"Done!\n\r"); 
01A9E:  MOV     #0,W1
01AA0:  MOV     W1,W0
01AA2:  CLR.B   1
01AA4:  CALL    6AE
01AA8:  INC     W1,W1
01AAA:  BTSC.B  219.1
01AAC:  BRA     1AAA
01AAE:  MOV.B   W0L,21A
01AB0:  MOV     #6,W0
01AB2:  CPSGT   W1,W0
01AB4:  BRA     1AA0
....................                   break; 
01AB6:  GOTO    1D56
....................       case 'd':   fprintf(RS232,"Disconnecting pins...\n\r"); 
01ABA:  MOV     #0,W1
01ABC:  MOV     W1,W0
01ABE:  CLR.B   1
01AC0:  CALL    732
01AC4:  INC     W1,W1
01AC6:  BTSC.B  219.1
01AC8:  BRA     1AC6
01ACA:  MOV.B   W0L,21A
01ACC:  MOV     #16,W0
01ACE:  CPSGT   W1,W0
01AD0:  BRA     1ABC
....................                   set_all_pins(0); 
01AD2:  CLR.B   93E
01AD4:  CALL    16B4
....................                   fprintf(RS232,"Done!\n\r"); 
01AD8:  MOV     #0,W1
01ADA:  MOV     W1,W0
01ADC:  CLR.B   1
01ADE:  CALL    6AE
01AE2:  INC     W1,W1
01AE4:  BTSC.B  219.1
01AE6:  BRA     1AE4
01AE8:  MOV.B   W0L,21A
01AEA:  MOV     #6,W0
01AEC:  CPSGT   W1,W0
01AEE:  BRA     1ADA
....................                   break; 
01AF0:  GOTO    1D56
....................       case 'c':   fprintf(RS232,"Connecting pins...\n\r"); 
01AF4:  MOV     #0,W1
01AF6:  MOV     W1,W0
01AF8:  CLR.B   1
01AFA:  CALL    756
01AFE:  INC     W1,W1
01B00:  BTSC.B  219.1
01B02:  BRA     1B00
01B04:  MOV.B   W0L,21A
01B06:  MOV     #13,W0
01B08:  CPSGT   W1,W0
01B0A:  BRA     1AF6
....................                   set_all_pins(1); 
01B0C:  MOV.B   #1,W0L
01B0E:  MOV.B   W0L,93E
01B10:  CALL    16B4
....................                   fprintf(RS232,"Done!\n\r"); 
01B14:  MOV     #0,W1
01B16:  MOV     W1,W0
01B18:  CLR.B   1
01B1A:  CALL    6AE
01B1E:  INC     W1,W1
01B20:  BTSC.B  219.1
01B22:  BRA     1B20
01B24:  MOV.B   W0L,21A
01B26:  MOV     #6,W0
01B28:  CPSGT   W1,W0
01B2A:  BRA     1B16
....................                   break; 
01B2C:  GOTO    1D56
....................       case 'u':   fprintf(RS232,"Set Up Time To(0<=X<=9999) (in ms): "); 
01B30:  MOV     #0,W1
01B32:  MOV     W1,W0
01B34:  CLR.B   1
01B36:  CALL    778
01B3A:  INC     W1,W1
01B3C:  BTSC.B  219.1
01B3E:  BRA     1B3C
01B40:  MOV.B   W0L,21A
01B42:  MOV     #23,W0
01B44:  CPSGT   W1,W0
01B46:  BRA     1B32
....................                   unsigned int input_up_time[4]; 
....................                    
....................                   for(i=0;i<4;i++){ 
01B48:  CLR     8D8
01B4A:  MOV     8D8,W4
01B4C:  CP      W4,#4
01B4E:  BRA     C,1B82
....................                      input_up_time[i]=(unsigned)(fgetc(RS232)-48); 
01B50:  MOV     8D8,W0
01B52:  SL      W0,#1,W0
01B54:  MOV     #8FC,W4
01B56:  ADD     W0,W4,W5
01B58:  BTSS.B  218.0
01B5A:  BRA     1B58
01B5C:  MOV     21C,W0
01B5E:  ZE      W0,W0
01B60:  CLR.B   1
01B62:  SUB     #30,W0
01B64:  MOV     W0,[W5]
....................                      fputc(input_up_time[i]+48,RS232); 
01B66:  MOV     8D8,W0
01B68:  SL      W0,#1,W0
01B6A:  MOV     #8FC,W4
01B6C:  ADD     W0,W4,W0
01B6E:  MOV     [W0],W5
01B70:  ADD     #30,W5
01B72:  MOV.B   W5L,W0L
01B74:  BTSC.B  219.1
01B76:  BRA     1B74
01B78:  MOV.B   W0L,21A
01B7A:  CLR.B   21B
01B7C:  INC     08D8
01B7E:  GOTO    1B4A
....................                   } 
....................                   fprintf(RS232,"\n\r"); 
01B82:  BTSC.B  219.1
01B84:  BRA     1B82
01B86:  MOV.B   #A,W0L
01B88:  MOV.B   W0L,21A
01B8A:  BTSC.B  219.1
01B8C:  BRA     1B8A
01B8E:  MOV.B   #D,W0L
01B90:  MOV.B   W0L,21A
....................                    
....................                   unsigned int16 up_time=1000*input_up_time[0]+100*input_up_time[1]+10*input_up_time[2]+1*input_up_time[3]; 
01B92:  MOV     #3E8,W4
01B94:  MOV     8FC,W3
01B96:  MUL.UU  W4,W3,W0
01B98:  MOV     W0,W5
01B9A:  MOV     #64,W4
01B9C:  MOV     8FE,W3
01B9E:  MUL.UU  W4,W3,W0
01BA0:  ADD     W0,W5,W5
01BA2:  MOV     900,W4
01BA4:  MUL.UU  W4,#A,W0
01BA6:  ADD     W0,W5,W5
01BA8:  MOV     W5,W0
01BAA:  ADD     902,W0
01BAC:  MOV     W0,904
....................                    
....................                   set_pin_up_time(up_time); 
01BAE:  PUSH    904
01BB0:  POP     93E
01BB2:  CALL    173C
....................                   fprintf(RS232,"Done!\n\r"); 
01BB6:  MOV     #0,W1
01BB8:  MOV     W1,W0
01BBA:  CLR.B   1
01BBC:  CALL    6AE
01BC0:  INC     W1,W1
01BC2:  BTSC.B  219.1
01BC4:  BRA     1BC2
01BC6:  MOV.B   W0L,21A
01BC8:  MOV     #6,W0
01BCA:  CPSGT   W1,W0
01BCC:  BRA     1BB8
....................                   break; 
01BCE:  GOTO    1D56
....................        case 't':   fprintf(RS232,"Set Down Time To(0<=X<=9999) (in ms): "); 
01BD2:  MOV     #0,W1
01BD4:  MOV     W1,W0
01BD6:  CLR.B   1
01BD8:  CALL    7AA
01BDC:  INC     W1,W1
01BDE:  BTSC.B  219.1
01BE0:  BRA     1BDE
01BE2:  MOV.B   W0L,21A
01BE4:  MOV     #25,W0
01BE6:  CPSGT   W1,W0
01BE8:  BRA     1BD4
....................                   unsigned int input_down_time[4]; 
....................                    
....................                   for(i=0;i<4;i++){ 
01BEA:  CLR     8D8
01BEC:  MOV     8D8,W4
01BEE:  CP      W4,#4
01BF0:  BRA     C,1C24
....................                      input_down_time[i]=(unsigned)(fgetc(RS232)-48); 
01BF2:  MOV     8D8,W0
01BF4:  SL      W0,#1,W0
01BF6:  MOV     #906,W4
01BF8:  ADD     W0,W4,W5
01BFA:  BTSS.B  218.0
01BFC:  BRA     1BFA
01BFE:  MOV     21C,W0
01C00:  ZE      W0,W0
01C02:  CLR.B   1
01C04:  SUB     #30,W0
01C06:  MOV     W0,[W5]
....................                      fputc(input_down_time[i]+48,RS232); 
01C08:  MOV     8D8,W0
01C0A:  SL      W0,#1,W0
01C0C:  MOV     #906,W4
01C0E:  ADD     W0,W4,W0
01C10:  MOV     [W0],W5
01C12:  ADD     #30,W5
01C14:  MOV.B   W5L,W0L
01C16:  BTSC.B  219.1
01C18:  BRA     1C16
01C1A:  MOV.B   W0L,21A
01C1C:  CLR.B   21B
01C1E:  INC     08D8
01C20:  GOTO    1BEC
....................                   } 
....................                   fprintf(RS232,"\n\r"); 
01C24:  BTSC.B  219.1
01C26:  BRA     1C24
01C28:  MOV.B   #A,W0L
01C2A:  MOV.B   W0L,21A
01C2C:  BTSC.B  219.1
01C2E:  BRA     1C2C
01C30:  MOV.B   #D,W0L
01C32:  MOV.B   W0L,21A
....................                    
....................                   unsigned int16 down_time=1000*input_down_time[0]+100*input_down_time[1]+10*input_down_time[2]+1*input_down_time[3]; 
01C34:  MOV     #3E8,W4
01C36:  MOV     906,W3
01C38:  MUL.UU  W4,W3,W0
01C3A:  MOV     W0,W5
01C3C:  MOV     #64,W4
01C3E:  MOV     908,W3
01C40:  MUL.UU  W4,W3,W0
01C42:  ADD     W0,W5,W5
01C44:  MOV     90A,W4
01C46:  MUL.UU  W4,#A,W0
01C48:  ADD     W0,W5,W5
01C4A:  MOV     W5,W0
01C4C:  ADD     90C,W0
01C4E:  MOV     W0,90E
....................                    
....................                   set_pin_down_time(down_time); 
01C50:  PUSH    90E
01C52:  POP     93E
01C54:  CALL    1776
....................                   fprintf(RS232,"Done!\n\r"); 
01C58:  MOV     #0,W1
01C5A:  MOV     W1,W0
01C5C:  CLR.B   1
01C5E:  CALL    6AE
01C62:  INC     W1,W1
01C64:  BTSC.B  219.1
01C66:  BRA     1C64
01C68:  MOV.B   W0L,21A
01C6A:  MOV     #6,W0
01C6C:  CPSGT   W1,W0
01C6E:  BRA     1C5A
....................                   break; 
01C70:  GOTO    1D56
....................        
....................       case 'b':   fprintf(RS232,"Pin State (0<=X<=65535): "); 
01C74:  MOV     #0,W1
01C76:  MOV     W1,W0
01C78:  CLR.B   1
01C7A:  CALL    7DE
01C7E:  INC     W1,W1
01C80:  BTSC.B  219.1
01C82:  BRA     1C80
01C84:  MOV.B   W0L,21A
01C86:  MOV     #18,W0
01C88:  CPSGT   W1,W0
01C8A:  BRA     1C76
....................                   unsigned int input_state[5]; 
....................                    
....................                   for(i=0;i<5;i++){ 
01C8C:  CLR     8D8
01C8E:  MOV     8D8,W4
01C90:  CP      W4,#5
01C92:  BRA     C,1CC6
....................                      input_state[i]=(unsigned)(fgetc(RS232)-48); 
01C94:  MOV     8D8,W0
01C96:  SL      W0,#1,W0
01C98:  MOV     #910,W4
01C9A:  ADD     W0,W4,W5
01C9C:  BTSS.B  218.0
01C9E:  BRA     1C9C
01CA0:  MOV     21C,W0
01CA2:  ZE      W0,W0
01CA4:  CLR.B   1
01CA6:  SUB     #30,W0
01CA8:  MOV     W0,[W5]
....................                      fputc(input_state[i]+48,RS232); 
01CAA:  MOV     8D8,W0
01CAC:  SL      W0,#1,W0
01CAE:  MOV     #910,W4
01CB0:  ADD     W0,W4,W0
01CB2:  MOV     [W0],W5
01CB4:  ADD     #30,W5
01CB6:  MOV.B   W5L,W0L
01CB8:  BTSC.B  219.1
01CBA:  BRA     1CB8
01CBC:  MOV.B   W0L,21A
01CBE:  CLR.B   21B
01CC0:  INC     08D8
01CC2:  GOTO    1C8E
....................                   } 
....................                   fprintf(RS232,"\n\r"); 
01CC6:  BTSC.B  219.1
01CC8:  BRA     1CC6
01CCA:  MOV.B   #A,W0L
01CCC:  MOV.B   W0L,21A
01CCE:  BTSC.B  219.1
01CD0:  BRA     1CCE
01CD2:  MOV.B   #D,W0L
01CD4:  MOV.B   W0L,21A
....................                    
....................                   unsigned int16 value = 10000*input_state[0] + 1000*input_state[1]+100*input_state[2]+10*input_state[3]+1*input_state[4]; 
01CD6:  MOV     #2710,W4
01CD8:  MOV     910,W3
01CDA:  MUL.UU  W4,W3,W0
01CDC:  MOV     W0,W5
01CDE:  MOV     #3E8,W4
01CE0:  MOV     912,W3
01CE2:  MUL.UU  W4,W3,W0
01CE4:  ADD     W0,W5,W5
01CE6:  MOV     #64,W4
01CE8:  MOV     914,W3
01CEA:  MUL.UU  W4,W3,W0
01CEC:  ADD     W0,W5,W5
01CEE:  MOV     916,W4
01CF0:  MUL.UU  W4,#A,W0
01CF2:  ADD     W0,W5,W5
01CF4:  MOV     W5,W0
01CF6:  ADD     918,W0
01CF8:  MOV     W0,91A
....................                    
....................                   send_pin_state(value); 
01CFA:  PUSH    91A
01CFC:  POP     960
01CFE:  CALL    11E4
....................                    
....................                   fprintf(RS232,"Done!\n\r"); 
01D02:  MOV     #0,W1
01D04:  MOV     W1,W0
01D06:  CLR.B   1
01D08:  CALL    6AE
01D0C:  INC     W1,W1
01D0E:  BTSC.B  219.1
01D10:  BRA     1D0E
01D12:  MOV.B   W0L,21A
01D14:  MOV     #6,W0
01D16:  CPSGT   W1,W0
01D18:  BRA     1D04
....................                   break; 
01D1A:  GOTO    1D56
....................       case 'r':   fprintf(RS232,"Demo Run..."); 
01D1E:  MOV     #0,W1
01D20:  MOV     W1,W0
01D22:  CLR.B   1
01D24:  CALL    804
01D28:  INC     W1,W1
01D2A:  BTSC.B  219.1
01D2C:  BRA     1D2A
01D2E:  MOV.B   W0L,21A
01D30:  MOV     #A,W0
01D32:  CPSGT   W1,W0
01D34:  BRA     1D20
....................                    
....................                   demo_run(); 
01D36:  CALL    17B0
....................                    
....................                   fprintf(RS232,"Done!\n\r"); 
01D3A:  MOV     #0,W1
01D3C:  MOV     W1,W0
01D3E:  CLR.B   1
01D40:  CALL    6AE
01D44:  INC     W1,W1
01D46:  BTSC.B  219.1
01D48:  BRA     1D46
01D4A:  MOV.B   W0L,21A
01D4C:  MOV     #6,W0
01D4E:  CPSGT   W1,W0
01D50:  BRA     1D3C
....................                   break; 
01D52:  GOTO    1D56
....................    } 
01D56:  MOV     [--W15],W6
01D58:  MOV     [--W15],W5
01D5A:  RETURN  
.................... } 
....................  
.................... // RS485 receive byte interrupt 
.................... #INT_RDA 
.................... void isr_rs485_message() 
*
00854:  PUSH    42
00856:  PUSH    36
00858:  PUSH    32
0085A:  MOV     W0,[W15++]
0085C:  MOV     #2,W0
0085E:  REPEAT  #C
00860:  MOV     [W0++],[W15++]
.................... { 
....................    if(fgetc(RS485) == 'r') 
00862:  BTSS.B  20E.0
00864:  BRA     862
00866:  MOV     212,W0
00868:  MOV     #72,W4
0086A:  CP.B    W4L,W0L
0086C:  BRA     NZ,870
....................       reg_rs485_busy = 0; 
0086E:  BCLR.B  8B0.7
.................... }  
.................... // RS232 receive byte interrupt 
00870:  BCLR.B  85.1
00872:  MOV     #1A,W0
00874:  REPEAT  #C
00876:  MOV     [--W15],[W0--]
00878:  MOV     [--W15],W0
0087A:  POP     32
0087C:  POP     36
0087E:  POP     42
00880:  RETFIE  
.................... #INT_RDA2 
.................... void isr_rs232_message() 
00882:  PUSH    42
00884:  PUSH    36
00886:  PUSH    32
00888:  MOV     W0,[W15++]
0088A:  MOV     #2,W0
0088C:  REPEAT  #C
0088E:  MOV     [W0++],[W15++]
.................... { 
....................    // Disable RS232 receive byte interrupt 
....................    disable_interrupts(INT_RDA2); 
00890:  BCLR.B  8F.0
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1;   
00892:  BSET.B  8B0.6
00894:  BCLR.B  87.0
00896:  MOV     #1A,W0
00898:  REPEAT  #C
0089A:  MOV     [--W15],[W0--]
0089C:  MOV     [--W15],W0
0089E:  POP     32
008A0:  POP     36
008A2:  POP     42
008A4:  RETFIE  
.................... }  
....................  
.................... // Main method 
.................... void main() 
*
01D5C:  BSET.B  81.7
01D5E:  MOV     #8000,W4
01D60:  MOV     W4,20C
01D62:  MOV     #400,W4
01D64:  MOV     W4,20E
01D66:  MOV     #2,W4
01D68:  MOV     W4,214
01D6A:  MOV     #8000,W4
01D6C:  MOV     W4,216
01D6E:  MOV     #400,W4
01D70:  MOV     W4,218
01D72:  MOV     #2,W4
01D74:  MOV     W4,21E
01D76:  BCLR.B  8B0.0
01D78:  BCLR.B  8B0.1
01D7A:  BCLR.B  8B0.2
01D7C:  MOV     #20,W4
01D7E:  MOV     W4,8B2
01D80:  MOV     #3FF,W4
01D82:  MOV     W4,8B4
01D84:  MOV     #323,W4
01D86:  MOV     W4,8B6
01D88:  MOV     #64,W4
01D8A:  MOV     W4,8B8
01D8C:  MOV     #4E2,W4
01D8E:  MOV     W4,8BA
01D90:  MOV     #7D0,W4
01D92:  MOV     W4,8BC
01D94:  MOV     #64,W4
01D96:  MOV     W4,8BE
01D98:  CLR     8C0
01D9A:  MOV     #1,W4
01D9C:  MOV     W4,8C2
01D9E:  CLR     8C4
01DA0:  MOV     #BB8,W4
01DA2:  MOV     W4,8C6
01DA4:  MOV     #BB8,W4
01DA6:  MOV     W4,8C8
01DA8:  CLR.B   8B1
01DAA:  CLR     8CA
01DAC:  CLR     8CC
01DAE:  CLR     8CE
01DB0:  CLR     8D0
01DB2:  BCLR.B  8B0.3
01DB4:  BCLR.B  8B0.4
01DB6:  BCLR.B  8B0.5
01DB8:  BCLR.B  8B0.6
01DBA:  BCLR.B  8B0.7
01DBC:  CLR     8D2
01DBE:  MOV     #3E8,W4
01DC0:  MOV     W4,8D4
01DC2:  SETM    2A8
01DC4:  MOV     #2780,W15
01DC6:  MOV     #27FF,W0
01DC8:  MOV     W0,20
01DCA:  NOP     
01DCC:  BRA     1E62
01DCE:  DATA    C0,06,08
01DD0:  DATA    00,00,00
01DD2:  DATA    4B,F0,3F
01DD4:  DATA    5C,0A,58
01DD6:  DATA    F6,3B,8F
01DD8:  DATA    00,C0,3C
01DDA:  DATA    8B,28,AC
01DDC:  DATA    3C,BE,F6
01DDE:  DATA    3F,D2,D5
01DE0:  DATA    44,16,8C
01DE2:  DATA    15,D7,BF
01DE4:  DATA    69,00,5A
01DE6:  DATA    2E,1B,87
01DE8:  DATA    99,3F,9A
01DEA:  DATA    5F,AD,4B
01DEC:  DATA    91,E4,01
01DEE:  DATA    C0,5D,11
01DF0:  DATA    2F,92,E4
01DF2:  DATA    81,FB,3F
01DF4:  DATA    38,DA,91
01DF6:  DATA    80,9D,C5
01DF8:  DATA    E0,BF,6F
01DFA:  DATA    12,C0,B4
01DFC:  DATA    C3,09,AB
01DFE:  DATA    3F,6B,C1
01E00:  DATA    03,4E,C1
01E02:  DATA    B5,45,BF
01E04:  DATA    F7,40,05
01E06:  DATA    FF,00,5A
01E08:  DATA    EF,3F,F3
01E0A:  DATA    A3,E2,F7
01E0C:  DATA    D7,FF,01
01E0E:  DATA    40,C0,B4
01E10:  DATA    FF,05,3C
01E12:  DATA    58,FC,3F
01E14:  DATA    3C,D3,C0
01E16:  DATA    B5,BA,8C
01E18:  DATA    E2,3F,39
01E1A:  DATA    D3,C7,3D
01E1C:  DATA    41,79,B2
01E1E:  DATA    3F,87,0D
01E20:  DATA    3C,50,D0
01E22:  DATA    AF,62,3F
01E24:  DATA    30,4B,8D
01E26:  DATA    A2,82,AA
01E28:  DATA    04,40,09
01E2A:  DATA    A0,40,4A
01E2C:  DATA    05,76,03
01E2E:  DATA    40,EC,9E
01E30:  DATA    37,88,A6
01E32:  DATA    44,F0,3F
01E34:  DATA    8F,12,8D
01E36:  DATA    29,9A,5B
01E38:  DATA    C7,3F,0E
01E3A:  DATA    E0,80,7C
01E3C:  DATA    A1,D8,86
01E3E:  DATA    3F,29,4B
01E40:  DATA    FB,95,C2
01E42:  DATA    37,1A,3F
01E44:  DATA    00,00,00
01E46:  INC     W2,W2
01E48:  CP      W2,#1
01E4A:  BRA     NZ,1E54
01E4C:  TBLRDL  [W1],W3
01E4E:  TBLRDH  [W1++],W4
01E50:  MOV.B   6,W0L
01E52:  RETURN  
01E54:  CP      W2,#2
01E56:  BRA     NZ,1E5C
01E58:  MOV.B   7,W0L
01E5A:  RETURN  
01E5C:  MOV.B   8,W0L
01E5E:  CLR     W2
01E60:  RETURN  
01E62:  MOV     #0,W6
01E64:  MOV     #0,W0
01E66:  MOV     W0,32
01E68:  MOV     #1DCE,W0
01E6A:  MOV     W0,W1
01E6C:  CLR     W2
01E6E:  CALL    1E46
01E72:  MOV.B   W0L,B
01E74:  CALL    1E46
01E78:  MOV.B   W0L,A
01E7A:  CP0     W5
01E7C:  BRA     Z,1EB0
01E7E:  BTSS    W5.F
01E80:  BRA     1E90
01E82:  CALL    1E46
01E86:  MOV.B   W0L,D
01E88:  CALL    1E46
01E8C:  MOV.B   W0L,C
01E8E:  BCLR    W5.F
01E90:  BTSS    W5.E
01E92:  BRA     1EA4
01E94:  BCLR    W5.E
01E96:  DEC     W5,W5
01E98:  CALL    1E46
01E9C:  MOV.B   W0L,W7L
01E9E:  REPEAT  W5
01EA0:  MOV.B   W7L,[W6++]
01EA2:  BRA     1E6E
01EA4:  CALL    1E46
01EA8:  MOV.B   W0L,[W6++]
01EAA:  DEC     W5,W5
01EAC:  BRA     NZ,1EA4
01EAE:  BRA     1E6E
.................... { 
....................    // Set I/O states of the ports 
....................    //           FEDCBA9876543210 
....................    set_tris_b(0b1111111011111100); 
01EB0:  MOV     #FEFC,W4
01EB2:  MOV     W4,2C6
....................    set_tris_c(0b1111111111111111); 
01EB4:  SETM    2CC
....................    set_tris_d(0b1111111100001111); 
01EB6:  MOV     #FF0F,W4
01EB8:  MOV     W4,2D2
....................    set_tris_e(0b1111111110000000); 
01EBA:  MOV     #FF80,W4
01EBC:  MOV     W4,2D8
....................    set_tris_f(0b1111111111111100); 
01EBE:  MOV     #FFFC,W4
01EC0:  MOV     W4,2DE
....................    set_tris_g(0b1111111100111111); 
01EC2:  MOV     #FF3F,W4
01EC4:  MOV     W4,2E4
....................     
....................    delay_ms(500); 
01EC6:  MOV     #1F4,W0
01EC8:  CALL    8A6
....................    fprintf(RS232,"\n\rSKS Control Card - Code Version V1.1\n\n\r"); 
01ECC:  MOV     #0,W1
01ECE:  MOV     W1,W0
01ED0:  CLR.B   1
01ED2:  CALL    81C
01ED6:  INC     W1,W1
01ED8:  BTSC.B  219.1
01EDA:  BRA     1ED8
01EDC:  MOV.B   W0L,21A
01EDE:  MOV     #28,W0
01EE0:  CPSGT   W1,W0
01EE2:  BRA     1ECE
....................  
....................    // Turn on debug led 
....................    output_high(LED); 
01EE4:  BCLR.B  2C7.0
01EE6:  BSET.B  2CB.0
....................  
....................    // Set A/D converter to read motor torque control voltage 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
01EE8:  MOV     #1F80,W4
01EEA:  MOV     W4,2A4
01EEC:  MOV     #80E0,W4
01EEE:  MOV     W4,2A0
....................    setup_adc_ports(sAN2); 
01EF0:  MOV     #FFFB,W4
01EF2:  MOV     W4,2A8
01EF4:  CLR     2A2
....................    set_adc_channel(2); 
01EF6:  MOV     #2,W4
01EF8:  MOV     W4,2A6
....................  
....................    // Initialize components 
....................    pwm_init();                            // Initialize PWM module 
01EFA:  CALL    8CE
....................    dp_init();                             // Initialize digital potentiometer 
01EFE:  CALL    90C
....................    md_init();                             // Initialize motor driver 
01F02:  CALL    EAC
....................  
....................    // Enable RS232 and RS485 receive byte interrupt 
....................    enable_interrupts(INT_RDA); 
01F06:  BSET.B  8D.1
....................    enable_interrupts(INT_RDA2); 
01F08:  BSET.B  8F.0
....................    // Enable RS485 communication 
....................    output_low(RX_Disable);     
01F0A:  BCLR.B  2E4.2
01F0C:  BCLR.B  2E8.2
....................    output_high(TX_Enable); 
01F0E:  BCLR.B  2E4.3
01F10:  BSET.B  2E8.3
....................  
....................    while(true) 
....................    { 
....................       if(reg_rs232_message) 
01F12:  BTSS.B  8B0.6
01F14:  BRA     1F24
....................       { 
....................          reg_rs232_message = 0; 
01F16:  BCLR.B  8B0.6
....................          rs232_message(); 
01F18:  CALL    17D6
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
01F1C:  REPEAT  #3
01F1E:  MOV     21C,W0
01F20:  BCLR.B  87.0
....................          enable_interrupts(INT_RDA2); 
01F22:  BSET.B  8F.0
....................       } 
01F24:  GOTO    1F12
....................    } 
.................... } 
01F28:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 8100   FRC NOCKSFSM
          H: FF00  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: FF00  
   Word  3L: 8733   PUT64 BORRES NOBROWNOUT LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: FF00  
   Word  4L: 310F   NOWRTB NOBSS NOEBS NORBS
          H: FF00  
   Word  5L: 310F   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  6L: 0005   NOWRT PROTECT
          H: FF00  
   Word  7L: C003   ICSP1 NODEBUG
          H: FF00   NODEBUG

CCS PCD C Compiler, Version 4.108, 15145               10-Mar-14 10:40

               Filename: E:\File Server\Modesis\Proje Dosyalarý\LPS - Lazer Projeksiyon Sistemi\Eski Dosyalar\Software\SLS_6015_Servo_Lazer_Control_v3.5 - reset nomclr\Control_Card_v2.0.lst

               ROM used: 19680 bytes (20%)
                         Largest free fragment is 45856
               RAM used: 209 (3%) at main() level
                         441 (5%) worst case
               Stack:    9 worst case (8 in main + 1 for interrupts)

*
00000:  GOTO    4752
*
00044:  DATA    40,15,00
*
0005C:  DATA    1E,15,00
.................... #INCLUDE <30f6015.h>  
.................... //////// Standard Header file for the DSPIC30F6015 device //////////////// 
.................... #device DSPIC30F6015 
.................... #list 
....................  
.................... #DEVICE ADC=10                                                    // Configures the read_adc return size as 10 bit 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                                                      // No Watch Dog Timer  
.................... #FUSES HS2_PLL16                                                  // HS crystal, Freq=16*(Fcryst/2) 
.................... #FUSES NOCKSFSM                                                   // Clock Switching is disabled, fail Safe clock monitor is disabled  
.................... #FUSES BROWNOUT                                                   // Reset when brownout detected  
.................... #FUSES NOPROTECT                                                  // Code not protected from reading  
.................... #FUSES NOWRT                                                      // Program memory not write protected  
.................... #FUSES NODEBUG                                                    // No Debug mode for ICD 
.................... #FUSES NOMCLR                                                     // Disable MCLR 
....................  
.................... #USE DELAY(clock=120000000)                                       // delay() func. adjusted for 120Mhz Primary Osc. 
*
0155E:  CP0     W0
01560:  BTSC.B  42.1
01562:  BRA     1570
01564:  REPEAT  #3529
01566:  NOP     
01568:  REPEAT  #3FFF
0156A:  NOP     
0156C:  DEC     W0,W0
0156E:  BRA     155E
01570:  RETURN  
*
01F08:  CP0     W0
01F0A:  BTSC.B  42.1
01F0C:  BRA     1F16
01F0E:  REPEAT  #17
01F10:  NOP     
01F12:  DEC     W0,W0
01F14:  BRA     1F08
01F16:  RETURN  
.................... #USE RS232(stream=RS485,UART1,baud=38400,parity=N,bits=8,stop=1)  // Set UART1 as RS485 stream 
.................... #USE RS232(stream=RS232,UART2,baud=38400,parity=N,bits=8,stop=1)  // Set UART2 as RS232 stream 
....................  
....................  
....................  
.................... //Register for Reset Info 
.................... #WORD RCON                 = 0x740           //Reset control register 
.................... #BIT RCON_POR              = RCON.0          //POR 
.................... #BIT RCON_BOR              = RCON.1          //BOR 
.................... #BIT RCON_IDLE             = RCON.2 
.................... #BIT RCON_SLEEP            = RCON.3 
.................... #BIT RCON_WDTO             = RCON.4 
.................... #BIT RCON_SWDTEN           = RCON.5 
.................... #BIT RCON_SWR              = RCON.6 
.................... #BIT RCON_EXTR             = RCON.7         //MCLR Reset during normal operation 
.................... #BIT RCON_BGST             = RCON.13 
.................... #BIT RCON_IOPUWR           = RCON.14 
.................... #BIT RCON_TRAPR            = RCON.15 
....................  
....................  
....................  
.................... // Registers of quadrature encoder interface module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD QEI_QEICON        = 0x122           // Control and status register QEICON allows control of the QEI operation and status flags indicating the module state. 
.................... #WORD QEI_DFLTCON       = 0x124           // Digital filter control register DFLTCON allows control of the digital input filter operation. 
.................... #WORD QEI_POSCNT        = 0x126           // Position count register POSCNT allows reading and writing of the 16-bit position counter. 
.................... #WORD QEI_MAXCNT        = 0x128           // Maximum count register MAXCNT holds a value that will be compared to the POSCNT counter in some operations. 
.................... // Bits of the QEICON register 
.................... #BIT QEI_QEICON_CNTERR  = QEI_QEICON.15   // Count error status flag bit 
.................... #BIT QEI_QEICON_QEISIDL = QEI_QEICON.13   // Stop in idle mode bit 
.................... #BIT QEI_QEICON_INDEX   = QEI_QEICON.12   // Index pin state status bit (read only) 
.................... #BIT QEI_QEICON_UPDN    = QEI_QEICON.11   // Position counter direction status bit (read only) 
.................... #BIT QEI_QEICON_QEIM2   = QEI_QEICON.10   // Quadrature encoder interface mode select bits 
.................... #BIT QEI_QEICON_QEIM1   = QEI_QEICON.9 
.................... #BIT QEI_QEICON_QEIM0   = QEI_QEICON.8 
.................... #BIT QEI_QEICON_SWPAB   = QEI_QEICON.7    // Phase A and phase B input swap select bit  
.................... #BIT QEI_QEICON_PCDOUT  = QEI_QEICON.6    // Position counter direction state output rnable bit 
.................... #BIT QEI_QEICON_TQGATE  = QEI_QEICON.5    // Timer gated time accumulation rnable bit 
.................... #BIT QEI_QEICON_TQCKPS1 = QEI_QEICON.4    // Timer input clock prescale select bits 
.................... #BIT QEI_QEICON_TQCKPS0 = QEI_QEICON.3 
.................... #BIT QEI_QEICON_POSRES  = QEI_QEICON.2    // Position counter reset enable bit 
.................... #BIT QEI_QEICON_TQCS    = QEI_QEICON.1    // Timer clock source select bit 
.................... #BIT QEI_QEICON_UDSRC   = QEI_QEICON.0    // Position counter direction selection control bit 
.................... // Bits of the DFLTCON register 
.................... #BIT QEI_DFLTCON_IMV1   = QEI_DFLTCON.10  // Index match value bits 
.................... #BIT QEI_DFLTCON_IMV0   = QEI_DFLTCON.9   // These bits allow the user to specify the state of the QEA and QEB input pins during an Index pulse when the POSCNT register is to be reset. 
.................... #BIT QEI_DFLTCON_CEID   = QEI_DFLTCON.8   // Count error interrupt disable bit 
.................... #BIT QEI_DFLTCON_QEOUT  = QEI_DFLTCON.7   // QEA/QEB/IND digital filter output enable bit  
.................... #BIT QEI_DFLTCON_QECK2  = QEI_DFLTCON.6   // QEA/QEB/IND digital filter clock divide select bits 
.................... #BIT QEI_DFLTCON_QECK1  = QEI_DFLTCON.5      
.................... #BIT QEI_DFLTCON_QECK0  = QEI_DFLTCON.4 
....................  
.................... // Registers of the motor control PWM module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD PWM_PTCON         = 0x1C0           // PWM Time base control register 
.................... #WORD PWM_PTPER         = 0x1C4           // PWM Time base period register 
.................... #WORD PWM_PWMCON1       = 0x1C8           // PWM Control register #1 
.................... #WORD PWM_PWMCON2       = 0x1CA           // PWM Control register #2 
.................... #WORD PWM_PDC1          = 0x1D6           // PWM Duty cycle register #1 
.................... #WORD PWM_IEC2          = 0x090           // PWM Interrupt Enable Control Register 
.................... #WORD PWM_IFS2          = 0x088           // PWM Interrupt Flag Status Register 
.................... // Bits of the PTCON register 
.................... #BIT PWM_PTCON_PTEN     = PWM_PTCON.15    // PWM Time base timer enable bit 
.................... #BIT PWM_PTCON_PTOPS3   = PWM_PTCON.7     // PWM Time base output postscale select bits  
.................... #BIT PWM_PTCON_PTOPS2   = PWM_PTCON.6 
.................... #BIT PWM_PTCON_PTOPS1   = PWM_PTCON.5 
.................... #BIT PWM_PTCON_PTOPS0   = PWM_PTCON.4 
.................... #BIT PWM_PTCON_PTCKPS1  = PWM_PTCON.3     // PWM Time base input clock prescale select bits 
.................... #BIT PWM_PTCON_PTCKPS0  = PWM_PTCON.2     
.................... #BIT PWM_PTCON_PTMOD1   = PWM_PTCON.1     // PWM Time base mode select bits 
.................... #BIT PWM_PTCON_PTMOD0   = PWM_PTCON.0 
.................... // Bits of the PWMCON1 register 
.................... #BIT PWM_PWMCON1_PMOD1  = PWM_PWMCON1.8   // PWM1 I/O pin pair mode bit 
.................... #BIT PWM_PWMCON1_PEN1H  = PWM_PWMCON1.4   // PWM1H I/O pin enable bit 
.................... #BIT PWM_PWMCON1_PEN1L  = PWM_PWMCON1.0   // PWM1L I/O pin enable bit 
.................... // Bits of the PWMCON2 register   
.................... #BIT PWM_PWMCON2_IUE    = PWM_PWMCON2.2   // Immediate update enable bit 
.................... #BIT PWM_PWMCON2_OSYNC  = PWM_PWMCON2.1   // Output override synchronization bit 
.................... #BIT PWM_PWMCON2_UDIS   = PWM_PWMCON2.0   // PWM update disable bit 
.................... // Bits of the IEC2 register 
.................... #BIT PWM_IEC2_PWMIE     = PWM_IEC2.7      // PWM Interrupt enable bit  
.................... // Bits of the IFS2 register 
.................... #BIT PWM_IFS2_PWMIF     = PWM_IFS2.7      // PWM Interrupt flag status bit     
....................  
.................... // Registers of the UART1 module 
.................... #WORD UART_IFS0          = 0x088           // UART Interrupt Flag Status Register 
.................... // Bits of the IFS0 register 
.................... #BIT UART_IFS0_U1RXIF    = UART_IFS0.9     // UART Receiver Interrupt flag status bit   
.................... #BIT UART_IFS0_U1TXIF    = UART_IFS0.10    // UART Transmiter Interrupt flag status bit   
....................  
.................... // Led pins 
.................... #DEFINE LED          PIN_B8               // Led used in debugging 
....................  
.................... // Laser pins 
.................... #DEFINE LAS_1        PIN_B0               // Control pin of the first laser 
.................... #DEFINE LAS_2        PIN_B1               // Control pin of the second laser 
.................... #DEFINE LAS_3        PIN_D6               // Control pin of the third laser 
....................  
.................... //Parallel Port Pin Assignments 
.................... #DEFINE PP_D0        PIN_D8               // Parallel port data pin first bit 
.................... #DEFINE PP_D1        PIN_D9               // Parallel port data pin second bit 
.................... #DEFINE PP_D2        PIN_D0               // Parallel port data pin third bit 
.................... #DEFINE PP_D3        PIN_C13              // Parallel port data pin fourth bit 
.................... #DEFINE PP_D4        PIN_C14              // Parallel port data pin fifth bit 
.................... #DEFINE PP_D5        PIN_D1               // Parallel port data pin sixth bit 
.................... #DEFINE PP_D6        PIN_D2               // Parallel port data pin seventh bit 
.................... #DEFINE PP_D7        PIN_D3               // Parallel port data pin eigth bit 
.................... #DEFINE PP_STR       PIN_D10              // Parallel port strobe pin 
.................... #DEFINE PP_ACK       PIN_D4               // Parallel port acknowledge pin used to  
.................... #DEFINE PP_RDY       PIN_D5               // Parallel port ready pin 
....................  
.................... // Pins used to control digital potentiometer 
.................... #DEFINE DP_CS        PIN_G9               // Digital potentiometer chip select pin assignment (active low) 
.................... #DEFINE DP_UD        PIN_G8               // Digital potentiometer up/down control pin assignment 
....................  
.................... // Pins used to control motor driver 
.................... #DEFINE MD_MS1       PIN_F0               // Step resolution select pin 1 assignment 
.................... #DEFINE MD_MS2       PIN_D7               // Step resolution select pin 2 assignment 
.................... #DEFINE MD_SR        PIN_F1               // Active mode (synchronous rectification) input pin assignment 
.................... #DEFINE MD_RESET     PIN_E0               // Reset input pin assignment (active low) 
.................... #DEFINE MD_STEP      PIN_E1               // Step input pin assignment 
.................... #DEFINE MD_ENABLE    PIN_E2               // Enable input pin assignment (active low) 
.................... #DEFINE MD_SLEEP     PIN_E3               // Sleep input pin assignment (active low) 
.................... #DEFINE MD_DIR       PIN_E4               // Direction input pin assignment 
.................... #DEFINE MD_SW        PIN_D11              // Homing switch input pin assignment 
....................  
.................... // Pins used to control FRAM 
.................... #DEFINE FR_CS        PIN_G7               // FRAM chip select pin assignment (active low) 
.................... #DEFINE FR_WP        PIN_G6               // FRAM write protection pin assignment (active low) 
.................... #DEFINE FR_SCK       PIN_E5               // FRAM serial clock pin assignment 
.................... #DEFINE FR_SI        PIN_E6               // FRAM serial input pin assignment 
.................... #DEFINE FR_SO        PIN_E7               // FRAM serial output pin assignment 
....................  
.................... // Speed ramp states 
.................... #DEFINE HOME         0 
.................... #DEFINE ACCEL        1 
.................... #DEFINE DECEL        2 
.................... #DEFINE RUN          3 
.................... #DEFINE POS          4 
....................  
.................... // PWM module operating modes 
.................... #DEFINE FREE         0 
.................... #DEFINE SINGLE       1 
....................  
.................... int1           debug_mode_dp     = 0;              // Debug state of digital potentiometer 
.................... int1           debug_mode_pp     = 0;              // Debug state of parallel port communication 
.................... int1           debug_mode_fr     = 0;              // Debug state of FRAM 
.................... int1           debug_mode_md     = 0;              // Debug state of motor driver 
.................... int1           debug_mode_pwm    = 0;              // Debug state of motor control PWM module 
.................... int1           debug_mode_qei    = 0;              // Debug state of quadrature encoder 
....................  
.................... unsigned int   dp_tap_limit      = 32;             // Digital potentiometer maximum tap level 
.................... unsigned int   dp_voltage_limit  = 1023;           // Digital potentiometer maximum voltage level 
....................  
.................... unsigned int   mt_voltage_limit  = 803;            // Motor torque control voltage is limited to 4V (which is defined in driver specs) 
.................... unsigned int   mt_percent_trip   = 70;             // Motor torque percent while system is moving 
.................... unsigned int   mt_percent_rest   = 28;             // Motor torque percent while system is stationary 
....................  
.................... unsigned int   md_conv_const     = 0;              // Constant used to convert encoder count to motor step 
.................... unsigned int   md_move_range     = 400;            // Movement range of the device 
.................... unsigned int   md_home_pos       = 45;             // Sets the number of encoder counts between the home position and homing switch position 
.................... unsigned int   md_end_pos        = 1000;           // Sets the number of encoder counts between the home position and the end of movement range 
.................... unsigned int   md_end_offset     = 50;             // Offset of the maximum count number from the end position 
.................... unsigned int   md_home_offset    = 100;            // Offset of the maximum count number from the home position 
.................... unsigned int   md_min_distance   = 70;             // Minimum distance between symmetricaly moving lasers 
.................... unsigned int   md_target_count   = 0;              // Target position count 
....................  
.................... unsigned int   md_accel          = 3000;           // Acceleration of the motor (0.01 mm/s2) 
.................... unsigned int   md_decel          = 3000;           // Deceleration of the motor (0.01 mm/s2) 
....................  
.................... unsigned int   md_min_delay      = 100;            // Minimum time delay (max speed) 
.................... unsigned char  md_run_state      = 0;              // What part of the speed ramp we are in. 
.................... unsigned int   md_decel_lim      = 0;              // What step_pos to start decelaration 
.................... unsigned int   md_accel_lim      = 0;              // What step_pos to end accelaration 
.................... unsigned int   md_decel_count    = 0;              // Counter used when decelerateing to calculate step_delay. 
.................... unsigned int   md_pos_iter       = 0;              // Number of iterations performed during positioning 
.................... int            md_error          = 0;              // Positioning error 
.................... unsigned int   md_backlash       = 0;              // Backlash of the positioning system 
....................  
.................... unsigned int   md_cc_step        = 0;              // Motor count used in conversion constant conversion 
.................... unsigned int   md_cc_count       = 0;              // Encoder count used in conversion constant conversion 
....................  
.................... unsigned int   fr_serial_no      = 0;              // External adress of product serial no 
.................... unsigned int   fr_move_range     = 13;             // External adress of movement range 
.................... unsigned int   fr_home_pos       = 15;             // External adress of home position 
.................... unsigned int   fr_end_pos        = 17;             // External addres of end position 
.................... unsigned int   fr_conv_const     = 19;             // External adress of conversion constant 
.................... unsigned int   fr_backlash       = 21;             // External adress of backlash compensation 
.................... unsigned int   fr_comm_type      = 23;             // External adress of communication type 
.................... unsigned int   fr_last_pos       = 24;             // External adress of last position 
.................... unsigned int   fr_pos_table      = 26;             // External adress of position table 
....................  
.................... unsigned int   pp_str_check      = 10;             // Parallel port strobe signal filter iteration number 
.................... unsigned int   pp_str_delay      = 1;              // Parallel port strobe signal filter pause time (ms) 
.................... unsigned int   pp_ack_delay      = 100;            // Parallel port acknowledge signal pause time (ms) 
.................... unsigned int   pp_rdy_delay      = 100;            // Parallel port ready signal pause time (ms) 
....................  
.................... int1           reg_comm_type     = 0;              // Communication type register 
.................... int1           reg_pp_stop       = 0;              // Parallel port emergency stop signal register 
.................... int1           reg_pp_strobe     = 0;              // Parallel port strobe signal active register 
.................... int1           reg_md_home       = 0;              // Homing action register 
.................... int1           reg_md_home_return= 0;              // Home correction return register 
.................... int1           reg_rs232_message = 0;              // RS232 message flag 
.................... int1           reg_md_cc_sample  = 0;              // Special case register for conversion constant calculation 
....................  
.................... #DEFINE ACC_15 
....................  
.................... #IFDEF ACC_10 
.................... unsigned int   md_max_acc_lim    = 116;             // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... unsigned int const delays[116]={2449,1015,779,656,578,523,481,447,420,397,378,361,346,333,322,311,302,293,285,277,271,264,258,253,247,243,238,234,229,226,222,218,215,212,209,206,203,200,197,195,192,190,188,186,184,182,180, 
.................... 178,176,174,172,171,169,167,166,164,163,162,160,159,157,156,155,154,152,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115, 
.................... 114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_15 
.................... unsigned int   md_max_acc_lim    = 88;             // Number of steps before we hit max speed. acc=15000 dec=15000 
.................... unsigned int const delays[88]={2000,828,636,536,472,427,393,365,343,325,309,295,283,272,263,254,246,239,233,226,221,216,211,206,202,198,194,191,187,184,181,178,175,173,170,168,166,163,161,159,157,155,153,152,150,148,147, 
.................... 145,144,142,141,139,138,137,135,134,133,132,131,130,129,128,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_20 
.................... unsigned int   md_max_acc_lim    = 71;             // Number of steps before we hit max speed. acc=20000 dec=20000  
.................... unsigned int const delays[71]={1732,717,551,464,409,370,340,316,297,281,267,255,245,236,227,220,213,207,201,196,191,187,183,179,175,172,168,165,162,159,157,154,152,150,147,145,143,141,140,138,136,134,133,131,130,128,127, 
.................... 126,124,123,122,121,120,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_25 
.................... unsigned int   md_max_acc_lim    = 59;             // Number of steps before we hit max speed. acc=25000 dec=25000  
.................... unsigned int const delays[59]={1549,642,492,415,366,331,304,283,266,251,239,228,219,211,203,197,191,185,180,175,171,167,163,160,157,153,150,148,145,143,140,138,136,134,132,130,128,126,125,123,122,120,119,117,116,115,114, 
.................... 112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_30 
.................... unsigned int   md_max_acc_lim    = 50;             // Number of steps before we hit max speed. acc=30000 dec=30000  
.................... unsigned int const delays[50]={1414,586,449,379,334,302,278,258,243,229,218,209,200,192,186,180,174,169,164,160,156,153,149,146,143,140,137,135,132,130,128,126,124,122,120,119,117,115,114,113,111,110,108,107,106,105,104, 
.................... 103,102,101}; 
.................... #ENDIF 
....................  
.................... void move_pos(unsigned int16 position); 
.................... unsigned int16 qei_get_count(); 
....................  
.................... // Initializes digital potentiometer 
.................... void dp_init()  
.................... { 
....................    output_high(DP_CS);                       // Chip select is active low so keep it disabled 
*
016CE:  BCLR.B  2E5.1
016D0:  BSET.B  2E9.1
....................    output_low(DP_UD);                        // Up/down control pin can be in any state 
016D2:  BCLR.B  2E5.0
016D4:  BCLR.B  2E9.0
.................... } 
016D6:  RETURN  
.................... // Increases digital potentiometer by given tap 
.................... void dp_up(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
*
0175C:  MOV     802,W0
0175E:  MOV     8C4,W4
01760:  CP      W4,W0
01762:  BRA     LEU,1768
....................       tap=dp_tap_limit; 
01764:  PUSH    802
01766:  POP     8C4
....................        
....................    output_high(DP_UD);        // Set U/D to high before activating digital potentiometer 
01768:  BCLR.B  2E5.0
0176A:  BSET.B  2E9.0
....................    delay_us(1); 
0176C:  REPEAT  #1C
0176E:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
01770:  BCLR.B  2E5.1
01772:  BCLR.B  2E9.1
....................    delay_us(1); 
01774:  REPEAT  #1C
01776:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
01778:  CLR     8C6
0177A:  MOV     8C6,W0
0177C:  MOV     8C4,W4
0177E:  CP      W4,W0
01780:  BRA     LEU,17A0
....................    { 
....................       output_low(DP_UD);      // Low part of pulse 
01782:  BCLR.B  2E5.0
01784:  BCLR.B  2E9.0
....................       delay_us(1); 
01786:  REPEAT  #1C
01788:  NOP     
....................       output_high(DP_UD);     // High part of pulse 
0178A:  BCLR.B  2E5.0
0178C:  BSET.B  2E9.0
....................       delay_us(1); 
0178E:  REPEAT  #1C
01790:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
01792:  BCLR.B  2E5.0
01794:  BCLR.B  2E9.0
....................       delay_us(1);  
01796:  REPEAT  #1C
01798:  NOP     
....................    } 
0179A:  INC     08C6
0179C:  GOTO    177A
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer   
017A0:  BCLR.B  2E5.1
017A2:  BSET.B  2E9.1
.................... } 
017A4:  RETURN  
.................... // Decreases digital potentiometer by given tap 
.................... void dp_down(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
017A6:  MOV     802,W0
017A8:  MOV     8C4,W4
017AA:  CP      W4,W0
017AC:  BRA     LEU,17B2
....................       tap=dp_tap_limit; 
017AE:  PUSH    802
017B0:  POP     8C4
....................        
....................    output_low(DP_UD);         // Set U/D to low before activating digital potentiometer 
017B2:  BCLR.B  2E5.0
017B4:  BCLR.B  2E9.0
....................    delay_us(1); 
017B6:  REPEAT  #1C
017B8:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
017BA:  BCLR.B  2E5.1
017BC:  BCLR.B  2E9.1
....................    delay_us(1);             
017BE:  REPEAT  #1C
017C0:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
017C2:  CLR     8C6
017C4:  MOV     8C6,W0
017C6:  MOV     8C4,W4
017C8:  CP      W4,W0
017CA:  BRA     LEU,17E2
....................    { 
....................       output_high(DP_UD);     // High part of pulse 
017CC:  BCLR.B  2E5.0
017CE:  BSET.B  2E9.0
....................       delay_us(1); 
017D0:  REPEAT  #1C
017D2:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
017D4:  BCLR.B  2E5.0
017D6:  BCLR.B  2E9.0
....................       delay_us(1);   
017D8:  REPEAT  #1C
017DA:  NOP     
....................    } 
017DC:  INC     08C6
017DE:  GOTO    17C4
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer 
017E2:  BCLR.B  2E5.1
017E4:  BSET.B  2E9.1
.................... } 
017E6:  RETURN  
.................... // Sets digital potentiometer to given voltage 
.................... void dp_set(unsigned int voltage) 
.................... { 
017E8:  MOV     W5,[W15++]
017EA:  MOV     #3,W4
017EC:  MOV     W4,8B0
017EE:  CLR     8B2
017F0:  MOV     #F,W4
017F2:  MOV     W4,8B4
017F4:  MOV     8AE,W4
017F6:  MOV     802,W3
017F8:  MUL.UU  W4,W3,W0
017FA:  MOV     W0,W5
017FC:  MOV     W5,W4
017FE:  MOV     804,W3
01800:  REPEAT  #11
01802:  DIV.U   W4,W3
01804:  MOV     W0,8B6
01806:  BCLR.B  2A0.0
01808:  BSET.B  2A0.1
0180A:  BTSS.B  2A0.0
0180C:  BRA     180A
0180E:  PUSH    280
01810:  POP     8B8
01812:  MOV     8AE,W4
01814:  MOV     8B8,W3
01816:  SUB     W4,W3,W5
01818:  MOV     W5,W0
0181A:  MOV     W5,8BA
....................    unsigned int iteration_limit=3;                                   // Maximum number of iterations to be performed to set voltage 
....................    unsigned int iteration=0;                                         // Number of iterations performed to set voltage 
....................    unsigned int region=15;                                           // We want the voltage to be inside this region (+/-)  
....................    unsigned int tap_desired=voltage*dp_tap_limit/dp_voltage_limit;   // Find the desired potentiometer tap 
....................    unsigned int voltage_current=read_adc();                          // Read the current voltage 
....................    unsigned int voltage_diff=abs(voltage-voltage_current);           // Find the difference between the current and desired voltage  
....................    unsigned int tap_current;                                         // Current tap value 
....................     
....................    if(debug_mode_dp) 
0181C:  BTSS.B  800.0
0181E:  BRA     18EE
....................    { 
....................       fprintf(RS232,"\n\r\tVoltage Desired: %u",voltage); 
01820:  MOV     #0,W1
01822:  MOV     W1,W0
01824:  CALL    196
01828:  INC     W1,W1
0182A:  MOV     W1,[W15++]
0182C:  BTSC.B  219.1
0182E:  BRA     182C
01830:  MOV     W0,21A
01832:  MOV     [--W15],W1
01834:  MOV     #13,W0
01836:  CPSGT   W1,W0
01838:  BRA     1822
0183A:  MOV     8AE,W0
0183C:  MOV     #0,W4
0183E:  CALL    1572
....................       fprintf(RS232,"\n\r\tTap Desired: %u",dp_tap_limit*voltage/dp_voltage_limit); 
01842:  MOV     802,W4
01844:  MOV     8AE,W3
01846:  MUL.UU  W4,W3,W0
01848:  MOV     W0,W5
0184A:  MOV     W5,W4
0184C:  MOV     804,W3
0184E:  REPEAT  #11
01850:  DIV.U   W4,W3
01852:  MOV     W0,W5
01854:  MOV     #0,W1
01856:  MOV     W1,W0
01858:  CALL    1BA
0185C:  INC     W1,W1
0185E:  MOV     W1,[W15++]
01860:  BTSC.B  219.1
01862:  BRA     1860
01864:  MOV     W0,21A
01866:  MOV     [--W15],W1
01868:  MOV     #F,W0
0186A:  CPSGT   W1,W0
0186C:  BRA     1856
0186E:  MOV     W5,W0
01870:  MOV     #0,W4
01872:  CALL    1572
....................       fprintf(RS232,"\n\r\tVoltage Current: %u",voltage_current); 
01876:  MOV     #0,W1
01878:  MOV     W1,W0
0187A:  CALL    1DA
0187E:  INC     W1,W1
01880:  MOV     W1,[W15++]
01882:  BTSC.B  219.1
01884:  BRA     1882
01886:  MOV     W0,21A
01888:  MOV     [--W15],W1
0188A:  MOV     #13,W0
0188C:  CPSGT   W1,W0
0188E:  BRA     1878
01890:  MOV     8B8,W0
01892:  MOV     #0,W4
01894:  CALL    1572
....................       fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01898:  MOV     802,W4
0189A:  MOV     8B8,W3
0189C:  MUL.UU  W4,W3,W0
0189E:  MOV     W0,W5
018A0:  MOV     W5,W4
018A2:  MOV     804,W3
018A4:  REPEAT  #11
018A6:  DIV.U   W4,W3
018A8:  MOV     W0,W5
018AA:  MOV     #0,W1
018AC:  MOV     W1,W0
018AE:  CALL    1FE
018B2:  INC     W1,W1
018B4:  MOV     W1,[W15++]
018B6:  BTSC.B  219.1
018B8:  BRA     18B6
018BA:  MOV     W0,21A
018BC:  MOV     [--W15],W1
018BE:  MOV     #F,W0
018C0:  CPSGT   W1,W0
018C2:  BRA     18AC
018C4:  MOV     W5,W0
018C6:  MOV     #0,W4
018C8:  CALL    1572
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",voltage_diff); 
018CC:  MOV     #0,W1
018CE:  MOV     W1,W0
018D0:  CALL    21E
018D4:  INC     W1,W1
018D6:  MOV     W1,[W15++]
018D8:  BTSC.B  219.1
018DA:  BRA     18D8
018DC:  MOV     W0,21A
018DE:  MOV     [--W15],W1
018E0:  MOV     #16,W0
018E2:  CPSGT   W1,W0
018E4:  BRA     18CE
018E6:  MOV     8BA,W0
018E8:  MOV     #0,W4
018EA:  CALL    1572
....................    } 
....................     
....................    while(voltage_diff>region)                                        // Try until voltage is found 
....................    {                                                                 // or iteration limit is reached  
018EE:  MOV     8B4,W0
018F0:  MOV     8BA,W4
018F2:  CP      W4,W0
018F4:  BRA     LEU,1A64
....................       if(iteration <iteration_limit)                      
018F6:  MOV     8B2,W0
018F8:  MOV     8B0,W4
018FA:  CP      W4,W0
018FC:  BRA     LEU,1A40
....................       { 
....................          iteration++;                                                // Set iteration number 
018FE:  INC     08B2
....................          tap_current=dp_tap_limit*voltage_current/dp_voltage_limit;  // Convert new voltage to tap 
01900:  MOV     802,W4
01902:  MOV     8B8,W3
01904:  MUL.UU  W4,W3,W0
01906:  MOV     W0,W5
01908:  MOV     W5,W4
0190A:  MOV     804,W3
0190C:  REPEAT  #11
0190E:  DIV.U   W4,W3
01910:  MOV     W0,8BC
....................  
....................          if(tap_desired>tap_current)                                 // Set the digital potentiometer to desired tap 
01912:  MOV     8BC,W0
01914:  MOV     8B6,W4
01916:  CP      W4,W0
01918:  BRA     LEU,192A
....................          { 
....................             dp_up(tap_desired-tap_current); 
0191A:  MOV     8B6,W4
0191C:  MOV     8BC,W3
0191E:  SUB     W4,W3,W5
01920:  MOV     W5,8C4
01922:  CALL    175C
....................          } 
....................          else if(tap_desired<tap_current) 
01926:  GOTO    195E
0192A:  MOV     8B6,W0
0192C:  MOV     8BC,W4
0192E:  CP      W4,W0
01930:  BRA     LEU,1942
....................          { 
....................             dp_down(tap_current-tap_desired); 
01932:  MOV     8BC,W4
01934:  MOV     8B6,W3
01936:  SUB     W4,W3,W5
01938:  MOV     W5,8C4
0193A:  CALL    17A6
....................          } 
....................          else                                                        // If tap level is same as the previous one and it still outside the region 
0193E:  GOTO    195E
....................          {                                                           // then go one step up or down according to desired voltage 
....................             if(voltage>voltage_current) 
01942:  MOV     8B8,W0
01944:  MOV     8AE,W4
01946:  CP      W4,W0
01948:  BRA     LEU,1956
....................                dp_up(1); 
0194A:  MOV     #1,W4
0194C:  MOV     W4,8C4
0194E:  CALL    175C
....................             else 
01952:  GOTO    195E
....................                dp_down(1); 
01956:  MOV     #1,W4
01958:  MOV     W4,8C4
0195A:  CALL    17A6
....................          } 
....................           
....................          delay_ms(2); 
0195E:  REPEAT  #2A5E
01960:  NOP     
01962:  REPEAT  #3FFF
01964:  NOP     
01966:  REPEAT  #3FFF
01968:  NOP     
0196A:  REPEAT  #3FFF
0196C:  NOP     
....................              
....................          voltage_current=read_adc();                                 // Read the new voltage 
0196E:  BCLR.B  2A0.0
01970:  BSET.B  2A0.1
01972:  BTSS.B  2A0.0
01974:  BRA     1972
01976:  PUSH    280
01978:  POP     8B8
....................           
....................          if(voltage>voltage_current)                                 // Find the difference between the new and desired voltages for next iteration check 
0197A:  MOV     8B8,W0
0197C:  MOV     8AE,W4
0197E:  CP      W4,W0
01980:  BRA     LEU,198E
....................             voltage_diff=voltage - voltage_current; 
01982:  MOV     8AE,W4
01984:  MOV     8B8,W3
01986:  SUB     W4,W3,W0
01988:  MOV     W0,8BA
....................          else 
0198A:  GOTO    1996
....................             voltage_diff=voltage_current - voltage; 
0198E:  MOV     8B8,W4
01990:  MOV     8AE,W3
01992:  SUB     W4,W3,W0
01994:  MOV     W0,8BA
....................           
....................          if(debug_mode_dp) 
01996:  BTSS.B  800.0
01998:  BRA     1A3C
....................          { 
....................             fprintf(RS232,"\n\rITERATION: %u",iteration); 
0199A:  MOV     #0,W1
0199C:  MOV     W1,W0
0199E:  CALL    244
019A2:  INC     W1,W1
019A4:  MOV     W1,[W15++]
019A6:  BTSC.B  219.1
019A8:  BRA     19A6
019AA:  MOV     W0,21A
019AC:  MOV     [--W15],W1
019AE:  MOV     #C,W0
019B0:  CPSGT   W1,W0
019B2:  BRA     199C
019B4:  MOV     8B2,W0
019B6:  MOV     #0,W4
019B8:  CALL    1572
....................             fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
019BC:  MOV     802,W4
019BE:  MOV     8B8,W3
019C0:  MUL.UU  W4,W3,W0
019C2:  MOV     W0,W5
019C4:  MOV     W5,W4
019C6:  MOV     804,W3
019C8:  REPEAT  #11
019CA:  DIV.U   W4,W3
019CC:  MOV     W0,W5
019CE:  MOV     #0,W1
019D0:  MOV     W1,W0
019D2:  CALL    1FE
019D6:  INC     W1,W1
019D8:  MOV     W1,[W15++]
019DA:  BTSC.B  219.1
019DC:  BRA     19DA
019DE:  MOV     W0,21A
019E0:  MOV     [--W15],W1
019E2:  MOV     #F,W0
019E4:  CPSGT   W1,W0
019E6:  BRA     19D0
019E8:  MOV     W5,W0
019EA:  MOV     #0,W4
019EC:  CALL    1572
....................             fprintf(RS232,"\n\r\tVoltage Current : %u",voltage_current); 
019F0:  MOV     #0,W1
019F2:  MOV     W1,W0
019F4:  CALL    260
019F8:  INC     W1,W1
019FA:  MOV     W1,[W15++]
019FC:  BTSC.B  219.1
019FE:  BRA     19FC
01A00:  MOV     W0,21A
01A02:  MOV     [--W15],W1
01A04:  MOV     #14,W0
01A06:  CPSGT   W1,W0
01A08:  BRA     19F2
01A0A:  MOV     8B8,W0
01A0C:  MOV     #0,W4
01A0E:  CALL    1572
....................             fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-voltage_current)); 
01A12:  MOV     8AE,W4
01A14:  MOV     8B8,W3
01A16:  SUB     W4,W3,W5
01A18:  MOV     W5,W0
01A1A:  MOV     #0,W1
01A1C:  MOV     W1,W0
01A1E:  CALL    21E
01A22:  INC     W1,W1
01A24:  MOV     W1,[W15++]
01A26:  BTSC.B  219.1
01A28:  BRA     1A26
01A2A:  MOV     W0,21A
01A2C:  MOV     [--W15],W1
01A2E:  MOV     #16,W0
01A30:  CPSGT   W1,W0
01A32:  BRA     1A1C
01A34:  MOV     W5,W0
01A36:  MOV     #0,W4
01A38:  CALL    1572
....................          } 
....................       } 
....................       else 
01A3C:  GOTO    1A60
....................       { 
....................          if(debug_mode_dp) 
01A40:  BTSS.B  800.0
01A42:  BRA     1A5E
....................             fprintf(RS232,"\n\rIteration limit reached"); 
01A44:  MOV     #0,W1
01A46:  MOV     W1,W0
01A48:  CALL    284
01A4C:  INC     W1,W1
01A4E:  MOV     W1,[W15++]
01A50:  BTSC.B  219.1
01A52:  BRA     1A50
01A54:  MOV     W0,21A
01A56:  MOV     [--W15],W1
01A58:  MOV     #18,W0
01A5A:  CPSGT   W1,W0
01A5C:  BRA     1A46
....................          return; 
01A5E:  BRA     1B14
....................       } 
....................    } 
01A60:  GOTO    18EE
....................     
....................    if(debug_mode_dp) 
01A64:  BTSS.B  800.0
01A66:  BRA     1B14
....................    { 
....................       fprintf(RS232,"\n\rFOUND!"); 
01A68:  MOV     #0,W1
01A6A:  MOV     W1,W0
01A6C:  CALL    2AA
01A70:  INC     W1,W1
01A72:  MOV     W1,[W15++]
01A74:  BTSC.B  219.1
01A76:  BRA     1A74
01A78:  MOV     W0,21A
01A7A:  MOV     [--W15],W1
01A7C:  MOV     #7,W0
01A7E:  CPSGT   W1,W0
01A80:  BRA     1A6A
....................       fprintf(RS232,"\n\r\tTap Current : %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01A82:  MOV     802,W4
01A84:  MOV     8B8,W3
01A86:  MUL.UU  W4,W3,W0
01A88:  MOV     W0,W5
01A8A:  MOV     W5,W4
01A8C:  MOV     804,W3
01A8E:  REPEAT  #11
01A90:  DIV.U   W4,W3
01A92:  MOV     W0,W5
01A94:  MOV     #0,W1
01A96:  MOV     W1,W0
01A98:  CALL    2C0
01A9C:  INC     W1,W1
01A9E:  MOV     W1,[W15++]
01AA0:  BTSC.B  219.1
01AA2:  BRA     1AA0
01AA4:  MOV     W0,21A
01AA6:  MOV     [--W15],W1
01AA8:  MOV     #10,W0
01AAA:  CPSGT   W1,W0
01AAC:  BRA     1A96
01AAE:  MOV     W5,W0
01AB0:  MOV     #0,W4
01AB2:  CALL    1572
....................       fprintf(RS232,"\n\r\tVoltage Current : %u",read_adc()); 
01AB6:  BCLR.B  2A0.0
01AB8:  BSET.B  2A0.1
01ABA:  BTSS.B  2A0.0
01ABC:  BRA     1ABA
01ABE:  MOV     280,W5
01AC0:  MOV     #0,W1
01AC2:  MOV     W1,W0
01AC4:  CALL    260
01AC8:  INC     W1,W1
01ACA:  MOV     W1,[W15++]
01ACC:  BTSC.B  219.1
01ACE:  BRA     1ACC
01AD0:  MOV     W0,21A
01AD2:  MOV     [--W15],W1
01AD4:  MOV     #14,W0
01AD6:  CPSGT   W1,W0
01AD8:  BRA     1AC2
01ADA:  MOV     W5,W0
01ADC:  MOV     #0,W4
01ADE:  CALL    1572
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-read_adc())); 
01AE2:  BCLR.B  2A0.0
01AE4:  BSET.B  2A0.1
01AE6:  BTSS.B  2A0.0
01AE8:  BRA     1AE6
01AEA:  MOV     280,W0
01AEC:  MOV     8AE,W4
01AEE:  SUB     W4,W0,W5
01AF0:  MOV     W5,W0
01AF2:  MOV     #0,W1
01AF4:  MOV     W1,W0
01AF6:  CALL    21E
01AFA:  INC     W1,W1
01AFC:  MOV     W1,[W15++]
01AFE:  BTSC.B  219.1
01B00:  BRA     1AFE
01B02:  MOV     W0,21A
01B04:  MOV     [--W15],W1
01B06:  MOV     #16,W0
01B08:  CPSGT   W1,W0
01B0A:  BRA     1AF4
01B0C:  MOV     W5,W0
01B0E:  MOV     #0,W4
01B10:  CALL    1572
....................    } 
.................... } 
01B14:  MOV     [--W15],W5
01B16:  RETURN  
....................  
.................... // Returns current motor torque in percent (%0-100) 
.................... unsigned int md_mt_get() 
.................... { 
01B18:  MOV     W5,[W15++]
01B1A:  MOV     W6,[W15++]
01B1C:  BCLR.B  2A0.0
01B1E:  BSET.B  2A0.1
01B20:  BTSS.B  2A0.0
01B22:  BRA     1B20
01B24:  MOV     280,W0
01B26:  MOV     #0,W1
01B28:  MOV     W0,W2
01B2A:  MOV     W1,W3
01B2C:  MOV     #64,W0
01B2E:  MOV     #0,W1
01B30:  CALL    16D8
01B34:  MOV     W0,W5
01B36:  MOV     W1,W6
01B38:  BCLR.B  43.0
01B3A:  MOV     W5,W0
01B3C:  MOV     W6,W1
01B3E:  MOV     806,W2
01B40:  MOV     #0,W3
01B42:  CALL    1708
01B46:  MOV     W0,8B0
....................    unsigned int analog=read_adc();                                         // Read the voltage level 
....................    unsigned int percent=100*(unsigned int32)analog/mt_voltage_limit;       // Convert voltage to percent 
....................     
....................    if(debug_mode_dp) 
01B48:  BTSS.B  800.0
01B4A:  BRA     1B7E
....................       fprintf(RS232,"\n\r\tPercent Current: %u\n\r",percent); 
01B4C:  MOV     #0,W1
01B4E:  MOV     W1,W0
01B50:  CALL    2E0
01B54:  INC     W1,W1
01B56:  MOV     W1,[W15++]
01B58:  BTSC.B  219.1
01B5A:  BRA     1B58
01B5C:  MOV     W0,21A
01B5E:  MOV     [--W15],W1
01B60:  MOV     #13,W0
01B62:  CPSGT   W1,W0
01B64:  BRA     1B4E
01B66:  MOV     8B0,W0
01B68:  MOV     #0,W4
01B6A:  CALL    1572
01B6E:  BTSC.B  219.1
01B70:  BRA     1B6E
01B72:  MOV     #A,W4
01B74:  MOV     W4,21A
01B76:  BTSC.B  219.1
01B78:  BRA     1B76
01B7A:  MOV     #D,W4
01B7C:  MOV     W4,21A
....................        
....................    return percent;   
01B7E:  PUSH    8B0
01B80:  POP     0
.................... } 
01B82:  MOV     [--W15],W6
01B84:  MOV     [--W15],W5
01B86:  RETURN  
.................... // Sets motor torque approximate to desired percent and returns the actual percent (%0-100) 
.................... unsigned int md_mt_set(unsigned int percent) 
.................... { 
01B88:  MOV     W5,[W15++]
01B8A:  MOV     W6,[W15++]
....................    // percent must be between 0 and 100 
....................    if(percent>100) 
01B8C:  MOV     8A8,W4
01B8E:  MOV     #64,W3
01B90:  CP      W3,W4
01B92:  BRA     C,1B98
....................       percent=100; 
01B94:  MOV     #64,W4
01B96:  MOV     W4,8A8
....................        
....................    if(debug_mode_dp) 
01B98:  BTSS.B  800.0
01B9A:  BRA     1BBE
....................    { 
....................       fprintf(RS232,"\n\r\tPercent Desired:"); 
01B9C:  MOV     #0,W1
01B9E:  MOV     W1,W0
01BA0:  CALL    306
01BA4:  INC     W1,W1
01BA6:  MOV     W1,[W15++]
01BA8:  BTSC.B  219.1
01BAA:  BRA     1BA8
01BAC:  MOV     W0,21A
01BAE:  MOV     [--W15],W1
01BB0:  MOV     #12,W0
01BB2:  CPSGT   W1,W0
01BB4:  BRA     1B9E
....................       fprintf(RS232,"%u",percent); 
01BB6:  MOV     8A8,W0
01BB8:  MOV     #0,W4
01BBA:  CALL    1572
....................    } 
....................     
....................    unsigned int voltage=(unsigned int32)percent*mt_voltage_limit/100;      // convert percent to voltage 
01BBE:  MOV     8A8,W5
01BC0:  MOV     #0,W6
01BC2:  MOV     W5,W0
01BC4:  MOV     W6,W1
01BC6:  MOV     806,W2
01BC8:  MOV     #0,W3
01BCA:  CALL    16D8
01BCE:  MOV     W0,W5
01BD0:  MOV     W1,W6
01BD2:  BCLR.B  43.0
01BD4:  MOV     W5,W0
01BD6:  MOV     W6,W1
01BD8:  MOV     #64,W2
01BDA:  MOV     #0,W3
01BDC:  CALL    1708
01BE0:  MOV     W0,8AA
....................    dp_set(voltage);                                      // set digital potentiometer 
01BE2:  PUSH    8AA
01BE4:  POP     8AE
01BE6:  CALL    17E8
....................     
....................    return md_mt_get(); 
01BEA:  CALL    1B18
01BEE:  MOV     W0,0
.................... } 
01BF0:  MOV     [--W15],W6
01BF2:  MOV     [--W15],W5
01BF4:  RETURN  
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_mt_set(mt_percent_rest);               // Set motor torque before initialization of motor driver 
01BF6:  PUSH    80A
01BF8:  POP     8A8
01BFA:  CALL    1B88
....................  
....................    output_high(MD_RESET);                    // Reset is active low so keep it disabled 
01BFE:  BCLR.B  2D8.0
01C00:  BSET.B  2DC.0
....................    output_high(MD_SLEEP);                    // Sleep is active low so keep it disabled 
01C02:  BCLR.B  2D8.3
01C04:  BSET.B  2DC.3
....................    output_low(MD_SR);                        // Activate synchronous rectification 
01C06:  BCLR.B  2DE.1
01C08:  BCLR.B  2E2.1
....................    output_high(MD_DIR);                      // Direction control pin can be in any state 
01C0A:  BCLR.B  2D8.4
01C0C:  BSET.B  2DC.4
....................    output_high(MD_MS1);                      // MS1 and MS2 high enables 8x microstepping mode 
01C0E:  BCLR.B  2DE.0
01C10:  BSET.B  2E2.0
....................    output_high(MD_MS2); 
01C12:  BCLR.B  2D2.7
01C14:  BSET.B  2D6.7
....................    output_low(MD_ENABLE);                    // Enable is active so keep it high 
01C16:  BCLR.B  2D8.2
01C18:  BCLR.B  2DC.2
....................    output_low(MD_STEP);                      // A low-to-high transition advances the motor one increment so keep step input low 
01C1A:  BCLR.B  2D8.1
01C1C:  BCLR.B  2DC.1
.................... } 
01C1E:  RETURN  
....................  
.................... // Initializes external EEPROM (FRAM) 
.................... void fr_init()  
.................... { 
....................    output_high(FR_CS);     // Chip select is active low when it is high the device enters low-power standby mode so initialy keep it high 
01C20:  BCLR.B  2E4.7
01C22:  BSET.B  2E8.7
....................    output_low(FR_WP);      // Write protection pin is active low and prevents write operations to the status register so initially keep it low 
01C24:  BCLR.B  2E4.6
01C26:  BCLR.B  2E8.6
....................    output_low(FR_SI);      // Serial input pin is driven to high logic state during communication so initially keep it low 
01C28:  BCLR.B  2D8.6
01C2A:  BCLR.B  2DC.6
....................    output_low(FR_SCK);     // Inputs are latched on the rising edge and outputs occur on the falling edge so initially serial clock can be in any state  
01C2C:  BCLR.B  2D8.5
01C2E:  BCLR.B  2DC.5
.................... } 
01C30:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... void fr_write_byte(unsigned int16 address, unsigned int8 data)  
.................... { 
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    unsigned int8 wren; 
....................    unsigned int8 write; 
....................    unsigned int8 wrdi; 
....................     
....................    //     76543210     
....................    wren=0b00000110; 
*
02264:  MOV.B   #6,W0L
02266:  MOV.B   W0L,8B4
....................    //      76543210  
....................    write=0b00000010; 
02268:  MOV.B   #2,W0L
0226A:  MOV.B   W0L,8B5
....................    //     76543210 
....................    wrdi=0b00000100; 
0226C:  MOV.B   #4,W0L
0226E:  MOV.B   W0L,8B6
....................     
....................    cmd[0]=data; 
02270:  MOV.B   8AE,W0L
02272:  MOV.B   W0L,8B0
....................    cmd[1]=address; 
02274:  MOV.B   8AC,W0L
02276:  MOV.B   W0L,8B1
....................    cmd[2]=address/256; 
02278:  MOV.B   8AD,W0L
0227A:  MOV.B   W0L,8B2
....................    cmd[3]=write; 
0227C:  MOV.B   8B5,W0L
0227E:  MOV.B   W0L,8B3
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    output_low(FR_CS); 
02280:  BCLR.B  2E4.7
02282:  BCLR.B  2E8.7
....................    delay_us(1); 
02284:  REPEAT  #1C
02286:  NOP     
....................    for(i=0; i<8; ++i) 
02288:  CLR.B   8AF
0228A:  MOV     8AE,W4
0228C:  LSR     W4,#8,W4
0228E:  CP.B    W4L,#8
02290:  BRA     C,22C2
....................    { 
....................       output_bit(FR_SI, shift_left(&wren,1,0)); 
02292:  BCLR.B  42.0
02294:  RLC.B   8B4
02296:  BRA     C,229C
02298:  BCLR.B  2DC.6
0229A:  BRA     229E
0229C:  BSET.B  2DC.6
0229E:  BCLR.B  2D8.6
....................       delay_us(1); 
022A0:  REPEAT  #1C
022A2:  NOP     
....................       output_high(FR_SCK); 
022A4:  BCLR.B  2D8.5
022A6:  BSET.B  2DC.5
....................       delay_us(1); 
022A8:  REPEAT  #1C
022AA:  NOP     
....................       output_low(FR_SI); 
022AC:  BCLR.B  2D8.6
022AE:  BCLR.B  2DC.6
....................       delay_us(1); 
022B0:  REPEAT  #1C
022B2:  NOP     
....................       output_low(FR_SCK); 
022B4:  BCLR.B  2D8.5
022B6:  BCLR.B  2DC.5
....................       delay_us(1); 
022B8:  REPEAT  #1C
022BA:  NOP     
....................    } 
022BC:  INC.B   08AF
022BE:  GOTO    228A
....................    delay_us(1); 
022C2:  REPEAT  #1C
022C4:  NOP     
....................    output_high(FR_CS); 
022C6:  BCLR.B  2E4.7
022C8:  BSET.B  2E8.7
....................    delay_us(1); 
022CA:  REPEAT  #1C
022CC:  NOP     
....................     
....................    output_low(FR_CS); 
022CE:  BCLR.B  2E4.7
022D0:  BCLR.B  2E8.7
....................    delay_us(1); 
022D2:  REPEAT  #1C
022D4:  NOP     
....................    for(i=0; i<32; ++i) 
022D6:  CLR.B   8AF
022D8:  MOV     8AE,W4
022DA:  LSR     W4,#8,W4
022DC:  MOV     #20,W3
022DE:  CP.B    W3L,W4L
022E0:  BRA     LEU,2314
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,4,0)); 
022E2:  BCLR.B  42.0
022E4:  RLC     8B0
022E6:  RLC     8B2
022E8:  BRA     C,22EE
022EA:  BCLR.B  2DC.6
022EC:  BRA     22F0
022EE:  BSET.B  2DC.6
022F0:  BCLR.B  2D8.6
....................       delay_us(1); 
022F2:  REPEAT  #1C
022F4:  NOP     
....................       output_high(FR_SCK); 
022F6:  BCLR.B  2D8.5
022F8:  BSET.B  2DC.5
....................       delay_us(1); 
022FA:  REPEAT  #1C
022FC:  NOP     
....................       output_low(FR_SI); 
022FE:  BCLR.B  2D8.6
02300:  BCLR.B  2DC.6
....................       delay_us(1); 
02302:  REPEAT  #1C
02304:  NOP     
....................       output_low(FR_SCK); 
02306:  BCLR.B  2D8.5
02308:  BCLR.B  2DC.5
....................       delay_us(1); 
0230A:  REPEAT  #1C
0230C:  NOP     
....................    } 
0230E:  INC.B   08AF
02310:  GOTO    22D8
....................    delay_us(1); 
02314:  REPEAT  #1C
02316:  NOP     
....................    output_high(FR_CS); 
02318:  BCLR.B  2E4.7
0231A:  BSET.B  2E8.7
....................    delay_us(1); 
0231C:  REPEAT  #1C
0231E:  NOP     
....................     
....................    output_low(FR_CS); 
02320:  BCLR.B  2E4.7
02322:  BCLR.B  2E8.7
....................    delay_us(1); 
02324:  REPEAT  #1C
02326:  NOP     
....................    for(i=0; i<8; ++i) 
02328:  CLR.B   8AF
0232A:  MOV     8AE,W4
0232C:  LSR     W4,#8,W4
0232E:  CP.B    W4L,#8
02330:  BRA     C,2362
....................    { 
....................       output_bit(FR_SI, shift_left(&wrdi,1,0)); 
02332:  BCLR.B  42.0
02334:  RLC.B   8B6
02336:  BRA     C,233C
02338:  BCLR.B  2DC.6
0233A:  BRA     233E
0233C:  BSET.B  2DC.6
0233E:  BCLR.B  2D8.6
....................       delay_us(1); 
02340:  REPEAT  #1C
02342:  NOP     
....................       output_high(FR_SCK); 
02344:  BCLR.B  2D8.5
02346:  BSET.B  2DC.5
....................       delay_us(1); 
02348:  REPEAT  #1C
0234A:  NOP     
....................       output_low(FR_SI); 
0234C:  BCLR.B  2D8.6
0234E:  BCLR.B  2DC.6
....................       delay_us(1); 
02350:  REPEAT  #1C
02352:  NOP     
....................       output_low(FR_SCK); 
02354:  BCLR.B  2D8.5
02356:  BCLR.B  2DC.5
....................       delay_us(1); 
02358:  REPEAT  #1C
0235A:  NOP     
....................    } 
0235C:  INC.B   08AF
0235E:  GOTO    232A
....................    delay_us(1); 
02362:  REPEAT  #1C
02364:  NOP     
....................    output_high(FR_CS); 
02366:  BCLR.B  2E4.7
02368:  BSET.B  2E8.7
....................    delay_us(1); 
0236A:  REPEAT  #1C
0236C:  NOP     
.................... } 
0236E:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... unsigned int8 fr_read_byte(unsigned int16 address)  
.................... { 
....................    unsigned int8 cmd[3]; 
....................    unsigned int8 i,data; 
....................    unsigned int8 read; 
....................     
....................    //     76543210  
....................    read=0b00000011; 
*
01C32:  MOV.B   #3,W0L
01C34:  MOV.B   W0L,8B5
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Read on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    cmd[0]=address; 
01C36:  MOV.B   8AE,W0L
01C38:  MOV.B   W0L,8B0
....................    cmd[1]=address/256; 
01C3A:  MOV.B   8AF,W0L
01C3C:  MOV.B   W0L,8B1
....................    cmd[2]=read; 
01C3E:  MOV.B   8B5,W0L
01C40:  MOV.B   W0L,8B2
....................  
....................    output_low(FR_CS); 
01C42:  BCLR.B  2E4.7
01C44:  BCLR.B  2E8.7
....................    delay_us(1); 
01C46:  REPEAT  #1C
01C48:  NOP     
....................    for(i=0; i<24; ++i) 
01C4A:  CLR.B   8B3
01C4C:  MOV     8B2,W4
01C4E:  LSR     W4,#8,W4
01C50:  CP.B    W4L,#18
01C52:  BRA     C,1C86
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,3,0)); 
01C54:  BCLR.B  42.0
01C56:  RLC     8B0
01C58:  RLC.B   8B2
01C5A:  BRA     C,1C60
01C5C:  BCLR.B  2DC.6
01C5E:  BRA     1C62
01C60:  BSET.B  2DC.6
01C62:  BCLR.B  2D8.6
....................       delay_us(1); 
01C64:  REPEAT  #1C
01C66:  NOP     
....................       output_high(FR_SCK); 
01C68:  BCLR.B  2D8.5
01C6A:  BSET.B  2DC.5
....................       delay_us(1); 
01C6C:  REPEAT  #1C
01C6E:  NOP     
....................       output_low(FR_SI); 
01C70:  BCLR.B  2D8.6
01C72:  BCLR.B  2DC.6
....................       delay_us(1); 
01C74:  REPEAT  #1C
01C76:  NOP     
....................       output_low(FR_SCK); 
01C78:  BCLR.B  2D8.5
01C7A:  BCLR.B  2DC.5
....................       delay_us(1); 
01C7C:  REPEAT  #1C
01C7E:  NOP     
....................    } 
01C80:  INC.B   08B3
01C82:  GOTO    1C4C
....................    for(i=0; i<8; ++i) 
01C86:  CLR.B   8B3
01C88:  MOV     8B2,W4
01C8A:  LSR     W4,#8,W4
01C8C:  CP.B    W4L,#8
01C8E:  BRA     C,1CBC
....................    { 
....................       delay_us(1); 
01C90:  REPEAT  #1C
01C92:  NOP     
....................       shift_left(&data,1,input(FR_SO)); 
01C94:  BSET.B  2D8.7
01C96:  BTSC.B  2DA.7
01C98:  BRA     1C9E
01C9A:  BCLR.B  42.0
01C9C:  BRA     1CA0
01C9E:  BSET.B  42.0
01CA0:  RLC.B   8B4
....................       output_high(FR_SCK); 
01CA2:  BCLR.B  2D8.5
01CA4:  BSET.B  2DC.5
....................       delay_us(1); 
01CA6:  REPEAT  #1C
01CA8:  NOP     
....................       delay_us(1); 
01CAA:  REPEAT  #1C
01CAC:  NOP     
....................       output_low(FR_SCK); 
01CAE:  BCLR.B  2D8.5
01CB0:  BCLR.B  2DC.5
....................       delay_us(1); 
01CB2:  REPEAT  #1C
01CB4:  NOP     
....................    } 
01CB6:  INC.B   08B3
01CB8:  GOTO    1C88
....................    output_high(FR_CS); 
01CBC:  BCLR.B  2E4.7
01CBE:  BSET.B  2E8.7
....................    delay_us(1); 
01CC0:  REPEAT  #1C
01CC2:  NOP     
....................     
....................    return(data); 
01CC4:  MOV.B   8B4,W0L
01CC6:  MOV.B   W0L,0
.................... } 
01CC8:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... void fr_write(unsigned int16 address,unsigned int16 data) 
.................... { 
*
02370:  MOV     W5,[W15++]
....................    unsigned int8 data_high; 
....................    unsigned int8 data_low; 
....................    data_low=(unsigned int8)data; 
02372:  MOV.B   8A0,W0L
02374:  MOV.B   W0L,8A3
....................    data_high=(unsigned int8)(data>>8); 
02376:  MOV.B   8A1,W0L
02378:  CLR.B   1
0237A:  MOV.B   W0L,8A2
....................     
....................    fr_write_byte(address,data_low); 
0237C:  MOV.B   8A3,W0L
0237E:  MOV.B   W0L,8AE
02380:  PUSH    89E
02382:  POP     8AC
02384:  CALL    2264
....................    fr_write_byte(address+1,data_high); 
02388:  MOV     89E,W4
0238A:  ADD     W4,#1,W4
0238C:  MOV     W4,W5
0238E:  MOV.B   8A2,W0L
02390:  MOV.B   W0L,8AE
02392:  MOV     W5,8AC
02394:  CALL    2264
....................     
....................    return; 
.................... } 
02398:  MOV     [--W15],W5
0239A:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... unsigned int16 fr_read(unsigned int16 address) 
.................... { 
*
01CCA:  MOV     W5,[W15++]
....................    unsigned int16 data_buffer; 
....................    unsigned int16 data_low; 
....................    unsigned int16 data_high; 
....................     
....................    data_low=fr_read_byte(address); 
01CCC:  PUSH    8A0
01CCE:  POP     8AE
01CD0:  CALL    1C32
01CD4:  MOV.B   W0L,8A4
01CD6:  CLR.B   8A5
....................    data_high=fr_read_byte(address+1); 
01CD8:  MOV     8A0,W4
01CDA:  ADD     W4,#1,W4
01CDC:  MOV     W4,W5
01CDE:  MOV     W5,8AE
01CE0:  CALL    1C32
01CE4:  MOV.B   W0L,8A6
01CE6:  CLR.B   8A7
....................     
....................    data_buffer=(data_high<<8)+data_low; 
01CE8:  MOV.B   8A6,W0L
01CEA:  MOV.B   W0L,B
01CEC:  CLR.B   W5
01CEE:  MOV     W5,W0
01CF0:  ADD     8A4,W0
01CF2:  MOV     W0,8A2
....................     
....................    return data_buffer; 
01CF4:  PUSH    8A2
01CF6:  POP     0
.................... } 
01CF8:  MOV     [--W15],W5
01CFA:  RETURN  
....................  
.................... // Returns serial number of the device via RS232 
.................... void data_get_serial_no() 
.................... { 
*
032FA:  MOV     W5,[W15++]
032FC:  MOV     W6,[W15++]
....................    if(!debug_mode_fr)  
032FE:  BTSC.B  800.2
03300:  BRA     3304
....................       return; 
03302:  BRA     336E
....................        
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
03304:  CLR.B   890
....................     
....................    fprintf(RS232, "Serial No:"); 
03306:  MOV     #0,W1
03308:  MOV     W1,W0
0330A:  CALL    326
0330E:  INC     W1,W1
03310:  MOV     W1,[W15++]
03312:  BTSC.B  219.1
03314:  BRA     3312
03316:  MOV     W0,21A
03318:  MOV     [--W15],W1
0331A:  MOV     #9,W0
0331C:  CPSGT   W1,W0
0331E:  BRA     3308
....................    for(i=0; i<13; i++) 
03320:  CLR.B   890
03322:  MOV     890,W4
03324:  CP.B    W4L,#D
03326:  BRA     C,335E
....................    { 
....................       input[i]=fr_read_byte(fr_serial_no+i); 
03328:  MOV     890,W4
0332A:  CLR.B   9
0332C:  MOV     #892,W3
0332E:  ADD     W4,W3,W5
03330:  MOV     890,W4
03332:  CLR.B   9
03334:  MOV     832,W3
03336:  ADD     W3,W4,W6
03338:  MOV     W6,8AE
0333A:  CALL    1C32
0333E:  MOV.B   W0L,[W5]
....................       fputc(input[i]+48,RS232); 
03340:  MOV     890,W4
03342:  CLR.B   9
03344:  MOV     #892,W3
03346:  ADD     W4,W3,W0
03348:  MOV     #30,W4
0334A:  MOV.B   [W0],W3L
0334C:  ADD.B   W3L,W4L,W5L
0334E:  MOV.B   W5L,W0L
03350:  BTSC.B  219.1
03352:  BRA     3350
03354:  MOV.B   W0L,21A
03356:  CLR.B   21B
....................    } 
03358:  INC.B   0890
0335A:  GOTO    3322
....................    fprintf(RS232, "\n\r"); 
0335E:  BTSC.B  219.1
03360:  BRA     335E
03362:  MOV     #A,W4
03364:  MOV     W4,21A
03366:  BTSC.B  219.1
03368:  BRA     3366
0336A:  MOV     #D,W4
0336C:  MOV     W4,21A
.................... } 
0336E:  MOV     [--W15],W6
03370:  MOV     [--W15],W5
03372:  RETURN  
.................... // Returns movement range of the device 
.................... unsigned int16 data_get_move_range() 
.................... { 
*
01CFC:  PUSH    834
01CFE:  POP     8A0
01D00:  CALL    1CCA
01D04:  MOV     W0,890
....................    unsigned int16 range = fr_read(fr_move_range); 
....................     
....................    if(debug_mode_fr)  
01D06:  BTSS.B  800.2
01D08:  BRA     1D46
....................       fprintf(RS232, "Movement Range: %u mm\n\r", range); 
01D0A:  MOV     #0,W1
01D0C:  MOV     W1,W0
01D0E:  CALL    33E
01D12:  INC     W1,W1
01D14:  MOV     W1,[W15++]
01D16:  BTSC.B  219.1
01D18:  BRA     1D16
01D1A:  MOV     W0,21A
01D1C:  MOV     [--W15],W1
01D1E:  MOV     #F,W0
01D20:  CPSGT   W1,W0
01D22:  BRA     1D0C
01D24:  MOV     890,W0
01D26:  MOV     #0,W4
01D28:  CALL    1572
01D2C:  MOV     #12,W1
01D2E:  MOV     W1,W0
01D30:  CALL    33E
01D34:  INC     W1,W1
01D36:  MOV     W1,[W15++]
01D38:  BTSC.B  219.1
01D3A:  BRA     1D38
01D3C:  MOV     W0,21A
01D3E:  MOV     [--W15],W1
01D40:  MOV     #16,W0
01D42:  CPSGT   W1,W0
01D44:  BRA     1D2E
....................     
....................    return range; 
01D46:  PUSH    890
01D48:  POP     0
.................... } 
01D4A:  RETURN  
.................... // Returns home position 
.................... unsigned int16 data_get_home_pos() 
.................... { 
01D4C:  PUSH    836
01D4E:  POP     8A0
01D50:  CALL    1CCA
01D54:  MOV     W0,89E
....................    unsigned int16 home_pos = fr_read(fr_home_pos); 
....................     
....................    if(debug_mode_fr)  
01D56:  BTSS.B  800.2
01D58:  BRA     1D96
....................       fprintf(RS232, "Home Distance: %u counts\n\r", home_pos); 
01D5A:  MOV     #0,W1
01D5C:  MOV     W1,W0
01D5E:  CALL    362
01D62:  INC     W1,W1
01D64:  MOV     W1,[W15++]
01D66:  BTSC.B  219.1
01D68:  BRA     1D66
01D6A:  MOV     W0,21A
01D6C:  MOV     [--W15],W1
01D6E:  MOV     #E,W0
01D70:  CPSGT   W1,W0
01D72:  BRA     1D5C
01D74:  MOV     89E,W0
01D76:  MOV     #0,W4
01D78:  CALL    1572
01D7C:  MOV     #11,W1
01D7E:  MOV     W1,W0
01D80:  CALL    362
01D84:  INC     W1,W1
01D86:  MOV     W1,[W15++]
01D88:  BTSC.B  219.1
01D8A:  BRA     1D88
01D8C:  MOV     W0,21A
01D8E:  MOV     [--W15],W1
01D90:  MOV     #19,W0
01D92:  CPSGT   W1,W0
01D94:  BRA     1D7E
....................        
....................    return home_pos; 
01D96:  PUSH    89E
01D98:  POP     0
.................... } 
01D9A:  RETURN  
.................... // Returns end position 
.................... unsigned int16 data_get_end_pos() 
.................... { 
01D9C:  PUSH    838
01D9E:  POP     8A0
01DA0:  CALL    1CCA
01DA4:  MOV     W0,890
....................    unsigned int16 end = fr_read(fr_end_pos); 
....................     
....................    if(debug_mode_fr) 
01DA6:  BTSS.B  800.2
01DA8:  BRA     1DE6
....................       fprintf(RS232, "End Distance: %u counts\n\r", end); 
01DAA:  MOV     #0,W1
01DAC:  MOV     W1,W0
01DAE:  CALL    38A
01DB2:  INC     W1,W1
01DB4:  MOV     W1,[W15++]
01DB6:  BTSC.B  219.1
01DB8:  BRA     1DB6
01DBA:  MOV     W0,21A
01DBC:  MOV     [--W15],W1
01DBE:  MOV     #D,W0
01DC0:  CPSGT   W1,W0
01DC2:  BRA     1DAC
01DC4:  MOV     890,W0
01DC6:  MOV     #0,W4
01DC8:  CALL    1572
01DCC:  MOV     #10,W1
01DCE:  MOV     W1,W0
01DD0:  CALL    38A
01DD4:  INC     W1,W1
01DD6:  MOV     W1,[W15++]
01DD8:  BTSC.B  219.1
01DDA:  BRA     1DD8
01DDC:  MOV     W0,21A
01DDE:  MOV     [--W15],W1
01DE0:  MOV     #18,W0
01DE2:  CPSGT   W1,W0
01DE4:  BRA     1DCE
....................     
....................    return end; 
01DE6:  PUSH    890
01DE8:  POP     0
.................... } 
01DEA:  RETURN  
.................... // Returns positioning velocity 
.................... unsigned int16 data_get_conv_const() 
.................... { 
*
01E80:  PUSH    83A
01E82:  POP     8A0
01E84:  CALL    1CCA
01E88:  MOV     W0,890
....................    unsigned int16 conv_const = fr_read(fr_conv_const); 
....................     
....................    if((conv_const < 12000)||(conv_const > 13000)) 
01E8A:  MOV     890,W4
01E8C:  MOV     #2EE0,W3
01E8E:  CP      W3,W4
01E90:  BRA     GTU,1E9A
01E92:  MOV     890,W4
01E94:  MOV     #32C8,W3
01E96:  CP      W3,W4
01E98:  BRA     C,1E9E
....................       conv_const = 12500; 
01E9A:  MOV     #30D4,W4
01E9C:  MOV     W4,890
....................     
....................    if(debug_mode_fr)  
01E9E:  BTSS.B  800.2
01EA0:  BRA     1EDC
....................       fprintf(RS232, "Conversion Constant: %u \n\r", conv_const); 
01EA2:  MOV     #0,W1
01EA4:  MOV     W1,W0
01EA6:  CALL    3B0
01EAA:  INC     W1,W1
01EAC:  MOV     W1,[W15++]
01EAE:  BTSC.B  219.1
01EB0:  BRA     1EAE
01EB2:  MOV     W0,21A
01EB4:  MOV     [--W15],W1
01EB6:  MOV     #14,W0
01EB8:  CPSGT   W1,W0
01EBA:  BRA     1EA4
01EBC:  MOV     890,W0
01EBE:  MOV     #0,W4
01EC0:  CALL    1572
01EC4:  BTSC.B  219.1
01EC6:  BRA     1EC4
01EC8:  MOV     #20,W4
01ECA:  MOV     W4,21A
01ECC:  BTSC.B  219.1
01ECE:  BRA     1ECC
01ED0:  MOV     #A,W4
01ED2:  MOV     W4,21A
01ED4:  BTSC.B  219.1
01ED6:  BRA     1ED4
01ED8:  MOV     #D,W4
01EDA:  MOV     W4,21A
....................     
....................    return conv_const; 
01EDC:  PUSH    890
01EDE:  POP     0
.................... } 
01EE0:  RETURN  
.................... // Returns the backlash of the system 
.................... unsigned int16 data_get_backlash() 
.................... { 
*
01DEC:  PUSH    83C
01DEE:  POP     8A0
01DF0:  CALL    1CCA
01DF4:  MOV     W0,890
....................    unsigned int16 backlash = fr_read(fr_backlash); 
....................  
....................    if(debug_mode_fr)  
01DF6:  BTSS.B  800.2
01DF8:  BRA     1E36
....................       fprintf(RS232, "Backlash: %u counts\n\r", backlash); 
01DFA:  MOV     #0,W1
01DFC:  MOV     W1,W0
01DFE:  CALL    3D8
01E02:  INC     W1,W1
01E04:  MOV     W1,[W15++]
01E06:  BTSC.B  219.1
01E08:  BRA     1E06
01E0A:  MOV     W0,21A
01E0C:  MOV     [--W15],W1
01E0E:  MOV     #9,W0
01E10:  CPSGT   W1,W0
01E12:  BRA     1DFC
01E14:  MOV     890,W0
01E16:  MOV     #0,W4
01E18:  CALL    1572
01E1C:  MOV     #C,W1
01E1E:  MOV     W1,W0
01E20:  CALL    3D8
01E24:  INC     W1,W1
01E26:  MOV     W1,[W15++]
01E28:  BTSC.B  219.1
01E2A:  BRA     1E28
01E2C:  MOV     W0,21A
01E2E:  MOV     [--W15],W1
01E30:  MOV     #14,W0
01E32:  CPSGT   W1,W0
01E34:  BRA     1E1E
....................     
....................    return backlash; 
01E36:  PUSH    890
01E38:  POP     0
.................... } 
01E3A:  RETURN  
.................... // Returns communication type 
.................... unsigned int8 data_get_comm_type() 
.................... { 
*
02E16:  PUSH    83E
02E18:  POP     8AE
02E1A:  CALL    1C32
02E1E:  MOV.B   W0L,890
....................    unsigned int8 comm_type=fr_read_byte(fr_comm_type); 
....................     
....................    if(debug_mode_fr) 
02E20:  BTSS.B  800.2
02E22:  BRA     2E8C
....................       switch (comm_type) 
....................       { 
02E24:  MOV.B   890,W0L
02E26:  CLR.B   1
02E28:  XOR     #0,W0
02E2A:  BRA     Z,2E32
02E2C:  XOR     #1,W0
02E2E:  BRA     Z,2E50
02E30:  BRA     2E6E
....................          case 0   :  fprintf(RS232,"Communication Type: Parallel Port\n\r"); 
02E32:  MOV     #0,W1
02E34:  MOV     W1,W0
02E36:  CALL    3FA
02E3A:  INC     W1,W1
02E3C:  MOV     W1,[W15++]
02E3E:  BTSC.B  219.1
02E40:  BRA     2E3E
02E42:  MOV     W0,21A
02E44:  MOV     [--W15],W1
02E46:  MOV     #22,W0
02E48:  CPSGT   W1,W0
02E4A:  BRA     2E34
....................                      break; 
02E4C:  GOTO    2E8C
....................          case 1   :  fprintf(RS232,"Communication Type: Serial Port\n\r"); 
02E50:  MOV     #0,W1
02E52:  MOV     W1,W0
02E54:  CALL    42A
02E58:  INC     W1,W1
02E5A:  MOV     W1,[W15++]
02E5C:  BTSC.B  219.1
02E5E:  BRA     2E5C
02E60:  MOV     W0,21A
02E62:  MOV     [--W15],W1
02E64:  MOV     #20,W0
02E66:  CPSGT   W1,W0
02E68:  BRA     2E52
....................                      break; 
02E6A:  GOTO    2E8C
....................          default  :  fprintf(RS232,"Communication Type: Undefined\n\r"); 
02E6E:  MOV     #0,W1
02E70:  MOV     W1,W0
02E72:  CALL    458
02E76:  INC     W1,W1
02E78:  MOV     W1,[W15++]
02E7A:  BTSC.B  219.1
02E7C:  BRA     2E7A
02E7E:  MOV     W0,21A
02E80:  MOV     [--W15],W1
02E82:  MOV     #1E,W0
02E84:  CPSGT   W1,W0
02E86:  BRA     2E70
....................                      break; 
02E88:  GOTO    2E8C
....................       } 
....................        
....................    return comm_type; 
02E8C:  MOV.B   890,W0L
02E8E:  MOV.B   W0L,0
.................... } 
02E90:  RETURN  
.................... // Returns last position 
.................... unsigned int16 data_get_last_pos() 
.................... { 
*
02214:  PUSH    840
02216:  POP     8A0
02218:  CALL    1CCA
0221C:  MOV     W0,890
....................    unsigned int16 position=fr_read(fr_last_pos); 
....................     
....................    if(debug_mode_fr)  
0221E:  BTSS.B  800.2
02220:  BRA     225E
....................       fprintf(RS232, "Last Position: %u mm\n\r", position); 
02222:  MOV     #0,W1
02224:  MOV     W1,W0
02226:  CALL    484
0222A:  INC     W1,W1
0222C:  MOV     W1,[W15++]
0222E:  BTSC.B  219.1
02230:  BRA     222E
02232:  MOV     W0,21A
02234:  MOV     [--W15],W1
02236:  MOV     #E,W0
02238:  CPSGT   W1,W0
0223A:  BRA     2224
0223C:  MOV     890,W0
0223E:  MOV     #0,W4
02240:  CALL    1572
02244:  MOV     #11,W1
02246:  MOV     W1,W0
02248:  CALL    484
0224C:  INC     W1,W1
0224E:  MOV     W1,[W15++]
02250:  BTSC.B  219.1
02252:  BRA     2250
02254:  MOV     W0,21A
02256:  MOV     [--W15],W1
02258:  MOV     #15,W0
0225A:  CPSGT   W1,W0
0225C:  BRA     2246
....................     
....................    return position; 
0225E:  PUSH    890
02260:  POP     0
.................... } 
02262:  RETURN  
.................... // Returns the position in the given index 
.................... unsigned int16 data_get_pos(unsigned int8 index) 
.................... { 
*
036C8:  MOV     W5,[W15++]
036CA:  MOV.B   896,W0L
036CC:  SL      W0,#1,W0
036CE:  ZE      W0,W0
036D0:  CLR.B   1
036D2:  MOV     842,W4
036D4:  ADD     W0,W4,W5
036D6:  MOV     W5,8A0
036D8:  CALL    1CCA
036DC:  MOV     W0,898
....................    unsigned int16 position=fr_read(fr_pos_table+index*2); 
....................     
....................    if(debug_mode_fr) 
036DE:  BTSS.B  800.2
036E0:  BRA     3742
....................       fprintf(RS232,"Index: %u, Position: %u mm\n\r", index, position); 
036E2:  MOV     #0,W1
036E4:  MOV     W1,W0
036E6:  CALL    4A8
036EA:  INC     W1,W1
036EC:  MOV     W1,[W15++]
036EE:  BTSC.B  219.1
036F0:  BRA     36EE
036F2:  MOV     W0,21A
036F4:  MOV     [--W15],W1
036F6:  MOV     #6,W0
036F8:  CPSGT   W1,W0
036FA:  BRA     36E4
036FC:  MOV.B   896,W0L
036FE:  CLR.B   1
03700:  MOV     #0,W4
03702:  CALL    1572
03706:  MOV     #9,W1
03708:  MOV     W1,W0
0370A:  CALL    4A8
0370E:  INC     W1,W1
03710:  MOV     W1,[W15++]
03712:  BTSC.B  219.1
03714:  BRA     3712
03716:  MOV     W0,21A
03718:  MOV     [--W15],W1
0371A:  MOV     #14,W0
0371C:  CPSGT   W1,W0
0371E:  BRA     3708
03720:  MOV     898,W0
03722:  MOV     #0,W4
03724:  CALL    1572
03728:  MOV     #17,W1
0372A:  MOV     W1,W0
0372C:  CALL    4A8
03730:  INC     W1,W1
03732:  MOV     W1,[W15++]
03734:  BTSC.B  219.1
03736:  BRA     3734
03738:  MOV     W0,21A
0373A:  MOV     [--W15],W1
0373C:  MOV     #1B,W0
0373E:  CPSGT   W1,W0
03740:  BRA     372A
....................     
....................    return position; 
03742:  PUSH    898
03744:  POP     0
.................... } 
03746:  MOV     [--W15],W5
03748:  RETURN  
.................... // Returns position table via RS232 
.................... void data_get_pos_table() 
.................... { 
0374A:  MOV     W5,[W15++]
....................    debug_mode_fr=1; 
0374C:  BSET.B  800.2
....................     
....................    unsigned int input; 
....................    unsigned int i; 
....................    unsigned int index; 
....................     
....................    input=(unsigned)(fgetc(RS232)-48); 
0374E:  BTSS.B  218.0
03750:  BRA     374E
03752:  MOV     21C,W0
03754:  MOV     #30,W4
03756:  SUB.B   W0L,W4L,W0L
03758:  MOV.B   W0L,890
0375A:  CLR.B   891
....................    fputc(input+48,RS232); 
0375C:  MOV     #30,W4
0375E:  MOV     890,W3
03760:  ADD     W3,W4,W5
03762:  MOV.B   W5L,W0L
03764:  BTSC.B  219.1
03766:  BRA     3764
03768:  MOV.B   W0L,21A
0376A:  CLR.B   21B
....................  
....................    if(input>9) 
0376C:  MOV     890,W4
0376E:  CP      W4,#9
03770:  BRA     LEU,3776
....................       input=9; 
03772:  MOV     #9,W4
03774:  MOV     W4,890
....................  
....................    fprintf(RS232,"\n\r"); 
03776:  BTSC.B  219.1
03778:  BRA     3776
0377A:  MOV     #A,W4
0377C:  MOV     W4,21A
0377E:  BTSC.B  219.1
03780:  BRA     377E
03782:  MOV     #D,W4
03784:  MOV     W4,21A
....................     
....................    for(i=0; i<10; i++) 
03786:  CLR     892
03788:  MOV     892,W4
0378A:  CP      W4,#A
0378C:  BRA     C,37A8
....................    { 
....................       index=input*10+i; 
0378E:  MOV     890,W4
03790:  MUL.UU  W4,#A,W0
03792:  MOV     W0,W5
03794:  MOV     W5,W0
03796:  ADD     892,W0
03798:  MOV     W0,894
....................       data_get_pos(index); 
0379A:  MOV.B   894,W0L
0379C:  MOV.B   W0L,896
0379E:  CALL    36C8
....................    } 
037A2:  INC     0892
037A4:  GOTO    3788
....................     
....................    debug_mode_fr=0; 
037A8:  BCLR.B  800.2
.................... } 
037AA:  MOV     [--W15],W5
037AC:  RETURN  
.................... // Returns all system data via RS232 
.................... void data_get_sys_data() 
.................... { 
*
03374:  MOV     W5,[W15++]
....................    fprintf(RS232,"MODESIS LASER POSITIONING SYSTEM\n\n\r"); 
03376:  MOV     #0,W1
03378:  MOV     W1,W0
0337A:  CALL    4D2
0337E:  INC     W1,W1
03380:  MOV     W1,[W15++]
03382:  BTSC.B  219.1
03384:  BRA     3382
03386:  MOV     W0,21A
03388:  MOV     [--W15],W1
0338A:  MOV     #22,W0
0338C:  CPSGT   W1,W0
0338E:  BRA     3378
....................    debug_mode_fr=1; 
03390:  BSET.B  800.2
....................    data_get_serial_no(); 
03392:  CALL    32FA
....................    data_get_move_range(); 
03396:  CALL    1CFC
....................    data_get_home_pos(); 
0339A:  CALL    1D4C
....................    data_get_end_pos(); 
0339E:  CALL    1D9C
....................    data_get_conv_const(); 
033A2:  CALL    1E80
....................    data_get_backlash(); 
033A6:  CALL    1DEC
....................    data_get_comm_type(); 
033AA:  CALL    2E16
....................    data_get_last_pos(); 
033AE:  CALL    2214
....................    debug_mode_fr=0; 
033B2:  BCLR.B  800.2
....................    fprintf(RS232,"\n\r"); 
033B4:  BTSC.B  219.1
033B6:  BRA     33B4
033B8:  MOV     #A,W4
033BA:  MOV     W4,21A
033BC:  BTSC.B  219.1
033BE:  BRA     33BC
033C0:  MOV     #D,W4
033C2:  MOV     W4,21A
....................    fprintf(RS232,"RCON REGISTER VALUE SIFIRLANIYOR..."); 
033C4:  MOV     #0,W1
033C6:  MOV     W1,W0
033C8:  CALL    502
033CC:  INC     W1,W1
033CE:  MOV     W1,[W15++]
033D0:  BTSC.B  219.1
033D2:  BRA     33D0
033D4:  MOV     W0,21A
033D6:  MOV     [--W15],W1
033D8:  MOV     #22,W0
033DA:  CPSGT   W1,W0
033DC:  BRA     33C6
....................    fprintf(RS232,"\n\r"); 
033DE:  BTSC.B  219.1
033E0:  BRA     33DE
033E2:  MOV     #A,W4
033E4:  MOV     W4,21A
033E6:  BTSC.B  219.1
033E8:  BRA     33E6
033EA:  MOV     #D,W4
033EC:  MOV     W4,21A
....................    fprintf(RS232,"YENI RCON REGISTER VALUE(10'luk Tabanda):"); 
033EE:  MOV     #0,W1
033F0:  MOV     W1,W0
033F2:  CALL    532
033F6:  INC     W1,W1
033F8:  MOV     W1,[W15++]
033FA:  BTSC.B  219.1
033FC:  BRA     33FA
033FE:  MOV     W0,21A
03400:  MOV     [--W15],W1
03402:  MOV     #28,W0
03404:  CPSGT   W1,W0
03406:  BRA     33F0
....................    fprintf(RS232,"%u",RCON); 
03408:  MOV     740,W0
0340A:  MOV     #0,W4
0340C:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
03410:  BTSC.B  219.1
03412:  BRA     3410
03414:  MOV     #A,W4
03416:  MOV     W4,21A
03418:  BTSC.B  219.1
0341A:  BRA     3418
0341C:  MOV     #D,W4
0341E:  MOV     W4,21A
....................     
....................    fprintf(RS232,"POR:    "); 
03420:  MOV     #0,W1
03422:  MOV     W1,W0
03424:  CALL    56A
03428:  INC     W1,W1
0342A:  MOV     W1,[W15++]
0342C:  BTSC.B  219.1
0342E:  BRA     342C
03430:  MOV     W0,21A
03432:  MOV     [--W15],W1
03434:  MOV     #7,W0
03436:  CPSGT   W1,W0
03438:  BRA     3422
....................    fprintf(RS232,"%u",RCON_POR); 
0343A:  CLR.B   W0
0343C:  BTSC.B  740.0
0343E:  INC     W0,W0
03440:  MOV.B   W0L,W5L
03442:  MOV.B   W5L,W0L
03444:  CLR.B   1
03446:  MOV     #0,W4
03448:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
0344C:  BTSC.B  219.1
0344E:  BRA     344C
03450:  MOV     #A,W4
03452:  MOV     W4,21A
03454:  BTSC.B  219.1
03456:  BRA     3454
03458:  MOV     #D,W4
0345A:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BOR:    "); 
0345C:  MOV     #0,W1
0345E:  MOV     W1,W0
03460:  CALL    580
03464:  INC     W1,W1
03466:  MOV     W1,[W15++]
03468:  BTSC.B  219.1
0346A:  BRA     3468
0346C:  MOV     W0,21A
0346E:  MOV     [--W15],W1
03470:  MOV     #7,W0
03472:  CPSGT   W1,W0
03474:  BRA     345E
....................    fprintf(RS232,"%u",RCON_BOR); 
03476:  CLR.B   W0
03478:  BTSC.B  740.1
0347A:  INC     W0,W0
0347C:  MOV.B   W0L,W5L
0347E:  MOV.B   W5L,W0L
03480:  CLR.B   1
03482:  MOV     #0,W4
03484:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
03488:  BTSC.B  219.1
0348A:  BRA     3488
0348C:  MOV     #A,W4
0348E:  MOV     W4,21A
03490:  BTSC.B  219.1
03492:  BRA     3490
03494:  MOV     #D,W4
03496:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IDLE:   "); 
03498:  MOV     #0,W1
0349A:  MOV     W1,W0
0349C:  CALL    596
034A0:  INC     W1,W1
034A2:  MOV     W1,[W15++]
034A4:  BTSC.B  219.1
034A6:  BRA     34A4
034A8:  MOV     W0,21A
034AA:  MOV     [--W15],W1
034AC:  MOV     #7,W0
034AE:  CPSGT   W1,W0
034B0:  BRA     349A
....................    fprintf(RS232,"%u",RCON_IDLE); 
034B2:  CLR.B   W0
034B4:  BTSC.B  740.2
034B6:  INC     W0,W0
034B8:  MOV.B   W0L,W5L
034BA:  MOV.B   W5L,W0L
034BC:  CLR.B   1
034BE:  MOV     #0,W4
034C0:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
034C4:  BTSC.B  219.1
034C6:  BRA     34C4
034C8:  MOV     #A,W4
034CA:  MOV     W4,21A
034CC:  BTSC.B  219.1
034CE:  BRA     34CC
034D0:  MOV     #D,W4
034D2:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SLEEP:  "); 
034D4:  MOV     #0,W1
034D6:  MOV     W1,W0
034D8:  CALL    5AC
034DC:  INC     W1,W1
034DE:  MOV     W1,[W15++]
034E0:  BTSC.B  219.1
034E2:  BRA     34E0
034E4:  MOV     W0,21A
034E6:  MOV     [--W15],W1
034E8:  MOV     #7,W0
034EA:  CPSGT   W1,W0
034EC:  BRA     34D6
....................    fprintf(RS232,"%u",RCON_SLEEP); 
034EE:  CLR.B   W0
034F0:  BTSC.B  740.3
034F2:  INC     W0,W0
034F4:  MOV.B   W0L,W5L
034F6:  MOV.B   W5L,W0L
034F8:  CLR.B   1
034FA:  MOV     #0,W4
034FC:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
03500:  BTSC.B  219.1
03502:  BRA     3500
03504:  MOV     #A,W4
03506:  MOV     W4,21A
03508:  BTSC.B  219.1
0350A:  BRA     3508
0350C:  MOV     #D,W4
0350E:  MOV     W4,21A
....................     
....................    fprintf(RS232,"WDTO:   "); 
03510:  MOV     #0,W1
03512:  MOV     W1,W0
03514:  CALL    5C2
03518:  INC     W1,W1
0351A:  MOV     W1,[W15++]
0351C:  BTSC.B  219.1
0351E:  BRA     351C
03520:  MOV     W0,21A
03522:  MOV     [--W15],W1
03524:  MOV     #7,W0
03526:  CPSGT   W1,W0
03528:  BRA     3512
....................    fprintf(RS232,"%u",RCON_WDTO); 
0352A:  CLR.B   W0
0352C:  BTSC.B  740.4
0352E:  INC     W0,W0
03530:  MOV.B   W0L,W5L
03532:  MOV.B   W5L,W0L
03534:  CLR.B   1
03536:  MOV     #0,W4
03538:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
0353C:  BTSC.B  219.1
0353E:  BRA     353C
03540:  MOV     #A,W4
03542:  MOV     W4,21A
03544:  BTSC.B  219.1
03546:  BRA     3544
03548:  MOV     #D,W4
0354A:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWDTEN: "); 
0354C:  MOV     #0,W1
0354E:  MOV     W1,W0
03550:  CALL    5D8
03554:  INC     W1,W1
03556:  MOV     W1,[W15++]
03558:  BTSC.B  219.1
0355A:  BRA     3558
0355C:  MOV     W0,21A
0355E:  MOV     [--W15],W1
03560:  MOV     #7,W0
03562:  CPSGT   W1,W0
03564:  BRA     354E
....................    fprintf(RS232,"%u",RCON_SWDTEN); 
03566:  CLR.B   W0
03568:  BTSC.B  740.5
0356A:  INC     W0,W0
0356C:  MOV.B   W0L,W5L
0356E:  MOV.B   W5L,W0L
03570:  CLR.B   1
03572:  MOV     #0,W4
03574:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
03578:  BTSC.B  219.1
0357A:  BRA     3578
0357C:  MOV     #A,W4
0357E:  MOV     W4,21A
03580:  BTSC.B  219.1
03582:  BRA     3580
03584:  MOV     #D,W4
03586:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWR:    "); 
03588:  MOV     #0,W1
0358A:  MOV     W1,W0
0358C:  CALL    5EE
03590:  INC     W1,W1
03592:  MOV     W1,[W15++]
03594:  BTSC.B  219.1
03596:  BRA     3594
03598:  MOV     W0,21A
0359A:  MOV     [--W15],W1
0359C:  MOV     #7,W0
0359E:  CPSGT   W1,W0
035A0:  BRA     358A
....................    fprintf(RS232,"%u",RCON_SWR); 
035A2:  CLR.B   W0
035A4:  BTSC.B  740.6
035A6:  INC     W0,W0
035A8:  MOV.B   W0L,W5L
035AA:  MOV.B   W5L,W0L
035AC:  CLR.B   1
035AE:  MOV     #0,W4
035B0:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
035B4:  BTSC.B  219.1
035B6:  BRA     35B4
035B8:  MOV     #A,W4
035BA:  MOV     W4,21A
035BC:  BTSC.B  219.1
035BE:  BRA     35BC
035C0:  MOV     #D,W4
035C2:  MOV     W4,21A
....................     
....................    fprintf(RS232,"EXTR:   "); 
035C4:  MOV     #0,W1
035C6:  MOV     W1,W0
035C8:  CALL    604
035CC:  INC     W1,W1
035CE:  MOV     W1,[W15++]
035D0:  BTSC.B  219.1
035D2:  BRA     35D0
035D4:  MOV     W0,21A
035D6:  MOV     [--W15],W1
035D8:  MOV     #7,W0
035DA:  CPSGT   W1,W0
035DC:  BRA     35C6
....................    fprintf(RS232,"%u",RCON_EXTR); 
035DE:  CLR.B   W0
035E0:  BTSC.B  740.7
035E2:  INC     W0,W0
035E4:  MOV.B   W0L,W5L
035E6:  MOV.B   W5L,W0L
035E8:  CLR.B   1
035EA:  MOV     #0,W4
035EC:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
035F0:  BTSC.B  219.1
035F2:  BRA     35F0
035F4:  MOV     #A,W4
035F6:  MOV     W4,21A
035F8:  BTSC.B  219.1
035FA:  BRA     35F8
035FC:  MOV     #D,W4
035FE:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BGST:   "); 
03600:  MOV     #0,W1
03602:  MOV     W1,W0
03604:  CALL    61A
03608:  INC     W1,W1
0360A:  MOV     W1,[W15++]
0360C:  BTSC.B  219.1
0360E:  BRA     360C
03610:  MOV     W0,21A
03612:  MOV     [--W15],W1
03614:  MOV     #7,W0
03616:  CPSGT   W1,W0
03618:  BRA     3602
....................    fprintf(RS232,"%u",RCON_BGST); 
0361A:  CLR.B   W0
0361C:  BTSC.B  741.5
0361E:  INC     W0,W0
03620:  MOV.B   W0L,W5L
03622:  MOV.B   W5L,W0L
03624:  CLR.B   1
03626:  MOV     #0,W4
03628:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
0362C:  BTSC.B  219.1
0362E:  BRA     362C
03630:  MOV     #A,W4
03632:  MOV     W4,21A
03634:  BTSC.B  219.1
03636:  BRA     3634
03638:  MOV     #D,W4
0363A:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IOPUWR: "); 
0363C:  MOV     #0,W1
0363E:  MOV     W1,W0
03640:  CALL    630
03644:  INC     W1,W1
03646:  MOV     W1,[W15++]
03648:  BTSC.B  219.1
0364A:  BRA     3648
0364C:  MOV     W0,21A
0364E:  MOV     [--W15],W1
03650:  MOV     #7,W0
03652:  CPSGT   W1,W0
03654:  BRA     363E
....................    fprintf(RS232,"%u",RCON_IOPUWR); 
03656:  CLR.B   W0
03658:  BTSC.B  741.6
0365A:  INC     W0,W0
0365C:  MOV.B   W0L,W5L
0365E:  MOV.B   W5L,W0L
03660:  CLR.B   1
03662:  MOV     #0,W4
03664:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
03668:  BTSC.B  219.1
0366A:  BRA     3668
0366C:  MOV     #A,W4
0366E:  MOV     W4,21A
03670:  BTSC.B  219.1
03672:  BRA     3670
03674:  MOV     #D,W4
03676:  MOV     W4,21A
....................     
....................    fprintf(RS232,"TRAPR:  "); 
03678:  MOV     #0,W1
0367A:  MOV     W1,W0
0367C:  CALL    646
03680:  INC     W1,W1
03682:  MOV     W1,[W15++]
03684:  BTSC.B  219.1
03686:  BRA     3684
03688:  MOV     W0,21A
0368A:  MOV     [--W15],W1
0368C:  MOV     #7,W0
0368E:  CPSGT   W1,W0
03690:  BRA     367A
....................    fprintf(RS232,"%u",RCON_TRAPR); 
03692:  CLR.B   W0
03694:  BTSC.B  741.7
03696:  INC     W0,W0
03698:  MOV.B   W0L,W5L
0369A:  MOV.B   W5L,W0L
0369C:  CLR.B   1
0369E:  MOV     #0,W4
036A0:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
036A4:  BTSC.B  219.1
036A6:  BRA     36A4
036A8:  MOV     #A,W4
036AA:  MOV     W4,21A
036AC:  BTSC.B  219.1
036AE:  BRA     36AC
036B0:  MOV     #D,W4
036B2:  MOV     W4,21A
....................  
....................    fprintf(RS232,"\n\r"); 
036B4:  BTSC.B  219.1
036B6:  BRA     36B4
036B8:  MOV     #A,W4
036BA:  MOV     W4,21A
036BC:  BTSC.B  219.1
036BE:  BRA     36BC
036C0:  MOV     #D,W4
036C2:  MOV     W4,21A
.................... } 
036C4:  MOV     [--W15],W5
036C6:  RETURN  
....................  
.................... // Sets serial nuber of the device 
.................... void data_set_serial_no() 
.................... { 
*
02E92:  MOV     W5,[W15++]
02E94:  MOV     W6,[W15++]
02E96:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
....................    for(i=0; i<13; i++) 
02E98:  CLR.B   890
02E9A:  MOV     890,W4
02E9C:  CP.B    W4L,#D
02E9E:  BRA     C,2EF0
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02EA0:  MOV     890,W4
02EA2:  CLR.B   9
02EA4:  MOV     #892,W3
02EA6:  ADD     W4,W3,W5
02EA8:  BTSS.B  218.0
02EAA:  BRA     2EA8
02EAC:  MOV     21C,W0
02EAE:  SUB.B   #30,W0L
02EB0:  CLR.B   1
02EB2:  MOV.B   W0L,[W5]
....................       fr_write_byte(fr_serial_no+i, input[i]); 
02EB4:  MOV     890,W4
02EB6:  CLR.B   9
02EB8:  MOV     832,W3
02EBA:  ADD     W3,W4,W5
02EBC:  MOV     890,W4
02EBE:  CLR.B   9
02EC0:  MOV     #892,W3
02EC2:  ADD     W4,W3,W0
02EC4:  MOV.B   [W0],W6L
02EC6:  PUSH    8AE
02EC8:  MOV.B   W6L,[W15-#2]
02ECA:  POP     8AE
02ECC:  MOV     W5,8AC
02ECE:  CALL    2264
....................       fputc(input[i]+48,RS232); 
02ED2:  MOV     890,W4
02ED4:  CLR.B   9
02ED6:  MOV     #892,W3
02ED8:  ADD     W4,W3,W0
02EDA:  MOV     #30,W4
02EDC:  MOV.B   [W0],W3L
02EDE:  ADD.B   W3L,W4L,W5L
02EE0:  MOV.B   W5L,W0L
02EE2:  BTSC.B  219.1
02EE4:  BRA     2EE2
02EE6:  MOV.B   W0L,21A
02EE8:  CLR.B   21B
....................    } 
02EEA:  INC.B   0890
02EEC:  GOTO    2E9A
.................... } 
02EF0:  MOV     [--W15],W6
02EF2:  MOV     [--W15],W5
02EF4:  RETURN  
.................... // Sets movement range of the device 
.................... void data_set_move_range() 
.................... { 
02EF6:  MOV     W5,[W15++]
02EF8:  MOV     W6,[W15++]
02EFA:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0;i<4;i++) 
02EFC:  CLR.B   890
02EFE:  MOV     890,W4
02F00:  CP.B    W4L,#4
02F02:  BRA     C,2F38
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02F04:  MOV.B   890,W0L
02F06:  CLR.B   1
02F08:  SL      W0,#1,W0
02F0A:  MOV     #892,W4
02F0C:  ADD     W0,W4,W5
02F0E:  BTSS.B  218.0
02F10:  BRA     2F0E
02F12:  MOV     21C,W0
02F14:  SUB.B   #30,W0L
02F16:  CLR.B   1
02F18:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
02F1A:  MOV.B   890,W0L
02F1C:  CLR.B   1
02F1E:  SL      W0,#1,W0
02F20:  MOV     #892,W4
02F22:  ADD     W0,W4,W0
02F24:  MOV     [W0],W5
02F26:  ADD     #30,W5
02F28:  MOV.B   W5L,W0L
02F2A:  BTSC.B  219.1
02F2C:  BRA     2F2A
02F2E:  MOV.B   W0L,21A
02F30:  CLR.B   21B
....................    } 
02F32:  INC.B   0890
02F34:  GOTO    2EFE
....................    unsigned int range=1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
02F38:  MOV     #3E8,W4
02F3A:  MOV     892,W3
02F3C:  MUL.UU  W4,W3,W0
02F3E:  MOV     W0,W5
02F40:  MOV     #64,W4
02F42:  MOV     894,W3
02F44:  MUL.UU  W4,W3,W0
02F46:  ADD     W0,W5,W5
02F48:  MOV     896,W4
02F4A:  MUL.UU  W4,#A,W0
02F4C:  ADD     W0,W5,W5
02F4E:  MOV     W5,W0
02F50:  ADD     898,W0
02F52:  MOV     W0,89A
....................     
....................    if(range<400) 
02F54:  MOV     89A,W4
02F56:  MOV     #190,W3
02F58:  CP      W3,W4
02F5A:  BRA     LEU,2F7E
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be smaller than 400 mm. Movement range is set to 400 mm."); 
02F5C:  MOV     #0,W1
02F5E:  MOV     W1,W0
02F60:  CALL    65C
02F64:  INC     W1,W1
02F66:  MOV     W1,[W15++]
02F68:  BTSC.B  219.1
02F6A:  BRA     2F68
02F6C:  MOV     W0,21A
02F6E:  MOV     [--W15],W1
02F70:  MOV     #5E,W0
02F72:  CPSGT   W1,W0
02F74:  BRA     2F5E
....................       range=400; 
02F76:  MOV     #190,W4
02F78:  MOV     W4,89A
....................    } 
....................    else if(range>2000) 
02F7A:  GOTO    2FA4
02F7E:  MOV     89A,W4
02F80:  MOV     #7D0,W3
02F82:  CP      W3,W4
02F84:  BRA     C,2FA4
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be larger than 2000 mm. Movement range is set to 2000 mm."); 
02F86:  MOV     #0,W1
02F88:  MOV     W1,W0
02F8A:  CALL    6B8
02F8E:  INC     W1,W1
02F90:  MOV     W1,[W15++]
02F92:  BTSC.B  219.1
02F94:  BRA     2F92
02F96:  MOV     W0,21A
02F98:  MOV     [--W15],W1
02F9A:  MOV     #5F,W0
02F9C:  CPSGT   W1,W0
02F9E:  BRA     2F88
....................       range=2000; 
02FA0:  MOV     #7D0,W4
02FA2:  MOV     W4,89A
....................    } 
....................     
....................    if(range==2000) 
02FA4:  MOV     89A,W4
02FA6:  MOV     #7D0,W3
02FA8:  CP      W3,W4
02FAA:  BRA     NZ,2FB4
....................       md_min_distance=120; 
02FAC:  MOV     #78,W4
02FAE:  MOV     W4,818
....................    else 
02FB0:  GOTO    2FB8
....................       md_min_distance=70; 
02FB4:  MOV     #46,W4
02FB6:  MOV     W4,818
....................        
....................    fr_write(fr_move_range, range); 
02FB8:  PUSH    834
02FBA:  POP     89E
02FBC:  PUSH    89A
02FBE:  POP     8A0
02FC0:  CALL    2370
....................    md_move_range=range; 
02FC4:  PUSH    89A
02FC6:  POP     80E
.................... } 
02FC8:  MOV     [--W15],W6
02FCA:  MOV     [--W15],W5
02FCC:  RETURN  
.................... // Sets home position 
.................... void data_set_home_pos() 
.................... { 
02FCE:  MOV     W5,[W15++]
02FD0:  MOV     W6,[W15++]
02FD2:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0; i<4; i++) 
02FD4:  CLR.B   890
02FD6:  MOV     890,W4
02FD8:  CP.B    W4L,#4
02FDA:  BRA     C,3010
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02FDC:  MOV.B   890,W0L
02FDE:  CLR.B   1
02FE0:  SL      W0,#1,W0
02FE2:  MOV     #892,W4
02FE4:  ADD     W0,W4,W5
02FE6:  BTSS.B  218.0
02FE8:  BRA     2FE6
02FEA:  MOV     21C,W0
02FEC:  SUB.B   #30,W0L
02FEE:  CLR.B   1
02FF0:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
02FF2:  MOV.B   890,W0L
02FF4:  CLR.B   1
02FF6:  SL      W0,#1,W0
02FF8:  MOV     #892,W4
02FFA:  ADD     W0,W4,W0
02FFC:  MOV     [W0],W5
02FFE:  ADD     #30,W5
03000:  MOV.B   W5L,W0L
03002:  BTSC.B  219.1
03004:  BRA     3002
03006:  MOV.B   W0L,21A
03008:  CLR.B   21B
....................    } 
0300A:  INC.B   0890
0300C:  GOTO    2FD6
....................    unsigned int home_pos = 1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
03010:  MOV     #3E8,W4
03012:  MOV     892,W3
03014:  MUL.UU  W4,W3,W0
03016:  MOV     W0,W5
03018:  MOV     #64,W4
0301A:  MOV     894,W3
0301C:  MUL.UU  W4,W3,W0
0301E:  ADD     W0,W5,W5
03020:  MOV     896,W4
03022:  MUL.UU  W4,#A,W0
03024:  ADD     W0,W5,W5
03026:  MOV     W5,W0
03028:  ADD     898,W0
0302A:  MOV     W0,89A
....................     
....................    if(home_pos<10) 
0302C:  MOV     89A,W4
0302E:  CP      W4,#A
03030:  BRA     C,304E
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Home position cannot be smaller than 10. Home position is not changed"); 
03032:  MOV     #0,W1
03034:  MOV     W1,W0
03036:  CALL    716
0303A:  INC     W1,W1
0303C:  MOV     W1,[W15++]
0303E:  BTSC.B  219.1
03040:  BRA     303E
03042:  MOV     W0,21A
03044:  MOV     [--W15],W1
03046:  MOV     #55,W0
03048:  CPSGT   W1,W0
0304A:  BRA     3034
....................       return; 
0304C:  BRA     305E
....................    } 
....................     
....................    fr_write(fr_home_pos,home_pos); 
0304E:  PUSH    836
03050:  POP     89E
03052:  PUSH    89A
03054:  POP     8A0
03056:  CALL    2370
....................    md_home_pos=home_pos; 
0305A:  PUSH    89A
0305C:  POP     810
.................... } 
0305E:  MOV     [--W15],W6
03060:  MOV     [--W15],W5
03062:  RETURN  
.................... // Sets end position 
.................... void data_set_end_pos() 
.................... { 
03064:  MOV     W5,[W15++]
03066:  MOV     W6,[W15++]
03068:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[5]; 
....................    for(i=0; i<5; i++) 
0306A:  CLR.B   890
0306C:  MOV     890,W4
0306E:  CP.B    W4L,#5
03070:  BRA     C,30A6
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03072:  MOV.B   890,W0L
03074:  CLR.B   1
03076:  SL      W0,#1,W0
03078:  MOV     #892,W4
0307A:  ADD     W0,W4,W5
0307C:  BTSS.B  218.0
0307E:  BRA     307C
03080:  MOV     21C,W0
03082:  SUB.B   #30,W0L
03084:  CLR.B   1
03086:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03088:  MOV.B   890,W0L
0308A:  CLR.B   1
0308C:  SL      W0,#1,W0
0308E:  MOV     #892,W4
03090:  ADD     W0,W4,W0
03092:  MOV     [W0],W5
03094:  ADD     #30,W5
03096:  MOV.B   W5L,W0L
03098:  BTSC.B  219.1
0309A:  BRA     3098
0309C:  MOV.B   W0L,21A
0309E:  CLR.B   21B
....................    } 
030A0:  INC.B   0890
030A2:  GOTO    306C
....................    unsigned int end=10000*input[0]+1000*input[1]+100*input[2]+10*input[3]+1*input[4]; 
030A6:  MOV     #2710,W4
030A8:  MOV     892,W3
030AA:  MUL.UU  W4,W3,W0
030AC:  MOV     W0,W5
030AE:  MOV     #3E8,W4
030B0:  MOV     894,W3
030B2:  MUL.UU  W4,W3,W0
030B4:  ADD     W0,W5,W5
030B6:  MOV     #64,W4
030B8:  MOV     896,W3
030BA:  MUL.UU  W4,W3,W0
030BC:  ADD     W0,W5,W5
030BE:  MOV     898,W4
030C0:  MUL.UU  W4,#A,W0
030C2:  ADD     W0,W5,W5
030C4:  MOV     W5,W0
030C6:  ADD     89A,W0
030C8:  MOV     W0,89C
....................     
....................    if(end<md_home_pos) 
030CA:  MOV     89C,W0
030CC:  MOV     810,W4
030CE:  CP      W4,W0
030D0:  BRA     LEU,30F8
....................    { 
....................       end=data_get_home_pos()+50; 
030D2:  CALL    1D4C
030D6:  MOV     W0,W5
030D8:  MOV     #32,W4
030DA:  ADD     W5,W4,W0
030DC:  MOV     W0,89C
....................       fprintf(RS232, "\n\rInvalid entry: End position cannot be smaller than home position. End position is set to its default."); 
030DE:  MOV     #0,W1
030E0:  MOV     W1,W0
030E2:  CALL    76C
030E6:  INC     W1,W1
030E8:  MOV     W1,[W15++]
030EA:  BTSC.B  219.1
030EC:  BRA     30EA
030EE:  MOV     W0,21A
030F0:  MOV     [--W15],W1
030F2:  MOV     #66,W0
030F4:  CPSGT   W1,W0
030F6:  BRA     30E0
....................    } 
....................     
....................    fr_write(fr_end_pos,end); 
030F8:  PUSH    838
030FA:  POP     89E
030FC:  PUSH    89C
030FE:  POP     8A0
03100:  CALL    2370
....................    md_end_pos=end; 
03104:  PUSH    89C
03106:  POP     812
.................... } 
03108:  MOV     [--W15],W6
0310A:  MOV     [--W15],W5
0310C:  RETURN  
.................... // Sets positioning velocity 
.................... void data_set_conv_const() 
.................... { 
0310E:  MOV     W5,[W15++]
03110:  MOV     W6,[W15++]
....................    md_conv_const = 12500; 
03112:  MOV     #30D4,W4
03114:  MOV     W4,80C
....................    md_cc_step = 0; 
03116:  CLR     82E
....................    md_cc_count = 0; 
03118:  CLR     830
....................     
....................    move_pos(md_min_distance); 
0311A:  PUSH    818
0311C:  POP     894
0311E:  CALL    2AD4
....................  
....................    unsigned int cc_first_count = qei_get_count(); 
03122:  CALL    1F8A
03126:  MOV     W0,890
....................     
....................    reg_md_cc_sample =1; 
03128:  BSET.B  84C.4
....................    move_pos(md_move_range); 
0312A:  PUSH    80E
0312C:  POP     894
0312E:  CALL    2AD4
....................     
....................    unsigned int conv_const = ((float)(cc_first_count - md_cc_count)/(float)md_cc_step)*10000; 
03132:  MOV     890,W4
03134:  MOV     830,W3
03136:  SUB     W4,W3,W0
03138:  CALL    23AA
*
03166:  MOV     W0,892
....................  
....................    fprintf(RS232, "Count: %u counts\n\r", cc_first_count-md_cc_count); 
03168:  MOV     890,W4
0316A:  MOV     830,W3
0316C:  SUB     W4,W3,W5
0316E:  MOV     #0,W1
03170:  MOV     W1,W0
03172:  CALL    7CE
03176:  INC     W1,W1
03178:  MOV     W1,[W15++]
0317A:  BTSC.B  219.1
0317C:  BRA     317A
0317E:  MOV     W0,21A
03180:  MOV     [--W15],W1
03182:  MOV     #6,W0
03184:  CPSGT   W1,W0
03186:  BRA     3170
03188:  MOV     W5,W0
0318A:  MOV     #0,W4
0318C:  CALL    1572
03190:  MOV     #9,W1
03192:  MOV     W1,W0
03194:  CALL    7CE
03198:  INC     W1,W1
0319A:  MOV     W1,[W15++]
0319C:  BTSC.B  219.1
0319E:  BRA     319C
031A0:  MOV     W0,21A
031A2:  MOV     [--W15],W1
031A4:  MOV     #11,W0
031A6:  CPSGT   W1,W0
031A8:  BRA     3192
....................    fprintf(RS232, "Step: %u steps\n\r", md_cc_step); 
031AA:  MOV     #0,W1
031AC:  MOV     W1,W0
031AE:  CALL    7EE
031B2:  INC     W1,W1
031B4:  MOV     W1,[W15++]
031B6:  BTSC.B  219.1
031B8:  BRA     31B6
031BA:  MOV     W0,21A
031BC:  MOV     [--W15],W1
031BE:  MOV     #5,W0
031C0:  CPSGT   W1,W0
031C2:  BRA     31AC
031C4:  MOV     82E,W0
031C6:  MOV     #0,W4
031C8:  CALL    1572
031CC:  MOV     #8,W1
031CE:  MOV     W1,W0
031D0:  CALL    7EE
031D4:  INC     W1,W1
031D6:  MOV     W1,[W15++]
031D8:  BTSC.B  219.1
031DA:  BRA     31D8
031DC:  MOV     W0,21A
031DE:  MOV     [--W15],W1
031E0:  MOV     #F,W0
031E2:  CPSGT   W1,W0
031E4:  BRA     31CE
....................    fprintf(RS232, "Conversion Constant: %u counts\n\r", conv_const); 
031E6:  MOV     #0,W1
031E8:  MOV     W1,W0
031EA:  CALL    80C
031EE:  INC     W1,W1
031F0:  MOV     W1,[W15++]
031F2:  BTSC.B  219.1
031F4:  BRA     31F2
031F6:  MOV     W0,21A
031F8:  MOV     [--W15],W1
031FA:  MOV     #14,W0
031FC:  CPSGT   W1,W0
031FE:  BRA     31E8
03200:  MOV     892,W0
03202:  MOV     #0,W4
03204:  CALL    1572
03208:  MOV     #17,W1
0320A:  MOV     W1,W0
0320C:  CALL    80C
03210:  INC     W1,W1
03212:  MOV     W1,[W15++]
03214:  BTSC.B  219.1
03216:  BRA     3214
03218:  MOV     W0,21A
0321A:  MOV     [--W15],W1
0321C:  MOV     #1F,W0
0321E:  CPSGT   W1,W0
03220:  BRA     320A
....................    
....................    fr_write(fr_conv_const,conv_const); 
03222:  PUSH    83A
03224:  POP     89E
03226:  PUSH    892
03228:  POP     8A0
0322A:  CALL    2370
....................    md_conv_const = conv_const; 
0322E:  PUSH    892
03230:  POP     80C
.................... } 
03232:  MOV     [--W15],W6
03234:  MOV     [--W15],W5
03236:  RETURN  
.................... // Sets backlash 
.................... void data_set_backlash() 
.................... { 
03238:  MOV     W5,[W15++]
0323A:  MOV     W6,[W15++]
0323C:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[2]; 
....................    for(i=0; i<2; i++) 
0323E:  CLR.B   890
03240:  MOV     890,W4
03242:  CP.B    W4L,#2
03244:  BRA     C,327A
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03246:  MOV.B   890,W0L
03248:  CLR.B   1
0324A:  SL      W0,#1,W0
0324C:  MOV     #892,W4
0324E:  ADD     W0,W4,W5
03250:  BTSS.B  218.0
03252:  BRA     3250
03254:  MOV     21C,W0
03256:  SUB.B   #30,W0L
03258:  CLR.B   1
0325A:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
0325C:  MOV.B   890,W0L
0325E:  CLR.B   1
03260:  SL      W0,#1,W0
03262:  MOV     #892,W4
03264:  ADD     W0,W4,W0
03266:  MOV     [W0],W5
03268:  ADD     #30,W5
0326A:  MOV.B   W5L,W0L
0326C:  BTSC.B  219.1
0326E:  BRA     326C
03270:  MOV.B   W0L,21A
03272:  CLR.B   21B
....................    } 
03274:  INC.B   0890
03276:  GOTO    3240
....................    unsigned int backlash = 10*input[0]+1*input[1]; 
0327A:  MOV     892,W4
0327C:  MUL.UU  W4,#A,W0
0327E:  MOV     W0,W5
03280:  MOV     W5,W0
03282:  ADD     894,W0
03284:  MOV     W0,896
....................     
....................    fr_write(fr_backlash,backlash); 
03286:  PUSH    83C
03288:  POP     89E
0328A:  PUSH    896
0328C:  POP     8A0
0328E:  CALL    2370
....................    md_backlash = backlash; 
03292:  PUSH    896
03294:  POP     82C
.................... } 
03296:  MOV     [--W15],W6
03298:  MOV     [--W15],W5
0329A:  RETURN  
.................... // Sets communication type 
.................... void data_set_comm_type() 
.................... { 
0329C:  MOV     W5,[W15++]
0329E:  BTSS.B  218.0
032A0:  BRA     329E
032A2:  MOV     21C,W0
032A4:  MOV     #30,W4
032A6:  SUB.B   W0L,W4L,W0L
032A8:  MOV.B   W0L,890
....................    unsigned int8 input=(unsigned)(fgetc(RS232)-48); 
....................    fputc(input+48,RS232); 
032AA:  MOV     #30,W4
032AC:  MOV     890,W3
032AE:  ADD.B   W3L,W4L,W5L
032B0:  MOV.B   W5L,W0L
032B2:  BTSC.B  219.1
032B4:  BRA     32B2
032B6:  MOV.B   W0L,21A
032B8:  CLR.B   21B
....................    switch (input) 
....................    { 
032BA:  MOV.B   890,W0L
032BC:  CLR.B   1
032BE:  XOR     #1,W0
032C0:  BRA     Z,32C8
032C2:  XOR     #1,W0
032C4:  BRA     Z,32E0
032C6:  BRA     32E0
....................       case 1   :  output_low(PP_ACK); 
032C8:  BCLR.B  2D2.4
032CA:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
032CC:  BCLR.B  2D2.5
032CE:  BCLR.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 1); 
032D0:  MOV.B   #1,W0L
032D2:  MOV.B   W0L,8AE
032D4:  PUSH    83E
032D6:  POP     8AC
032D8:  CALL    2264
....................                   break; 
032DC:  GOTO    32F6
....................       case 0   :     
....................       default  :  output_high(PP_ACK); 
032E0:  BCLR.B  2D2.4
032E2:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
032E4:  BCLR.B  2D2.5
032E6:  BSET.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 0); 
032E8:  CLR.B   8AE
032EA:  PUSH    83E
032EC:  POP     8AC
032EE:  CALL    2264
....................                   break; 
032F2:  GOTO    32F6
....................    } 
.................... } 
032F6:  MOV     [--W15],W5
032F8:  RETURN  
.................... // Sets last position 
.................... void data_set_last_pos(unsigned int16 position) 
.................... { 
....................    fr_write(fr_last_pos, position); 
*
0239C:  PUSH    840
0239E:  POP     89E
023A0:  PUSH    89A
023A2:  POP     8A0
023A4:  CALL    2370
.................... } 
023A8:  RETURN  
.................... // Sets position to given index 
.................... void data_set_pos(unsigned int8 index, unsigned int16 position) 
.................... { 
*
037AE:  MOV     W5,[W15++]
....................    fr_write(fr_pos_table+index*2, position); 
037B0:  MOV.B   892,W0L
037B2:  SL      W0,#1,W0
037B4:  ZE      W0,W0
037B6:  CLR.B   1
037B8:  MOV     842,W4
037BA:  ADD     W0,W4,W5
037BC:  MOV     W5,89E
037BE:  PUSH    894
037C0:  POP     8A0
037C2:  CALL    2370
.................... } 
037C6:  MOV     [--W15],W5
037C8:  RETURN  
....................  
.................... // Initializes the quadrature encoder interface module by using default values 
.................... void qei_init() 
.................... { 
....................    // Disable QEI module  
....................    QEI_QEICON_QEIM0=0; 
*
01628:  BCLR.B  123.0
....................    QEI_QEICON_QEIM1=0; 
0162A:  BCLR.B  123.1
....................    QEI_QEICON_QEIM2=0; 
0162C:  BCLR.B  123.2
....................    // Clear any count errors 
....................    QEI_QEICON_CNTERR=0; 
0162E:  BCLR.B  123.7
....................    // Continue module operation during sleep 
....................    QEI_QEICON_QEISIDL=0; 
01630:  BCLR.B  123.5
....................    // QEA and QEB not swapped 
....................    QEI_QEICON_SWPAB=0; 
01632:  BCLR.B  122.7
....................    // Normal I/O pin operation 
....................    QEI_QEICON_PCDOUT=0; 
01634:  BCLR.B  122.6
....................    // Timer gated time accumulation disabled 
....................    QEI_QEICON_TQGATE=0; 
01636:  BCLR.B  122.5
....................    // 1:1 timer input clock prescale 
....................    QEI_QEICON_TQCKPS0=0; 
01638:  BCLR.B  122.3
....................    QEI_QEICON_TQCKPS1=0; 
0163A:  BCLR.B  122.4
....................    // Index pulse does not reset the position counter 
....................    QEI_QEICON_POSRES = 0; 
0163C:  BCLR.B  122.2
....................    // Internal clock as timer clock source 
....................    QEI_QEICON_TQCS = 0; 
0163E:  BCLR.B  122.1
....................    // QEI_QEICON_UPDN defines timer counter (QEI_POSCNT) direction 
....................    QEI_QEICON_UDSRC = 0; 
01640:  BCLR.B  122.0
....................     
....................    // Count error interrupts enabled 
....................    QEI_DFLTCON_CEID = 0;  
01642:  BCLR.B  125.0
....................    // Digital filter outputs enabled 
....................    QEI_DFLTCON_QEOUT = 1;  
01644:  BSET.B  124.7
....................    // 1:256 clock divide for digital filter 
....................    QEI_DFLTCON_QECK2 = 1; 
01646:  BSET.B  124.6
....................    QEI_DFLTCON_QECK1 = 1; 
01648:  BSET.B  124.5
....................    QEI_DFLTCON_QECK0 = 1; 
0164A:  BSET.B  124.4
....................     
....................    // Reset position counter 
....................    QEI_POSCNT = 0x0000; 
0164C:  CLR     126
....................     
....................    // Set maximum count 
....................    QEI_MAXCNT = 0xFFFF; 
0164E:  SETM    128
....................     
....................    // QEI module enabled in x4 mode with position counter reset by QEI_MAXCNT match 
....................    QEI_QEICON_QEIM2 = 1; 
01650:  BSET.B  123.2
....................    QEI_QEICON_QEIM1 = 1; 
01652:  BSET.B  123.1
....................    QEI_QEICON_QEIM0 = 1; 
01654:  BSET.B  123.0
....................     
....................    if(debug_mode_qei) 
01656:  BTSS.B  800.5
01658:  BRA     1674
....................       fprintf(RS232,"Quadrature Encoder Initialized\n\n\r"); 
0165A:  MOV     #0,W1
0165C:  MOV     W1,W0
0165E:  CALL    83A
01662:  INC     W1,W1
01664:  MOV     W1,[W15++]
01666:  BTSC.B  219.1
01668:  BRA     1666
0166A:  MOV     W0,21A
0166C:  MOV     [--W15],W1
0166E:  MOV     #20,W0
01670:  CPSGT   W1,W0
01672:  BRA     165C
.................... } 
01674:  RETURN  
.................... // Sets the position counter to given value 
.................... void qei_set_count(unsigned int16 value) 
.................... {  
....................    QEI_POSCNT = value; 
*
01F46:  PUSH    8A8
01F48:  POP     126
....................     
....................    if(debug_mode_qei) 
01F4A:  BTSS.B  800.5
01F4C:  BRA     1F88
....................       fprintf(RS232,"Quadrature Encoder Count Set: %u\n\n\r", value); 
01F4E:  MOV     #0,W1
01F50:  MOV     W1,W0
01F52:  CALL    868
01F56:  INC     W1,W1
01F58:  MOV     W1,[W15++]
01F5A:  BTSC.B  219.1
01F5C:  BRA     1F5A
01F5E:  MOV     W0,21A
01F60:  MOV     [--W15],W1
01F62:  MOV     #1D,W0
01F64:  CPSGT   W1,W0
01F66:  BRA     1F50
01F68:  MOV     8A8,W0
01F6A:  MOV     #0,W4
01F6C:  CALL    1572
01F70:  BTSC.B  219.1
01F72:  BRA     1F70
01F74:  MOV     #A,W4
01F76:  MOV     W4,21A
01F78:  BTSC.B  219.1
01F7A:  BRA     1F78
01F7C:  MOV     #A,W4
01F7E:  MOV     W4,21A
01F80:  BTSC.B  219.1
01F82:  BRA     1F80
01F84:  MOV     #D,W4
01F86:  MOV     W4,21A
.................... } 
01F88:  RETURN  
.................... // Sets the maximum count to given value 
.................... void qei_set_max_count(unsigned int16 value) 
.................... {  
....................    QEI_MAXCNT = value; 
*
01E3C:  PUSH    856
01E3E:  POP     128
....................     
....................    if(debug_mode_qei) 
01E40:  BTSS.B  800.5
01E42:  BRA     1E7E
....................       fprintf(RS232,"Quadrature Encoder Maximum Count Set: %u\n\n\r", value); 
01E44:  MOV     #0,W1
01E46:  MOV     W1,W0
01E48:  CALL    898
01E4C:  INC     W1,W1
01E4E:  MOV     W1,[W15++]
01E50:  BTSC.B  219.1
01E52:  BRA     1E50
01E54:  MOV     W0,21A
01E56:  MOV     [--W15],W1
01E58:  MOV     #25,W0
01E5A:  CPSGT   W1,W0
01E5C:  BRA     1E46
01E5E:  MOV     856,W0
01E60:  MOV     #0,W4
01E62:  CALL    1572
01E66:  BTSC.B  219.1
01E68:  BRA     1E66
01E6A:  MOV     #A,W4
01E6C:  MOV     W4,21A
01E6E:  BTSC.B  219.1
01E70:  BRA     1E6E
01E72:  MOV     #A,W4
01E74:  MOV     W4,21A
01E76:  BTSC.B  219.1
01E78:  BRA     1E76
01E7A:  MOV     #D,W4
01E7C:  MOV     W4,21A
.................... } 
01E7E:  RETURN  
.................... // Returns the value of the position counter 
.................... unsigned int16 qei_get_count(){ return QEI_POSCNT;} 
*
01F8A:  PUSH    126
01F8C:  POP     0
01F8E:  RETURN  
....................  
.................... // Sets the operating mode of the PWM module 
.................... void pwm_select_mode(unsigned int mode) 
.................... { 
....................    if(mode == FREE) 
*
01676:  CP0     8A8
01678:  BRA     NZ,1682
....................    { 
....................       // Select free running PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
0167A:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 0; 
0167C:  BCLR.B  1C0.0
....................    } 
....................    else if(mode == SINGLE) 
0167E:  GOTO    168C
01682:  MOV     8A8,W4
01684:  CP      W4,#1
01686:  BRA     NZ,168C
....................    { 
....................       // Select single event PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
01688:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 1; 
0168A:  BSET.B  1C0.0
....................    } 
.................... } 
0168C:  RETURN  
.................... // Initializes the PWM module by using default values 
.................... void pwm_init() 
.................... { 
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN       = 0; 
0168E:  BCLR.B  1C1.7
....................     
....................    // Select 1:1 output postscale 
....................    PWM_PTCON_PTOPS3     = 0; 
01690:  BCLR.B  1C0.7
....................    PWM_PTCON_PTOPS2     = 0; 
01692:  BCLR.B  1C0.6
....................    PWM_PTCON_PTOPS1     = 0; 
01694:  BCLR.B  1C0.5
....................    PWM_PTCON_PTOPS0     = 0; 
01696:  BCLR.B  1C0.4
....................    // Select 1:1 input prescale 
....................    PWM_PTCON_PTCKPS1    = 0; 
01698:  BCLR.B  1C0.3
....................    PWM_PTCON_PTCKPS0    = 0; 
0169A:  BCLR.B  1C0.2
....................     
....................    // Set the operating mode of PWM module 
....................    pwm_select_mode(FREE); 
0169C:  CLR     8A8
0169E:  CALL    1676
....................  
....................    // Select independent output mode for PWM1 I/O pair 
....................    PWM_PWMCON1_PMOD1    = 1; 
016A2:  BSET.B  1C9.0
....................    // Set PWM1H pin as PWM output 
....................    PWM_PWMCON1_PEN1H    = 1; 
016A4:  BSET.B  1C8.4
....................     
....................    // Synchronize PDC registers to the PWM time base 
....................    PWM_PWMCON2_IUE      = 0; 
016A6:  BCLR.B  1CA.2
....................    // Enable PWM interrupt 
....................    PWM_IEC2_PWMIE       = 0; 
016A8:  BCLR.B  90.7
....................     
....................    // Set time base period value 
....................    PWM_PTPER            = 0; 
016AA:  CLR     1C4
....................    // Set time base duty cycle 
....................    PWM_PDC1             = 0; 
016AC:  CLR     1D6
....................  
....................    if(debug_mode_md) 
016AE:  BTSS.B  800.3
016B0:  BRA     16CC
....................       fprintf(RS232,"PWM Module Initialized\n\n\r"); 
016B2:  MOV     #0,W1
016B4:  MOV     W1,W0
016B6:  CALL    8D2
016BA:  INC     W1,W1
016BC:  MOV     W1,[W15++]
016BE:  BTSC.B  219.1
016C0:  BRA     16BE
016C2:  MOV     W0,21A
016C4:  MOV     [--W15],W1
016C6:  MOV     #18,W0
016C8:  CPSGT   W1,W0
016CA:  BRA     16B4
.................... } 
016CC:  RETURN  
.................... // Set PWM period time (us) 
.................... void pwm_set_period(unsigned int16 period) 
.................... { 
*
01EE2:  MOV     W5,[W15++]
....................    // PWM period 
....................    unsigned int16 pwm_period;  
....................     
....................    // Set the PWM period 
....................    if(period==0) 
01EE4:  CP0     8AC
01EE6:  BRA     NZ,1EEE
....................       pwm_period = 0; 
01EE8:  CLR     8AE
....................    else 
01EEA:  GOTO    1EF8
....................       pwm_period = 30 * period - 1; 
01EEE:  MOV     8AC,W4
01EF0:  MUL.UU  W4,#1E,W0
01EF2:  MOV     W0,W5
01EF4:  SUB     W5,#1,W0
01EF6:  MOV     W0,8AE
....................     
....................    // Updates from duty cycle and period buffer registers are disabled 
....................    PWM_PWMCON2_UDIS = 1; 
01EF8:  BSET.B  1CA.0
....................    // Set time base period value 
....................    PWM_PTPER        = pwm_period; 
01EFA:  PUSH    8AE
01EFC:  POP     1C4
....................    // Set time base duty cycle if PWM module is enabled (duty cycle > 0%) 
....................    PWM_PDC1         = pwm_period; 
01EFE:  PUSH    8AE
01F00:  POP     1D6
....................    // Updates from duty cycle and period buffer registers are enabled 
....................    PWM_PWMCON2_UDIS = 0; 
01F02:  BCLR.B  1CA.0
.................... } 
01F04:  MOV     [--W15],W5
01F06:  RETURN  
.................... // Disable PWM module 
.................... void pwm_disable() 
.................... { 
....................    // Set duty cycle to zero 
....................    PWM_PDC1=0; 
*
01F18:  CLR     1D6
....................    // Wait for the last signal 
....................    delay_us(PWM_PTPER + 1 / 30); 
01F1A:  MOV     1C4,W0
01F1C:  CALL    1F08
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN = 0; 
01F20:  BCLR.B  1C1.7
....................    // Set duty cycle to its initial value 
....................    PWM_PDC1=PWM_PTPER; 
01F22:  PUSH    1C4
01F24:  POP     1D6
....................     
....................    if(debug_mode_pwm) 
01F26:  BTSS.B  800.4
01F28:  BRA     1F44
....................       fprintf(RS232,"PWM Disabled\n\r"); 
01F2A:  MOV     #0,W1
01F2C:  MOV     W1,W0
01F2E:  CALL    8F8
01F32:  INC     W1,W1
01F34:  MOV     W1,[W15++]
01F36:  BTSC.B  219.1
01F38:  BRA     1F36
01F3A:  MOV     W0,21A
01F3C:  MOV     [--W15],W1
01F3E:  MOV     #D,W0
01F40:  CPSGT   W1,W0
01F42:  BRA     1F2C
.................... } 
01F44:  RETURN  
.................... // Enable PWM module 
.................... void pwm_enable() 
.................... { 
*
01F90:  MOV     W5,[W15++]
....................    // Disable RS232 receive byte interrupt 
....................    disable_interrupts(INT_RDA2); 
01F92:  BCLR.B  8F.0
....................     
....................    // Enable PWM module 
....................    PWM_PTCON_PTEN = 1; 
01F94:  BSET.B  1C1.7
....................    // Start pwm cycle 
....................    int1 reg_md_running = 1; 
....................    unsigned int md_step_count = 0; 
01F96:  BSET.B  8A2.0
01F98:  CLR     8A4
....................     
....................    while(reg_md_running) 
....................    { 
01F9A:  BTSS.B  8A2.0
01F9C:  BRA     21CA
....................       if(PWM_IFS2_PWMIF) 
01F9E:  BTSS.B  88.7
01FA0:  BRA     21C6
....................       { 
....................          // Clear the flag register 
....................          PWM_IFS2_PWMIF = 0; 
01FA2:  BCLR.B  88.7
....................           
....................          md_step_count++; 
01FA4:  INC     08A4
....................        
....................          switch(md_run_state)  
....................          { 
01FA6:  MOV.B   801,W0L
01FA8:  CLR.B   1
01FAA:  XOR     #0,W0
01FAC:  BRA     Z,1FC0
01FAE:  XOR     #1,W0
01FB0:  BRA     Z,2068
01FB2:  XOR     #2,W0
01FB4:  BRA     Z,20D2
01FB6:  XOR     #1,W0
01FB8:  BRA     Z,20F2
01FBA:  XOR     #6,W0
01FBC:  BRA     Z,213C
01FBE:  BRA     21C6
....................             case HOME: 
....................                if(reg_md_home_return == 0) 
01FC0:  BTSC.B  84C.2
01FC2:  BRA     2042
....................                { 
....................                   if(reg_md_home == 0) 
01FC4:  BTSC.B  84C.1
01FC6:  BRA     2016
....................                   { 
....................                      if(input(MD_SW)) 
01FC8:  BSET.B  2D3.3
01FCA:  BTSS.B  2D5.3
01FCC:  BRA     1FFE
....................                      { 
....................                         if(md_step_count < md_max_acc_lim) 
01FCE:  MOV     8A4,W0
01FD0:  MOV     84E,W4
01FD2:  CP      W4,W0
01FD4:  BRA     LEU,1FEE
....................                         { 
....................                            md_decel_count = md_step_count; 
01FD6:  PUSH    8A4
01FD8:  POP     826
....................                            pwm_set_period(delays[md_step_count]); 
01FDA:  MOV     8A4,W0
01FDC:  SL      W0,#1,W0
01FDE:  CALL    100
01FE2:  MOV     W0,W5
01FE4:  MOV     W5,8AC
01FE6:  CALL    1EE2
....................                         } 
....................                         else 
01FEA:  GOTO    1FFA
....................                         { 
....................                            md_decel_count = md_max_acc_lim; 
01FEE:  PUSH    84E
01FF0:  POP     826
....................                            pwm_set_period(md_min_delay); 
01FF2:  PUSH    820
01FF4:  POP     8AC
01FF6:  CALL    1EE2
....................                         } 
....................                      } 
....................                      else 
01FFA:  GOTO    2012
....................                      { 
....................                         reg_md_home = 1; 
01FFE:  BSET.B  84C.1
....................                         md_decel_count--; 
02000:  DEC     0826
....................                         pwm_set_period(delays[md_decel_count]); 
02002:  MOV     826,W0
02004:  SL      W0,#1,W0
02006:  CALL    100
0200A:  MOV     W0,W5
0200C:  MOV     W5,8AC
0200E:  CALL    1EE2
....................                      } 
....................                   } 
....................                   else 
02012:  GOTO    203E
....................                   { 
....................                      if(md_decel_count == 0) 
02016:  CP0     826
02018:  BRA     NZ,202C
....................                      {   
....................                         reg_md_home_return = 1; 
0201A:  BSET.B  84C.2
....................                         output_low(MD_DIR); 
0201C:  BCLR.B  2D8.4
0201E:  BCLR.B  2DC.4
....................                         pwm_set_period(1000); 
02020:  MOV     #3E8,W4
02022:  MOV     W4,8AC
02024:  CALL    1EE2
....................                      } 
....................                      else 
02028:  GOTO    203E
....................                      { 
....................                         md_decel_count--; 
0202C:  DEC     0826
....................                         pwm_set_period(delays[md_decel_count]); 
0202E:  MOV     826,W0
02030:  SL      W0,#1,W0
02032:  CALL    100
02036:  MOV     W0,W5
02038:  MOV     W5,8AC
0203A:  CALL    1EE2
....................                      } 
....................                   } 
....................                } 
....................                else 
0203E:  GOTO    2064
....................                { 
....................                   if(input(MD_SW)) 
02042:  BSET.B  2D3.3
02044:  BTSS.B  2D5.3
02046:  BRA     2064
....................                   { 
....................                      pwm_disable(); 
02048:  CALL    1F18
....................                      reg_md_running = 0; 
0204C:  BCLR.B  8A2.0
....................                       
....................                      delay_ms(50); 
0204E:  MOV     #32,W0
02050:  CALL    155E
....................                      qei_set_count(md_home_offset); 
02054:  PUSH    816
02056:  POP     8A8
02058:  CALL    1F46
....................                      md_mt_set(mt_percent_rest); 
0205C:  PUSH    80A
0205E:  POP     8A8
02060:  CALL    1B88
....................                   } 
....................                } 
....................                break; 
02064:  GOTO    21C6
....................                 
....................             case ACCEL: 
....................                // Check if we should start deceleration. 
....................                if(md_step_count >= md_accel_lim)  
02068:  MOV     824,W0
0206A:  MOV     8A4,W4
0206C:  CP      W4,W0
0206E:  BRA     NC,20BE
....................                { 
....................                   if(md_step_count == md_decel_lim) 
02070:  MOV     8A4,W0
02072:  CP      822
02074:  BRA     NZ,2090
....................                   { 
....................                      md_decel_count--; 
02076:  DEC     0826
....................                      pwm_set_period(delays[md_decel_count]); 
02078:  MOV     826,W0
0207A:  SL      W0,#1,W0
0207C:  CALL    100
02080:  MOV     W0,W5
02082:  MOV     W5,8AC
02084:  CALL    1EE2
....................                      md_run_state = DECEL; 
02088:  MOV.B   #2,W0L
0208A:  MOV.B   W0L,801
....................                   } 
....................                   else if(md_decel_lim - md_step_count < 2) 
0208C:  GOTO    20BA
02090:  MOV     822,W4
02092:  MOV     8A4,W3
02094:  SUB     W4,W3,W5
02096:  CP      W5,#2
02098:  BRA     C,20AE
....................                   { 
....................                      pwm_set_period(delays[md_step_count]); 
0209A:  MOV     8A4,W0
0209C:  SL      W0,#1,W0
0209E:  CALL    100
020A2:  MOV     W0,W5
020A4:  MOV     W5,8AC
020A6:  CALL    1EE2
....................                   } 
....................                   else 
020AA:  GOTO    20BA
....................                   { 
....................                      pwm_set_period(md_min_delay); 
020AE:  PUSH    820
020B0:  POP     8AC
020B2:  CALL    1EE2
....................                      md_run_state = RUN; 
020B6:  MOV.B   #3,W0L
020B8:  MOV.B   W0L,801
....................                   } 
....................                } 
....................                else 
020BA:  GOTO    20CE
....................                { 
....................                   pwm_set_period(delays[md_step_count]); 
020BE:  MOV     8A4,W0
020C0:  SL      W0,#1,W0
020C2:  CALL    100
020C6:  MOV     W0,W5
020C8:  MOV     W5,8AC
020CA:  CALL    1EE2
....................                } 
....................                break; 
020CE:  GOTO    21C6
....................        
....................             case RUN: 
....................                // Check if we should start decelration. 
....................                if(md_step_count == md_decel_lim)  
020D2:  MOV     8A4,W0
020D4:  CP      822
020D6:  BRA     NZ,20EE
....................                { 
....................                   md_decel_count--; 
020D8:  DEC     0826
....................                   pwm_set_period(delays[md_decel_count]); 
020DA:  MOV     826,W0
020DC:  SL      W0,#1,W0
020DE:  CALL    100
020E2:  MOV     W0,W5
020E4:  MOV     W5,8AC
020E6:  CALL    1EE2
....................                   md_run_state = DECEL; 
020EA:  MOV.B   #2,W0L
020EC:  MOV.B   W0L,801
....................                } 
....................                break; 
020EE:  GOTO    21C6
....................        
....................             case DECEL: 
....................                // Check if we at last step 
....................                if(md_decel_count == 0) 
020F2:  CP0     826
020F4:  BRA     NZ,2126
....................                { 
....................                   pwm_disable(); 
020F6:  CALL    1F18
....................                   md_pos_iter = 0; 
020FA:  CLR     828
....................                   md_run_state = POS; 
020FC:  MOV.B   #4,W0L
020FE:  MOV.B   W0L,801
....................                    
....................                   delay_ms(50); 
02100:  MOV     #32,W0
02102:  CALL    155E
....................  
....................                   md_error = md_target_count - qei_get_count(); 
02106:  CALL    1F8A
0210A:  MOV     81A,W4
0210C:  SUB     W4,W0,W0
0210E:  MOV     W0,82A
....................                    
....................                   if(md_error > 1) 
02110:  MOV     82A,W4
02112:  CP      W4,#1
02114:  BRA     LE,211E
....................                      output_low(MD_DIR); 
02116:  BCLR.B  2D8.4
02118:  BCLR.B  2DC.4
....................                   else 
0211A:  GOTO    2122
....................                      output_high(MD_DIR); 
0211E:  BCLR.B  2D8.4
02120:  BSET.B  2DC.4
....................                } 
....................                else 
02122:  GOTO    2138
....................                { 
....................                   md_decel_count--; 
02126:  DEC     0826
....................                   pwm_set_period(delays[md_decel_count]); 
02128:  MOV     826,W0
0212A:  SL      W0,#1,W0
0212C:  CALL    100
02130:  MOV     W0,W5
02132:  MOV     W5,8AC
02134:  CALL    1EE2
....................                } 
....................                break; 
02138:  GOTO    21C6
....................                 
....................             case POS: 
....................                md_pos_iter++; 
0213C:  INC     0828
....................                 
....................                delay_ms(50); 
0213E:  MOV     #32,W0
02140:  CALL    155E
....................                 
....................                if(reg_md_cc_sample) 
02144:  BTSS.B  84C.4
02146:  BRA     215A
....................                { 
....................                   reg_md_cc_sample = 0; 
02148:  BCLR.B  84C.4
....................                   delay_ms(50); 
0214A:  MOV     #32,W0
0214C:  CALL    155E
....................                   md_cc_step = md_step_count; 
02150:  PUSH    8A4
02152:  POP     82E
....................                   md_cc_count = qei_get_count(); 
02154:  CALL    1F8A
02158:  MOV     W0,830
....................                } 
....................  
....................                int difference; 
....................                 
....................                if(md_error < 1) 
0215A:  MOV     82A,W4
0215C:  CP      W4,#1
0215E:  BRA     GE,2170
....................                   difference = qei_get_count() - md_target_count; 
02160:  CALL    1F8A
02164:  MOV     W0,W5
02166:  MOV     81A,W4
02168:  SUB     W5,W4,W0
0216A:  MOV     W0,8A6
....................                else 
0216C:  GOTO    217A
....................                   difference = md_target_count - qei_get_count(); 
02170:  CALL    1F8A
02174:  MOV     81A,W4
02176:  SUB     W4,W0,W0
02178:  MOV     W0,8A6
....................  
....................                if((difference < 1)||(md_pos_iter > 50)) 
0217A:  MOV     8A6,W4
0217C:  CP      W4,#1
0217E:  BRA     LT,2188
02180:  MOV     828,W4
02182:  MOV     #32,W3
02184:  CP      W3,W4
02186:  BRA     C,219A
....................                { 
....................                   pwm_disable(); 
02188:  CALL    1F18
....................                   reg_md_running = 0; 
0218C:  BCLR.B  8A2.0
....................                   md_mt_set(mt_percent_rest); 
0218E:  PUSH    80A
02190:  POP     8A8
02192:  CALL    1B88
....................                } 
....................                else 
02196:  GOTO    21C2
....................                { 
....................                   if(md_target_count > qei_get_count()) 
0219A:  CALL    1F8A
0219E:  MOV     81A,W4
021A0:  CP      W4,W0
021A2:  BRA     LEU,21AC
....................                      output_low(MD_DIR); 
021A4:  BCLR.B  2D8.4
021A6:  BCLR.B  2DC.4
....................                   else 
021A8:  GOTO    21B0
....................                      output_high(MD_DIR); 
021AC:  BCLR.B  2D8.4
021AE:  BSET.B  2DC.4
....................                          
....................                   pwm_set_period(1000); 
021B0:  MOV     #3E8,W4
021B2:  MOV     W4,8AC
021B4:  CALL    1EE2
....................                   pwm_select_mode(SINGLE); 
021B8:  MOV     #1,W4
021BA:  MOV     W4,8A8
021BC:  CALL    1676
....................                   // Enable PWM module 
....................                   PWM_PTCON_PTEN = 1; 
021C0:  BSET.B  1C1.7
....................                } 
....................                break; 
021C2:  GOTO    21C6
....................          } 
....................       } 
....................    } 
021C6:  GOTO    1F9A
....................  
....................    // Enable RS232 receive byte interrupt 
....................    clear_interrupt(INT_RDA2); 
....................    enable_interrupts(INT_RDA2); 
021CA:  BSET.B  8F.0
....................    reg_rs232_message = 0; 
021CC:  BCLR.B  84C.3
.................... } 
021CE:  MOV     [--W15],W5
021D0:  RETURN  
....................  
.................... // Move to given position (encoder count) 
.................... void move_to(unsigned int count) 
.................... { 
*
0280A:  MOV     W5,[W15++]
0280C:  MOV     W6,[W15++]
0280E:  CALL    1F8A
02812:  MOV     W0,89E
....................    // Calculate the number of steps 
....................    unsigned int displ;             
....................    // Calculate the current motor step by using current encoder count 
....................    unsigned int current_count = qei_get_count(); 
....................    // Calculate the target motor step by using given encoder step 
....................    md_target_count = count;  
02814:  PUSH    89A
02816:  POP     81A
....................     
....................    // Set direction 
....................    if(md_target_count > current_count) 
02818:  MOV     89E,W0
0281A:  MOV     81A,W4
0281C:  CP      W4,W0
0281E:  BRA     LEU,2830
....................    { 
....................       output_low(MD_DIR); 
02820:  BCLR.B  2D8.4
02822:  BCLR.B  2DC.4
....................       displ = md_target_count - current_count; 
02824:  MOV     81A,W4
02826:  MOV     89E,W3
02828:  SUB     W4,W3,W0
0282A:  MOV     W0,89C
....................    } 
....................    else 
0282C:  GOTO    283C
....................    { 
....................       output_high(MD_DIR); 
02830:  BCLR.B  2D8.4
02832:  BSET.B  2DC.4
....................       displ = current_count - md_target_count; 
02834:  MOV     89E,W4
02836:  MOV     81A,W3
02838:  SUB     W4,W3,W0
0283A:  MOV     W0,89C
....................    } 
....................     
....................    displ = (long)displ * 10000 / md_conv_const; 
0283C:  MOV     89C,W5
0283E:  MOV     #0,W6
02840:  MOV     W5,W0
02842:  MOV     W6,W1
02844:  MOV     #2710,W2
02846:  MOV     #0,W3
02848:  CALL    273E
0284C:  MOV     W0,W5
0284E:  MOV     W1,W6
02850:  BCLR.B  43.0
02852:  MOV     W5,W0
02854:  MOV     W6,W1
02856:  MOV     80C,W2
02858:  MOV     #0,W3
0285A:  CALL    2780
0285E:  MOV     W0,89C
....................     
....................    if(debug_mode_pwm) 
02860:  BTSS.B  800.4
02862:  BRA     2896
....................       fprintf(RS232,"Displacement: %u\n\r", displ); 
02864:  MOV     #0,W1
02866:  MOV     W1,W0
02868:  CALL    914
0286C:  INC     W1,W1
0286E:  MOV     W1,[W15++]
02870:  BTSC.B  219.1
02872:  BRA     2870
02874:  MOV     W0,21A
02876:  MOV     [--W15],W1
02878:  MOV     #D,W0
0287A:  CPSGT   W1,W0
0287C:  BRA     2866
0287E:  MOV     89C,W0
02880:  MOV     #0,W4
02882:  CALL    1572
02886:  BTSC.B  219.1
02888:  BRA     2886
0288A:  MOV     #A,W4
0288C:  MOV     W4,21A
0288E:  BTSC.B  219.1
02890:  BRA     288E
02892:  MOV     #D,W4
02894:  MOV     W4,21A
....................     
....................    // If displacement is zero than no need to move 
....................    if(displ == 0) 
02896:  CP0     89C
02898:  BRA     NZ,289C
....................       return; 
0289A:  BRA     29D4
....................        
....................    // Find out after how many steps we must start deceleration. 
....................    md_accel_lim = ((long)displ * md_decel) / (md_accel + md_decel); 
0289C:  MOV     89C,W5
0289E:  MOV     #0,W6
028A0:  MOV     W5,W0
028A2:  MOV     W6,W1
028A4:  MOV     81E,W2
028A6:  MOV     #0,W3
028A8:  CALL    273E
028AC:  MOV     W0,W5
028AE:  MOV     W1,W6
028B0:  MOV     81C,W0
028B2:  ADD     81E,W0
028B4:  BCLR.B  43.0
028B6:  MOV     W6,W1
028B8:  MOV     W0,W2
028BA:  MOV     #0,W3
028BC:  MOV     W5,W0
028BE:  CALL    2780
028C2:  MOV     W0,824
....................    // We must accelerate at least 1 step before we can start deceleration. 
....................    if(md_accel_lim == 0) 
028C4:  CP0     824
028C6:  BRA     NZ,28CC
....................       md_accel_lim = 1; 
028C8:  MOV     #1,W4
028CA:  MOV     W4,824
....................     
....................    // Use the limit we hit first to calc decel. 
....................    if(md_accel_lim >= md_max_acc_lim) 
028CC:  MOV     84E,W0
028CE:  MOV     824,W4
028D0:  CP      W4,W0
028D2:  BRA     NC,2908
....................    { 
....................       md_accel_lim = md_max_acc_lim; 
028D4:  PUSH    84E
028D6:  POP     824
....................        
....................       // Find step to start decleration. 
....................       md_decel_count = ((long)md_max_acc_lim * md_accel) / md_decel; 
028D8:  MOV     84E,W5
028DA:  MOV     #0,W6
028DC:  MOV     W5,W0
028DE:  MOV     W6,W1
028E0:  MOV     81C,W2
028E2:  MOV     #0,W3
028E4:  CALL    273E
028E8:  MOV     W0,W5
028EA:  MOV     W1,W6
028EC:  BCLR.B  43.0
028EE:  MOV     W5,W0
028F0:  MOV     W6,W1
028F2:  MOV     81E,W2
028F4:  MOV     #0,W3
028F6:  CALL    2780
028FA:  MOV     W0,826
....................       md_decel_lim = displ - md_decel_count;  
028FC:  MOV     89C,W4
028FE:  MOV     826,W3
02900:  SUB     W4,W3,W0
02902:  MOV     W0,822
....................    } 
....................    else 
02904:  GOTO    2914
....................    { 
....................       md_decel_lim = displ - md_accel_lim; 
02908:  MOV     89C,W4
0290A:  MOV     824,W3
0290C:  SUB     W4,W3,W0
0290E:  MOV     W0,822
....................       md_decel_count = md_accel_lim; 
02910:  PUSH    824
02912:  POP     826
....................    } 
....................     
....................    // We must decelerate at least 1 step to stop. 
....................    if(md_decel_lim == 0) 
02914:  CP0     822
02916:  BRA     NZ,291C
....................       md_decel_lim = 1; 
02918:  MOV     #1,W4
0291A:  MOV     W4,822
....................  
....................    if(debug_mode_pwm) 
0291C:  BTSS.B  800.4
0291E:  BRA     29B6
....................    { 
....................       fprintf(RS232,"Acceleration Limit: %u\n\r", md_accel_lim); 
02920:  MOV     #0,W1
02922:  MOV     W1,W0
02924:  CALL    934
02928:  INC     W1,W1
0292A:  MOV     W1,[W15++]
0292C:  BTSC.B  219.1
0292E:  BRA     292C
02930:  MOV     W0,21A
02932:  MOV     [--W15],W1
02934:  MOV     #13,W0
02936:  CPSGT   W1,W0
02938:  BRA     2922
0293A:  MOV     824,W0
0293C:  MOV     #0,W4
0293E:  CALL    1572
02942:  BTSC.B  219.1
02944:  BRA     2942
02946:  MOV     #A,W4
02948:  MOV     W4,21A
0294A:  BTSC.B  219.1
0294C:  BRA     294A
0294E:  MOV     #D,W4
02950:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Limit: %u\n\r", md_decel_lim); 
02952:  MOV     #0,W1
02954:  MOV     W1,W0
02956:  CALL    95A
0295A:  INC     W1,W1
0295C:  MOV     W1,[W15++]
0295E:  BTSC.B  219.1
02960:  BRA     295E
02962:  MOV     W0,21A
02964:  MOV     [--W15],W1
02966:  MOV     #13,W0
02968:  CPSGT   W1,W0
0296A:  BRA     2954
0296C:  MOV     822,W0
0296E:  MOV     #0,W4
02970:  CALL    1572
02974:  BTSC.B  219.1
02976:  BRA     2974
02978:  MOV     #A,W4
0297A:  MOV     W4,21A
0297C:  BTSC.B  219.1
0297E:  BRA     297C
02980:  MOV     #D,W4
02982:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Count: %u\n\r", md_decel_count); 
02984:  MOV     #0,W1
02986:  MOV     W1,W0
02988:  CALL    980
0298C:  INC     W1,W1
0298E:  MOV     W1,[W15++]
02990:  BTSC.B  219.1
02992:  BRA     2990
02994:  MOV     W0,21A
02996:  MOV     [--W15],W1
02998:  MOV     #13,W0
0299A:  CPSGT   W1,W0
0299C:  BRA     2986
0299E:  MOV     826,W0
029A0:  MOV     #0,W4
029A2:  CALL    1572
029A6:  BTSC.B  219.1
029A8:  BRA     29A6
029AA:  MOV     #A,W4
029AC:  MOV     W4,21A
029AE:  BTSC.B  219.1
029B0:  BRA     29AE
029B2:  MOV     #D,W4
029B4:  MOV     W4,21A
....................    } 
....................  
....................    md_run_state = ACCEL; 
029B6:  MOV.B   #1,W0L
029B8:  MOV.B   W0L,801
....................    md_mt_set(mt_percent_trip); 
029BA:  PUSH    808
029BC:  POP     8A8
029BE:  CALL    1B88
....................  
....................    pwm_set_period(delays[0]); 
029C2:  MOV     #7D0,W4
029C4:  MOV     W4,8AC
029C6:  CALL    1EE2
....................    pwm_select_mode(FREE); 
029CA:  CLR     8A8
029CC:  CALL    1676
....................    pwm_enable(); 
029D0:  CALL    1F90
.................... } 
029D4:  MOV     [--W15],W6
029D6:  MOV     [--W15],W5
029D8:  RETURN  
.................... // Move to given position (mm) 
.................... void move_pos(unsigned int16 position) 
.................... { 
*
02AD4:  MOV     W5,[W15++]
02AD6:  MOV     #C,W5
02AD8:  REPEAT  #4
02ADA:  MOV     [W5++],[W15++]
....................    if(position>md_move_range) 
02ADC:  MOV     80E,W0
02ADE:  MOV     894,W4
02AE0:  CP      W4,W0
02AE2:  BRA     LEU,2B0A
....................    { 
....................       position=md_move_range; 
02AE4:  PUSH    80E
02AE6:  POP     894
....................       if(debug_mode_md) 
02AE8:  BTSS.B  800.3
02AEA:  BRA     2B06
....................          fprintf(RS232, "Invalid entry: System cannot move to a position beyond the movement range. System will move to maximum possible distance."); 
02AEC:  MOV     #0,W1
02AEE:  MOV     W1,W0
02AF0:  CALL    9A6
02AF4:  INC     W1,W1
02AF6:  MOV     W1,[W15++]
02AF8:  BTSC.B  219.1
02AFA:  BRA     2AF8
02AFC:  MOV     W0,21A
02AFE:  MOV     [--W15],W1
02B00:  MOV     #78,W0
02B02:  CPSGT   W1,W0
02B04:  BRA     2AEE
....................    } 
....................    else if(position<md_min_distance) 
02B06:  GOTO    2B56
02B0A:  MOV     894,W0
02B0C:  MOV     818,W4
02B0E:  CP      W4,W0
02B10:  BRA     LEU,2B56
....................    { 
....................       position=md_min_distance; 
02B12:  PUSH    818
02B14:  POP     894
....................       if(debug_mode_md) 
02B16:  BTSS.B  800.3
02B18:  BRA     2B56
....................          fprintf(RS232, "Invalid entry: System cannot move to a position smaller than %u mm. System will move to minimum possible distance.", md_min_distance); 
02B1A:  MOV     #0,W1
02B1C:  MOV     W1,W0
02B1E:  CALL    A14
02B22:  INC     W1,W1
02B24:  MOV     W1,[W15++]
02B26:  BTSC.B  219.1
02B28:  BRA     2B26
02B2A:  MOV     W0,21A
02B2C:  MOV     [--W15],W1
02B2E:  MOV     #3C,W0
02B30:  CPSGT   W1,W0
02B32:  BRA     2B1C
02B34:  MOV     818,W0
02B36:  MOV     #0,W4
02B38:  CALL    1572
02B3C:  MOV     #3F,W1
02B3E:  MOV     W1,W0
02B40:  CALL    A14
02B44:  INC     W1,W1
02B46:  MOV     W1,[W15++]
02B48:  BTSC.B  219.1
02B4A:  BRA     2B48
02B4C:  MOV     W0,21A
02B4E:  MOV     [--W15],W1
02B50:  MOV     #71,W0
02B52:  CPSGT   W1,W0
02B54:  BRA     2B3E
....................    } 
....................     
....................    fprintf(RS232,"\n\rTarget Position: %u mm\n\r", position); 
02B56:  MOV     #0,W1
02B58:  MOV     W1,W0
02B5A:  CALL    A7E
02B5E:  INC     W1,W1
02B60:  MOV     W1,[W15++]
02B62:  BTSC.B  219.1
02B64:  BRA     2B62
02B66:  MOV     W0,21A
02B68:  MOV     [--W15],W1
02B6A:  MOV     #12,W0
02B6C:  CPSGT   W1,W0
02B6E:  BRA     2B58
02B70:  MOV     894,W0
02B72:  MOV     #0,W4
02B74:  CALL    1572
02B78:  MOV     #15,W1
02B7A:  MOV     W1,W0
02B7C:  CALL    A7E
02B80:  INC     W1,W1
02B82:  MOV     W1,[W15++]
02B84:  BTSC.B  219.1
02B86:  BRA     2B84
02B88:  MOV     W0,21A
02B8A:  MOV     [--W15],W1
02B8C:  MOV     #19,W0
02B8E:  CPSGT   W1,W0
02B90:  BRA     2B7A
....................  
....................    data_set_last_pos(position); 
02B92:  PUSH    894
02B94:  POP     89A
02B96:  CALL    239C
....................     
....................    unsigned int16 count = md_end_pos-((float)(position-md_min_distance)/2.0f)*((float)(md_end_pos-md_home_pos)/((float)(md_move_range-md_min_distance)/2.0f)); 
02B9A:  MOV     894,W4
02B9C:  MOV     818,W3
02B9E:  SUB     W4,W3,W0
02BA0:  CALL    23AA
*
02C10:  MOV     W0,896
....................     
....................    if(qei_get_count() < count) 
02C12:  CALL    1F8A
02C16:  MOV     W0,W5
02C18:  MOV     896,W4
02C1A:  CP      W4,W5
02C1C:  BRA     LEU,2C26
....................       count-=md_backlash; 
02C1E:  MOV     896,W4
02C20:  MOV     82C,W3
02C22:  SUB     W4,W3,W0
02C24:  MOV     W0,896
....................     
....................    move_to(count); 
02C26:  PUSH    896
02C28:  POP     89A
02C2A:  CALL    280A
....................     
....................    delay_ms(100); 
02C2E:  MOV     #64,W0
02C30:  CALL    155E
....................     
....................    if(debug_mode_md) 
02C34:  BTSS.B  800.3
02C36:  BRA     2D38
....................    { 
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02C38:  MOV     #0,W1
02C3A:  MOV     W1,W0
02C3C:  CALL    AA6
02C40:  INC     W1,W1
02C42:  MOV     W1,[W15++]
02C44:  BTSC.B  219.1
02C46:  BRA     2C44
02C48:  MOV     W0,21A
02C4A:  MOV     [--W15],W1
02C4C:  MOV     #E,W0
02C4E:  CPSGT   W1,W0
02C50:  BRA     2C3A
02C52:  MOV     82A,W0
02C54:  MOV     #0,W4
02C56:  CALL    29DA
02C5A:  BTSC.B  219.1
02C5C:  BRA     2C5A
02C5E:  MOV     #A,W4
02C60:  MOV     W4,21A
02C62:  BTSC.B  219.1
02C64:  BRA     2C62
02C66:  MOV     #D,W4
02C68:  MOV     W4,21A
....................       fprintf(RS232,"Target Encoder count: %u\n\r",md_target_count); 
02C6A:  MOV     #0,W1
02C6C:  MOV     W1,W0
02C6E:  CALL    AC6
02C72:  INC     W1,W1
02C74:  MOV     W1,[W15++]
02C76:  BTSC.B  219.1
02C78:  BRA     2C76
02C7A:  MOV     W0,21A
02C7C:  MOV     [--W15],W1
02C7E:  MOV     #15,W0
02C80:  CPSGT   W1,W0
02C82:  BRA     2C6C
02C84:  MOV     81A,W0
02C86:  MOV     #0,W4
02C88:  CALL    1572
02C8C:  BTSC.B  219.1
02C8E:  BRA     2C8C
02C90:  MOV     #A,W4
02C92:  MOV     W4,21A
02C94:  BTSC.B  219.1
02C96:  BRA     2C94
02C98:  MOV     #D,W4
02C9A:  MOV     W4,21A
....................       fprintf(RS232,"Current Encoder count: %u\n\r",qei_get_count()); 
02C9C:  CALL    1F8A
02CA0:  MOV     W0,W5
02CA2:  MOV     #0,W1
02CA4:  MOV     W1,W0
02CA6:  CALL    AEE
02CAA:  INC     W1,W1
02CAC:  MOV     W1,[W15++]
02CAE:  BTSC.B  219.1
02CB0:  BRA     2CAE
02CB2:  MOV     W0,21A
02CB4:  MOV     [--W15],W1
02CB6:  MOV     #16,W0
02CB8:  CPSGT   W1,W0
02CBA:  BRA     2CA4
02CBC:  MOV     W5,W0
02CBE:  MOV     #0,W4
02CC0:  CALL    1572
02CC4:  BTSC.B  219.1
02CC6:  BRA     2CC4
02CC8:  MOV     #A,W4
02CCA:  MOV     W4,21A
02CCC:  BTSC.B  219.1
02CCE:  BRA     2CCC
02CD0:  MOV     #D,W4
02CD2:  MOV     W4,21A
....................       fprintf(RS232,"Number of Iterations: %u\n\r",md_pos_iter); 
02CD4:  MOV     #0,W1
02CD6:  MOV     W1,W0
02CD8:  CALL    B16
02CDC:  INC     W1,W1
02CDE:  MOV     W1,[W15++]
02CE0:  BTSC.B  219.1
02CE2:  BRA     2CE0
02CE4:  MOV     W0,21A
02CE6:  MOV     [--W15],W1
02CE8:  MOV     #15,W0
02CEA:  CPSGT   W1,W0
02CEC:  BRA     2CD6
02CEE:  MOV     828,W0
02CF0:  MOV     #0,W4
02CF2:  CALL    1572
02CF6:  BTSC.B  219.1
02CF8:  BRA     2CF6
02CFA:  MOV     #A,W4
02CFC:  MOV     W4,21A
02CFE:  BTSC.B  219.1
02D00:  BRA     2CFE
02D02:  MOV     #D,W4
02D04:  MOV     W4,21A
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02D06:  MOV     #0,W1
02D08:  MOV     W1,W0
02D0A:  CALL    AA6
02D0E:  INC     W1,W1
02D10:  MOV     W1,[W15++]
02D12:  BTSC.B  219.1
02D14:  BRA     2D12
02D16:  MOV     W0,21A
02D18:  MOV     [--W15],W1
02D1A:  MOV     #E,W0
02D1C:  CPSGT   W1,W0
02D1E:  BRA     2D08
02D20:  MOV     82A,W0
02D22:  MOV     #0,W4
02D24:  CALL    29DA
02D28:  BTSC.B  219.1
02D2A:  BRA     2D28
02D2C:  MOV     #A,W4
02D2E:  MOV     W4,21A
02D30:  BTSC.B  219.1
02D32:  BRA     2D30
02D34:  MOV     #D,W4
02D36:  MOV     W4,21A
....................    } 
....................     
....................    fprintf(RS232,"Error: %d\n\r",(int)qei_get_count()-(int)md_target_count); 
02D38:  CALL    1F8A
02D3C:  MOV     W0,W5
02D3E:  MOV     81A,W4
02D40:  SUB     W5,W4,W5
02D42:  MOV     #0,W1
02D44:  MOV     W1,W0
02D46:  CALL    B3E
02D4A:  INC     W1,W1
02D4C:  MOV     W1,[W15++]
02D4E:  BTSC.B  219.1
02D50:  BRA     2D4E
02D52:  MOV     W0,21A
02D54:  MOV     [--W15],W1
02D56:  MOV     #6,W0
02D58:  CPSGT   W1,W0
02D5A:  BRA     2D44
02D5C:  MOV     W5,W0
02D5E:  MOV     #0,W4
02D60:  CALL    29DA
02D64:  BTSC.B  219.1
02D66:  BRA     2D64
02D68:  MOV     #A,W4
02D6A:  MOV     W4,21A
02D6C:  BTSC.B  219.1
02D6E:  BRA     2D6C
02D70:  MOV     #D,W4
02D72:  MOV     W4,21A
.................... } 
02D74:  MOV     #14,W5
02D76:  REPEAT  #4
02D78:  MOV     [--W15],[W5--]
02D7A:  MOV     [--W15],W5
02D7C:  RETURN  
.................... // Homing Function 
.................... void move_home() 
.................... { 
....................    fprintf(RS232,"Homing...\n\r");    
*
021D2:  MOV     #0,W1
021D4:  MOV     W1,W0
021D6:  CALL    B56
021DA:  INC     W1,W1
021DC:  MOV     W1,[W15++]
021DE:  BTSC.B  219.1
021E0:  BRA     21DE
021E2:  MOV     W0,21A
021E4:  MOV     [--W15],W1
021E6:  MOV     #A,W0
021E8:  CPSGT   W1,W0
021EA:  BRA     21D4
....................     
....................    md_run_state = HOME; 
021EC:  CLR.B   801
....................    md_decel_count = 0; 
021EE:  CLR     826
....................    reg_md_home = 0; 
021F0:  BCLR.B  84C.1
....................    reg_md_home_return = 0; 
021F2:  BCLR.B  84C.2
....................     
....................    output_high(MD_DIR); 
021F4:  BCLR.B  2D8.4
021F6:  BSET.B  2DC.4
....................    md_mt_set(mt_percent_trip); 
021F8:  PUSH    808
021FA:  POP     8A8
021FC:  CALL    1B88
....................  
....................    pwm_set_period(delays[0]); 
02200:  MOV     #7D0,W4
02202:  MOV     W4,8AC
02204:  CALL    1EE2
....................    pwm_select_mode(FREE); 
02208:  CLR     8A8
0220A:  CALL    1676
....................    pwm_enable(); 
0220E:  CALL    1F90
.................... } 
02212:  RETURN  
.................... // Initializes the system for movement 
.................... void move_init() 
.................... { 
*
02D7E:  MOV     W5,[W15++]
....................    md_move_range = data_get_move_range(); 
02D80:  CALL    1CFC
02D84:  MOV     W0,80E
....................    md_home_pos = data_get_home_pos(); 
02D86:  CALL    1D4C
02D8A:  MOV     W0,810
....................    md_end_pos = data_get_end_pos(); 
02D8C:  CALL    1D9C
02D90:  MOV     W0,812
....................    md_backlash = data_get_backlash(); 
02D92:  CALL    1DEC
02D96:  MOV     W0,82C
....................    qei_set_max_count(md_end_pos+md_end_offset); 
02D98:  MOV     812,W0
02D9A:  ADD     814,W0
02D9C:  MOV     W0,W5
02D9E:  MOV     W5,856
02DA0:  CALL    1E3C
....................    md_conv_const = data_get_conv_const(); 
02DA4:  CALL    1E80
02DA8:  MOV     W0,80C
....................     
....................    if(md_move_range==2000) 
02DAA:  MOV     80E,W4
02DAC:  MOV     #7D0,W3
02DAE:  CP      W3,W4
02DB0:  BRA     NZ,2DB6
....................       md_min_distance=120; 
02DB2:  MOV     #78,W4
02DB4:  MOV     W4,818
....................           
....................    move_home();                        // Move to home position 
02DB6:  CALL    21D2
....................     
....................    delay_ms(500); 
02DBA:  MOV     #1F4,W0
02DBC:  CALL    155E
....................        
....................    if(debug_mode_md) 
02DC0:  BTSS.B  800.3
02DC2:  BRA     2E06
....................       fprintf(RS232,"Moving Last Position: %u mm\n\r", data_get_last_pos()); 
02DC4:  CALL    2214
02DC8:  MOV     W0,W5
02DCA:  MOV     #0,W1
02DCC:  MOV     W1,W0
02DCE:  CALL    B6E
02DD2:  INC     W1,W1
02DD4:  MOV     W1,[W15++]
02DD6:  BTSC.B  219.1
02DD8:  BRA     2DD6
02DDA:  MOV     W0,21A
02DDC:  MOV     [--W15],W1
02DDE:  MOV     #15,W0
02DE0:  CPSGT   W1,W0
02DE2:  BRA     2DCC
02DE4:  MOV     W5,W0
02DE6:  MOV     #0,W4
02DE8:  CALL    1572
02DEC:  MOV     #18,W1
02DEE:  MOV     W1,W0
02DF0:  CALL    B6E
02DF4:  INC     W1,W1
02DF6:  MOV     W1,[W15++]
02DF8:  BTSC.B  219.1
02DFA:  BRA     2DF8
02DFC:  MOV     W0,21A
02DFE:  MOV     [--W15],W1
02E00:  MOV     #1C,W0
02E02:  CPSGT   W1,W0
02E04:  BRA     2DEE
....................  
....................    move_pos(data_get_last_pos()); 
02E06:  CALL    2214
02E0A:  MOV     W0,W5
02E0C:  MOV     W5,894
02E0E:  CALL    2AD4
.................... } 
02E12:  MOV     [--W15],W5
02E14:  RETURN  
....................  
.................... //Gets byte via parallel port 
.................... unsigned int pp_get_byte() 
.................... { 
*
0432A:  MOV     W5,[W15++]
0432C:  CLR     854
0432E:  CLR     856
04330:  CLR     858
04332:  CLR     85A
04334:  CLR     85C
04336:  CLR     85E
04338:  CLR     860
0433A:  CLR     862
0433C:  CLR     864
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................     
....................    D7=(!input(PP_D7))*1; 
0433E:  BSET.B  2D2.3
04340:  CLR     856
04342:  BTSS.B  2D4.3
04344:  INC     0856
....................    D6=(!input(PP_D6))*1; 
04346:  BSET.B  2D2.2
04348:  CLR     858
0434A:  BTSS.B  2D4.2
0434C:  INC     0858
....................    D5=(!input(PP_D5))*1; 
0434E:  BSET.B  2D2.1
04350:  CLR     85A
04352:  BTSS.B  2D4.1
04354:  INC     085A
....................    D4=(!input(PP_D4))*1; 
04356:  BSET.B  2CD.6
04358:  CLR     85C
0435A:  BTSS.B  2CF.6
0435C:  INC     085C
....................    D3=(!input(PP_D3))*1; 
0435E:  BSET.B  2CD.5
04360:  CLR     85E
04362:  BTSS.B  2CF.5
04364:  INC     085E
....................    D2=(!input(PP_D2))*1; 
04366:  BSET.B  2D2.0
04368:  CLR     860
0436A:  BTSS.B  2D4.0
0436C:  INC     0860
....................    D1=(!input(PP_D1))*1; 
0436E:  BSET.B  2D3.1
04370:  CLR     862
04372:  BTSS.B  2D5.1
04374:  INC     0862
....................    D0=(!input(PP_D0))*1; 
04376:  BSET.B  2D3.0
04378:  CLR     864
0437A:  BTSS.B  2D5.0
0437C:  INC     0864
....................     
....................     
....................     
....................    data=(D7<<7)+(D6<<6)+(D5<<5)+(D4<<4)+(D3<<3)+(D2<<2)+(D1<<1)+D0; 
0437E:  MOV     856,W5
04380:  SL      W5,#7,W5
04382:  MOV     858,W0
04384:  SL      W0,#6,W0
04386:  ADD     W0,W5,W5
04388:  MOV     85A,W0
0438A:  SL      W0,#5,W0
0438C:  ADD     W0,W5,W5
0438E:  MOV     85C,W0
04390:  SL      W0,#4,W0
04392:  ADD     W0,W5,W5
04394:  MOV     85E,W0
04396:  SL      W0,#3,W0
04398:  ADD     W0,W5,W5
0439A:  MOV     860,W0
0439C:  SL      W0,#2,W0
0439E:  ADD     W0,W5,W5
043A0:  MOV     862,W0
043A2:  SL      W0,#1,W0
043A4:  ADD     W0,W5,W5
043A6:  MOV     W5,W0
043A8:  ADD     864,W0
043AA:  MOV     W0,854
....................  
....................    return data; 
043AC:  PUSH    854
043AE:  POP     0
.................... } 
043B0:  MOV     [--W15],W5
043B2:  RETURN  
.................... //Gets BCD byte via parallel port 
.................... unsigned int pp_get_BCD_byte() 
.................... { 
*
04448:  MOV     W5,[W15++]
0444A:  CLR     85C
0444C:  CLR     85E
0444E:  CLR     860
04450:  CLR     862
04452:  CLR     864
04454:  CLR     866
04456:  CLR     868
04458:  CLR     86A
0445A:  CLR     86C
0445C:  CLR     86E
0445E:  CLR     870
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    D7=(!input(PP_D7))*1; 
04460:  BSET.B  2D2.3
04462:  CLR     85E
04464:  BTSS.B  2D4.3
04466:  INC     085E
....................    D6=(!input(PP_D6))*1; 
04468:  BSET.B  2D2.2
0446A:  CLR     860
0446C:  BTSS.B  2D4.2
0446E:  INC     0860
....................    D5=(!input(PP_D5))*1; 
04470:  BSET.B  2D2.1
04472:  CLR     862
04474:  BTSS.B  2D4.1
04476:  INC     0862
....................    D4=(!input(PP_D4))*1; 
04478:  BSET.B  2CD.6
0447A:  CLR     864
0447C:  BTSS.B  2CF.6
0447E:  INC     0864
....................    D3=(!input(PP_D3))*1; 
04480:  BSET.B  2CD.5
04482:  CLR     866
04484:  BTSS.B  2CF.5
04486:  INC     0866
....................    D2=(!input(PP_D2))*1; 
04488:  BSET.B  2D2.0
0448A:  CLR     868
0448C:  BTSS.B  2D4.0
0448E:  INC     0868
....................    D1=(!input(PP_D1))*1; 
04490:  BSET.B  2D3.1
04492:  CLR     86A
04494:  BTSS.B  2D5.1
04496:  INC     086A
....................    D0=(!input(PP_D0))*1; 
04498:  BSET.B  2D3.0
0449A:  CLR     86C
0449C:  BTSS.B  2D5.0
0449E:  INC     086C
....................     
....................    byte0=8*D7+4*D6+2*D5+D4; 
044A0:  MOV     85E,W5
044A2:  SL      W5,#3,W5
044A4:  MOV     860,W0
044A6:  SL      W0,#2,W0
044A8:  ADD     W0,W5,W5
044AA:  MOV     862,W0
044AC:  SL      W0,#1,W0
044AE:  ADD     W0,W5,W5
044B0:  MOV     W5,W0
044B2:  ADD     864,W0
044B4:  MOV     W0,86E
....................    byte1=8*D3+4*D2+2*D1+D0; 
044B6:  MOV     866,W5
044B8:  SL      W5,#3,W5
044BA:  MOV     868,W0
044BC:  SL      W0,#2,W0
044BE:  ADD     W0,W5,W5
044C0:  MOV     86A,W0
044C2:  SL      W0,#1,W0
044C4:  ADD     W0,W5,W5
044C6:  MOV     W5,W0
044C8:  ADD     86C,W0
044CA:  MOV     W0,870
....................    data=byte0*10+byte1; 
044CC:  MOV     86E,W4
044CE:  MUL.UU  W4,#A,W0
044D0:  MOV     W0,W5
044D2:  MOV     W5,W0
044D4:  ADD     870,W0
044D6:  MOV     W0,85C
....................     
....................    return data; 
044D8:  PUSH    85C
044DA:  POP     0
.................... } 
044DC:  MOV     [--W15],W5
044DE:  RETURN  
.................... // Returns binary coded decimal byte of the given input 
.................... unsigned int pp_get_BCD_byte(unsigned int input) 
.................... { 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    byte0=8*bit_test(input,7)+4*bit_test(input,6)+2*bit_test(input,5)+bit_test(input,4); 
....................    byte1=8*bit_test(input,3)+4*bit_test(input,2)+2*bit_test(input,1)+bit_test(input,0); 
....................  
....................    return byte0*10+byte1; 
.................... } 
.................... // Pauses parallel port until strobe signal (returns 0) or communication time out (returns 1) 
.................... unsigned int1 pp_comm_pause() 
.................... {  
*
043B4:  MOV     W5,[W15++]
....................    while(true) 
....................    { 
....................       if(reg_pp_strobe) 
043B6:  BTSS.B  84C.0
043B8:  BRA     443C
....................       { 
....................          reg_pp_strobe = 0; 
043BA:  BCLR.B  84C.0
....................           
....................          if(debug_mode_pp) 
043BC:  BTSS.B  800.1
043BE:  BRA     43DA
....................             fprintf(RS232,"Strobe received\n\r"); 
043C0:  MOV     #0,W1
043C2:  MOV     W1,W0
043C4:  CALL    B98
043C8:  INC     W1,W1
043CA:  MOV     W1,[W15++]
043CC:  BTSC.B  219.1
043CE:  BRA     43CC
043D0:  MOV     W0,21A
043D2:  MOV     [--W15],W1
043D4:  MOV     #10,W0
043D6:  CPSGT   W1,W0
043D8:  BRA     43C2
....................  
....................          unsigned int i; 
....................          for(i=0; i<pp_str_check; i++) 
043DA:  CLR     85A
043DC:  MOV     85A,W0
043DE:  MOV     844,W4
043E0:  CP      W4,W0
043E2:  BRA     LEU,441A
....................          { 
....................             delay_ms(pp_str_delay); 
043E4:  MOV     846,W0
043E6:  CALL    155E
....................             if(input(PP_STR) == 1) 
043EA:  BSET.B  2D3.2
043EC:  BTSS.B  2D5.2
043EE:  BRA     4414
....................             { 
....................                if(debug_mode_pp) 
043F0:  BTSS.B  800.1
043F2:  BRA     440E
....................                   fprintf(RS232,"Strobe signal rejected\n\r"); 
043F4:  MOV     #0,W1
043F6:  MOV     W1,W0
043F8:  CALL    BB6
043FC:  INC     W1,W1
043FE:  MOV     W1,[W15++]
04400:  BTSC.B  219.1
04402:  BRA     4400
04404:  MOV     W0,21A
04406:  MOV     [--W15],W1
04408:  MOV     #17,W0
0440A:  CPSGT   W1,W0
0440C:  BRA     43F6
....................                return 1; 
0440E:  MOV.B   #1,W0L
04410:  MOV.B   W0L,0
04412:  BRA     4444
....................             } 
....................          } 
04414:  INC     085A
04416:  GOTO    43DC
....................           
....................          if(debug_mode_pp) 
0441A:  BTSS.B  800.1
0441C:  BRA     4438
....................             fprintf(RS232,"Strobe confirmed\n\r"); 
0441E:  MOV     #0,W1
04420:  MOV     W1,W0
04422:  CALL    BDC
04426:  INC     W1,W1
04428:  MOV     W1,[W15++]
0442A:  BTSC.B  219.1
0442C:  BRA     442A
0442E:  MOV     W0,21A
04430:  MOV     [--W15],W1
04432:  MOV     #11,W0
04434:  CPSGT   W1,W0
04436:  BRA     4420
....................              
....................          return 0; 
04438:  CLR.B   0
0443A:  BRA     4444
....................       } 
....................    } 
0443C:  GOTO    43B6
....................     
....................    return 1; 
04440:  MOV.B   #1,W0L
04442:  MOV.B   W0L,0
.................... } 
04444:  MOV     [--W15],W5
04446:  RETURN  
.................... // Sets position given via parallel port 
.................... void pp_set_pos() 
.................... { 
*
044E0:  MOV     W5,[W15++]
....................    delay_ms(pp_rdy_delay); 
044E2:  MOV     84A,W0
044E4:  CALL    155E
....................    output_high(PP_RDY); 
044E8:  BCLR.B  2D2.5
044EA:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
044EC:  CALL    43B4
044F0:  CP0.B   W0L
044F2:  BRA     Z,44F6
....................       return; 
044F4:  BRA     45E0
....................  
....................    output_low(PP_ACK); 
044F6:  BCLR.B  2D2.4
044F8:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
044FA:  BCLR.B  2D2.5
044FC:  BCLR.B  2D6.5
....................    unsigned int index=pp_get_BCD_byte(); 
044FE:  CALL    4448
04502:  MOV     W0,854
....................    delay_ms(pp_ack_delay); 
04504:  MOV     848,W0
04506:  CALL    155E
....................    output_high(PP_ACK); 
0450A:  BCLR.B  2D2.4
0450C:  BSET.B  2D6.4
....................    delay_ms(pp_rdy_delay); 
0450E:  MOV     84A,W0
04510:  CALL    155E
....................    output_high(PP_RDY); 
04514:  BCLR.B  2D2.5
04516:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
04518:  CALL    43B4
0451C:  CP0.B   W0L
0451E:  BRA     Z,4522
....................       return; 
04520:  BRA     45E0
....................     
....................    output_low(PP_ACK); 
04522:  BCLR.B  2D2.4
04524:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04526:  BCLR.B  2D2.5
04528:  BCLR.B  2D6.5
....................    unsigned int pos0=pp_get_BCD_byte(); 
0452A:  CALL    4448
0452E:  MOV     W0,856
....................    delay_ms(pp_ack_delay); 
04530:  MOV     848,W0
04532:  CALL    155E
....................    output_high(PP_ACK); 
04536:  BCLR.B  2D2.4
04538:  BSET.B  2D6.4
....................    delay_ms(pp_rdy_delay); 
0453A:  MOV     84A,W0
0453C:  CALL    155E
....................    output_high(PP_RDY); 
04540:  BCLR.B  2D2.5
04542:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
04544:  CALL    43B4
04548:  CP0.B   W0L
0454A:  BRA     Z,454E
....................       return; 
0454C:  BRA     45E0
....................  
....................    output_low(PP_ACK); 
0454E:  BCLR.B  2D2.4
04550:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04552:  BCLR.B  2D2.5
04554:  BCLR.B  2D6.5
....................    unsigned int pos1=pp_get_BCD_byte(); 
04556:  CALL    4448
0455A:  MOV     W0,858
....................    delay_ms(pp_ack_delay); 
0455C:  MOV     848,W0
0455E:  CALL    155E
....................    output_high(PP_ACK); 
04562:  BCLR.B  2D2.4
04564:  BSET.B  2D6.4
....................  
....................    data_set_pos(index, pos0*100+pos1); 
04566:  MOV     856,W4
04568:  MOV     #64,W3
0456A:  MUL.UU  W4,W3,W0
0456C:  MOV     W0,W5
0456E:  MOV     W5,W0
04570:  ADD     858,W0
04572:  MOV     W0,W5
04574:  MOV.B   854,W0L
04576:  MOV.B   W0L,892
04578:  MOV     W5,894
0457A:  CALL    37AE
....................     
....................    fprintf(RS232,"Position set -> index: %u position: %u\n\r", index, pos0*100+pos1); 
0457E:  MOV     856,W4
04580:  MOV     #64,W3
04582:  MUL.UU  W4,W3,W0
04584:  MOV     W0,W5
04586:  MOV     W5,W0
04588:  ADD     858,W0
0458A:  MOV     W0,W5
0458C:  MOV     #0,W1
0458E:  MOV     W1,W0
04590:  CALL    BFC
04594:  INC     W1,W1
04596:  MOV     W1,[W15++]
04598:  BTSC.B  219.1
0459A:  BRA     4598
0459C:  MOV     W0,21A
0459E:  MOV     [--W15],W1
045A0:  MOV     #16,W0
045A2:  CPSGT   W1,W0
045A4:  BRA     458E
045A6:  MOV     854,W0
045A8:  MOV     #0,W4
045AA:  CALL    1572
045AE:  MOV     #19,W1
045B0:  MOV     W1,W0
045B2:  CALL    BFC
045B6:  INC     W1,W1
045B8:  MOV     W1,[W15++]
045BA:  BTSC.B  219.1
045BC:  BRA     45BA
045BE:  MOV     W0,21A
045C0:  MOV     [--W15],W1
045C2:  MOV     #23,W0
045C4:  CPSGT   W1,W0
045C6:  BRA     45B0
045C8:  MOV     W5,W0
045CA:  MOV     #0,W4
045CC:  CALL    1572
045D0:  BTSC.B  219.1
045D2:  BRA     45D0
045D4:  MOV     #A,W4
045D6:  MOV     W4,21A
045D8:  BTSC.B  219.1
045DA:  BRA     45D8
045DC:  MOV     #D,W4
045DE:  MOV     W4,21A
.................... } 
045E0:  MOV     [--W15],W5
045E2:  RETURN  
.................... // Moves to position given via parallel port 
.................... void pp_move_pos(unsigned int input) 
.................... { 
045E4:  CALL    4448
045E8:  MOV     W0,856
....................    unsigned int index=pp_get_BCD_byte();; 
....................    unsigned int position=data_get_pos(index); 
045EA:  MOV.B   856,W0L
045EC:  MOV.B   W0L,896
045EE:  CALL    36C8
045F2:  MOV     W0,858
....................     
....................    fprintf(RS232,"Move Position -> index: %u position: %u\n\r", index, position); 
045F4:  MOV     #0,W1
045F6:  MOV     W1,W0
045F8:  CALL    C32
045FC:  INC     W1,W1
045FE:  MOV     W1,[W15++]
04600:  BTSC.B  219.1
04602:  BRA     4600
04604:  MOV     W0,21A
04606:  MOV     [--W15],W1
04608:  MOV     #17,W0
0460A:  CPSGT   W1,W0
0460C:  BRA     45F6
0460E:  MOV     856,W0
04610:  MOV     #0,W4
04612:  CALL    1572
04616:  MOV     #1A,W1
04618:  MOV     W1,W0
0461A:  CALL    C32
0461E:  INC     W1,W1
04620:  MOV     W1,[W15++]
04622:  BTSC.B  219.1
04624:  BRA     4622
04626:  MOV     W0,21A
04628:  MOV     [--W15],W1
0462A:  MOV     #24,W0
0462C:  CPSGT   W1,W0
0462E:  BRA     4618
04630:  MOV     858,W0
04632:  MOV     #0,W4
04634:  CALL    1572
04638:  BTSC.B  219.1
0463A:  BRA     4638
0463C:  MOV     #A,W4
0463E:  MOV     W4,21A
04640:  BTSC.B  219.1
04642:  BRA     4640
04644:  MOV     #D,W4
04646:  MOV     W4,21A
....................        
....................    move_pos(position); 
04648:  PUSH    858
0464A:  POP     894
0464C:  CALL    2AD4
.................... } 
04650:  RETURN  
.................... // Gets command via parallel port when system is idle 
.................... void pp_get_command() 
.................... { 
....................    output_low(PP_ACK); 
04652:  BCLR.B  2D2.4
04654:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04656:  BCLR.B  2D2.5
04658:  BCLR.B  2D6.5
....................    unsigned int input=pp_get_byte(); 
0465A:  CALL    432A
0465E:  MOV     W0,852
....................    delay_ms(pp_ack_delay); 
04660:  MOV     848,W0
04662:  CALL    155E
....................    output_high(PP_ACK); 
04666:  BCLR.B  2D2.4
04668:  BSET.B  2D6.4
....................  
....................    switch (input) 
....................    { 
0466A:  MOV     852,W0
0466C:  XOR     #FE,W0
0466E:  BRA     Z,4682
04670:  XOR     #3,W0
04672:  BRA     Z,46A2
04674:  XOR     #1,W0
04676:  BRA     Z,46C4
04678:  XOR     #7,W0
0467A:  BRA     Z,46EE
0467C:  XOR     #4,W0
0467E:  BRA     Z,4718
04680:  BRA     473A
....................       case 0x00FE:   fprintf(RS232,"Emergency Stop Command\n\r"); 
04682:  MOV     #0,W1
04684:  MOV     W1,W0
04686:  CALL    C6A
0468A:  INC     W1,W1
0468C:  MOV     W1,[W15++]
0468E:  BTSC.B  219.1
04690:  BRA     468E
04692:  MOV     W0,21A
04694:  MOV     [--W15],W1
04696:  MOV     #17,W0
04698:  CPSGT   W1,W0
0469A:  BRA     4684
....................                       
....................                      reg_pp_stop=1; 
0469C:  BSET.B  800.7
....................                      break; 
0469E:  GOTO    4746
....................       case 0x00FD:   fprintf(RS232,"Homing Command\n\r"); 
046A2:  MOV     #0,W1
046A4:  MOV     W1,W0
046A6:  CALL    C90
046AA:  INC     W1,W1
046AC:  MOV     W1,[W15++]
046AE:  BTSC.B  219.1
046B0:  BRA     46AE
046B2:  MOV     W0,21A
046B4:  MOV     [--W15],W1
046B6:  MOV     #F,W0
046B8:  CPSGT   W1,W0
046BA:  BRA     46A4
....................        
....................                      move_home();    
046BC:  CALL    21D2
....................                      break; 
046C0:  GOTO    4746
....................       case 0x00FC:   fprintf(RS232,"Laser Off Command\n\r"); 
046C4:  MOV     #0,W1
046C6:  MOV     W1,W0
046C8:  CALL    CAE
046CC:  INC     W1,W1
046CE:  MOV     W1,[W15++]
046D0:  BTSC.B  219.1
046D2:  BRA     46D0
046D4:  MOV     W0,21A
046D6:  MOV     [--W15],W1
046D8:  MOV     #12,W0
046DA:  CPSGT   W1,W0
046DC:  BRA     46C6
....................                          
....................                      output_low(LAS_1); 
046DE:  BCLR.B  2C6.0
046E0:  BCLR.B  2CA.0
....................                      output_low(LAS_2); 
046E2:  BCLR.B  2C6.1
046E4:  BCLR.B  2CA.1
....................                      output_low(LAS_3); 
046E6:  BCLR.B  2D2.6
046E8:  BCLR.B  2D6.6
....................                      break; 
046EA:  GOTO    4746
....................       case 0x00FB:   fprintf(RS232,"Laser On Command\n\r"); 
046EE:  MOV     #0,W1
046F0:  MOV     W1,W0
046F2:  CALL    CCE
046F6:  INC     W1,W1
046F8:  MOV     W1,[W15++]
046FA:  BTSC.B  219.1
046FC:  BRA     46FA
046FE:  MOV     W0,21A
04700:  MOV     [--W15],W1
04702:  MOV     #11,W0
04704:  CPSGT   W1,W0
04706:  BRA     46F0
....................                       
....................                      output_high(LAS_1); 
04708:  BCLR.B  2C6.0
0470A:  BSET.B  2CA.0
....................                      output_high(LAS_2); 
0470C:  BCLR.B  2C6.1
0470E:  BSET.B  2CA.1
....................                      output_high(LAS_3); 
04710:  BCLR.B  2D2.6
04712:  BSET.B  2D6.6
....................                      break;  
04714:  GOTO    4746
....................       case 0x00FF:   fprintf(RS232,"Set Position Command\n\r"); 
04718:  MOV     #0,W1
0471A:  MOV     W1,W0
0471C:  CALL    CEE
04720:  INC     W1,W1
04722:  MOV     W1,[W15++]
04724:  BTSC.B  219.1
04726:  BRA     4724
04728:  MOV     W0,21A
0472A:  MOV     [--W15],W1
0472C:  MOV     #15,W0
0472E:  CPSGT   W1,W0
04730:  BRA     471A
....................                       
....................                      pp_set_pos(); 
04732:  CALL    44E0
....................                      break; 
04736:  GOTO    4746
....................       default:       pp_move_pos(input);  
0473A:  PUSH    852
0473C:  POP     854
0473E:  CALL    45E4
....................                      break; 
04742:  GOTO    4746
....................    } 
....................     
....................    delay_ms(pp_rdy_delay); 
04746:  MOV     84A,W0
04748:  CALL    155E
....................    output_high(PP_RDY); 
0474C:  BCLR.B  2D2.5
0474E:  BSET.B  2D6.5
.................... } 
04750:  RETURN  
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
.................... { 
*
037CA:  MOV     W5,[W15++]
037CC:  MOV     W6,[W15++]
....................    char input; 
....................     
....................    input=fgetc(RS232); 
037CE:  BTSS.B  218.0
037D0:  BRA     37CE
037D2:  MOV     21C,W0
037D4:  MOV.B   W0L,852
....................    switch (input){ 
037D6:  MOV.B   852,W0L
037D8:  CLR.B   1
037DA:  XOR     #63,W0
037DC:  BRA     Z,382C
037DE:  XOR     #10,W0
037E0:  BRA     Z,3A1C
037E2:  XOR     #1,W0
037E4:  BRA     Z,3A56
037E6:  XOR     #1A,W0
037E8:  BRA     Z,3A90
037EA:  XOR     #D,W0
037EC:  BRA     Z,3ACA
037EE:  XOR     #13,W0
037F0:  BRA     Z,3B04
037F2:  XOR     #14,W0
037F4:  BRA     Z,3B3E
037F6:  XOR     #16,W0
037F8:  BRA     Z,3B78
037FA:  XOR     #1D,W0
037FC:  BRA     Z,3BB2
037FE:  XOR     #4,W0
03800:  BRA     Z,3BBA
03802:  XOR     #15,W0
03804:  BRA     Z,3BDC
03806:  XOR     #9,W0
03808:  BRA     Z,3C72
0380A:  XOR     #1E,W0
0380C:  BRA     Z,3DC8
0380E:  XOR     #3,W0
03810:  BRA     Z,3EBC
03812:  XOR     #8,W0
03814:  BRA     Z,3FAA
03816:  XOR     #13,W0
03818:  BRA     Z,41C0
0381A:  XOR     #D,W0
0381C:  BRA     Z,41FC
0381E:  XOR     #1C,W0
03820:  BRA     Z,4294
03822:  XOR     #1,W0
03824:  BRA     Z,431C
03826:  XOR     #1E,W0
03828:  BRA     Z,4320
0382A:  BRA     4324
....................       case 'c':   fprintf(RS232,"\n\rCOMMAND LIST\n\r"); 
0382C:  MOV     #0,W1
0382E:  MOV     W1,W0
03830:  CALL    D12
03834:  INC     W1,W1
03836:  MOV     W1,[W15++]
03838:  BTSC.B  219.1
0383A:  BRA     3838
0383C:  MOV     W0,21A
0383E:  MOV     [--W15],W1
03840:  MOV     #F,W0
03842:  CPSGT   W1,W0
03844:  BRA     382E
....................                   fprintf(RS232,"\n\rSet Serial Number\t(s)"); 
03846:  MOV     #0,W1
03848:  MOV     W1,W0
0384A:  CALL    D30
0384E:  INC     W1,W1
03850:  MOV     W1,[W15++]
03852:  BTSC.B  219.1
03854:  BRA     3852
03856:  MOV     W0,21A
03858:  MOV     [--W15],W1
0385A:  MOV     #16,W0
0385C:  CPSGT   W1,W0
0385E:  BRA     3848
....................                   fprintf(RS232,"\n\rSet Move Range \t\t(r)"); 
03860:  MOV     #0,W1
03862:  MOV     W1,W0
03864:  CALL    D54
03868:  INC     W1,W1
0386A:  MOV     W1,[W15++]
0386C:  BTSC.B  219.1
0386E:  BRA     386C
03870:  MOV     W0,21A
03872:  MOV     [--W15],W1
03874:  MOV     #15,W0
03876:  CPSGT   W1,W0
03878:  BRA     3862
....................                   fprintf(RS232,"\n\rSet Homing Distance \t(h)"); 
0387A:  MOV     #0,W1
0387C:  MOV     W1,W0
0387E:  CALL    D78
03882:  INC     W1,W1
03884:  MOV     W1,[W15++]
03886:  BTSC.B  219.1
03888:  BRA     3886
0388A:  MOV     W0,21A
0388C:  MOV     [--W15],W1
0388E:  MOV     #19,W0
03890:  CPSGT   W1,W0
03892:  BRA     387C
....................                   fprintf(RS232,"\n\rSet End Distance \t(e)"); 
03894:  MOV     #0,W1
03896:  MOV     W1,W0
03898:  CALL    DA0
0389C:  INC     W1,W1
0389E:  MOV     W1,[W15++]
038A0:  BTSC.B  219.1
038A2:  BRA     38A0
038A4:  MOV     W0,21A
038A6:  MOV     [--W15],W1
038A8:  MOV     #16,W0
038AA:  CPSGT   W1,W0
038AC:  BRA     3896
....................                   fprintf(RS232,"\n\rSet Conversion Constant\t(v)"); 
038AE:  MOV     #0,W1
038B0:  MOV     W1,W0
038B2:  CALL    DC4
038B6:  INC     W1,W1
038B8:  MOV     W1,[W15++]
038BA:  BTSC.B  219.1
038BC:  BRA     38BA
038BE:  MOV     W0,21A
038C0:  MOV     [--W15],W1
038C2:  MOV     #1C,W0
038C4:  CPSGT   W1,W0
038C6:  BRA     38B0
....................                   fprintf(RS232,"\n\rSet Backlash \t\t(b)"); 
038C8:  MOV     #0,W1
038CA:  MOV     W1,W0
038CC:  CALL    DEE
038D0:  INC     W1,W1
038D2:  MOV     W1,[W15++]
038D4:  BTSC.B  219.1
038D6:  BRA     38D4
038D8:  MOV     W0,21A
038DA:  MOV     [--W15],W1
038DC:  MOV     #13,W0
038DE:  CPSGT   W1,W0
038E0:  BRA     38CA
....................                   fprintf(RS232,"\n\rSet Communication Type \t(t)"); 
038E2:  MOV     #0,W1
038E4:  MOV     W1,W0
038E6:  CALL    E10
038EA:  INC     W1,W1
038EC:  MOV     W1,[W15++]
038EE:  BTSC.B  219.1
038F0:  BRA     38EE
038F2:  MOV     W0,21A
038F4:  MOV     [--W15],W1
038F6:  MOV     #1C,W0
038F8:  CPSGT   W1,W0
038FA:  BRA     38E4
....................                   fprintf(RS232,"\n\rGet System Data \t(i)"); 
038FC:  MOV     #0,W1
038FE:  MOV     W1,W0
03900:  CALL    E3A
03904:  INC     W1,W1
03906:  MOV     W1,[W15++]
03908:  BTSC.B  219.1
0390A:  BRA     3908
0390C:  MOV     W0,21A
0390E:  MOV     [--W15],W1
03910:  MOV     #15,W0
03912:  CPSGT   W1,W0
03914:  BRA     38FE
....................                   fprintf(RS232,"\n\rGet Position List \t(m)"); 
03916:  MOV     #0,W1
03918:  MOV     W1,W0
0391A:  CALL    E5E
0391E:  INC     W1,W1
03920:  MOV     W1,[W15++]
03922:  BTSC.B  219.1
03924:  BRA     3922
03926:  MOV     W0,21A
03928:  MOV     [--W15],W1
0392A:  MOV     #17,W0
0392C:  CPSGT   W1,W0
0392E:  BRA     3918
....................                   fprintf(RS232,"\n\rMove To Position \t(x)"); 
03930:  MOV     #0,W1
03932:  MOV     W1,W0
03934:  CALL    E84
03938:  INC     W1,W1
0393A:  MOV     W1,[W15++]
0393C:  BTSC.B  219.1
0393E:  BRA     393C
03940:  MOV     W0,21A
03942:  MOV     [--W15],W1
03944:  MOV     #16,W0
03946:  CPSGT   W1,W0
03948:  BRA     3932
....................                   fprintf(RS232,"\n\rSet Table Data \t\t(q)"); 
0394A:  MOV     #0,W1
0394C:  MOV     W1,W0
0394E:  CALL    EA8
03952:  INC     W1,W1
03954:  MOV     W1,[W15++]
03956:  BTSC.B  219.1
03958:  BRA     3956
0395A:  MOV     W0,21A
0395C:  MOV     [--W15],W1
0395E:  MOV     #15,W0
03960:  CPSGT   W1,W0
03962:  BRA     394C
....................                   fprintf(RS232,"\n\rTest Run (low res) \t(o)"); 
03964:  MOV     #0,W1
03966:  MOV     W1,W0
03968:  CALL    ECC
0396C:  INC     W1,W1
0396E:  MOV     W1,[W15++]
03970:  BTSC.B  219.1
03972:  BRA     3970
03974:  MOV     W0,21A
03976:  MOV     [--W15],W1
03978:  MOV     #18,W0
0397A:  CPSGT   W1,W0
0397C:  BRA     3966
....................                   fprintf(RS232,"\n\rTest Run (high res) \t(l)"); 
0397E:  MOV     #0,W1
03980:  MOV     W1,W0
03982:  CALL    EF2
03986:  INC     W1,W1
03988:  MOV     W1,[W15++]
0398A:  BTSC.B  219.1
0398C:  BRA     398A
0398E:  MOV     W0,21A
03990:  MOV     [--W15],W1
03992:  MOV     #19,W0
03994:  CPSGT   W1,W0
03996:  BRA     3980
....................                   fprintf(RS232,"\n\rSet Debug State \t(d)"); 
03998:  MOV     #0,W1
0399A:  MOV     W1,W0
0399C:  CALL    F1A
039A0:  INC     W1,W1
039A2:  MOV     W1,[W15++]
039A4:  BTSC.B  219.1
039A6:  BRA     39A4
039A8:  MOV     W0,21A
039AA:  MOV     [--W15],W1
039AC:  MOV     #15,W0
039AE:  CPSGT   W1,W0
039B0:  BRA     399A
....................                   fprintf(RS232,"\n\rGet Encoder Count \t(w)"); 
039B2:  MOV     #0,W1
039B4:  MOV     W1,W0
039B6:  CALL    F3E
039BA:  INC     W1,W1
039BC:  MOV     W1,[W15++]
039BE:  BTSC.B  219.1
039C0:  BRA     39BE
039C2:  MOV     W0,21A
039C4:  MOV     [--W15],W1
039C6:  MOV     #17,W0
039C8:  CPSGT   W1,W0
039CA:  BRA     39B4
....................                   fprintf(RS232,"\n\rStart Memory Test \t(z)"); 
039CC:  MOV     #0,W1
039CE:  MOV     W1,W0
039D0:  CALL    F64
039D4:  INC     W1,W1
039D6:  MOV     W1,[W15++]
039D8:  BTSC.B  219.1
039DA:  BRA     39D8
039DC:  MOV     W0,21A
039DE:  MOV     [--W15],W1
039E0:  MOV     #17,W0
039E2:  CPSGT   W1,W0
039E4:  BRA     39CE
....................                   fprintf(RS232,"\n\rClear Memory \t\t(f)"); 
039E6:  MOV     #0,W1
039E8:  MOV     W1,W0
039EA:  CALL    F8A
039EE:  INC     W1,W1
039F0:  MOV     W1,[W15++]
039F2:  BTSC.B  219.1
039F4:  BRA     39F2
039F6:  MOV     W0,21A
039F8:  MOV     [--W15],W1
039FA:  MOV     #13,W0
039FC:  CPSGT   W1,W0
039FE:  BRA     39E8
....................                   fprintf(RS232,"\n\n\r"); 
03A00:  BTSC.B  219.1
03A02:  BRA     3A00
03A04:  MOV     #A,W4
03A06:  MOV     W4,21A
03A08:  BTSC.B  219.1
03A0A:  BRA     3A08
03A0C:  MOV     #A,W4
03A0E:  MOV     W4,21A
03A10:  BTSC.B  219.1
03A12:  BRA     3A10
03A14:  MOV     #D,W4
03A16:  MOV     W4,21A
....................                   break; 
03A18:  GOTO    4324
....................       case 's':   fprintf(RS232,"\n\rSet Serial Number (13 Characters): "); 
03A1C:  MOV     #0,W1
03A1E:  MOV     W1,W0
03A20:  CALL    FAC
03A24:  INC     W1,W1
03A26:  MOV     W1,[W15++]
03A28:  BTSC.B  219.1
03A2A:  BRA     3A28
03A2C:  MOV     W0,21A
03A2E:  MOV     [--W15],W1
03A30:  MOV     #24,W0
03A32:  CPSGT   W1,W0
03A34:  BRA     3A1E
....................                   data_set_serial_no(); 
03A36:  CALL    2E92
....................                   fprintf(RS232,"\n\n\r"); 
03A3A:  BTSC.B  219.1
03A3C:  BRA     3A3A
03A3E:  MOV     #A,W4
03A40:  MOV     W4,21A
03A42:  BTSC.B  219.1
03A44:  BRA     3A42
03A46:  MOV     #A,W4
03A48:  MOV     W4,21A
03A4A:  BTSC.B  219.1
03A4C:  BRA     3A4A
03A4E:  MOV     #D,W4
03A50:  MOV     W4,21A
....................                   break; 
03A52:  GOTO    4324
....................       case 'r':   fprintf(RS232,"\n\rSet Move Range in mm (xxxx): "); 
03A56:  MOV     #0,W1
03A58:  MOV     W1,W0
03A5A:  CALL    FDE
03A5E:  INC     W1,W1
03A60:  MOV     W1,[W15++]
03A62:  BTSC.B  219.1
03A64:  BRA     3A62
03A66:  MOV     W0,21A
03A68:  MOV     [--W15],W1
03A6A:  MOV     #1E,W0
03A6C:  CPSGT   W1,W0
03A6E:  BRA     3A58
....................                   data_set_move_range(); 
03A70:  CALL    2EF6
....................                   fprintf(RS232,"\n\n\r"); 
03A74:  BTSC.B  219.1
03A76:  BRA     3A74
03A78:  MOV     #A,W4
03A7A:  MOV     W4,21A
03A7C:  BTSC.B  219.1
03A7E:  BRA     3A7C
03A80:  MOV     #A,W4
03A82:  MOV     W4,21A
03A84:  BTSC.B  219.1
03A86:  BRA     3A84
03A88:  MOV     #D,W4
03A8A:  MOV     W4,21A
....................                   break; 
03A8C:  GOTO    4324
....................       case 'h':   fprintf(RS232,"\n\rSet Homing Distance in counts (xxxx): "); 
03A90:  MOV     #0,W1
03A92:  MOV     W1,W0
03A94:  CALL    100A
03A98:  INC     W1,W1
03A9A:  MOV     W1,[W15++]
03A9C:  BTSC.B  219.1
03A9E:  BRA     3A9C
03AA0:  MOV     W0,21A
03AA2:  MOV     [--W15],W1
03AA4:  MOV     #27,W0
03AA6:  CPSGT   W1,W0
03AA8:  BRA     3A92
....................                   data_set_home_pos(); 
03AAA:  CALL    2FCE
....................                   fprintf(RS232,"\n\n\r"); 
03AAE:  BTSC.B  219.1
03AB0:  BRA     3AAE
03AB2:  MOV     #A,W4
03AB4:  MOV     W4,21A
03AB6:  BTSC.B  219.1
03AB8:  BRA     3AB6
03ABA:  MOV     #A,W4
03ABC:  MOV     W4,21A
03ABE:  BTSC.B  219.1
03AC0:  BRA     3ABE
03AC2:  MOV     #D,W4
03AC4:  MOV     W4,21A
....................                   break; 
03AC6:  GOTO    4324
....................       case 'e':   fprintf(RS232,"\n\rSet End Distance in counts (xxxxx): "); 
03ACA:  MOV     #0,W1
03ACC:  MOV     W1,W0
03ACE:  CALL    1040
03AD2:  INC     W1,W1
03AD4:  MOV     W1,[W15++]
03AD6:  BTSC.B  219.1
03AD8:  BRA     3AD6
03ADA:  MOV     W0,21A
03ADC:  MOV     [--W15],W1
03ADE:  MOV     #25,W0
03AE0:  CPSGT   W1,W0
03AE2:  BRA     3ACC
....................                   data_set_end_pos(); 
03AE4:  CALL    3064
....................                   fprintf(RS232,"\n\n\r"); 
03AE8:  BTSC.B  219.1
03AEA:  BRA     3AE8
03AEC:  MOV     #A,W4
03AEE:  MOV     W4,21A
03AF0:  BTSC.B  219.1
03AF2:  BRA     3AF0
03AF4:  MOV     #A,W4
03AF6:  MOV     W4,21A
03AF8:  BTSC.B  219.1
03AFA:  BRA     3AF8
03AFC:  MOV     #D,W4
03AFE:  MOV     W4,21A
....................                   break; 
03B00:  GOTO    4324
....................       case 'v':   fprintf(RS232,"\n\rSet Conversion Constant (xxxxx): "); 
03B04:  MOV     #0,W1
03B06:  MOV     W1,W0
03B08:  CALL    1074
03B0C:  INC     W1,W1
03B0E:  MOV     W1,[W15++]
03B10:  BTSC.B  219.1
03B12:  BRA     3B10
03B14:  MOV     W0,21A
03B16:  MOV     [--W15],W1
03B18:  MOV     #22,W0
03B1A:  CPSGT   W1,W0
03B1C:  BRA     3B06
....................                   data_set_conv_const(); 
03B1E:  CALL    310E
....................                   fprintf(RS232,"\n\n\r"); 
03B22:  BTSC.B  219.1
03B24:  BRA     3B22
03B26:  MOV     #A,W4
03B28:  MOV     W4,21A
03B2A:  BTSC.B  219.1
03B2C:  BRA     3B2A
03B2E:  MOV     #A,W4
03B30:  MOV     W4,21A
03B32:  BTSC.B  219.1
03B34:  BRA     3B32
03B36:  MOV     #D,W4
03B38:  MOV     W4,21A
....................                   break; 
03B3A:  GOTO    4324
....................       case 'b':   fprintf(RS232,"\n\rSet Backlash (xx): "); 
03B3E:  MOV     #0,W1
03B40:  MOV     W1,W0
03B42:  CALL    10A4
03B46:  INC     W1,W1
03B48:  MOV     W1,[W15++]
03B4A:  BTSC.B  219.1
03B4C:  BRA     3B4A
03B4E:  MOV     W0,21A
03B50:  MOV     [--W15],W1
03B52:  MOV     #14,W0
03B54:  CPSGT   W1,W0
03B56:  BRA     3B40
....................                   data_set_backlash(); 
03B58:  CALL    3238
....................                   fprintf(RS232,"\n\n\r"); 
03B5C:  BTSC.B  219.1
03B5E:  BRA     3B5C
03B60:  MOV     #A,W4
03B62:  MOV     W4,21A
03B64:  BTSC.B  219.1
03B66:  BRA     3B64
03B68:  MOV     #A,W4
03B6A:  MOV     W4,21A
03B6C:  BTSC.B  219.1
03B6E:  BRA     3B6C
03B70:  MOV     #D,W4
03B72:  MOV     W4,21A
....................                   break; 
03B74:  GOTO    4324
....................       case 't':   fprintf(RS232,"\n\rSet Communication Type (0: Parallel, 1: RS232"); 
03B78:  MOV     #0,W1
03B7A:  MOV     W1,W0
03B7C:  CALL    10C6
03B80:  INC     W1,W1
03B82:  MOV     W1,[W15++]
03B84:  BTSC.B  219.1
03B86:  BRA     3B84
03B88:  MOV     W0,21A
03B8A:  MOV     [--W15],W1
03B8C:  MOV     #2E,W0
03B8E:  CPSGT   W1,W0
03B90:  BRA     3B7A
....................                   data_set_comm_type(); 
03B92:  CALL    329C
....................                   fprintf(RS232,"\n\n\r"); 
03B96:  BTSC.B  219.1
03B98:  BRA     3B96
03B9A:  MOV     #A,W4
03B9C:  MOV     W4,21A
03B9E:  BTSC.B  219.1
03BA0:  BRA     3B9E
03BA2:  MOV     #A,W4
03BA4:  MOV     W4,21A
03BA6:  BTSC.B  219.1
03BA8:  BRA     3BA6
03BAA:  MOV     #D,W4
03BAC:  MOV     W4,21A
....................                   break; 
03BAE:  GOTO    4324
....................       case 'i':   data_get_sys_data(); 
03BB2:  CALL    3374
....................                   break; 
03BB6:  GOTO    4324
....................       case 'm':   fprintf(RS232,"\n\rGet Position List(0<=X<=9): "); 
03BBA:  MOV     #0,W1
03BBC:  MOV     W1,W0
03BBE:  CALL    1102
03BC2:  INC     W1,W1
03BC4:  MOV     W1,[W15++]
03BC6:  BTSC.B  219.1
03BC8:  BRA     3BC6
03BCA:  MOV     W0,21A
03BCC:  MOV     [--W15],W1
03BCE:  MOV     #1D,W0
03BD0:  CPSGT   W1,W0
03BD2:  BRA     3BBC
....................                   data_get_pos_table(); 
03BD4:  CALL    374A
....................                   break; 
03BD8:  GOTO    4324
....................       case 'x':   fprintf(RS232,"\n\rMove To(0<=X<=9999): "); 
03BDC:  MOV     #0,W1
03BDE:  MOV     W1,W0
03BE0:  CALL    112E
03BE4:  INC     W1,W1
03BE6:  MOV     W1,[W15++]
03BE8:  BTSC.B  219.1
03BEA:  BRA     3BE8
03BEC:  MOV     W0,21A
03BEE:  MOV     [--W15],W1
03BF0:  MOV     #16,W0
03BF2:  CPSGT   W1,W0
03BF4:  BRA     3BDE
....................                   unsigned int i=0; 
....................                   unsigned int input_step[4]; 
....................                   unsigned int step=0; 
03BF6:  CLR     854
03BF8:  CLR     85E
....................                   for(i=0;i<4;i++){ 
03BFA:  CLR     854
03BFC:  MOV     854,W4
03BFE:  CP      W4,#4
03C00:  BRA     C,3C32
....................                      input_step[i]=(unsigned)(fgetc(RS232)-48); 
03C02:  MOV     854,W0
03C04:  SL      W0,#1,W0
03C06:  MOV     #856,W4
03C08:  ADD     W0,W4,W5
03C0A:  BTSS.B  218.0
03C0C:  BRA     3C0A
03C0E:  MOV     21C,W0
03C10:  SUB.B   #30,W0L
03C12:  CLR.B   1
03C14:  MOV     W0,[W5]
....................                      fputc(input_step[i]+48,RS232); 
03C16:  MOV     854,W0
03C18:  SL      W0,#1,W0
03C1A:  MOV     #856,W4
03C1C:  ADD     W0,W4,W0
03C1E:  MOV     [W0],W5
03C20:  ADD     #30,W5
03C22:  MOV.B   W5L,W0L
03C24:  BTSC.B  219.1
03C26:  BRA     3C24
03C28:  MOV.B   W0L,21A
03C2A:  CLR.B   21B
....................                   } 
03C2C:  INC     0854
03C2E:  GOTO    3BFC
....................                   fprintf(RS232,"\n\n\r"); 
03C32:  BTSC.B  219.1
03C34:  BRA     3C32
03C36:  MOV     #A,W4
03C38:  MOV     W4,21A
03C3A:  BTSC.B  219.1
03C3C:  BRA     3C3A
03C3E:  MOV     #A,W4
03C40:  MOV     W4,21A
03C42:  BTSC.B  219.1
03C44:  BRA     3C42
03C46:  MOV     #D,W4
03C48:  MOV     W4,21A
....................                    
....................                   step=1000*input_step[0]+100*input_step[1]+10*input_step[2]+1*input_step[3]; 
03C4A:  MOV     #3E8,W4
03C4C:  MOV     856,W3
03C4E:  MUL.UU  W4,W3,W0
03C50:  MOV     W0,W5
03C52:  MOV     #64,W4
03C54:  MOV     858,W3
03C56:  MUL.UU  W4,W3,W0
03C58:  ADD     W0,W5,W5
03C5A:  MOV     85A,W4
03C5C:  MUL.UU  W4,#A,W0
03C5E:  ADD     W0,W5,W5
03C60:  MOV     W5,W0
03C62:  ADD     85C,W0
03C64:  MOV     W0,85E
....................                    
....................                   move_pos(step); 
03C66:  PUSH    85E
03C68:  POP     894
03C6A:  CALL    2AD4
....................                   break; 
03C6E:  GOTO    4324
....................       case 'q':   fprintf(RS232,"\n\rEnter Table Index (xx): "); 
03C72:  MOV     #0,W1
03C74:  MOV     W1,W0
03C76:  CALL    1152
03C7A:  INC     W1,W1
03C7C:  MOV     W1,[W15++]
03C7E:  BTSC.B  219.1
03C80:  BRA     3C7E
03C82:  MOV     W0,21A
03C84:  MOV     [--W15],W1
03C86:  MOV     #19,W0
03C88:  CPSGT   W1,W0
03C8A:  BRA     3C74
....................                   unsigned int k=0; 
....................                   unsigned int input_index[2]; 
....................                   unsigned int index=0; 
03C8C:  CLR     860
03C8E:  CLR     866
....................                   for(k=0;k<2;k++){ 
03C90:  CLR     860
03C92:  MOV     860,W4
03C94:  CP      W4,#2
03C96:  BRA     C,3CC8
....................                      input_index[k]=(unsigned)(fgetc(RS232)-48); 
03C98:  MOV     860,W0
03C9A:  SL      W0,#1,W0
03C9C:  MOV     #862,W4
03C9E:  ADD     W0,W4,W5
03CA0:  BTSS.B  218.0
03CA2:  BRA     3CA0
03CA4:  MOV     21C,W0
03CA6:  SUB.B   #30,W0L
03CA8:  CLR.B   1
03CAA:  MOV     W0,[W5]
....................                      fputc(input_index[k]+48,RS232); 
03CAC:  MOV     860,W0
03CAE:  SL      W0,#1,W0
03CB0:  MOV     #862,W4
03CB2:  ADD     W0,W4,W0
03CB4:  MOV     [W0],W5
03CB6:  ADD     #30,W5
03CB8:  MOV.B   W5L,W0L
03CBA:  BTSC.B  219.1
03CBC:  BRA     3CBA
03CBE:  MOV.B   W0L,21A
03CC0:  CLR.B   21B
....................                   } 
03CC2:  INC     0860
03CC4:  GOTO    3C92
....................                   fprintf(RS232,"\n\n\r"); 
03CC8:  BTSC.B  219.1
03CCA:  BRA     3CC8
03CCC:  MOV     #A,W4
03CCE:  MOV     W4,21A
03CD0:  BTSC.B  219.1
03CD2:  BRA     3CD0
03CD4:  MOV     #A,W4
03CD6:  MOV     W4,21A
03CD8:  BTSC.B  219.1
03CDA:  BRA     3CD8
03CDC:  MOV     #D,W4
03CDE:  MOV     W4,21A
....................                    
....................                   index=10*input_index[0]+1*input_index[1]; 
03CE0:  MOV     862,W4
03CE2:  MUL.UU  W4,#A,W0
03CE4:  MOV     W0,W5
03CE6:  MOV     W5,W0
03CE8:  ADD     864,W0
03CEA:  MOV     W0,866
....................                    
....................                   fprintf(RS232,"\n\rIndex: %u", index); 
03CEC:  MOV     #0,W1
03CEE:  MOV     W1,W0
03CF0:  CALL    117A
03CF4:  INC     W1,W1
03CF6:  MOV     W1,[W15++]
03CF8:  BTSC.B  219.1
03CFA:  BRA     3CF8
03CFC:  MOV     W0,21A
03CFE:  MOV     [--W15],W1
03D00:  MOV     #8,W0
03D02:  CPSGT   W1,W0
03D04:  BRA     3CEE
03D06:  MOV     866,W0
03D08:  MOV     #0,W4
03D0A:  CALL    1572
....................                    
....................                   fprintf(RS232,"\n\rEnter Position (xxxx): "); 
03D0E:  MOV     #0,W1
03D10:  MOV     W1,W0
03D12:  CALL    1192
03D16:  INC     W1,W1
03D18:  MOV     W1,[W15++]
03D1A:  BTSC.B  219.1
03D1C:  BRA     3D1A
03D1E:  MOV     W0,21A
03D20:  MOV     [--W15],W1
03D22:  MOV     #18,W0
03D24:  CPSGT   W1,W0
03D26:  BRA     3D10
....................                   unsigned int input_pos[2]; 
....................                   unsigned int posi=0; 
03D28:  CLR     86C
....................                   for(k=0;k<4;k++){ 
03D2A:  CLR     860
03D2C:  MOV     860,W4
03D2E:  CP      W4,#4
03D30:  BRA     C,3D62
....................                      input_pos[k]=(unsigned)(fgetc(RS232)-48); 
03D32:  MOV     860,W0
03D34:  SL      W0,#1,W0
03D36:  MOV     #868,W4
03D38:  ADD     W0,W4,W5
03D3A:  BTSS.B  218.0
03D3C:  BRA     3D3A
03D3E:  MOV     21C,W0
03D40:  SUB.B   #30,W0L
03D42:  CLR.B   1
03D44:  MOV     W0,[W5]
....................                      fputc(input_pos[k]+48,RS232); 
03D46:  MOV     860,W0
03D48:  SL      W0,#1,W0
03D4A:  MOV     #868,W4
03D4C:  ADD     W0,W4,W0
03D4E:  MOV     [W0],W5
03D50:  ADD     #30,W5
03D52:  MOV.B   W5L,W0L
03D54:  BTSC.B  219.1
03D56:  BRA     3D54
03D58:  MOV.B   W0L,21A
03D5A:  CLR.B   21B
....................                   } 
03D5C:  INC     0860
03D5E:  GOTO    3D2C
....................                   fprintf(RS232,"\n\n\r"); 
03D62:  BTSC.B  219.1
03D64:  BRA     3D62
03D66:  MOV     #A,W4
03D68:  MOV     W4,21A
03D6A:  BTSC.B  219.1
03D6C:  BRA     3D6A
03D6E:  MOV     #A,W4
03D70:  MOV     W4,21A
03D72:  BTSC.B  219.1
03D74:  BRA     3D72
03D76:  MOV     #D,W4
03D78:  MOV     W4,21A
....................                    
....................                   posi=1000*input_pos[0]+100*input_pos[1]+10*input_pos[2]+1*input_pos[3]; 
03D7A:  MOV     #3E8,W4
03D7C:  MOV     868,W3
03D7E:  MUL.UU  W4,W3,W0
03D80:  MOV     W0,W5
03D82:  MOV     #64,W4
03D84:  MOV     86A,W3
03D86:  MUL.UU  W4,W3,W0
03D88:  ADD     W0,W5,W5
03D8A:  MOV     86C,W4
03D8C:  MUL.UU  W4,#A,W0
03D8E:  ADD     W0,W5,W5
03D90:  MOV     W5,W0
03D92:  ADD     86E,W0
03D94:  MOV     W0,86C
....................                    
....................                   fprintf(RS232,"\n\rPosition: %u", posi); 
03D96:  MOV     #0,W1
03D98:  MOV     W1,W0
03D9A:  CALL    11B8
03D9E:  INC     W1,W1
03DA0:  MOV     W1,[W15++]
03DA2:  BTSC.B  219.1
03DA4:  BRA     3DA2
03DA6:  MOV     W0,21A
03DA8:  MOV     [--W15],W1
03DAA:  MOV     #B,W0
03DAC:  CPSGT   W1,W0
03DAE:  BRA     3D98
03DB0:  MOV     86C,W0
03DB2:  MOV     #0,W4
03DB4:  CALL    1572
....................                    
....................                   data_set_pos(index, posi); 
03DB8:  MOV.B   866,W0L
03DBA:  MOV.B   W0L,892
03DBC:  PUSH    86C
03DBE:  POP     894
03DC0:  CALL    37AE
....................                   break; 
03DC4:  GOTO    4324
....................       case 'o':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
03DC8:  MOV     #0,W1
03DCA:  MOV     W1,W0
03DCC:  CALL    11D4
03DD0:  INC     W1,W1
03DD2:  MOV     W1,[W15++]
03DD4:  BTSC.B  219.1
03DD6:  BRA     3DD4
03DD8:  MOV     W0,21A
03DDA:  MOV     [--W15],W1
03DDC:  MOV     #F,W0
03DDE:  CPSGT   W1,W0
03DE0:  BRA     3DCA
....................                   unsigned int r=0; 
....................                   unsigned int input_speed[4]; 
....................                   unsigned int delay=0; 
03DE2:  CLR     86E
03DE4:  CLR     878
....................                   for(r=0;r<4;r++){ 
03DE6:  CLR     86E
03DE8:  MOV     86E,W4
03DEA:  CP      W4,#4
03DEC:  BRA     C,3E1E
....................                      input_speed[r]=(unsigned)(fgetc(RS232)-48); 
03DEE:  MOV     86E,W0
03DF0:  SL      W0,#1,W0
03DF2:  MOV     #870,W4
03DF4:  ADD     W0,W4,W5
03DF6:  BTSS.B  218.0
03DF8:  BRA     3DF6
03DFA:  MOV     21C,W0
03DFC:  SUB.B   #30,W0L
03DFE:  CLR.B   1
03E00:  MOV     W0,[W5]
....................                      fputc(input_speed[r]+48,RS232); 
03E02:  MOV     86E,W0
03E04:  SL      W0,#1,W0
03E06:  MOV     #870,W4
03E08:  ADD     W0,W4,W0
03E0A:  MOV     [W0],W5
03E0C:  ADD     #30,W5
03E0E:  MOV.B   W5L,W0L
03E10:  BTSC.B  219.1
03E12:  BRA     3E10
03E14:  MOV.B   W0L,21A
03E16:  CLR.B   21B
....................                   } 
03E18:  INC     086E
03E1A:  GOTO    3DE8
....................                   fprintf(RS232,"\n\r"); 
03E1E:  BTSC.B  219.1
03E20:  BRA     3E1E
03E22:  MOV     #A,W4
03E24:  MOV     W4,21A
03E26:  BTSC.B  219.1
03E28:  BRA     3E26
03E2A:  MOV     #D,W4
03E2C:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
03E2E:  MOV     #3E8,W4
03E30:  MOV     870,W3
03E32:  MUL.UU  W4,W3,W0
03E34:  MOV     W0,W5
03E36:  MOV     #64,W4
03E38:  MOV     872,W3
03E3A:  MUL.UU  W4,W3,W0
03E3C:  ADD     W0,W5,W5
03E3E:  MOV     874,W4
03E40:  MUL.UU  W4,#A,W0
03E42:  ADD     W0,W5,W5
03E44:  MOV     W5,W0
03E46:  ADD     876,W0
03E48:  MOV     W0,878
....................        
....................                   unsigned int m; 
....................                   unsigned int pos_cal=md_min_distance; 
....................                   unsigned int num=(md_move_range-md_min_distance)/40+1; 
03E4A:  PUSH    818
03E4C:  POP     87C
03E4E:  MOV     80E,W4
03E50:  MOV     818,W3
03E52:  SUB     W4,W3,W5
03E54:  MOV     W5,W4
03E56:  MOV     #28,W3
03E58:  REPEAT  #11
03E5A:  DIV.U   W4,W3
03E5C:  MOV     W0,W5
03E5E:  ADD     W5,#1,W5
03E60:  MOV     W5,87E
....................                    
....................                   for(m=0; m<num; m++) 
03E62:  CLR     87A
03E64:  MOV     87A,W0
03E66:  MOV     87E,W4
03E68:  CP      W4,W0
03E6A:  BRA     LEU,3E88
....................                   { 
....................                      move_pos(pos_cal+m*40); 
03E6C:  MOV     87A,W4
03E6E:  MOV     #28,W3
03E70:  MUL.UU  W4,W3,W0
03E72:  MOV     87C,W4
03E74:  ADD     W0,W4,W5
03E76:  MOV     W5,894
03E78:  CALL    2AD4
....................                      delay_ms(delay); 
03E7C:  MOV     878,W0
03E7E:  CALL    155E
....................                   } 
03E82:  INC     087A
03E84:  GOTO    3E64
....................                    
....................                   pos_cal=pos_cal+(num-1)*40; 
03E88:  MOV     87E,W4
03E8A:  SUB     W4,#1,W5
03E8C:  MOV     #28,W4
03E8E:  MUL.UU  W5,W4,W0
03E90:  ADD     87C
....................                    
....................                   for(m=0; m<num; m++) 
03E92:  CLR     87A
03E94:  MOV     87A,W0
03E96:  MOV     87E,W4
03E98:  CP      W4,W0
03E9A:  BRA     LEU,3EB8
....................                   { 
....................                      move_pos(pos_cal-m*40); 
03E9C:  MOV     87A,W4
03E9E:  MOV     #28,W3
03EA0:  MUL.UU  W4,W3,W0
03EA2:  MOV     87C,W4
03EA4:  SUB     W4,W0,W5
03EA6:  MOV     W5,894
03EA8:  CALL    2AD4
....................                      delay_ms(delay); 
03EAC:  MOV     878,W0
03EAE:  CALL    155E
....................                   } 
03EB2:  INC     087A
03EB4:  GOTO    3E94
....................                   break; 
03EB8:  GOTO    4324
....................       case 'l':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
03EBC:  MOV     #0,W1
03EBE:  MOV     W1,W0
03EC0:  CALL    11D4
03EC4:  INC     W1,W1
03EC6:  MOV     W1,[W15++]
03EC8:  BTSC.B  219.1
03ECA:  BRA     3EC8
03ECC:  MOV     W0,21A
03ECE:  MOV     [--W15],W1
03ED0:  MOV     #F,W0
03ED2:  CPSGT   W1,W0
03ED4:  BRA     3EBE
....................                   unsigned int p=0; 
03ED6:  CLR     880
....................                   for(p=0;p<4;p++){ 
03ED8:  CLR     880
03EDA:  MOV     880,W4
03EDC:  CP      W4,#4
03EDE:  BRA     C,3F10
....................                      input_speed[p]=(unsigned)(fgetc(RS232)-48); 
03EE0:  MOV     880,W0
03EE2:  SL      W0,#1,W0
03EE4:  MOV     #870,W4
03EE6:  ADD     W0,W4,W5
03EE8:  BTSS.B  218.0
03EEA:  BRA     3EE8
03EEC:  MOV     21C,W0
03EEE:  SUB.B   #30,W0L
03EF0:  CLR.B   1
03EF2:  MOV     W0,[W5]
....................                      fputc(input_speed[p]+48,RS232); 
03EF4:  MOV     880,W0
03EF6:  SL      W0,#1,W0
03EF8:  MOV     #870,W4
03EFA:  ADD     W0,W4,W0
03EFC:  MOV     [W0],W5
03EFE:  ADD     #30,W5
03F00:  MOV.B   W5L,W0L
03F02:  BTSC.B  219.1
03F04:  BRA     3F02
03F06:  MOV.B   W0L,21A
03F08:  CLR.B   21B
....................                   } 
03F0A:  INC     0880
03F0C:  GOTO    3EDA
....................                   fprintf(RS232,"\n\r"); 
03F10:  BTSC.B  219.1
03F12:  BRA     3F10
03F14:  MOV     #A,W4
03F16:  MOV     W4,21A
03F18:  BTSC.B  219.1
03F1A:  BRA     3F18
03F1C:  MOV     #D,W4
03F1E:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
03F20:  MOV     #3E8,W4
03F22:  MOV     870,W3
03F24:  MUL.UU  W4,W3,W0
03F26:  MOV     W0,W5
03F28:  MOV     #64,W4
03F2A:  MOV     872,W3
03F2C:  MUL.UU  W4,W3,W0
03F2E:  ADD     W0,W5,W5
03F30:  MOV     874,W4
03F32:  MUL.UU  W4,#A,W0
03F34:  ADD     W0,W5,W5
03F36:  MOV     W5,W0
03F38:  ADD     876,W0
03F3A:  MOV     W0,878
....................        
....................                   unsigned int l; 
....................                   unsigned int pos_cal_2=md_min_distance; 
....................                   unsigned int num_2=(md_move_range-md_min_distance)/10+1; 
03F3C:  PUSH    818
03F3E:  POP     884
03F40:  MOV     80E,W4
03F42:  MOV     818,W3
03F44:  SUB     W4,W3,W5
03F46:  MOV     W5,W4
03F48:  MOV     #A,W3
03F4A:  REPEAT  #11
03F4C:  DIV.U   W4,W3
03F4E:  MOV     W0,W5
03F50:  ADD     W5,#1,W5
03F52:  MOV     W5,886
....................                    
....................                   for(l=0; l<num_2; l++) 
03F54:  CLR     882
03F56:  MOV     882,W0
03F58:  MOV     886,W4
03F5A:  CP      W4,W0
03F5C:  BRA     LEU,3F78
....................                   { 
....................                      move_pos(pos_cal_2+l*10); 
03F5E:  MOV     882,W4
03F60:  MUL.UU  W4,#A,W0
03F62:  MOV     884,W4
03F64:  ADD     W0,W4,W5
03F66:  MOV     W5,894
03F68:  CALL    2AD4
....................                      delay_ms(delay); 
03F6C:  MOV     878,W0
03F6E:  CALL    155E
....................                   } 
03F72:  INC     0882
03F74:  GOTO    3F56
....................                    
....................                   pos_cal_2=pos_cal_2+(num_2-1)*10; 
03F78:  MOV     886,W4
03F7A:  SUB     W4,#1,W5
03F7C:  MOV     W5,W4
03F7E:  MUL.UU  W4,#A,W0
03F80:  ADD     884
....................                    
....................                   for(l=0; l<num_2; l++) 
03F82:  CLR     882
03F84:  MOV     882,W0
03F86:  MOV     886,W4
03F88:  CP      W4,W0
03F8A:  BRA     LEU,3FA6
....................                   { 
....................                      move_pos(pos_cal_2-l*10); 
03F8C:  MOV     882,W4
03F8E:  MUL.UU  W4,#A,W0
03F90:  MOV     884,W4
03F92:  SUB     W4,W0,W5
03F94:  MOV     W5,894
03F96:  CALL    2AD4
....................                      delay_ms(delay); 
03F9A:  MOV     878,W0
03F9C:  CALL    155E
....................                   } 
03FA0:  INC     0882
03FA2:  GOTO    3F84
....................                   break; 
03FA6:  GOTO    4324
....................       case 'd':   fprintf(RS232,"\n\rSet debug state\n\r"); 
03FAA:  MOV     #0,W1
03FAC:  MOV     W1,W0
03FAE:  CALL    11F2
03FB2:  INC     W1,W1
03FB4:  MOV     W1,[W15++]
03FB6:  BTSC.B  219.1
03FB8:  BRA     3FB6
03FBA:  MOV     W0,21A
03FBC:  MOV     [--W15],W1
03FBE:  MOV     #12,W0
03FC0:  CPSGT   W1,W0
03FC2:  BRA     3FAC
....................                   fprintf(RS232,"Digital potentiometer (a)(0 or 1): \n\r"); 
03FC4:  MOV     #0,W1
03FC6:  MOV     W1,W0
03FC8:  CALL    1212
03FCC:  INC     W1,W1
03FCE:  MOV     W1,[W15++]
03FD0:  BTSC.B  219.1
03FD2:  BRA     3FD0
03FD4:  MOV     W0,21A
03FD6:  MOV     [--W15],W1
03FD8:  MOV     #24,W0
03FDA:  CPSGT   W1,W0
03FDC:  BRA     3FC6
....................                   fprintf(RS232,"Parallel port         (b)(0 or 1): \n\r"); 
03FDE:  MOV     #0,W1
03FE0:  MOV     W1,W0
03FE2:  CALL    1244
03FE6:  INC     W1,W1
03FE8:  MOV     W1,[W15++]
03FEA:  BTSC.B  219.1
03FEC:  BRA     3FEA
03FEE:  MOV     W0,21A
03FF0:  MOV     [--W15],W1
03FF2:  MOV     #24,W0
03FF4:  CPSGT   W1,W0
03FF6:  BRA     3FE0
....................                   fprintf(RS232,"FRAM                  (c)(0 or 1): \n\r"); 
03FF8:  MOV     #0,W1
03FFA:  MOV     W1,W0
03FFC:  CALL    1276
04000:  INC     W1,W1
04002:  MOV     W1,[W15++]
04004:  BTSC.B  219.1
04006:  BRA     4004
04008:  MOV     W0,21A
0400A:  MOV     [--W15],W1
0400C:  MOV     #24,W0
0400E:  CPSGT   W1,W0
04010:  BRA     3FFA
....................                   fprintf(RS232,"Motor driver          (d)(0 or 1): \n\r"); 
04012:  MOV     #0,W1
04014:  MOV     W1,W0
04016:  CALL    12A8
0401A:  INC     W1,W1
0401C:  MOV     W1,[W15++]
0401E:  BTSC.B  219.1
04020:  BRA     401E
04022:  MOV     W0,21A
04024:  MOV     [--W15],W1
04026:  MOV     #24,W0
04028:  CPSGT   W1,W0
0402A:  BRA     4014
....................                   fprintf(RS232,"Encoder               (e)(0 or 1): \n\r"); 
0402C:  MOV     #0,W1
0402E:  MOV     W1,W0
04030:  CALL    12DA
04034:  INC     W1,W1
04036:  MOV     W1,[W15++]
04038:  BTSC.B  219.1
0403A:  BRA     4038
0403C:  MOV     W0,21A
0403E:  MOV     [--W15],W1
04040:  MOV     #24,W0
04042:  CPSGT   W1,W0
04044:  BRA     402E
....................                   fprintf(RS232,"PWM Module            (f)(0 or 1): \n\r"); 
04046:  MOV     #0,W1
04048:  MOV     W1,W0
0404A:  CALL    130C
0404E:  INC     W1,W1
04050:  MOV     W1,[W15++]
04052:  BTSC.B  219.1
04054:  BRA     4052
04056:  MOV     W0,21A
04058:  MOV     [--W15],W1
0405A:  MOV     #24,W0
0405C:  CPSGT   W1,W0
0405E:  BRA     4048
....................                   fprintf(RS232,"All Modes             (g)(0 or 1): \n\r"); 
04060:  MOV     #0,W1
04062:  MOV     W1,W0
04064:  CALL    133E
04068:  INC     W1,W1
0406A:  MOV     W1,[W15++]
0406C:  BTSC.B  219.1
0406E:  BRA     406C
04070:  MOV     W0,21A
04072:  MOV     [--W15],W1
04074:  MOV     #24,W0
04076:  CPSGT   W1,W0
04078:  BRA     4062
....................                   fprintf(RS232,"Selection (xx): "); 
0407A:  MOV     #0,W1
0407C:  MOV     W1,W0
0407E:  CALL    1370
04082:  INC     W1,W1
04084:  MOV     W1,[W15++]
04086:  BTSC.B  219.1
04088:  BRA     4086
0408A:  MOV     W0,21A
0408C:  MOV     [--W15],W1
0408E:  MOV     #F,W0
04090:  CPSGT   W1,W0
04092:  BRA     407C
....................                    
....................                   int1 value=0; 
....................                   unsigned int f=0; 
....................                   char input_ds[2]; 
04094:  BCLR.B  853.0
04096:  CLR     888
....................                   for(f=0;f<2;f++){ 
04098:  CLR     888
0409A:  MOV     888,W4
0409C:  CP      W4,#2
0409E:  BRA     C,40C6
....................                      input_ds[f]=fgetc(RS232); 
040A0:  MOV     #88A,W4
040A2:  MOV     888,W3
040A4:  ADD     W3,W4,W5
040A6:  BTSS.B  218.0
040A8:  BRA     40A6
040AA:  MOV     21C,W0
040AC:  MOV.B   W0L,[W5]
....................                      fputc(input_ds[f],RS232); 
040AE:  MOV     #88A,W4
040B0:  MOV     888,W3
040B2:  ADD     W3,W4,W0
040B4:  MOV.B   [W0],W5L
040B6:  MOV.B   W5L,W0L
040B8:  BTSC.B  219.1
040BA:  BRA     40B8
040BC:  MOV.B   W0L,21A
040BE:  CLR.B   21B
....................                   } 
040C0:  INC     0888
040C2:  GOTO    409A
....................                   fprintf(RS232,"\n\n\r"); 
040C6:  BTSC.B  219.1
040C8:  BRA     40C6
040CA:  MOV     #A,W4
040CC:  MOV     W4,21A
040CE:  BTSC.B  219.1
040D0:  BRA     40CE
040D2:  MOV     #A,W4
040D4:  MOV     W4,21A
040D6:  BTSC.B  219.1
040D8:  BRA     40D6
040DA:  MOV     #D,W4
040DC:  MOV     W4,21A
....................                    
....................                   if(input_ds[1]=='0') 
040DE:  MOV     88A,W4
040E0:  LSR     W4,#8,W4
040E2:  XOR.B   #30,W4L
040E4:  BRA     NZ,40EC
....................                      value=0; 
040E6:  BCLR.B  853.0
....................                   else if(input_ds[1]=='1') 
040E8:  GOTO    4118
040EC:  MOV     88A,W4
040EE:  LSR     W4,#8,W4
040F0:  XOR.B   #31,W4L
040F2:  BRA     NZ,40FA
....................                      value=1; 
040F4:  BSET.B  853.0
....................                   else 
040F6:  GOTO    4118
....................                   { 
....................                      fprintf(RS232,"Invalid Entry\n\r"); 
040FA:  MOV     #0,W1
040FC:  MOV     W1,W0
040FE:  CALL    138E
04102:  INC     W1,W1
04104:  MOV     W1,[W15++]
04106:  BTSC.B  219.1
04108:  BRA     4106
0410A:  MOV     W0,21A
0410C:  MOV     [--W15],W1
0410E:  MOV     #E,W0
04110:  CPSGT   W1,W0
04112:  BRA     40FC
....................                      break; 
04114:  GOTO    4324
....................                   } 
....................  
....................                   switch (input_ds[0]){ 
04118:  MOV.B   88A,W0L
0411A:  CLR.B   1
0411C:  XOR     #61,W0
0411E:  BRA     Z,413A
04120:  XOR     #3,W0
04122:  BRA     Z,4144
04124:  XOR     #1,W0
04126:  BRA     Z,414E
04128:  XOR     #7,W0
0412A:  BRA     Z,4158
0412C:  XOR     #1,W0
0412E:  BRA     Z,4162
04130:  XOR     #3,W0
04132:  BRA     Z,416C
04134:  XOR     #1,W0
04136:  BRA     Z,4176
04138:  BRA     419E
....................                      case 'a':   debug_mode_dp = value; 
0413A:  BCLR.B  800.0
0413C:  BTSC.B  853.0
0413E:  BSET.B  800.0
....................                                  break; 
04140:  GOTO    41BC
....................                      case 'b':   debug_mode_pp = value; 
04144:  BCLR.B  800.1
04146:  BTSC.B  853.0
04148:  BSET.B  800.1
....................                                  break; 
0414A:  GOTO    41BC
....................                      case 'c':   debug_mode_fr = value; 
0414E:  BCLR.B  800.2
04150:  BTSC.B  853.0
04152:  BSET.B  800.2
....................                                  break; 
04154:  GOTO    41BC
....................                      case 'd':   debug_mode_md = value; 
04158:  BCLR.B  800.3
0415A:  BTSC.B  853.0
0415C:  BSET.B  800.3
....................                                  break; 
0415E:  GOTO    41BC
....................                      case 'e':   debug_mode_qei = value; 
04162:  BCLR.B  800.5
04164:  BTSC.B  853.0
04166:  BSET.B  800.5
....................                                  break; 
04168:  GOTO    41BC
....................                      case 'f':   debug_mode_pwm = value; 
0416C:  BCLR.B  800.4
0416E:  BTSC.B  853.0
04170:  BSET.B  800.4
....................                                  break;           
04172:  GOTO    41BC
....................                      case 'g':   debug_mode_dp = value; 
04176:  BCLR.B  800.0
04178:  BTSC.B  853.0
0417A:  BSET.B  800.0
....................                                  debug_mode_pp = value; 
0417C:  BCLR.B  800.1
0417E:  BTSC.B  853.0
04180:  BSET.B  800.1
....................                                  debug_mode_fr = value; 
04182:  BCLR.B  800.2
04184:  BTSC.B  853.0
04186:  BSET.B  800.2
....................                                  debug_mode_md = value; 
04188:  BCLR.B  800.3
0418A:  BTSC.B  853.0
0418C:  BSET.B  800.3
....................                                  debug_mode_qei = value; 
0418E:  BCLR.B  800.5
04190:  BTSC.B  853.0
04192:  BSET.B  800.5
....................                                  debug_mode_pwm = value; 
04194:  BCLR.B  800.4
04196:  BTSC.B  853.0
04198:  BSET.B  800.4
....................                                  break; 
0419A:  GOTO    41BC
....................                      default:    fprintf(RS232,"Invalid Entry\n\r"); 
0419E:  MOV     #0,W1
041A0:  MOV     W1,W0
041A2:  CALL    138E
041A6:  INC     W1,W1
041A8:  MOV     W1,[W15++]
041AA:  BTSC.B  219.1
041AC:  BRA     41AA
041AE:  MOV     W0,21A
041B0:  MOV     [--W15],W1
041B2:  MOV     #E,W0
041B4:  CPSGT   W1,W0
041B6:  BRA     41A0
....................                                  break; 
041B8:  GOTO    41BC
....................                   } 
....................                   break; 
041BC:  GOTO    4324
....................       case 'w':   fprintf(RS232,"\n\rEncoder count %4u\n\r",qei_get_count()); 
041C0:  CALL    1F8A
041C4:  MOV     W0,W5
041C6:  MOV     #0,W1
041C8:  MOV     W1,W0
041CA:  CALL    13AA
041CE:  INC     W1,W1
041D0:  MOV     W1,[W15++]
041D2:  BTSC.B  219.1
041D4:  BRA     41D2
041D6:  MOV     W0,21A
041D8:  MOV     [--W15],W1
041DA:  MOV     #F,W0
041DC:  CPSGT   W1,W0
041DE:  BRA     41C8
041E0:  MOV     W5,W0
041E2:  MOV     #4,W4
041E4:  CALL    1572
041E8:  BTSC.B  219.1
041EA:  BRA     41E8
041EC:  MOV     #A,W4
041EE:  MOV     W4,21A
041F0:  BTSC.B  219.1
041F2:  BRA     41F0
041F4:  MOV     #D,W4
041F6:  MOV     W4,21A
....................                   break; 
041F8:  GOTO    4324
....................       case 'z':   fprintf(RS232,"\n\rStart Memory Test (Yes -> 1, No -> 0): "); 
041FC:  MOV     #0,W1
041FE:  MOV     W1,W0
04200:  CALL    13CC
04204:  INC     W1,W1
04206:  MOV     W1,[W15++]
04208:  BTSC.B  219.1
0420A:  BRA     4208
0420C:  MOV     W0,21A
0420E:  MOV     [--W15],W1
04210:  MOV     #28,W0
04212:  CPSGT   W1,W0
04214:  BRA     41FE
....................                   unsigned int input_mem_test=(unsigned)(fgetc(RS232)-48); 
04216:  BTSS.B  218.0
04218:  BRA     4216
0421A:  MOV     21C,W0
0421C:  MOV     #30,W4
0421E:  SUB.B   W0L,W4L,W0L
04220:  MOV.B   W0L,88C
04222:  CLR.B   88D
....................                   fputc(input_mem_test+48,RS232); 
04224:  MOV     #30,W4
04226:  MOV     88C,W3
04228:  ADD     W3,W4,W5
0422A:  MOV.B   W5L,W0L
0422C:  BTSC.B  219.1
0422E:  BRA     422C
04230:  MOV.B   W0L,21A
04232:  CLR.B   21B
....................                   
....................                   unsigned int8 mem=0; 
04234:  CLR.B   88E
....................                    
....................                   if(input_mem_test == 1) 
04236:  MOV     88C,W4
04238:  CP      W4,#1
0423A:  BRA     NZ,4290
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
0423C:  CLR.B   88E
0423E:  MOV     88E,W4
04240:  MOV     #64,W3
04242:  CP.B    W3L,W4L
04244:  BRA     LEU,4264
....................                         data_set_pos(mem, mem+1); 
04246:  MOV     88E,W4
04248:  ADD.B   W4L,#1,W4L
0424A:  MOV.B   W4L,W0L
0424C:  MOV.B   W0L,A
0424E:  MOV.B   88E,W0L
04250:  MOV.B   W0L,892
04252:  PUSH    894
04254:  MOV.B   W5L,[W15-#2]
04256:  POP     894
04258:  CLR.B   895
0425A:  CALL    37AE
0425E:  INC.B   088E
04260:  GOTO    423E
....................                          
....................                      fprintf(RS232,"\n\r"); 
04264:  BTSC.B  219.1
04266:  BRA     4264
04268:  MOV     #A,W4
0426A:  MOV     W4,21A
0426C:  BTSC.B  219.1
0426E:  BRA     426C
04270:  MOV     #D,W4
04272:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
04274:  BSET.B  800.2
....................                      for(mem=0; mem<100; mem++) 
04276:  CLR.B   88E
04278:  MOV     88E,W4
0427A:  MOV     #64,W3
0427C:  CP.B    W3L,W4L
0427E:  BRA     LEU,428E
....................                         data_get_pos(mem); 
04280:  MOV.B   88E,W0L
04282:  MOV.B   W0L,896
04284:  CALL    36C8
04288:  INC.B   088E
0428A:  GOTO    4278
....................                      debug_mode_fr=0; 
0428E:  BCLR.B  800.2
....................                   } 
....................                   break; 
04290:  GOTO    4324
....................       case 'f':   fprintf(RS232,"\n\rClear Memory (Yes -> 1, No -> 0): "); 
04294:  MOV     #0,W1
04296:  MOV     W1,W0
04298:  CALL    1404
0429C:  INC     W1,W1
0429E:  MOV     W1,[W15++]
042A0:  BTSC.B  219.1
042A2:  BRA     42A0
042A4:  MOV     W0,21A
042A6:  MOV     [--W15],W1
042A8:  MOV     #23,W0
042AA:  CPSGT   W1,W0
042AC:  BRA     4296
....................                   input_mem_test=(unsigned)(fgetc(RS232)-48); 
042AE:  BTSS.B  218.0
042B0:  BRA     42AE
042B2:  MOV     21C,W0
042B4:  MOV     #30,W4
042B6:  SUB.B   W0L,W4L,W0L
042B8:  MOV.B   W0L,88C
042BA:  CLR.B   88D
....................                   fputc(input_mem_test+48,RS232); 
042BC:  MOV     #30,W4
042BE:  MOV     88C,W3
042C0:  ADD     W3,W4,W5
042C2:  MOV.B   W5L,W0L
042C4:  BTSC.B  219.1
042C6:  BRA     42C4
042C8:  MOV.B   W0L,21A
042CA:  CLR.B   21B
....................                    
....................                   if(input_mem_test == 1) 
042CC:  MOV     88C,W4
042CE:  CP      W4,#1
042D0:  BRA     NZ,4318
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
042D2:  CLR.B   88E
042D4:  MOV     88E,W4
042D6:  MOV     #64,W3
042D8:  CP.B    W3L,W4L
042DA:  BRA     LEU,42EC
....................                         data_set_pos(mem, 0); 
042DC:  MOV.B   88E,W0L
042DE:  MOV.B   W0L,892
042E0:  CLR     894
042E2:  CALL    37AE
042E6:  INC.B   088E
042E8:  GOTO    42D4
....................                          
....................                      fprintf(RS232,"\n\r"); 
042EC:  BTSC.B  219.1
042EE:  BRA     42EC
042F0:  MOV     #A,W4
042F2:  MOV     W4,21A
042F4:  BTSC.B  219.1
042F6:  BRA     42F4
042F8:  MOV     #D,W4
042FA:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
042FC:  BSET.B  800.2
....................                      for(mem=0; mem<100; mem++) 
042FE:  CLR.B   88E
04300:  MOV     88E,W4
04302:  MOV     #64,W3
04304:  CP.B    W3L,W4L
04306:  BRA     LEU,4316
....................                         data_get_pos(mem); 
04308:  MOV.B   88E,W0L
0430A:  MOV.B   W0L,896
0430C:  CALL    36C8
04310:  INC.B   088E
04312:  GOTO    4300
....................                      debug_mode_fr=0; 
04316:  BCLR.B  800.2
....................                   } 
....................                   break; 
04318:  GOTO    4324
....................       case 'g':    
....................                   break; 
0431C:  GOTO    4324
....................       case 'y':    
....................                   break; 
04320:  GOTO    4324
....................    } 
....................     
....................    return; 
.................... } 
04324:  MOV     [--W15],W6
04326:  MOV     [--W15],W5
04328:  RETURN  
....................  
.................... // Parallel port strobe signal interrupt 
.................... #INT_EXT3 
.................... void isr_pp_strobe() 
.................... { 
*
0151E:  PUSH    42
01520:  PUSH    36
01522:  MOV     W0,[W15++]
01524:  MOV     #2,W0
01526:  REPEAT  #C
01528:  MOV     [W0++],[W15++]
....................    if(reg_comm_type == 0) 
0152A:  BTSC.B  800.6
0152C:  BRA     1530
....................       reg_pp_strobe = 1; 
0152E:  BSET.B  84C.0
.................... } 
.................... // RS232 receive byte interrupt 
01530:  BCLR.B  88.4
01532:  MOV     #1A,W0
01534:  REPEAT  #C
01536:  MOV     [--W15],[W0--]
01538:  MOV     [--W15],W0
0153A:  POP     36
0153C:  POP     42
0153E:  RETFIE  
.................... #INT_RDA2 
.................... void isr_rs232_message() 
.................... { 
01540:  PUSH    42
01542:  PUSH    36
01544:  MOV     W0,[W15++]
01546:  MOV     #2,W0
01548:  REPEAT  #C
0154A:  MOV     [W0++],[W15++]
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1;   
0154C:  BSET.B  84C.3
.................... }  
.................... // Clears RS232 interrupt flags 
0154E:  BCLR.B  87.0
01550:  MOV     #1A,W0
01552:  REPEAT  #C
01554:  MOV     [--W15],[W0--]
01556:  MOV     [--W15],W0
01558:  POP     36
0155A:  POP     42
0155C:  RETFIE  
.................... void rs232_clear() 
.................... { 
....................    UART_IFS0_U1RXIF = 0; 
....................    UART_IFS0_U1TXIF = 0; 
....................    reg_rs232_message = 0; 
.................... } 
....................  
.................... // Main method 
.................... void main() 
.................... { 
*
04752:  BSET.B  81.7
04754:  MOV     #8000,W4
04756:  MOV     W4,20C
04758:  MOV     #400,W4
0475A:  MOV     W4,20E
0475C:  MOV     #30,W4
0475E:  MOV     W4,214
04760:  MOV     #8000,W4
04762:  MOV     W4,216
04764:  MOV     #400,W4
04766:  MOV     W4,218
04768:  MOV     #30,W4
0476A:  MOV     W4,21E
0476C:  BCLR.B  800.0
0476E:  BCLR.B  800.1
04770:  BCLR.B  800.2
04772:  BCLR.B  800.3
04774:  BCLR.B  800.4
04776:  BCLR.B  800.5
04778:  MOV     #20,W4
0477A:  MOV     W4,802
0477C:  MOV     #3FF,W4
0477E:  MOV     W4,804
04780:  MOV     #323,W4
04782:  MOV     W4,806
04784:  MOV     #46,W4
04786:  MOV     W4,808
04788:  MOV     #1C,W4
0478A:  MOV     W4,80A
0478C:  CLR     80C
0478E:  MOV     #190,W4
04790:  MOV     W4,80E
04792:  MOV     #2D,W4
04794:  MOV     W4,810
04796:  MOV     #3E8,W4
04798:  MOV     W4,812
0479A:  MOV     #32,W4
0479C:  MOV     W4,814
0479E:  MOV     #64,W4
047A0:  MOV     W4,816
047A2:  MOV     #46,W4
047A4:  MOV     W4,818
047A6:  CLR     81A
047A8:  MOV     #BB8,W4
047AA:  MOV     W4,81C
047AC:  MOV     #BB8,W4
047AE:  MOV     W4,81E
047B0:  MOV     #64,W4
047B2:  MOV     W4,820
047B4:  CLR.B   801
047B6:  CLR     822
047B8:  CLR     824
047BA:  CLR     826
047BC:  CLR     828
047BE:  CLR     82A
047C0:  CLR     82C
047C2:  CLR     82E
047C4:  CLR     830
047C6:  CLR     832
047C8:  MOV     #D,W4
047CA:  MOV     W4,834
047CC:  MOV     #F,W4
047CE:  MOV     W4,836
047D0:  MOV     #11,W4
047D2:  MOV     W4,838
047D4:  MOV     #13,W4
047D6:  MOV     W4,83A
047D8:  MOV     #15,W4
047DA:  MOV     W4,83C
047DC:  MOV     #17,W4
047DE:  MOV     W4,83E
047E0:  MOV     #18,W4
047E2:  MOV     W4,840
047E4:  MOV     #1A,W4
047E6:  MOV     W4,842
047E8:  MOV     #A,W4
047EA:  MOV     W4,844
047EC:  MOV     #1,W4
047EE:  MOV     W4,846
047F0:  MOV     #64,W4
047F2:  MOV     W4,848
047F4:  MOV     #64,W4
047F6:  MOV     W4,84A
047F8:  BCLR.B  800.6
047FA:  BCLR.B  800.7
047FC:  BCLR.B  84C.0
047FE:  BCLR.B  84C.1
04800:  BCLR.B  84C.2
04802:  BCLR.B  84C.3
04804:  BCLR.B  84C.4
04806:  MOV     #58,W4
04808:  MOV     W4,84E
0480A:  SETM    2A8
0480C:  MOV     #2780,W15
0480E:  MOV     #27FF,W0
04810:  MOV     W0,20
04812:  NOP     
....................    // Set I/O states of the ports 
....................    //           FEDCBA9876543210 
....................    set_tris_b(0b1111111011111100); 
04814:  MOV     #FEFC,W4
04816:  MOV     W4,2C6
....................    set_tris_c(0b1111111111111111); 
04818:  SETM    2CC
....................    set_tris_d(0b1111111100001111); 
0481A:  MOV     #FF0F,W4
0481C:  MOV     W4,2D2
....................    set_tris_e(0b1111111110000000); 
0481E:  MOV     #FF80,W4
04820:  MOV     W4,2D8
....................    set_tris_f(0b1111111111111100); 
04822:  MOV     #FFFC,W4
04824:  MOV     W4,2DE
....................    set_tris_g(0b1111111100111111); 
04826:  MOV     #FF3F,W4
04828:  MOV     W4,2E4
....................     
....................    // Set parallel port pins 
....................    output_low(PP_ACK); 
0482A:  BCLR.B  2D2.4
0482C:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
0482E:  BCLR.B  2D2.5
04830:  BCLR.B  2D6.5
....................     
....................    // Turn on debug led 
....................    output_high(LED); 
04832:  BCLR.B  2C7.0
04834:  BSET.B  2CB.0
....................     
....................    //Turn on lasers 
....................    output_high(LAS_1); 
04836:  BCLR.B  2C6.0
04838:  BSET.B  2CA.0
....................    output_high(LAS_2); 
0483A:  BCLR.B  2C6.1
0483C:  BSET.B  2CA.1
....................    output_high(LAS_3); 
0483E:  BCLR.B  2D2.6
04840:  BSET.B  2D6.6
....................  
....................    // Set A/D converter to read motor torque control voltage 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
04842:  MOV     #80,W4
04844:  MOV     W4,2A4
04846:  MOV     #80E0,W4
04848:  MOV     W4,2A0
....................    setup_adc_ports(sAN2); 
0484A:  MOV     #FFFB,W4
0484C:  MOV     W4,2A8
0484E:  CLR     2A2
....................    set_adc_channel(2); 
04850:  MOV     #2,W4
04852:  MOV     W4,2A6
....................     
....................    delay_ms(500); 
04854:  MOV     #1F4,W0
04856:  CALL    155E
....................     
....................    fprintf(RS232,"\n\r"); 
0485A:  BTSC.B  219.1
0485C:  BRA     485A
0485E:  MOV     #A,W4
04860:  MOV     W4,21A
04862:  BTSC.B  219.1
04864:  BRA     4862
04866:  MOV     #D,W4
04868:  MOV     W4,21A
....................    fprintf(RS232,"______________________________________________________________\n\r"); 
0486A:  MOV.B   #3E,W5L
0486C:  MOV     #5F,W0
0486E:  BTSC.B  219.1
04870:  BRA     486E
04872:  MOV.B   W0L,21A
04874:  CLR.B   21B
04876:  DEC.B   000A
04878:  BTSS.B  42.1
0487A:  BRA     486C
0487C:  BTSC.B  219.1
0487E:  BRA     487C
04880:  MOV     #A,W4
04882:  MOV     W4,21A
04884:  BTSC.B  219.1
04886:  BRA     4884
04888:  MOV     #D,W4
0488A:  MOV     W4,21A
....................    fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING SYSTEM\n\n\r"); 
0488C:  MOV     #0,W1
0488E:  MOV     W1,W0
04890:  CALL    1436
04894:  INC     W1,W1
04896:  MOV     W1,[W15++]
04898:  BTSC.B  219.1
0489A:  BRA     4898
0489C:  MOV     W0,21A
0489E:  MOV     [--W15],W1
048A0:  MOV     #25,W0
048A2:  CPSGT   W1,W0
048A4:  BRA     488E
....................    fprintf(RS232,"Press 'c' for command list\n\n\r"); 
048A6:  MOV     #0,W1
048A8:  MOV     W1,W0
048AA:  CALL    146A
048AE:  INC     W1,W1
048B0:  MOV     W1,[W15++]
048B2:  BTSC.B  219.1
048B4:  BRA     48B2
048B6:  MOV     W0,21A
048B8:  MOV     [--W15],W1
048BA:  MOV     #1C,W0
048BC:  CPSGT   W1,W0
048BE:  BRA     48A8
....................    fprintf(RS232,"RCON REGISTER VALUE(10'luk Tabanda):  "); 
048C0:  MOV     #0,W1
048C2:  MOV     W1,W0
048C4:  CALL    1494
048C8:  INC     W1,W1
048CA:  MOV     W1,[W15++]
048CC:  BTSC.B  219.1
048CE:  BRA     48CC
048D0:  MOV     W0,21A
048D2:  MOV     [--W15],W1
048D4:  MOV     #25,W0
048D6:  CPSGT   W1,W0
048D8:  BRA     48C2
....................    fprintf(RS232,"%u",RCON); 
048DA:  MOV     740,W0
048DC:  MOV     #0,W4
048DE:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
048E2:  BTSC.B  219.1
048E4:  BRA     48E2
048E6:  MOV     #A,W4
048E8:  MOV     W4,21A
048EA:  BTSC.B  219.1
048EC:  BRA     48EA
048EE:  MOV     #D,W4
048F0:  MOV     W4,21A
....................    fprintf(RS232,"RCON REGISTER BITLERI:"); 
048F2:  MOV     #0,W1
048F4:  MOV     W1,W0
048F6:  CALL    14C8
048FA:  INC     W1,W1
048FC:  MOV     W1,[W15++]
048FE:  BTSC.B  219.1
04900:  BRA     48FE
04902:  MOV     W0,21A
04904:  MOV     [--W15],W1
04906:  MOV     #15,W0
04908:  CPSGT   W1,W0
0490A:  BRA     48F4
....................    fprintf(RS232,"\n\r"); 
0490C:  BTSC.B  219.1
0490E:  BRA     490C
04910:  MOV     #A,W4
04912:  MOV     W4,21A
04914:  BTSC.B  219.1
04916:  BRA     4914
04918:  MOV     #D,W4
0491A:  MOV     W4,21A
....................     
....................    fprintf(RS232,"POR:    "); 
0491C:  MOV     #0,W1
0491E:  MOV     W1,W0
04920:  CALL    56A
04924:  INC     W1,W1
04926:  MOV     W1,[W15++]
04928:  BTSC.B  219.1
0492A:  BRA     4928
0492C:  MOV     W0,21A
0492E:  MOV     [--W15],W1
04930:  MOV     #7,W0
04932:  CPSGT   W1,W0
04934:  BRA     491E
....................    fprintf(RS232,"%u",RCON_POR); 
04936:  CLR.B   W0
04938:  BTSC.B  740.0
0493A:  INC     W0,W0
0493C:  MOV.B   W0L,W5L
0493E:  MOV.B   W5L,W0L
04940:  CLR.B   1
04942:  MOV     #0,W4
04944:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04948:  BTSC.B  219.1
0494A:  BRA     4948
0494C:  MOV     #A,W4
0494E:  MOV     W4,21A
04950:  BTSC.B  219.1
04952:  BRA     4950
04954:  MOV     #D,W4
04956:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BOR:    "); 
04958:  MOV     #0,W1
0495A:  MOV     W1,W0
0495C:  CALL    580
04960:  INC     W1,W1
04962:  MOV     W1,[W15++]
04964:  BTSC.B  219.1
04966:  BRA     4964
04968:  MOV     W0,21A
0496A:  MOV     [--W15],W1
0496C:  MOV     #7,W0
0496E:  CPSGT   W1,W0
04970:  BRA     495A
....................    fprintf(RS232,"%u",RCON_BOR); 
04972:  CLR.B   W0
04974:  BTSC.B  740.1
04976:  INC     W0,W0
04978:  MOV.B   W0L,W5L
0497A:  MOV.B   W5L,W0L
0497C:  CLR.B   1
0497E:  MOV     #0,W4
04980:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04984:  BTSC.B  219.1
04986:  BRA     4984
04988:  MOV     #A,W4
0498A:  MOV     W4,21A
0498C:  BTSC.B  219.1
0498E:  BRA     498C
04990:  MOV     #D,W4
04992:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IDLE:   "); 
04994:  MOV     #0,W1
04996:  MOV     W1,W0
04998:  CALL    596
0499C:  INC     W1,W1
0499E:  MOV     W1,[W15++]
049A0:  BTSC.B  219.1
049A2:  BRA     49A0
049A4:  MOV     W0,21A
049A6:  MOV     [--W15],W1
049A8:  MOV     #7,W0
049AA:  CPSGT   W1,W0
049AC:  BRA     4996
....................    fprintf(RS232,"%u",RCON_IDLE); 
049AE:  CLR.B   W0
049B0:  BTSC.B  740.2
049B2:  INC     W0,W0
049B4:  MOV.B   W0L,W5L
049B6:  MOV.B   W5L,W0L
049B8:  CLR.B   1
049BA:  MOV     #0,W4
049BC:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
049C0:  BTSC.B  219.1
049C2:  BRA     49C0
049C4:  MOV     #A,W4
049C6:  MOV     W4,21A
049C8:  BTSC.B  219.1
049CA:  BRA     49C8
049CC:  MOV     #D,W4
049CE:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SLEEP:  "); 
049D0:  MOV     #0,W1
049D2:  MOV     W1,W0
049D4:  CALL    5AC
049D8:  INC     W1,W1
049DA:  MOV     W1,[W15++]
049DC:  BTSC.B  219.1
049DE:  BRA     49DC
049E0:  MOV     W0,21A
049E2:  MOV     [--W15],W1
049E4:  MOV     #7,W0
049E6:  CPSGT   W1,W0
049E8:  BRA     49D2
....................    fprintf(RS232,"%u",RCON_SLEEP); 
049EA:  CLR.B   W0
049EC:  BTSC.B  740.3
049EE:  INC     W0,W0
049F0:  MOV.B   W0L,W5L
049F2:  MOV.B   W5L,W0L
049F4:  CLR.B   1
049F6:  MOV     #0,W4
049F8:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
049FC:  BTSC.B  219.1
049FE:  BRA     49FC
04A00:  MOV     #A,W4
04A02:  MOV     W4,21A
04A04:  BTSC.B  219.1
04A06:  BRA     4A04
04A08:  MOV     #D,W4
04A0A:  MOV     W4,21A
....................     
....................    fprintf(RS232,"WDTO:   "); 
04A0C:  MOV     #0,W1
04A0E:  MOV     W1,W0
04A10:  CALL    5C2
04A14:  INC     W1,W1
04A16:  MOV     W1,[W15++]
04A18:  BTSC.B  219.1
04A1A:  BRA     4A18
04A1C:  MOV     W0,21A
04A1E:  MOV     [--W15],W1
04A20:  MOV     #7,W0
04A22:  CPSGT   W1,W0
04A24:  BRA     4A0E
....................    fprintf(RS232,"%u",RCON_WDTO); 
04A26:  CLR.B   W0
04A28:  BTSC.B  740.4
04A2A:  INC     W0,W0
04A2C:  MOV.B   W0L,W5L
04A2E:  MOV.B   W5L,W0L
04A30:  CLR.B   1
04A32:  MOV     #0,W4
04A34:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04A38:  BTSC.B  219.1
04A3A:  BRA     4A38
04A3C:  MOV     #A,W4
04A3E:  MOV     W4,21A
04A40:  BTSC.B  219.1
04A42:  BRA     4A40
04A44:  MOV     #D,W4
04A46:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWDTEN: "); 
04A48:  MOV     #0,W1
04A4A:  MOV     W1,W0
04A4C:  CALL    5D8
04A50:  INC     W1,W1
04A52:  MOV     W1,[W15++]
04A54:  BTSC.B  219.1
04A56:  BRA     4A54
04A58:  MOV     W0,21A
04A5A:  MOV     [--W15],W1
04A5C:  MOV     #7,W0
04A5E:  CPSGT   W1,W0
04A60:  BRA     4A4A
....................    fprintf(RS232,"%u",RCON_SWDTEN); 
04A62:  CLR.B   W0
04A64:  BTSC.B  740.5
04A66:  INC     W0,W0
04A68:  MOV.B   W0L,W5L
04A6A:  MOV.B   W5L,W0L
04A6C:  CLR.B   1
04A6E:  MOV     #0,W4
04A70:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04A74:  BTSC.B  219.1
04A76:  BRA     4A74
04A78:  MOV     #A,W4
04A7A:  MOV     W4,21A
04A7C:  BTSC.B  219.1
04A7E:  BRA     4A7C
04A80:  MOV     #D,W4
04A82:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWR:    "); 
04A84:  MOV     #0,W1
04A86:  MOV     W1,W0
04A88:  CALL    5EE
04A8C:  INC     W1,W1
04A8E:  MOV     W1,[W15++]
04A90:  BTSC.B  219.1
04A92:  BRA     4A90
04A94:  MOV     W0,21A
04A96:  MOV     [--W15],W1
04A98:  MOV     #7,W0
04A9A:  CPSGT   W1,W0
04A9C:  BRA     4A86
....................    fprintf(RS232,"%u",RCON_SWR); 
04A9E:  CLR.B   W0
04AA0:  BTSC.B  740.6
04AA2:  INC     W0,W0
04AA4:  MOV.B   W0L,W5L
04AA6:  MOV.B   W5L,W0L
04AA8:  CLR.B   1
04AAA:  MOV     #0,W4
04AAC:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04AB0:  BTSC.B  219.1
04AB2:  BRA     4AB0
04AB4:  MOV     #A,W4
04AB6:  MOV     W4,21A
04AB8:  BTSC.B  219.1
04ABA:  BRA     4AB8
04ABC:  MOV     #D,W4
04ABE:  MOV     W4,21A
....................     
....................    fprintf(RS232,"EXTR:   "); 
04AC0:  MOV     #0,W1
04AC2:  MOV     W1,W0
04AC4:  CALL    604
04AC8:  INC     W1,W1
04ACA:  MOV     W1,[W15++]
04ACC:  BTSC.B  219.1
04ACE:  BRA     4ACC
04AD0:  MOV     W0,21A
04AD2:  MOV     [--W15],W1
04AD4:  MOV     #7,W0
04AD6:  CPSGT   W1,W0
04AD8:  BRA     4AC2
....................    fprintf(RS232,"%u",RCON_EXTR); 
04ADA:  CLR.B   W0
04ADC:  BTSC.B  740.7
04ADE:  INC     W0,W0
04AE0:  MOV.B   W0L,W5L
04AE2:  MOV.B   W5L,W0L
04AE4:  CLR.B   1
04AE6:  MOV     #0,W4
04AE8:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04AEC:  BTSC.B  219.1
04AEE:  BRA     4AEC
04AF0:  MOV     #A,W4
04AF2:  MOV     W4,21A
04AF4:  BTSC.B  219.1
04AF6:  BRA     4AF4
04AF8:  MOV     #D,W4
04AFA:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BGST:   "); 
04AFC:  MOV     #0,W1
04AFE:  MOV     W1,W0
04B00:  CALL    61A
04B04:  INC     W1,W1
04B06:  MOV     W1,[W15++]
04B08:  BTSC.B  219.1
04B0A:  BRA     4B08
04B0C:  MOV     W0,21A
04B0E:  MOV     [--W15],W1
04B10:  MOV     #7,W0
04B12:  CPSGT   W1,W0
04B14:  BRA     4AFE
....................    fprintf(RS232,"%u",RCON_BGST); 
04B16:  CLR.B   W0
04B18:  BTSC.B  741.5
04B1A:  INC     W0,W0
04B1C:  MOV.B   W0L,W5L
04B1E:  MOV.B   W5L,W0L
04B20:  CLR.B   1
04B22:  MOV     #0,W4
04B24:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04B28:  BTSC.B  219.1
04B2A:  BRA     4B28
04B2C:  MOV     #A,W4
04B2E:  MOV     W4,21A
04B30:  BTSC.B  219.1
04B32:  BRA     4B30
04B34:  MOV     #D,W4
04B36:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IOPUWR: "); 
04B38:  MOV     #0,W1
04B3A:  MOV     W1,W0
04B3C:  CALL    630
04B40:  INC     W1,W1
04B42:  MOV     W1,[W15++]
04B44:  BTSC.B  219.1
04B46:  BRA     4B44
04B48:  MOV     W0,21A
04B4A:  MOV     [--W15],W1
04B4C:  MOV     #7,W0
04B4E:  CPSGT   W1,W0
04B50:  BRA     4B3A
....................    fprintf(RS232,"%u",RCON_IOPUWR); 
04B52:  CLR.B   W0
04B54:  BTSC.B  741.6
04B56:  INC     W0,W0
04B58:  MOV.B   W0L,W5L
04B5A:  MOV.B   W5L,W0L
04B5C:  CLR.B   1
04B5E:  MOV     #0,W4
04B60:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04B64:  BTSC.B  219.1
04B66:  BRA     4B64
04B68:  MOV     #A,W4
04B6A:  MOV     W4,21A
04B6C:  BTSC.B  219.1
04B6E:  BRA     4B6C
04B70:  MOV     #D,W4
04B72:  MOV     W4,21A
....................     
....................    fprintf(RS232,"TRAPR:  "); 
04B74:  MOV     #0,W1
04B76:  MOV     W1,W0
04B78:  CALL    646
04B7C:  INC     W1,W1
04B7E:  MOV     W1,[W15++]
04B80:  BTSC.B  219.1
04B82:  BRA     4B80
04B84:  MOV     W0,21A
04B86:  MOV     [--W15],W1
04B88:  MOV     #7,W0
04B8A:  CPSGT   W1,W0
04B8C:  BRA     4B76
....................    fprintf(RS232,"%u",RCON_TRAPR); 
04B8E:  CLR.B   W0
04B90:  BTSC.B  741.7
04B92:  INC     W0,W0
04B94:  MOV.B   W0L,W5L
04B96:  MOV.B   W5L,W0L
04B98:  CLR.B   1
04B9A:  MOV     #0,W4
04B9C:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04BA0:  BTSC.B  219.1
04BA2:  BRA     4BA0
04BA4:  MOV     #A,W4
04BA6:  MOV     W4,21A
04BA8:  BTSC.B  219.1
04BAA:  BRA     4BA8
04BAC:  MOV     #D,W4
04BAE:  MOV     W4,21A
....................     
....................    fprintf(RS232,"Register Ekrana Yazdirilip Sifirlandi"); 
04BB0:  MOV     #0,W1
04BB2:  MOV     W1,W0
04BB4:  CALL    14EC
04BB8:  INC     W1,W1
04BBA:  MOV     W1,[W15++]
04BBC:  BTSC.B  219.1
04BBE:  BRA     4BBC
04BC0:  MOV     W0,21A
04BC2:  MOV     [--W15],W1
04BC4:  MOV     #24,W0
04BC6:  CPSGT   W1,W0
04BC8:  BRA     4BB2
....................    fprintf(RS232,"\n\r"); 
04BCA:  BTSC.B  219.1
04BCC:  BRA     4BCA
04BCE:  MOV     #A,W4
04BD0:  MOV     W4,21A
04BD2:  BTSC.B  219.1
04BD4:  BRA     4BD2
04BD6:  MOV     #D,W4
04BD8:  MOV     W4,21A
....................    RCON = 0x0000; 
04BDA:  CLR     740
....................     
....................    // Initialize components 
....................    qei_init();                            // Initialize quadrature encoder  
04BDC:  CALL    1628
....................    pwm_init();                            // Initialize PWM module 
04BE0:  CALL    168E
....................    dp_init();                             // Initialize digital potentiometer 
04BE4:  CALL    16CE
....................    md_init();                             // Initialize motor driver 
04BE8:  CALL    1BF6
....................    fr_init();                             // Initialize FRAM 
04BEC:  CALL    1C20
....................    move_init();                           // Initializes the system for movement 
04BF0:  CALL    2D7E
....................     
....................    // Enable RS232 receive byte interrupt 
....................    enable_interrupts(INT_RDA2); 
04BF4:  BSET.B  8F.0
....................    // Enable parallel port strobe signal interrupt 
....................    ext_int_edge(3, H_TO_L); 
04BF6:  BSET.B  82.3
....................    enable_interrupts(INT_EXT3); 
04BF8:  BSET.B  90.4
....................     
....................    reg_comm_type = data_get_comm_type();  // Set communication type 
04BFA:  CALL    2E16
04BFE:  BCLR.B  800.6
04C00:  BTSC.B  0.0
04C02:  BSET.B  800.6
....................     
....................    switch (reg_comm_type) 
....................    { 
04C04:  CLR.B   W0
04C06:  BTSC.B  800.6
04C08:  INC     W0,W0
04C0A:  CLR.B   1
04C0C:  XOR     #0,W0
04C0E:  BRA     Z,4C16
04C10:  XOR     #1,W0
04C12:  BRA     Z,4C22
04C14:  BRA     4C2E
....................       case 0   :  output_high(PP_ACK); 
04C16:  BCLR.B  2D2.4
04C18:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04C1A:  BCLR.B  2D2.5
04C1C:  BSET.B  2D6.5
....................                   break; 
04C1E:  GOTO    4C44
....................       case 1   :  output_low(PP_ACK); 
04C22:  BCLR.B  2D2.4
04C24:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
04C26:  BCLR.B  2D2.5
04C28:  BCLR.B  2D6.5
....................                   break; 
04C2A:  GOTO    4C44
....................       default:    output_high(PP_ACK); 
04C2E:  BCLR.B  2D2.4
04C30:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04C32:  BCLR.B  2D2.5
04C34:  BSET.B  2D6.5
....................                   fr_write_byte(fr_comm_type, 0); 
04C36:  CLR.B   8AE
04C38:  PUSH    83E
04C3A:  POP     8AC
04C3C:  CALL    2264
....................                   break; 
04C40:  GOTO    4C44
....................    } 
....................     
....................    while(true) 
....................    { 
....................       if(reg_rs232_message) 
04C44:  BTSS.B  84C.3
04C46:  BRA     4C52
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04C48:  BCLR.B  8F.0
....................  
....................          rs232_message(); 
04C4A:  CALL    37CA
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
....................          enable_interrupts(INT_RDA2); 
04C4E:  BSET.B  8F.0
....................          reg_rs232_message = 0; 
04C50:  BCLR.B  84C.3
....................       } 
....................       if(reg_pp_strobe) 
04C52:  BTSS.B  84C.0
04C54:  BRA     4CDA
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04C56:  BCLR.B  8F.0
....................           
....................          reg_pp_strobe=0; 
04C58:  BCLR.B  84C.0
....................           
....................          if(debug_mode_pp) 
04C5A:  BTSS.B  800.1
04C5C:  BRA     4C78
....................             fprintf(RS232,"Strobe received\n\r"); 
04C5E:  MOV     #0,W1
04C60:  MOV     W1,W0
04C62:  CALL    B98
04C66:  INC     W1,W1
04C68:  MOV     W1,[W15++]
04C6A:  BTSC.B  219.1
04C6C:  BRA     4C6A
04C6E:  MOV     W0,21A
04C70:  MOV     [--W15],W1
04C72:  MOV     #10,W0
04C74:  CPSGT   W1,W0
04C76:  BRA     4C60
....................  
....................          unsigned int i; 
....................          for(i=0; i<pp_str_check; i++) 
04C78:  CLR     850
04C7A:  MOV     850,W0
04C7C:  MOV     844,W4
04C7E:  CP      W4,W0
04C80:  BRA     LEU,4CB4
....................          { 
....................             delay_ms(pp_str_delay); 
04C82:  MOV     846,W0
04C84:  CALL    155E
....................             if(input(PP_STR)==1) 
04C88:  BSET.B  2D3.2
04C8A:  BTSS.B  2D5.2
04C8C:  BRA     4CAE
....................             { 
....................                if(debug_mode_pp) 
04C8E:  BTSS.B  800.1
04C90:  BRA     4CAC
....................                   fprintf(RS232,"Strobe signal rejected\n\r"); 
04C92:  MOV     #0,W1
04C94:  MOV     W1,W0
04C96:  CALL    BB6
04C9A:  INC     W1,W1
04C9C:  MOV     W1,[W15++]
04C9E:  BTSC.B  219.1
04CA0:  BRA     4C9E
04CA2:  MOV     W0,21A
04CA4:  MOV     [--W15],W1
04CA6:  MOV     #17,W0
04CA8:  CPSGT   W1,W0
04CAA:  BRA     4C94
....................                return; 
04CAC:  BRA     4CDE
....................             } 
....................          } 
04CAE:  INC     0850
04CB0:  GOTO    4C7A
....................           
....................          if(debug_mode_pp) 
04CB4:  BTSS.B  800.1
04CB6:  BRA     4CD2
....................             fprintf(RS232,"Strobe confirmed\n\r"); 
04CB8:  MOV     #0,W1
04CBA:  MOV     W1,W0
04CBC:  CALL    BDC
04CC0:  INC     W1,W1
04CC2:  MOV     W1,[W15++]
04CC4:  BTSC.B  219.1
04CC6:  BRA     4CC4
04CC8:  MOV     W0,21A
04CCA:  MOV     [--W15],W1
04CCC:  MOV     #11,W0
04CCE:  CPSGT   W1,W0
04CD0:  BRA     4CBA
....................  
....................          pp_get_command(); 
04CD2:  CALL    4652
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
....................          enable_interrupts(INT_RDA2); 
04CD6:  BSET.B  8F.0
....................          reg_rs232_message = 0; 
04CD8:  BCLR.B  84C.3
....................       } 
....................    } 
04CDA:  GOTO    4C44
.................... } 
04CDE:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C713   NOCKSFSM HS2_PLL16 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 07B3   PUT64 BROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN NOMCLR
          H: 0000  
   Word  4L: 310F   WRTB NOBSS NOEBS NORBS
          H: 0000  
   Word  5L: 330F   NOWRTSS NOSSS NORSS NOESS
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  

CCS PCD C Compiler, Version 4.108, 15145               07-Mar-14 10:35

               Filename: E:\File Server\Modesis\Proje Dosyalarý\LPS - Lazer Projeksiyon Sistemi\Eski Dosyalar\Software\SLS_6015_Servo_Lazer_Control_v3.5 - reset\Control_Card_v2.0.lst

               ROM used: 19016 bytes (19%)
                         Largest free fragment is 46520
               RAM used: 209 (3%) at main() level
                         437 (5%) worst case
               Stack:    9 worst case (8 in main + 1 for interrupts)

*
00000:  GOTO    44BA
*
00044:  DATA    40,15,00
*
0005C:  DATA    1E,15,00
.................... #INCLUDE <30f6015.h>  
.................... //////// Standard Header file for the DSPIC30F6015 device //////////////// 
.................... #device DSPIC30F6015 
.................... #list 
....................  
.................... #DEVICE ADC=10                                                    // Configures the read_adc return size as 10 bit 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                                                      // No Watch Dog Timer  
.................... #FUSES HS2_PLL16                                                  // HS crystal, Freq=16*(Fcryst/2) 
.................... #FUSES NOCKSFSM                                                   // Clock Switching is disabled, fail Safe clock monitor is disabled  
.................... #FUSES BROWNOUT                                                   // Reset when brownout detected  
.................... #FUSES NOPROTECT                                                  // Code not protected from reading  
.................... #FUSES NOWRT                                                      // Program memory not write protected  
.................... #FUSES NODEBUG                                                    // No Debug mode for ICD 
....................  
.................... #USE DELAY(clock=120000000)                                       // delay() func. adjusted for 120Mhz Primary Osc. 
*
0155E:  CP0     W0
01560:  BTSC.B  42.1
01562:  BRA     1570
01564:  REPEAT  #3529
01566:  NOP     
01568:  REPEAT  #3FFF
0156A:  NOP     
0156C:  DEC     W0,W0
0156E:  BRA     155E
01570:  RETURN  
*
01F08:  CP0     W0
01F0A:  BTSC.B  42.1
01F0C:  BRA     1F16
01F0E:  REPEAT  #17
01F10:  NOP     
01F12:  DEC     W0,W0
01F14:  BRA     1F08
01F16:  RETURN  
.................... #USE RS232(stream=RS485,UART1,baud=38400,parity=N,bits=8,stop=1)  // Set UART1 as RS485 stream 
.................... #USE RS232(stream=RS232,UART2,baud=38400,parity=N,bits=8,stop=1)  // Set UART2 as RS232 stream 
....................  
....................  
....................  
.................... //Register for Reset Info 
.................... #WORD RCON                 = 0x740           //Reset control register 
.................... #BIT RCON_POR              = RCON.0          //POR 
.................... #BIT RCON_BOR              = RCON.1          //BOR 
.................... #BIT RCON_IDLE             = RCON.2 
.................... #BIT RCON_SLEEP            = RCON.3 
.................... #BIT RCON_WDTO             = RCON.4 
.................... #BIT RCON_SWDTEN           = RCON.5 
.................... #BIT RCON_SWR              = RCON.6 
.................... #BIT RCON_EXTR             = RCON.7         //MCLR Reset during normal operation 
.................... #BIT RCON_BGST             = RCON.13 
.................... #BIT RCON_IOPUWR           = RCON.14 
.................... #BIT RCON_TRAPR            = RCON.15 
....................  
....................  
....................  
.................... // Registers of quadrature encoder interface module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD QEI_QEICON        = 0x122           // Control and status register QEICON allows control of the QEI operation and status flags indicating the module state. 
.................... #WORD QEI_DFLTCON       = 0x124           // Digital filter control register DFLTCON allows control of the digital input filter operation. 
.................... #WORD QEI_POSCNT        = 0x126           // Position count register POSCNT allows reading and writing of the 16-bit position counter. 
.................... #WORD QEI_MAXCNT        = 0x128           // Maximum count register MAXCNT holds a value that will be compared to the POSCNT counter in some operations. 
.................... // Bits of the QEICON register 
.................... #BIT QEI_QEICON_CNTERR  = QEI_QEICON.15   // Count error status flag bit 
.................... #BIT QEI_QEICON_QEISIDL = QEI_QEICON.13   // Stop in idle mode bit 
.................... #BIT QEI_QEICON_INDEX   = QEI_QEICON.12   // Index pin state status bit (read only) 
.................... #BIT QEI_QEICON_UPDN    = QEI_QEICON.11   // Position counter direction status bit (read only) 
.................... #BIT QEI_QEICON_QEIM2   = QEI_QEICON.10   // Quadrature encoder interface mode select bits 
.................... #BIT QEI_QEICON_QEIM1   = QEI_QEICON.9 
.................... #BIT QEI_QEICON_QEIM0   = QEI_QEICON.8 
.................... #BIT QEI_QEICON_SWPAB   = QEI_QEICON.7    // Phase A and phase B input swap select bit  
.................... #BIT QEI_QEICON_PCDOUT  = QEI_QEICON.6    // Position counter direction state output rnable bit 
.................... #BIT QEI_QEICON_TQGATE  = QEI_QEICON.5    // Timer gated time accumulation rnable bit 
.................... #BIT QEI_QEICON_TQCKPS1 = QEI_QEICON.4    // Timer input clock prescale select bits 
.................... #BIT QEI_QEICON_TQCKPS0 = QEI_QEICON.3 
.................... #BIT QEI_QEICON_POSRES  = QEI_QEICON.2    // Position counter reset enable bit 
.................... #BIT QEI_QEICON_TQCS    = QEI_QEICON.1    // Timer clock source select bit 
.................... #BIT QEI_QEICON_UDSRC   = QEI_QEICON.0    // Position counter direction selection control bit 
.................... // Bits of the DFLTCON register 
.................... #BIT QEI_DFLTCON_IMV1   = QEI_DFLTCON.10  // Index match value bits 
.................... #BIT QEI_DFLTCON_IMV0   = QEI_DFLTCON.9   // These bits allow the user to specify the state of the QEA and QEB input pins during an Index pulse when the POSCNT register is to be reset. 
.................... #BIT QEI_DFLTCON_CEID   = QEI_DFLTCON.8   // Count error interrupt disable bit 
.................... #BIT QEI_DFLTCON_QEOUT  = QEI_DFLTCON.7   // QEA/QEB/IND digital filter output enable bit  
.................... #BIT QEI_DFLTCON_QECK2  = QEI_DFLTCON.6   // QEA/QEB/IND digital filter clock divide select bits 
.................... #BIT QEI_DFLTCON_QECK1  = QEI_DFLTCON.5      
.................... #BIT QEI_DFLTCON_QECK0  = QEI_DFLTCON.4 
....................  
.................... // Registers of the motor control PWM module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD PWM_PTCON         = 0x1C0           // PWM Time base control register 
.................... #WORD PWM_PTPER         = 0x1C4           // PWM Time base period register 
.................... #WORD PWM_PWMCON1       = 0x1C8           // PWM Control register #1 
.................... #WORD PWM_PWMCON2       = 0x1CA           // PWM Control register #2 
.................... #WORD PWM_PDC1          = 0x1D6           // PWM Duty cycle register #1 
.................... #WORD PWM_IEC2          = 0x090           // PWM Interrupt Enable Control Register 
.................... #WORD PWM_IFS2          = 0x088           // PWM Interrupt Flag Status Register 
.................... // Bits of the PTCON register 
.................... #BIT PWM_PTCON_PTEN     = PWM_PTCON.15    // PWM Time base timer enable bit 
.................... #BIT PWM_PTCON_PTOPS3   = PWM_PTCON.7     // PWM Time base output postscale select bits  
.................... #BIT PWM_PTCON_PTOPS2   = PWM_PTCON.6 
.................... #BIT PWM_PTCON_PTOPS1   = PWM_PTCON.5 
.................... #BIT PWM_PTCON_PTOPS0   = PWM_PTCON.4 
.................... #BIT PWM_PTCON_PTCKPS1  = PWM_PTCON.3     // PWM Time base input clock prescale select bits 
.................... #BIT PWM_PTCON_PTCKPS0  = PWM_PTCON.2     
.................... #BIT PWM_PTCON_PTMOD1   = PWM_PTCON.1     // PWM Time base mode select bits 
.................... #BIT PWM_PTCON_PTMOD0   = PWM_PTCON.0 
.................... // Bits of the PWMCON1 register 
.................... #BIT PWM_PWMCON1_PMOD1  = PWM_PWMCON1.8   // PWM1 I/O pin pair mode bit 
.................... #BIT PWM_PWMCON1_PEN1H  = PWM_PWMCON1.4   // PWM1H I/O pin enable bit 
.................... #BIT PWM_PWMCON1_PEN1L  = PWM_PWMCON1.0   // PWM1L I/O pin enable bit 
.................... // Bits of the PWMCON2 register   
.................... #BIT PWM_PWMCON2_IUE    = PWM_PWMCON2.2   // Immediate update enable bit 
.................... #BIT PWM_PWMCON2_OSYNC  = PWM_PWMCON2.1   // Output override synchronization bit 
.................... #BIT PWM_PWMCON2_UDIS   = PWM_PWMCON2.0   // PWM update disable bit 
.................... // Bits of the IEC2 register 
.................... #BIT PWM_IEC2_PWMIE     = PWM_IEC2.7      // PWM Interrupt enable bit  
.................... // Bits of the IFS2 register 
.................... #BIT PWM_IFS2_PWMIF     = PWM_IFS2.7      // PWM Interrupt flag status bit     
....................  
.................... // Registers of the UART1 module 
.................... #WORD UART_IFS0          = 0x088           // UART Interrupt Flag Status Register 
.................... // Bits of the IFS0 register 
.................... #BIT UART_IFS0_U1RXIF    = UART_IFS0.9     // UART Receiver Interrupt flag status bit   
.................... #BIT UART_IFS0_U1TXIF    = UART_IFS0.10    // UART Transmiter Interrupt flag status bit   
....................  
.................... // Led pins 
.................... #DEFINE LED          PIN_B8               // Led used in debugging 
....................  
.................... // Laser pins 
.................... #DEFINE LAS_1        PIN_B0               // Control pin of the first laser 
.................... #DEFINE LAS_2        PIN_B1               // Control pin of the second laser 
.................... #DEFINE LAS_3        PIN_D6               // Control pin of the third laser 
....................  
.................... //Parallel Port Pin Assignments 
.................... #DEFINE PP_D0        PIN_D8               // Parallel port data pin first bit 
.................... #DEFINE PP_D1        PIN_D9               // Parallel port data pin second bit 
.................... #DEFINE PP_D2        PIN_D0               // Parallel port data pin third bit 
.................... #DEFINE PP_D3        PIN_C13              // Parallel port data pin fourth bit 
.................... #DEFINE PP_D4        PIN_C14              // Parallel port data pin fifth bit 
.................... #DEFINE PP_D5        PIN_D1               // Parallel port data pin sixth bit 
.................... #DEFINE PP_D6        PIN_D2               // Parallel port data pin seventh bit 
.................... #DEFINE PP_D7        PIN_D3               // Parallel port data pin eigth bit 
.................... #DEFINE PP_STR       PIN_D10              // Parallel port strobe pin 
.................... #DEFINE PP_ACK       PIN_D4               // Parallel port acknowledge pin used to  
.................... #DEFINE PP_RDY       PIN_D5               // Parallel port ready pin 
....................  
.................... // Pins used to control digital potentiometer 
.................... #DEFINE DP_CS        PIN_G9               // Digital potentiometer chip select pin assignment (active low) 
.................... #DEFINE DP_UD        PIN_G8               // Digital potentiometer up/down control pin assignment 
....................  
.................... // Pins used to control motor driver 
.................... #DEFINE MD_MS1       PIN_F0               // Step resolution select pin 1 assignment 
.................... #DEFINE MD_MS2       PIN_D7               // Step resolution select pin 2 assignment 
.................... #DEFINE MD_SR        PIN_F1               // Active mode (synchronous rectification) input pin assignment 
.................... #DEFINE MD_RESET     PIN_E0               // Reset input pin assignment (active low) 
.................... #DEFINE MD_STEP      PIN_E1               // Step input pin assignment 
.................... #DEFINE MD_ENABLE    PIN_E2               // Enable input pin assignment (active low) 
.................... #DEFINE MD_SLEEP     PIN_E3               // Sleep input pin assignment (active low) 
.................... #DEFINE MD_DIR       PIN_E4               // Direction input pin assignment 
.................... #DEFINE MD_SW        PIN_D11              // Homing switch input pin assignment 
....................  
.................... // Pins used to control FRAM 
.................... #DEFINE FR_CS        PIN_G7               // FRAM chip select pin assignment (active low) 
.................... #DEFINE FR_WP        PIN_G6               // FRAM write protection pin assignment (active low) 
.................... #DEFINE FR_SCK       PIN_E5               // FRAM serial clock pin assignment 
.................... #DEFINE FR_SI        PIN_E6               // FRAM serial input pin assignment 
.................... #DEFINE FR_SO        PIN_E7               // FRAM serial output pin assignment 
....................  
.................... // Speed ramp states 
.................... #DEFINE HOME         0 
.................... #DEFINE ACCEL        1 
.................... #DEFINE DECEL        2 
.................... #DEFINE RUN          3 
.................... #DEFINE POS          4 
....................  
.................... // PWM module operating modes 
.................... #DEFINE FREE         0 
.................... #DEFINE SINGLE       1 
....................  
.................... int1           debug_mode_dp     = 0;              // Debug state of digital potentiometer 
.................... int1           debug_mode_pp     = 0;              // Debug state of parallel port communication 
.................... int1           debug_mode_fr     = 0;              // Debug state of FRAM 
.................... int1           debug_mode_md     = 0;              // Debug state of motor driver 
.................... int1           debug_mode_pwm    = 0;              // Debug state of motor control PWM module 
.................... int1           debug_mode_qei    = 0;              // Debug state of quadrature encoder 
....................  
.................... unsigned int   dp_tap_limit      = 32;             // Digital potentiometer maximum tap level 
.................... unsigned int   dp_voltage_limit  = 1023;           // Digital potentiometer maximum voltage level 
....................  
.................... unsigned int   mt_voltage_limit  = 803;            // Motor torque control voltage is limited to 4V (which is defined in driver specs) 
.................... unsigned int   mt_percent_trip   = 70;             // Motor torque percent while system is moving 
.................... unsigned int   mt_percent_rest   = 28;             // Motor torque percent while system is stationary 
....................  
.................... unsigned int   md_conv_const     = 0;              // Constant used to convert encoder count to motor step 
.................... unsigned int   md_move_range     = 400;            // Movement range of the device 
.................... unsigned int   md_home_pos       = 45;             // Sets the number of encoder counts between the home position and homing switch position 
.................... unsigned int   md_end_pos        = 1000;           // Sets the number of encoder counts between the home position and the end of movement range 
.................... unsigned int   md_end_offset     = 50;             // Offset of the maximum count number from the end position 
.................... unsigned int   md_home_offset    = 100;            // Offset of the maximum count number from the home position 
.................... unsigned int   md_min_distance   = 70;             // Minimum distance between symmetricaly moving lasers 
.................... unsigned int   md_target_count   = 0;              // Target position count 
....................  
.................... unsigned int   md_accel          = 3000;           // Acceleration of the motor (0.01 mm/s2) 
.................... unsigned int   md_decel          = 3000;           // Deceleration of the motor (0.01 mm/s2) 
....................  
.................... unsigned int   md_min_delay      = 100;            // Minimum time delay (max speed) 
.................... unsigned char  md_run_state      = 0;              // What part of the speed ramp we are in. 
.................... unsigned int   md_decel_lim      = 0;              // What step_pos to start decelaration 
.................... unsigned int   md_accel_lim      = 0;              // What step_pos to end accelaration 
.................... unsigned int   md_decel_count    = 0;              // Counter used when decelerateing to calculate step_delay. 
.................... unsigned int   md_pos_iter       = 0;              // Number of iterations performed during positioning 
.................... int            md_error          = 0;              // Positioning error 
.................... unsigned int   md_backlash       = 0;              // Backlash of the positioning system 
....................  
.................... unsigned int   md_cc_step        = 0;              // Motor count used in conversion constant conversion 
.................... unsigned int   md_cc_count       = 0;              // Encoder count used in conversion constant conversion 
....................  
.................... unsigned int   fr_serial_no      = 0;              // External adress of product serial no 
.................... unsigned int   fr_move_range     = 13;             // External adress of movement range 
.................... unsigned int   fr_home_pos       = 15;             // External adress of home position 
.................... unsigned int   fr_end_pos        = 17;             // External addres of end position 
.................... unsigned int   fr_conv_const     = 19;             // External adress of conversion constant 
.................... unsigned int   fr_backlash       = 21;             // External adress of backlash compensation 
.................... unsigned int   fr_comm_type      = 23;             // External adress of communication type 
.................... unsigned int   fr_last_pos       = 24;             // External adress of last position 
.................... unsigned int   fr_pos_table      = 26;             // External adress of position table 
....................  
.................... unsigned int   pp_str_check      = 10;             // Parallel port strobe signal filter iteration number 
.................... unsigned int   pp_str_delay      = 1;              // Parallel port strobe signal filter pause time (ms) 
.................... unsigned int   pp_ack_delay      = 100;            // Parallel port acknowledge signal pause time (ms) 
.................... unsigned int   pp_rdy_delay      = 100;            // Parallel port ready signal pause time (ms) 
....................  
.................... int1           reg_comm_type     = 0;              // Communication type register 
.................... int1           reg_pp_stop       = 0;              // Parallel port emergency stop signal register 
.................... int1           reg_pp_strobe     = 0;              // Parallel port strobe signal active register 
.................... int1           reg_md_home       = 0;              // Homing action register 
.................... int1           reg_md_home_return= 0;              // Home correction return register 
.................... int1           reg_rs232_message = 0;              // RS232 message flag 
.................... int1           reg_md_cc_sample  = 0;              // Special case register for conversion constant calculation 
....................  
.................... #DEFINE ACC_15 
....................  
.................... #IFDEF ACC_10 
.................... unsigned int   md_max_acc_lim    = 116;             // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... unsigned int const delays[116]={2449,1015,779,656,578,523,481,447,420,397,378,361,346,333,322,311,302,293,285,277,271,264,258,253,247,243,238,234,229,226,222,218,215,212,209,206,203,200,197,195,192,190,188,186,184,182,180, 
.................... 178,176,174,172,171,169,167,166,164,163,162,160,159,157,156,155,154,152,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115, 
.................... 114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_15 
.................... unsigned int   md_max_acc_lim    = 88;             // Number of steps before we hit max speed. acc=15000 dec=15000 
.................... unsigned int const delays[88]={2000,828,636,536,472,427,393,365,343,325,309,295,283,272,263,254,246,239,233,226,221,216,211,206,202,198,194,191,187,184,181,178,175,173,170,168,166,163,161,159,157,155,153,152,150,148,147, 
.................... 145,144,142,141,139,138,137,135,134,133,132,131,130,129,128,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_20 
.................... unsigned int   md_max_acc_lim    = 71;             // Number of steps before we hit max speed. acc=20000 dec=20000  
.................... unsigned int const delays[71]={1732,717,551,464,409,370,340,316,297,281,267,255,245,236,227,220,213,207,201,196,191,187,183,179,175,172,168,165,162,159,157,154,152,150,147,145,143,141,140,138,136,134,133,131,130,128,127, 
.................... 126,124,123,122,121,120,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_25 
.................... unsigned int   md_max_acc_lim    = 59;             // Number of steps before we hit max speed. acc=25000 dec=25000  
.................... unsigned int const delays[59]={1549,642,492,415,366,331,304,283,266,251,239,228,219,211,203,197,191,185,180,175,171,167,163,160,157,153,150,148,145,143,140,138,136,134,132,130,128,126,125,123,122,120,119,117,116,115,114, 
.................... 112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_30 
.................... unsigned int   md_max_acc_lim    = 50;             // Number of steps before we hit max speed. acc=30000 dec=30000  
.................... unsigned int const delays[50]={1414,586,449,379,334,302,278,258,243,229,218,209,200,192,186,180,174,169,164,160,156,153,149,146,143,140,137,135,132,130,128,126,124,122,120,119,117,115,114,113,111,110,108,107,106,105,104, 
.................... 103,102,101}; 
.................... #ENDIF 
....................  
.................... void move_pos(unsigned int16 position); 
.................... unsigned int16 qei_get_count(); 
....................  
.................... // Initializes digital potentiometer 
.................... void dp_init()  
.................... { 
....................    output_high(DP_CS);                       // Chip select is active low so keep it disabled 
*
016CE:  BCLR.B  2E5.1
016D0:  BSET.B  2E9.1
....................    output_low(DP_UD);                        // Up/down control pin can be in any state 
016D2:  BCLR.B  2E5.0
016D4:  BCLR.B  2E9.0
.................... } 
016D6:  RETURN  
.................... // Increases digital potentiometer by given tap 
.................... void dp_up(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
*
0175C:  MOV     802,W0
0175E:  MOV     8C4,W4
01760:  CP      W4,W0
01762:  BRA     LEU,1768
....................       tap=dp_tap_limit; 
01764:  PUSH    802
01766:  POP     8C4
....................        
....................    output_high(DP_UD);        // Set U/D to high before activating digital potentiometer 
01768:  BCLR.B  2E5.0
0176A:  BSET.B  2E9.0
....................    delay_us(1); 
0176C:  REPEAT  #1C
0176E:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
01770:  BCLR.B  2E5.1
01772:  BCLR.B  2E9.1
....................    delay_us(1); 
01774:  REPEAT  #1C
01776:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
01778:  CLR     8C6
0177A:  MOV     8C6,W0
0177C:  MOV     8C4,W4
0177E:  CP      W4,W0
01780:  BRA     LEU,17A0
....................    { 
....................       output_low(DP_UD);      // Low part of pulse 
01782:  BCLR.B  2E5.0
01784:  BCLR.B  2E9.0
....................       delay_us(1); 
01786:  REPEAT  #1C
01788:  NOP     
....................       output_high(DP_UD);     // High part of pulse 
0178A:  BCLR.B  2E5.0
0178C:  BSET.B  2E9.0
....................       delay_us(1); 
0178E:  REPEAT  #1C
01790:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
01792:  BCLR.B  2E5.0
01794:  BCLR.B  2E9.0
....................       delay_us(1);  
01796:  REPEAT  #1C
01798:  NOP     
....................    } 
0179A:  INC     08C6
0179C:  GOTO    177A
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer   
017A0:  BCLR.B  2E5.1
017A2:  BSET.B  2E9.1
.................... } 
017A4:  RETURN  
.................... // Decreases digital potentiometer by given tap 
.................... void dp_down(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
017A6:  MOV     802,W0
017A8:  MOV     8C4,W4
017AA:  CP      W4,W0
017AC:  BRA     LEU,17B2
....................       tap=dp_tap_limit; 
017AE:  PUSH    802
017B0:  POP     8C4
....................        
....................    output_low(DP_UD);         // Set U/D to low before activating digital potentiometer 
017B2:  BCLR.B  2E5.0
017B4:  BCLR.B  2E9.0
....................    delay_us(1); 
017B6:  REPEAT  #1C
017B8:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
017BA:  BCLR.B  2E5.1
017BC:  BCLR.B  2E9.1
....................    delay_us(1);             
017BE:  REPEAT  #1C
017C0:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
017C2:  CLR     8C6
017C4:  MOV     8C6,W0
017C6:  MOV     8C4,W4
017C8:  CP      W4,W0
017CA:  BRA     LEU,17E2
....................    { 
....................       output_high(DP_UD);     // High part of pulse 
017CC:  BCLR.B  2E5.0
017CE:  BSET.B  2E9.0
....................       delay_us(1); 
017D0:  REPEAT  #1C
017D2:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
017D4:  BCLR.B  2E5.0
017D6:  BCLR.B  2E9.0
....................       delay_us(1);   
017D8:  REPEAT  #1C
017DA:  NOP     
....................    } 
017DC:  INC     08C6
017DE:  GOTO    17C4
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer 
017E2:  BCLR.B  2E5.1
017E4:  BSET.B  2E9.1
.................... } 
017E6:  RETURN  
.................... // Sets digital potentiometer to given voltage 
.................... void dp_set(unsigned int voltage) 
.................... { 
017E8:  MOV     W5,[W15++]
017EA:  MOV     #3,W4
017EC:  MOV     W4,8B0
017EE:  CLR     8B2
017F0:  MOV     #F,W4
017F2:  MOV     W4,8B4
017F4:  MOV     8AE,W4
017F6:  MOV     802,W3
017F8:  MUL.UU  W4,W3,W0
017FA:  MOV     W0,W5
017FC:  MOV     W5,W4
017FE:  MOV     804,W3
01800:  REPEAT  #11
01802:  DIV.U   W4,W3
01804:  MOV     W0,8B6
01806:  BCLR.B  2A0.0
01808:  BSET.B  2A0.1
0180A:  BTSS.B  2A0.0
0180C:  BRA     180A
0180E:  PUSH    280
01810:  POP     8B8
01812:  MOV     8AE,W4
01814:  MOV     8B8,W3
01816:  SUB     W4,W3,W5
01818:  MOV     W5,W0
0181A:  MOV     W5,8BA
....................    unsigned int iteration_limit=3;                                   // Maximum number of iterations to be performed to set voltage 
....................    unsigned int iteration=0;                                         // Number of iterations performed to set voltage 
....................    unsigned int region=15;                                           // We want the voltage to be inside this region (+/-)  
....................    unsigned int tap_desired=voltage*dp_tap_limit/dp_voltage_limit;   // Find the desired potentiometer tap 
....................    unsigned int voltage_current=read_adc();                          // Read the current voltage 
....................    unsigned int voltage_diff=abs(voltage-voltage_current);           // Find the difference between the current and desired voltage  
....................    unsigned int tap_current;                                         // Current tap value 
....................     
....................    if(debug_mode_dp) 
0181C:  BTSS.B  800.0
0181E:  BRA     18EE
....................    { 
....................       fprintf(RS232,"\n\r\tVoltage Desired: %u",voltage); 
01820:  MOV     #0,W1
01822:  MOV     W1,W0
01824:  CALL    196
01828:  INC     W1,W1
0182A:  MOV     W1,[W15++]
0182C:  BTSC.B  219.1
0182E:  BRA     182C
01830:  MOV     W0,21A
01832:  MOV     [--W15],W1
01834:  MOV     #13,W0
01836:  CPSGT   W1,W0
01838:  BRA     1822
0183A:  MOV     8AE,W0
0183C:  MOV     #0,W4
0183E:  CALL    1572
....................       fprintf(RS232,"\n\r\tTap Desired: %u",dp_tap_limit*voltage/dp_voltage_limit); 
01842:  MOV     802,W4
01844:  MOV     8AE,W3
01846:  MUL.UU  W4,W3,W0
01848:  MOV     W0,W5
0184A:  MOV     W5,W4
0184C:  MOV     804,W3
0184E:  REPEAT  #11
01850:  DIV.U   W4,W3
01852:  MOV     W0,W5
01854:  MOV     #0,W1
01856:  MOV     W1,W0
01858:  CALL    1BA
0185C:  INC     W1,W1
0185E:  MOV     W1,[W15++]
01860:  BTSC.B  219.1
01862:  BRA     1860
01864:  MOV     W0,21A
01866:  MOV     [--W15],W1
01868:  MOV     #F,W0
0186A:  CPSGT   W1,W0
0186C:  BRA     1856
0186E:  MOV     W5,W0
01870:  MOV     #0,W4
01872:  CALL    1572
....................       fprintf(RS232,"\n\r\tVoltage Current: %u",voltage_current); 
01876:  MOV     #0,W1
01878:  MOV     W1,W0
0187A:  CALL    1DA
0187E:  INC     W1,W1
01880:  MOV     W1,[W15++]
01882:  BTSC.B  219.1
01884:  BRA     1882
01886:  MOV     W0,21A
01888:  MOV     [--W15],W1
0188A:  MOV     #13,W0
0188C:  CPSGT   W1,W0
0188E:  BRA     1878
01890:  MOV     8B8,W0
01892:  MOV     #0,W4
01894:  CALL    1572
....................       fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01898:  MOV     802,W4
0189A:  MOV     8B8,W3
0189C:  MUL.UU  W4,W3,W0
0189E:  MOV     W0,W5
018A0:  MOV     W5,W4
018A2:  MOV     804,W3
018A4:  REPEAT  #11
018A6:  DIV.U   W4,W3
018A8:  MOV     W0,W5
018AA:  MOV     #0,W1
018AC:  MOV     W1,W0
018AE:  CALL    1FE
018B2:  INC     W1,W1
018B4:  MOV     W1,[W15++]
018B6:  BTSC.B  219.1
018B8:  BRA     18B6
018BA:  MOV     W0,21A
018BC:  MOV     [--W15],W1
018BE:  MOV     #F,W0
018C0:  CPSGT   W1,W0
018C2:  BRA     18AC
018C4:  MOV     W5,W0
018C6:  MOV     #0,W4
018C8:  CALL    1572
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",voltage_diff); 
018CC:  MOV     #0,W1
018CE:  MOV     W1,W0
018D0:  CALL    21E
018D4:  INC     W1,W1
018D6:  MOV     W1,[W15++]
018D8:  BTSC.B  219.1
018DA:  BRA     18D8
018DC:  MOV     W0,21A
018DE:  MOV     [--W15],W1
018E0:  MOV     #16,W0
018E2:  CPSGT   W1,W0
018E4:  BRA     18CE
018E6:  MOV     8BA,W0
018E8:  MOV     #0,W4
018EA:  CALL    1572
....................    } 
....................     
....................    while(voltage_diff>region)                                        // Try until voltage is found 
....................    {                                                                 // or iteration limit is reached  
018EE:  MOV     8B4,W0
018F0:  MOV     8BA,W4
018F2:  CP      W4,W0
018F4:  BRA     LEU,1A64
....................       if(iteration <iteration_limit)                      
018F6:  MOV     8B2,W0
018F8:  MOV     8B0,W4
018FA:  CP      W4,W0
018FC:  BRA     LEU,1A40
....................       { 
....................          iteration++;                                                // Set iteration number 
018FE:  INC     08B2
....................          tap_current=dp_tap_limit*voltage_current/dp_voltage_limit;  // Convert new voltage to tap 
01900:  MOV     802,W4
01902:  MOV     8B8,W3
01904:  MUL.UU  W4,W3,W0
01906:  MOV     W0,W5
01908:  MOV     W5,W4
0190A:  MOV     804,W3
0190C:  REPEAT  #11
0190E:  DIV.U   W4,W3
01910:  MOV     W0,8BC
....................  
....................          if(tap_desired>tap_current)                                 // Set the digital potentiometer to desired tap 
01912:  MOV     8BC,W0
01914:  MOV     8B6,W4
01916:  CP      W4,W0
01918:  BRA     LEU,192A
....................          { 
....................             dp_up(tap_desired-tap_current); 
0191A:  MOV     8B6,W4
0191C:  MOV     8BC,W3
0191E:  SUB     W4,W3,W5
01920:  MOV     W5,8C4
01922:  CALL    175C
....................          } 
....................          else if(tap_desired<tap_current) 
01926:  GOTO    195E
0192A:  MOV     8B6,W0
0192C:  MOV     8BC,W4
0192E:  CP      W4,W0
01930:  BRA     LEU,1942
....................          { 
....................             dp_down(tap_current-tap_desired); 
01932:  MOV     8BC,W4
01934:  MOV     8B6,W3
01936:  SUB     W4,W3,W5
01938:  MOV     W5,8C4
0193A:  CALL    17A6
....................          } 
....................          else                                                        // If tap level is same as the previous one and it still outside the region 
0193E:  GOTO    195E
....................          {                                                           // then go one step up or down according to desired voltage 
....................             if(voltage>voltage_current) 
01942:  MOV     8B8,W0
01944:  MOV     8AE,W4
01946:  CP      W4,W0
01948:  BRA     LEU,1956
....................                dp_up(1); 
0194A:  MOV     #1,W4
0194C:  MOV     W4,8C4
0194E:  CALL    175C
....................             else 
01952:  GOTO    195E
....................                dp_down(1); 
01956:  MOV     #1,W4
01958:  MOV     W4,8C4
0195A:  CALL    17A6
....................          } 
....................           
....................          delay_ms(2); 
0195E:  REPEAT  #2A5E
01960:  NOP     
01962:  REPEAT  #3FFF
01964:  NOP     
01966:  REPEAT  #3FFF
01968:  NOP     
0196A:  REPEAT  #3FFF
0196C:  NOP     
....................              
....................          voltage_current=read_adc();                                 // Read the new voltage 
0196E:  BCLR.B  2A0.0
01970:  BSET.B  2A0.1
01972:  BTSS.B  2A0.0
01974:  BRA     1972
01976:  PUSH    280
01978:  POP     8B8
....................           
....................          if(voltage>voltage_current)                                 // Find the difference between the new and desired voltages for next iteration check 
0197A:  MOV     8B8,W0
0197C:  MOV     8AE,W4
0197E:  CP      W4,W0
01980:  BRA     LEU,198E
....................             voltage_diff=voltage - voltage_current; 
01982:  MOV     8AE,W4
01984:  MOV     8B8,W3
01986:  SUB     W4,W3,W0
01988:  MOV     W0,8BA
....................          else 
0198A:  GOTO    1996
....................             voltage_diff=voltage_current - voltage; 
0198E:  MOV     8B8,W4
01990:  MOV     8AE,W3
01992:  SUB     W4,W3,W0
01994:  MOV     W0,8BA
....................           
....................          if(debug_mode_dp) 
01996:  BTSS.B  800.0
01998:  BRA     1A3C
....................          { 
....................             fprintf(RS232,"\n\rITERATION: %u",iteration); 
0199A:  MOV     #0,W1
0199C:  MOV     W1,W0
0199E:  CALL    244
019A2:  INC     W1,W1
019A4:  MOV     W1,[W15++]
019A6:  BTSC.B  219.1
019A8:  BRA     19A6
019AA:  MOV     W0,21A
019AC:  MOV     [--W15],W1
019AE:  MOV     #C,W0
019B0:  CPSGT   W1,W0
019B2:  BRA     199C
019B4:  MOV     8B2,W0
019B6:  MOV     #0,W4
019B8:  CALL    1572
....................             fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
019BC:  MOV     802,W4
019BE:  MOV     8B8,W3
019C0:  MUL.UU  W4,W3,W0
019C2:  MOV     W0,W5
019C4:  MOV     W5,W4
019C6:  MOV     804,W3
019C8:  REPEAT  #11
019CA:  DIV.U   W4,W3
019CC:  MOV     W0,W5
019CE:  MOV     #0,W1
019D0:  MOV     W1,W0
019D2:  CALL    1FE
019D6:  INC     W1,W1
019D8:  MOV     W1,[W15++]
019DA:  BTSC.B  219.1
019DC:  BRA     19DA
019DE:  MOV     W0,21A
019E0:  MOV     [--W15],W1
019E2:  MOV     #F,W0
019E4:  CPSGT   W1,W0
019E6:  BRA     19D0
019E8:  MOV     W5,W0
019EA:  MOV     #0,W4
019EC:  CALL    1572
....................             fprintf(RS232,"\n\r\tVoltage Current : %u",voltage_current); 
019F0:  MOV     #0,W1
019F2:  MOV     W1,W0
019F4:  CALL    260
019F8:  INC     W1,W1
019FA:  MOV     W1,[W15++]
019FC:  BTSC.B  219.1
019FE:  BRA     19FC
01A00:  MOV     W0,21A
01A02:  MOV     [--W15],W1
01A04:  MOV     #14,W0
01A06:  CPSGT   W1,W0
01A08:  BRA     19F2
01A0A:  MOV     8B8,W0
01A0C:  MOV     #0,W4
01A0E:  CALL    1572
....................             fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-voltage_current)); 
01A12:  MOV     8AE,W4
01A14:  MOV     8B8,W3
01A16:  SUB     W4,W3,W5
01A18:  MOV     W5,W0
01A1A:  MOV     #0,W1
01A1C:  MOV     W1,W0
01A1E:  CALL    21E
01A22:  INC     W1,W1
01A24:  MOV     W1,[W15++]
01A26:  BTSC.B  219.1
01A28:  BRA     1A26
01A2A:  MOV     W0,21A
01A2C:  MOV     [--W15],W1
01A2E:  MOV     #16,W0
01A30:  CPSGT   W1,W0
01A32:  BRA     1A1C
01A34:  MOV     W5,W0
01A36:  MOV     #0,W4
01A38:  CALL    1572
....................          } 
....................       } 
....................       else 
01A3C:  GOTO    1A60
....................       { 
....................          if(debug_mode_dp) 
01A40:  BTSS.B  800.0
01A42:  BRA     1A5E
....................             fprintf(RS232,"\n\rIteration limit reached"); 
01A44:  MOV     #0,W1
01A46:  MOV     W1,W0
01A48:  CALL    284
01A4C:  INC     W1,W1
01A4E:  MOV     W1,[W15++]
01A50:  BTSC.B  219.1
01A52:  BRA     1A50
01A54:  MOV     W0,21A
01A56:  MOV     [--W15],W1
01A58:  MOV     #18,W0
01A5A:  CPSGT   W1,W0
01A5C:  BRA     1A46
....................          return; 
01A5E:  BRA     1B14
....................       } 
....................    } 
01A60:  GOTO    18EE
....................     
....................    if(debug_mode_dp) 
01A64:  BTSS.B  800.0
01A66:  BRA     1B14
....................    { 
....................       fprintf(RS232,"\n\rFOUND!"); 
01A68:  MOV     #0,W1
01A6A:  MOV     W1,W0
01A6C:  CALL    2AA
01A70:  INC     W1,W1
01A72:  MOV     W1,[W15++]
01A74:  BTSC.B  219.1
01A76:  BRA     1A74
01A78:  MOV     W0,21A
01A7A:  MOV     [--W15],W1
01A7C:  MOV     #7,W0
01A7E:  CPSGT   W1,W0
01A80:  BRA     1A6A
....................       fprintf(RS232,"\n\r\tTap Current : %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01A82:  MOV     802,W4
01A84:  MOV     8B8,W3
01A86:  MUL.UU  W4,W3,W0
01A88:  MOV     W0,W5
01A8A:  MOV     W5,W4
01A8C:  MOV     804,W3
01A8E:  REPEAT  #11
01A90:  DIV.U   W4,W3
01A92:  MOV     W0,W5
01A94:  MOV     #0,W1
01A96:  MOV     W1,W0
01A98:  CALL    2C0
01A9C:  INC     W1,W1
01A9E:  MOV     W1,[W15++]
01AA0:  BTSC.B  219.1
01AA2:  BRA     1AA0
01AA4:  MOV     W0,21A
01AA6:  MOV     [--W15],W1
01AA8:  MOV     #10,W0
01AAA:  CPSGT   W1,W0
01AAC:  BRA     1A96
01AAE:  MOV     W5,W0
01AB0:  MOV     #0,W4
01AB2:  CALL    1572
....................       fprintf(RS232,"\n\r\tVoltage Current : %u",read_adc()); 
01AB6:  BCLR.B  2A0.0
01AB8:  BSET.B  2A0.1
01ABA:  BTSS.B  2A0.0
01ABC:  BRA     1ABA
01ABE:  MOV     280,W5
01AC0:  MOV     #0,W1
01AC2:  MOV     W1,W0
01AC4:  CALL    260
01AC8:  INC     W1,W1
01ACA:  MOV     W1,[W15++]
01ACC:  BTSC.B  219.1
01ACE:  BRA     1ACC
01AD0:  MOV     W0,21A
01AD2:  MOV     [--W15],W1
01AD4:  MOV     #14,W0
01AD6:  CPSGT   W1,W0
01AD8:  BRA     1AC2
01ADA:  MOV     W5,W0
01ADC:  MOV     #0,W4
01ADE:  CALL    1572
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-read_adc())); 
01AE2:  BCLR.B  2A0.0
01AE4:  BSET.B  2A0.1
01AE6:  BTSS.B  2A0.0
01AE8:  BRA     1AE6
01AEA:  MOV     280,W0
01AEC:  MOV     8AE,W4
01AEE:  SUB     W4,W0,W5
01AF0:  MOV     W5,W0
01AF2:  MOV     #0,W1
01AF4:  MOV     W1,W0
01AF6:  CALL    21E
01AFA:  INC     W1,W1
01AFC:  MOV     W1,[W15++]
01AFE:  BTSC.B  219.1
01B00:  BRA     1AFE
01B02:  MOV     W0,21A
01B04:  MOV     [--W15],W1
01B06:  MOV     #16,W0
01B08:  CPSGT   W1,W0
01B0A:  BRA     1AF4
01B0C:  MOV     W5,W0
01B0E:  MOV     #0,W4
01B10:  CALL    1572
....................    } 
.................... } 
01B14:  MOV     [--W15],W5
01B16:  RETURN  
....................  
.................... // Returns current motor torque in percent (%0-100) 
.................... unsigned int md_mt_get() 
.................... { 
01B18:  MOV     W5,[W15++]
01B1A:  MOV     W6,[W15++]
01B1C:  BCLR.B  2A0.0
01B1E:  BSET.B  2A0.1
01B20:  BTSS.B  2A0.0
01B22:  BRA     1B20
01B24:  MOV     280,W0
01B26:  MOV     #0,W1
01B28:  MOV     W0,W2
01B2A:  MOV     W1,W3
01B2C:  MOV     #64,W0
01B2E:  MOV     #0,W1
01B30:  CALL    16D8
01B34:  MOV     W0,W5
01B36:  MOV     W1,W6
01B38:  BCLR.B  43.0
01B3A:  MOV     W5,W0
01B3C:  MOV     W6,W1
01B3E:  MOV     806,W2
01B40:  MOV     #0,W3
01B42:  CALL    1708
01B46:  MOV     W0,8B0
....................    unsigned int analog=read_adc();                                         // Read the voltage level 
....................    unsigned int percent=100*(unsigned int32)analog/mt_voltage_limit;       // Convert voltage to percent 
....................     
....................    if(debug_mode_dp) 
01B48:  BTSS.B  800.0
01B4A:  BRA     1B7E
....................       fprintf(RS232,"\n\r\tPercent Current: %u\n\r",percent); 
01B4C:  MOV     #0,W1
01B4E:  MOV     W1,W0
01B50:  CALL    2E0
01B54:  INC     W1,W1
01B56:  MOV     W1,[W15++]
01B58:  BTSC.B  219.1
01B5A:  BRA     1B58
01B5C:  MOV     W0,21A
01B5E:  MOV     [--W15],W1
01B60:  MOV     #13,W0
01B62:  CPSGT   W1,W0
01B64:  BRA     1B4E
01B66:  MOV     8B0,W0
01B68:  MOV     #0,W4
01B6A:  CALL    1572
01B6E:  BTSC.B  219.1
01B70:  BRA     1B6E
01B72:  MOV     #A,W4
01B74:  MOV     W4,21A
01B76:  BTSC.B  219.1
01B78:  BRA     1B76
01B7A:  MOV     #D,W4
01B7C:  MOV     W4,21A
....................        
....................    return percent;   
01B7E:  PUSH    8B0
01B80:  POP     0
.................... } 
01B82:  MOV     [--W15],W6
01B84:  MOV     [--W15],W5
01B86:  RETURN  
.................... // Sets motor torque approximate to desired percent and returns the actual percent (%0-100) 
.................... unsigned int md_mt_set(unsigned int percent) 
.................... { 
01B88:  MOV     W5,[W15++]
01B8A:  MOV     W6,[W15++]
....................    // percent must be between 0 and 100 
....................    if(percent>100) 
01B8C:  MOV     8A8,W4
01B8E:  MOV     #64,W3
01B90:  CP      W3,W4
01B92:  BRA     C,1B98
....................       percent=100; 
01B94:  MOV     #64,W4
01B96:  MOV     W4,8A8
....................        
....................    if(debug_mode_dp) 
01B98:  BTSS.B  800.0
01B9A:  BRA     1BBE
....................    { 
....................       fprintf(RS232,"\n\r\tPercent Desired:"); 
01B9C:  MOV     #0,W1
01B9E:  MOV     W1,W0
01BA0:  CALL    306
01BA4:  INC     W1,W1
01BA6:  MOV     W1,[W15++]
01BA8:  BTSC.B  219.1
01BAA:  BRA     1BA8
01BAC:  MOV     W0,21A
01BAE:  MOV     [--W15],W1
01BB0:  MOV     #12,W0
01BB2:  CPSGT   W1,W0
01BB4:  BRA     1B9E
....................       fprintf(RS232,"%u",percent); 
01BB6:  MOV     8A8,W0
01BB8:  MOV     #0,W4
01BBA:  CALL    1572
....................    } 
....................     
....................    unsigned int voltage=(unsigned int32)percent*mt_voltage_limit/100;      // convert percent to voltage 
01BBE:  MOV     8A8,W5
01BC0:  MOV     #0,W6
01BC2:  MOV     W5,W0
01BC4:  MOV     W6,W1
01BC6:  MOV     806,W2
01BC8:  MOV     #0,W3
01BCA:  CALL    16D8
01BCE:  MOV     W0,W5
01BD0:  MOV     W1,W6
01BD2:  BCLR.B  43.0
01BD4:  MOV     W5,W0
01BD6:  MOV     W6,W1
01BD8:  MOV     #64,W2
01BDA:  MOV     #0,W3
01BDC:  CALL    1708
01BE0:  MOV     W0,8AA
....................    dp_set(voltage);                                      // set digital potentiometer 
01BE2:  PUSH    8AA
01BE4:  POP     8AE
01BE6:  CALL    17E8
....................     
....................    return md_mt_get(); 
01BEA:  CALL    1B18
01BEE:  MOV     W0,0
.................... } 
01BF0:  MOV     [--W15],W6
01BF2:  MOV     [--W15],W5
01BF4:  RETURN  
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_mt_set(mt_percent_rest);               // Set motor torque before initialization of motor driver 
01BF6:  PUSH    80A
01BF8:  POP     8A8
01BFA:  CALL    1B88
....................  
....................    output_high(MD_RESET);                    // Reset is active low so keep it disabled 
01BFE:  BCLR.B  2D8.0
01C00:  BSET.B  2DC.0
....................    output_high(MD_SLEEP);                    // Sleep is active low so keep it disabled 
01C02:  BCLR.B  2D8.3
01C04:  BSET.B  2DC.3
....................    output_low(MD_SR);                        // Activate synchronous rectification 
01C06:  BCLR.B  2DE.1
01C08:  BCLR.B  2E2.1
....................    output_high(MD_DIR);                      // Direction control pin can be in any state 
01C0A:  BCLR.B  2D8.4
01C0C:  BSET.B  2DC.4
....................    output_high(MD_MS1);                      // MS1 and MS2 high enables 8x microstepping mode 
01C0E:  BCLR.B  2DE.0
01C10:  BSET.B  2E2.0
....................    output_high(MD_MS2); 
01C12:  BCLR.B  2D2.7
01C14:  BSET.B  2D6.7
....................    output_low(MD_ENABLE);                    // Enable is active so keep it high 
01C16:  BCLR.B  2D8.2
01C18:  BCLR.B  2DC.2
....................    output_low(MD_STEP);                      // A low-to-high transition advances the motor one increment so keep step input low 
01C1A:  BCLR.B  2D8.1
01C1C:  BCLR.B  2DC.1
.................... } 
01C1E:  RETURN  
....................  
.................... // Initializes external EEPROM (FRAM) 
.................... void fr_init()  
.................... { 
....................    output_high(FR_CS);     // Chip select is active low when it is high the device enters low-power standby mode so initialy keep it high 
01C20:  BCLR.B  2E4.7
01C22:  BSET.B  2E8.7
....................    output_low(FR_WP);      // Write protection pin is active low and prevents write operations to the status register so initially keep it low 
01C24:  BCLR.B  2E4.6
01C26:  BCLR.B  2E8.6
....................    output_low(FR_SI);      // Serial input pin is driven to high logic state during communication so initially keep it low 
01C28:  BCLR.B  2D8.6
01C2A:  BCLR.B  2DC.6
....................    output_low(FR_SCK);     // Inputs are latched on the rising edge and outputs occur on the falling edge so initially serial clock can be in any state  
01C2C:  BCLR.B  2D8.5
01C2E:  BCLR.B  2DC.5
.................... } 
01C30:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... void fr_write_byte(unsigned int16 address, unsigned int8 data)  
.................... { 
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    unsigned int8 wren; 
....................    unsigned int8 write; 
....................    unsigned int8 wrdi; 
....................     
....................    //     76543210     
....................    wren=0b00000110; 
*
02264:  MOV.B   #6,W0L
02266:  MOV.B   W0L,8B4
....................    //      76543210  
....................    write=0b00000010; 
02268:  MOV.B   #2,W0L
0226A:  MOV.B   W0L,8B5
....................    //     76543210 
....................    wrdi=0b00000100; 
0226C:  MOV.B   #4,W0L
0226E:  MOV.B   W0L,8B6
....................     
....................    cmd[0]=data; 
02270:  MOV.B   8AE,W0L
02272:  MOV.B   W0L,8B0
....................    cmd[1]=address; 
02274:  MOV.B   8AC,W0L
02276:  MOV.B   W0L,8B1
....................    cmd[2]=address/256; 
02278:  MOV.B   8AD,W0L
0227A:  MOV.B   W0L,8B2
....................    cmd[3]=write; 
0227C:  MOV.B   8B5,W0L
0227E:  MOV.B   W0L,8B3
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    output_low(FR_CS); 
02280:  BCLR.B  2E4.7
02282:  BCLR.B  2E8.7
....................    delay_us(1); 
02284:  REPEAT  #1C
02286:  NOP     
....................    for(i=0; i<8; ++i) 
02288:  CLR.B   8AF
0228A:  MOV     8AE,W4
0228C:  LSR     W4,#8,W4
0228E:  CP.B    W4L,#8
02290:  BRA     C,22C2
....................    { 
....................       output_bit(FR_SI, shift_left(&wren,1,0)); 
02292:  BCLR.B  42.0
02294:  RLC.B   8B4
02296:  BRA     C,229C
02298:  BCLR.B  2DC.6
0229A:  BRA     229E
0229C:  BSET.B  2DC.6
0229E:  BCLR.B  2D8.6
....................       delay_us(1); 
022A0:  REPEAT  #1C
022A2:  NOP     
....................       output_high(FR_SCK); 
022A4:  BCLR.B  2D8.5
022A6:  BSET.B  2DC.5
....................       delay_us(1); 
022A8:  REPEAT  #1C
022AA:  NOP     
....................       output_low(FR_SI); 
022AC:  BCLR.B  2D8.6
022AE:  BCLR.B  2DC.6
....................       delay_us(1); 
022B0:  REPEAT  #1C
022B2:  NOP     
....................       output_low(FR_SCK); 
022B4:  BCLR.B  2D8.5
022B6:  BCLR.B  2DC.5
....................       delay_us(1); 
022B8:  REPEAT  #1C
022BA:  NOP     
....................    } 
022BC:  INC.B   08AF
022BE:  GOTO    228A
....................    delay_us(1); 
022C2:  REPEAT  #1C
022C4:  NOP     
....................    output_high(FR_CS); 
022C6:  BCLR.B  2E4.7
022C8:  BSET.B  2E8.7
....................    delay_us(1); 
022CA:  REPEAT  #1C
022CC:  NOP     
....................     
....................    output_low(FR_CS); 
022CE:  BCLR.B  2E4.7
022D0:  BCLR.B  2E8.7
....................    delay_us(1); 
022D2:  REPEAT  #1C
022D4:  NOP     
....................    for(i=0; i<32; ++i) 
022D6:  CLR.B   8AF
022D8:  MOV     8AE,W4
022DA:  LSR     W4,#8,W4
022DC:  MOV     #20,W3
022DE:  CP.B    W3L,W4L
022E0:  BRA     LEU,2314
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,4,0)); 
022E2:  BCLR.B  42.0
022E4:  RLC     8B0
022E6:  RLC     8B2
022E8:  BRA     C,22EE
022EA:  BCLR.B  2DC.6
022EC:  BRA     22F0
022EE:  BSET.B  2DC.6
022F0:  BCLR.B  2D8.6
....................       delay_us(1); 
022F2:  REPEAT  #1C
022F4:  NOP     
....................       output_high(FR_SCK); 
022F6:  BCLR.B  2D8.5
022F8:  BSET.B  2DC.5
....................       delay_us(1); 
022FA:  REPEAT  #1C
022FC:  NOP     
....................       output_low(FR_SI); 
022FE:  BCLR.B  2D8.6
02300:  BCLR.B  2DC.6
....................       delay_us(1); 
02302:  REPEAT  #1C
02304:  NOP     
....................       output_low(FR_SCK); 
02306:  BCLR.B  2D8.5
02308:  BCLR.B  2DC.5
....................       delay_us(1); 
0230A:  REPEAT  #1C
0230C:  NOP     
....................    } 
0230E:  INC.B   08AF
02310:  GOTO    22D8
....................    delay_us(1); 
02314:  REPEAT  #1C
02316:  NOP     
....................    output_high(FR_CS); 
02318:  BCLR.B  2E4.7
0231A:  BSET.B  2E8.7
....................    delay_us(1); 
0231C:  REPEAT  #1C
0231E:  NOP     
....................     
....................    output_low(FR_CS); 
02320:  BCLR.B  2E4.7
02322:  BCLR.B  2E8.7
....................    delay_us(1); 
02324:  REPEAT  #1C
02326:  NOP     
....................    for(i=0; i<8; ++i) 
02328:  CLR.B   8AF
0232A:  MOV     8AE,W4
0232C:  LSR     W4,#8,W4
0232E:  CP.B    W4L,#8
02330:  BRA     C,2362
....................    { 
....................       output_bit(FR_SI, shift_left(&wrdi,1,0)); 
02332:  BCLR.B  42.0
02334:  RLC.B   8B6
02336:  BRA     C,233C
02338:  BCLR.B  2DC.6
0233A:  BRA     233E
0233C:  BSET.B  2DC.6
0233E:  BCLR.B  2D8.6
....................       delay_us(1); 
02340:  REPEAT  #1C
02342:  NOP     
....................       output_high(FR_SCK); 
02344:  BCLR.B  2D8.5
02346:  BSET.B  2DC.5
....................       delay_us(1); 
02348:  REPEAT  #1C
0234A:  NOP     
....................       output_low(FR_SI); 
0234C:  BCLR.B  2D8.6
0234E:  BCLR.B  2DC.6
....................       delay_us(1); 
02350:  REPEAT  #1C
02352:  NOP     
....................       output_low(FR_SCK); 
02354:  BCLR.B  2D8.5
02356:  BCLR.B  2DC.5
....................       delay_us(1); 
02358:  REPEAT  #1C
0235A:  NOP     
....................    } 
0235C:  INC.B   08AF
0235E:  GOTO    232A
....................    delay_us(1); 
02362:  REPEAT  #1C
02364:  NOP     
....................    output_high(FR_CS); 
02366:  BCLR.B  2E4.7
02368:  BSET.B  2E8.7
....................    delay_us(1); 
0236A:  REPEAT  #1C
0236C:  NOP     
.................... } 
0236E:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... unsigned int8 fr_read_byte(unsigned int16 address)  
.................... { 
....................    unsigned int8 cmd[3]; 
....................    unsigned int8 i,data; 
....................    unsigned int8 read; 
....................     
....................    //     76543210  
....................    read=0b00000011; 
*
01C32:  MOV.B   #3,W0L
01C34:  MOV.B   W0L,8B5
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Read on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    cmd[0]=address; 
01C36:  MOV.B   8AE,W0L
01C38:  MOV.B   W0L,8B0
....................    cmd[1]=address/256; 
01C3A:  MOV.B   8AF,W0L
01C3C:  MOV.B   W0L,8B1
....................    cmd[2]=read; 
01C3E:  MOV.B   8B5,W0L
01C40:  MOV.B   W0L,8B2
....................  
....................    output_low(FR_CS); 
01C42:  BCLR.B  2E4.7
01C44:  BCLR.B  2E8.7
....................    delay_us(1); 
01C46:  REPEAT  #1C
01C48:  NOP     
....................    for(i=0; i<24; ++i) 
01C4A:  CLR.B   8B3
01C4C:  MOV     8B2,W4
01C4E:  LSR     W4,#8,W4
01C50:  CP.B    W4L,#18
01C52:  BRA     C,1C86
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,3,0)); 
01C54:  BCLR.B  42.0
01C56:  RLC     8B0
01C58:  RLC.B   8B2
01C5A:  BRA     C,1C60
01C5C:  BCLR.B  2DC.6
01C5E:  BRA     1C62
01C60:  BSET.B  2DC.6
01C62:  BCLR.B  2D8.6
....................       delay_us(1); 
01C64:  REPEAT  #1C
01C66:  NOP     
....................       output_high(FR_SCK); 
01C68:  BCLR.B  2D8.5
01C6A:  BSET.B  2DC.5
....................       delay_us(1); 
01C6C:  REPEAT  #1C
01C6E:  NOP     
....................       output_low(FR_SI); 
01C70:  BCLR.B  2D8.6
01C72:  BCLR.B  2DC.6
....................       delay_us(1); 
01C74:  REPEAT  #1C
01C76:  NOP     
....................       output_low(FR_SCK); 
01C78:  BCLR.B  2D8.5
01C7A:  BCLR.B  2DC.5
....................       delay_us(1); 
01C7C:  REPEAT  #1C
01C7E:  NOP     
....................    } 
01C80:  INC.B   08B3
01C82:  GOTO    1C4C
....................    for(i=0; i<8; ++i) 
01C86:  CLR.B   8B3
01C88:  MOV     8B2,W4
01C8A:  LSR     W4,#8,W4
01C8C:  CP.B    W4L,#8
01C8E:  BRA     C,1CBC
....................    { 
....................       delay_us(1); 
01C90:  REPEAT  #1C
01C92:  NOP     
....................       shift_left(&data,1,input(FR_SO)); 
01C94:  BSET.B  2D8.7
01C96:  BTSC.B  2DA.7
01C98:  BRA     1C9E
01C9A:  BCLR.B  42.0
01C9C:  BRA     1CA0
01C9E:  BSET.B  42.0
01CA0:  RLC.B   8B4
....................       output_high(FR_SCK); 
01CA2:  BCLR.B  2D8.5
01CA4:  BSET.B  2DC.5
....................       delay_us(1); 
01CA6:  REPEAT  #1C
01CA8:  NOP     
....................       delay_us(1); 
01CAA:  REPEAT  #1C
01CAC:  NOP     
....................       output_low(FR_SCK); 
01CAE:  BCLR.B  2D8.5
01CB0:  BCLR.B  2DC.5
....................       delay_us(1); 
01CB2:  REPEAT  #1C
01CB4:  NOP     
....................    } 
01CB6:  INC.B   08B3
01CB8:  GOTO    1C88
....................    output_high(FR_CS); 
01CBC:  BCLR.B  2E4.7
01CBE:  BSET.B  2E8.7
....................    delay_us(1); 
01CC0:  REPEAT  #1C
01CC2:  NOP     
....................     
....................    return(data); 
01CC4:  MOV.B   8B4,W0L
01CC6:  MOV.B   W0L,0
.................... } 
01CC8:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... void fr_write(unsigned int16 address,unsigned int16 data) 
.................... { 
*
02370:  MOV     W5,[W15++]
....................    unsigned int8 data_high; 
....................    unsigned int8 data_low; 
....................    data_low=(unsigned int8)data; 
02372:  MOV.B   8A0,W0L
02374:  MOV.B   W0L,8A3
....................    data_high=(unsigned int8)(data>>8); 
02376:  MOV.B   8A1,W0L
02378:  CLR.B   1
0237A:  MOV.B   W0L,8A2
....................     
....................    fr_write_byte(address,data_low); 
0237C:  MOV.B   8A3,W0L
0237E:  MOV.B   W0L,8AE
02380:  PUSH    89E
02382:  POP     8AC
02384:  CALL    2264
....................    fr_write_byte(address+1,data_high); 
02388:  MOV     89E,W4
0238A:  ADD     W4,#1,W4
0238C:  MOV     W4,W5
0238E:  MOV.B   8A2,W0L
02390:  MOV.B   W0L,8AE
02392:  MOV     W5,8AC
02394:  CALL    2264
....................     
....................    return; 
.................... } 
02398:  MOV     [--W15],W5
0239A:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... unsigned int16 fr_read(unsigned int16 address) 
.................... { 
*
01CCA:  MOV     W5,[W15++]
....................    unsigned int16 data_buffer; 
....................    unsigned int16 data_low; 
....................    unsigned int16 data_high; 
....................     
....................    data_low=fr_read_byte(address); 
01CCC:  PUSH    8A0
01CCE:  POP     8AE
01CD0:  CALL    1C32
01CD4:  MOV.B   W0L,8A4
01CD6:  CLR.B   8A5
....................    data_high=fr_read_byte(address+1); 
01CD8:  MOV     8A0,W4
01CDA:  ADD     W4,#1,W4
01CDC:  MOV     W4,W5
01CDE:  MOV     W5,8AE
01CE0:  CALL    1C32
01CE4:  MOV.B   W0L,8A6
01CE6:  CLR.B   8A7
....................     
....................    data_buffer=(data_high<<8)+data_low; 
01CE8:  MOV.B   8A6,W0L
01CEA:  MOV.B   W0L,B
01CEC:  CLR.B   W5
01CEE:  MOV     W5,W0
01CF0:  ADD     8A4,W0
01CF2:  MOV     W0,8A2
....................     
....................    return data_buffer; 
01CF4:  PUSH    8A2
01CF6:  POP     0
.................... } 
01CF8:  MOV     [--W15],W5
01CFA:  RETURN  
....................  
.................... // Returns serial number of the device via RS232 
.................... void data_get_serial_no() 
.................... { 
*
032FA:  MOV     W5,[W15++]
032FC:  MOV     W6,[W15++]
....................    if(!debug_mode_fr)  
032FE:  BTSC.B  800.2
03300:  BRA     3304
....................       return; 
03302:  BRA     336E
....................        
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
03304:  CLR.B   890
....................     
....................    fprintf(RS232, "Serial No:"); 
03306:  MOV     #0,W1
03308:  MOV     W1,W0
0330A:  CALL    326
0330E:  INC     W1,W1
03310:  MOV     W1,[W15++]
03312:  BTSC.B  219.1
03314:  BRA     3312
03316:  MOV     W0,21A
03318:  MOV     [--W15],W1
0331A:  MOV     #9,W0
0331C:  CPSGT   W1,W0
0331E:  BRA     3308
....................    for(i=0; i<13; i++) 
03320:  CLR.B   890
03322:  MOV     890,W4
03324:  CP.B    W4L,#D
03326:  BRA     C,335E
....................    { 
....................       input[i]=fr_read_byte(fr_serial_no+i); 
03328:  MOV     890,W4
0332A:  CLR.B   9
0332C:  MOV     #892,W3
0332E:  ADD     W4,W3,W5
03330:  MOV     890,W4
03332:  CLR.B   9
03334:  MOV     832,W3
03336:  ADD     W3,W4,W6
03338:  MOV     W6,8AE
0333A:  CALL    1C32
0333E:  MOV.B   W0L,[W5]
....................       fputc(input[i]+48,RS232); 
03340:  MOV     890,W4
03342:  CLR.B   9
03344:  MOV     #892,W3
03346:  ADD     W4,W3,W0
03348:  MOV     #30,W4
0334A:  MOV.B   [W0],W3L
0334C:  ADD.B   W3L,W4L,W5L
0334E:  MOV.B   W5L,W0L
03350:  BTSC.B  219.1
03352:  BRA     3350
03354:  MOV.B   W0L,21A
03356:  CLR.B   21B
....................    } 
03358:  INC.B   0890
0335A:  GOTO    3322
....................    fprintf(RS232, "\n\r"); 
0335E:  BTSC.B  219.1
03360:  BRA     335E
03362:  MOV     #A,W4
03364:  MOV     W4,21A
03366:  BTSC.B  219.1
03368:  BRA     3366
0336A:  MOV     #D,W4
0336C:  MOV     W4,21A
.................... } 
0336E:  MOV     [--W15],W6
03370:  MOV     [--W15],W5
03372:  RETURN  
.................... // Returns movement range of the device 
.................... unsigned int16 data_get_move_range() 
.................... { 
*
01CFC:  PUSH    834
01CFE:  POP     8A0
01D00:  CALL    1CCA
01D04:  MOV     W0,890
....................    unsigned int16 range = fr_read(fr_move_range); 
....................     
....................    if(debug_mode_fr)  
01D06:  BTSS.B  800.2
01D08:  BRA     1D46
....................       fprintf(RS232, "Movement Range: %u mm\n\r", range); 
01D0A:  MOV     #0,W1
01D0C:  MOV     W1,W0
01D0E:  CALL    33E
01D12:  INC     W1,W1
01D14:  MOV     W1,[W15++]
01D16:  BTSC.B  219.1
01D18:  BRA     1D16
01D1A:  MOV     W0,21A
01D1C:  MOV     [--W15],W1
01D1E:  MOV     #F,W0
01D20:  CPSGT   W1,W0
01D22:  BRA     1D0C
01D24:  MOV     890,W0
01D26:  MOV     #0,W4
01D28:  CALL    1572
01D2C:  MOV     #12,W1
01D2E:  MOV     W1,W0
01D30:  CALL    33E
01D34:  INC     W1,W1
01D36:  MOV     W1,[W15++]
01D38:  BTSC.B  219.1
01D3A:  BRA     1D38
01D3C:  MOV     W0,21A
01D3E:  MOV     [--W15],W1
01D40:  MOV     #16,W0
01D42:  CPSGT   W1,W0
01D44:  BRA     1D2E
....................     
....................    return range; 
01D46:  PUSH    890
01D48:  POP     0
.................... } 
01D4A:  RETURN  
.................... // Returns home position 
.................... unsigned int16 data_get_home_pos() 
.................... { 
01D4C:  PUSH    836
01D4E:  POP     8A0
01D50:  CALL    1CCA
01D54:  MOV     W0,89E
....................    unsigned int16 home_pos = fr_read(fr_home_pos); 
....................     
....................    if(debug_mode_fr)  
01D56:  BTSS.B  800.2
01D58:  BRA     1D96
....................       fprintf(RS232, "Home Distance: %u counts\n\r", home_pos); 
01D5A:  MOV     #0,W1
01D5C:  MOV     W1,W0
01D5E:  CALL    362
01D62:  INC     W1,W1
01D64:  MOV     W1,[W15++]
01D66:  BTSC.B  219.1
01D68:  BRA     1D66
01D6A:  MOV     W0,21A
01D6C:  MOV     [--W15],W1
01D6E:  MOV     #E,W0
01D70:  CPSGT   W1,W0
01D72:  BRA     1D5C
01D74:  MOV     89E,W0
01D76:  MOV     #0,W4
01D78:  CALL    1572
01D7C:  MOV     #11,W1
01D7E:  MOV     W1,W0
01D80:  CALL    362
01D84:  INC     W1,W1
01D86:  MOV     W1,[W15++]
01D88:  BTSC.B  219.1
01D8A:  BRA     1D88
01D8C:  MOV     W0,21A
01D8E:  MOV     [--W15],W1
01D90:  MOV     #19,W0
01D92:  CPSGT   W1,W0
01D94:  BRA     1D7E
....................        
....................    return home_pos; 
01D96:  PUSH    89E
01D98:  POP     0
.................... } 
01D9A:  RETURN  
.................... // Returns end position 
.................... unsigned int16 data_get_end_pos() 
.................... { 
01D9C:  PUSH    838
01D9E:  POP     8A0
01DA0:  CALL    1CCA
01DA4:  MOV     W0,890
....................    unsigned int16 end = fr_read(fr_end_pos); 
....................     
....................    if(debug_mode_fr) 
01DA6:  BTSS.B  800.2
01DA8:  BRA     1DE6
....................       fprintf(RS232, "End Distance: %u counts\n\r", end); 
01DAA:  MOV     #0,W1
01DAC:  MOV     W1,W0
01DAE:  CALL    38A
01DB2:  INC     W1,W1
01DB4:  MOV     W1,[W15++]
01DB6:  BTSC.B  219.1
01DB8:  BRA     1DB6
01DBA:  MOV     W0,21A
01DBC:  MOV     [--W15],W1
01DBE:  MOV     #D,W0
01DC0:  CPSGT   W1,W0
01DC2:  BRA     1DAC
01DC4:  MOV     890,W0
01DC6:  MOV     #0,W4
01DC8:  CALL    1572
01DCC:  MOV     #10,W1
01DCE:  MOV     W1,W0
01DD0:  CALL    38A
01DD4:  INC     W1,W1
01DD6:  MOV     W1,[W15++]
01DD8:  BTSC.B  219.1
01DDA:  BRA     1DD8
01DDC:  MOV     W0,21A
01DDE:  MOV     [--W15],W1
01DE0:  MOV     #18,W0
01DE2:  CPSGT   W1,W0
01DE4:  BRA     1DCE
....................     
....................    return end; 
01DE6:  PUSH    890
01DE8:  POP     0
.................... } 
01DEA:  RETURN  
.................... // Returns positioning velocity 
.................... unsigned int16 data_get_conv_const() 
.................... { 
*
01E80:  PUSH    83A
01E82:  POP     8A0
01E84:  CALL    1CCA
01E88:  MOV     W0,890
....................    unsigned int16 conv_const = fr_read(fr_conv_const); 
....................     
....................    if((conv_const < 12000)||(conv_const > 13000)) 
01E8A:  MOV     890,W4
01E8C:  MOV     #2EE0,W3
01E8E:  CP      W3,W4
01E90:  BRA     GTU,1E9A
01E92:  MOV     890,W4
01E94:  MOV     #32C8,W3
01E96:  CP      W3,W4
01E98:  BRA     C,1E9E
....................       conv_const = 12500; 
01E9A:  MOV     #30D4,W4
01E9C:  MOV     W4,890
....................     
....................    if(debug_mode_fr)  
01E9E:  BTSS.B  800.2
01EA0:  BRA     1EDC
....................       fprintf(RS232, "Conversion Constant: %u \n\r", conv_const); 
01EA2:  MOV     #0,W1
01EA4:  MOV     W1,W0
01EA6:  CALL    3B0
01EAA:  INC     W1,W1
01EAC:  MOV     W1,[W15++]
01EAE:  BTSC.B  219.1
01EB0:  BRA     1EAE
01EB2:  MOV     W0,21A
01EB4:  MOV     [--W15],W1
01EB6:  MOV     #14,W0
01EB8:  CPSGT   W1,W0
01EBA:  BRA     1EA4
01EBC:  MOV     890,W0
01EBE:  MOV     #0,W4
01EC0:  CALL    1572
01EC4:  BTSC.B  219.1
01EC6:  BRA     1EC4
01EC8:  MOV     #20,W4
01ECA:  MOV     W4,21A
01ECC:  BTSC.B  219.1
01ECE:  BRA     1ECC
01ED0:  MOV     #A,W4
01ED2:  MOV     W4,21A
01ED4:  BTSC.B  219.1
01ED6:  BRA     1ED4
01ED8:  MOV     #D,W4
01EDA:  MOV     W4,21A
....................     
....................    return conv_const; 
01EDC:  PUSH    890
01EDE:  POP     0
.................... } 
01EE0:  RETURN  
.................... // Returns the backlash of the system 
.................... unsigned int16 data_get_backlash() 
.................... { 
*
01DEC:  PUSH    83C
01DEE:  POP     8A0
01DF0:  CALL    1CCA
01DF4:  MOV     W0,890
....................    unsigned int16 backlash = fr_read(fr_backlash); 
....................  
....................    if(debug_mode_fr)  
01DF6:  BTSS.B  800.2
01DF8:  BRA     1E36
....................       fprintf(RS232, "Backlash: %u counts\n\r", backlash); 
01DFA:  MOV     #0,W1
01DFC:  MOV     W1,W0
01DFE:  CALL    3D8
01E02:  INC     W1,W1
01E04:  MOV     W1,[W15++]
01E06:  BTSC.B  219.1
01E08:  BRA     1E06
01E0A:  MOV     W0,21A
01E0C:  MOV     [--W15],W1
01E0E:  MOV     #9,W0
01E10:  CPSGT   W1,W0
01E12:  BRA     1DFC
01E14:  MOV     890,W0
01E16:  MOV     #0,W4
01E18:  CALL    1572
01E1C:  MOV     #C,W1
01E1E:  MOV     W1,W0
01E20:  CALL    3D8
01E24:  INC     W1,W1
01E26:  MOV     W1,[W15++]
01E28:  BTSC.B  219.1
01E2A:  BRA     1E28
01E2C:  MOV     W0,21A
01E2E:  MOV     [--W15],W1
01E30:  MOV     #14,W0
01E32:  CPSGT   W1,W0
01E34:  BRA     1E1E
....................     
....................    return backlash; 
01E36:  PUSH    890
01E38:  POP     0
.................... } 
01E3A:  RETURN  
.................... // Returns communication type 
.................... unsigned int8 data_get_comm_type() 
.................... { 
*
02E16:  PUSH    83E
02E18:  POP     8AE
02E1A:  CALL    1C32
02E1E:  MOV.B   W0L,890
....................    unsigned int8 comm_type=fr_read_byte(fr_comm_type); 
....................     
....................    if(debug_mode_fr) 
02E20:  BTSS.B  800.2
02E22:  BRA     2E8C
....................       switch (comm_type) 
....................       { 
02E24:  MOV.B   890,W0L
02E26:  CLR.B   1
02E28:  XOR     #0,W0
02E2A:  BRA     Z,2E32
02E2C:  XOR     #1,W0
02E2E:  BRA     Z,2E50
02E30:  BRA     2E6E
....................          case 0   :  fprintf(RS232,"Communication Type: Parallel Port\n\r"); 
02E32:  MOV     #0,W1
02E34:  MOV     W1,W0
02E36:  CALL    3FA
02E3A:  INC     W1,W1
02E3C:  MOV     W1,[W15++]
02E3E:  BTSC.B  219.1
02E40:  BRA     2E3E
02E42:  MOV     W0,21A
02E44:  MOV     [--W15],W1
02E46:  MOV     #22,W0
02E48:  CPSGT   W1,W0
02E4A:  BRA     2E34
....................                      break; 
02E4C:  GOTO    2E8C
....................          case 1   :  fprintf(RS232,"Communication Type: Serial Port\n\r"); 
02E50:  MOV     #0,W1
02E52:  MOV     W1,W0
02E54:  CALL    42A
02E58:  INC     W1,W1
02E5A:  MOV     W1,[W15++]
02E5C:  BTSC.B  219.1
02E5E:  BRA     2E5C
02E60:  MOV     W0,21A
02E62:  MOV     [--W15],W1
02E64:  MOV     #20,W0
02E66:  CPSGT   W1,W0
02E68:  BRA     2E52
....................                      break; 
02E6A:  GOTO    2E8C
....................          default  :  fprintf(RS232,"Communication Type: Undefined\n\r"); 
02E6E:  MOV     #0,W1
02E70:  MOV     W1,W0
02E72:  CALL    458
02E76:  INC     W1,W1
02E78:  MOV     W1,[W15++]
02E7A:  BTSC.B  219.1
02E7C:  BRA     2E7A
02E7E:  MOV     W0,21A
02E80:  MOV     [--W15],W1
02E82:  MOV     #1E,W0
02E84:  CPSGT   W1,W0
02E86:  BRA     2E70
....................                      break; 
02E88:  GOTO    2E8C
....................       } 
....................        
....................    return comm_type; 
02E8C:  MOV.B   890,W0L
02E8E:  MOV.B   W0L,0
.................... } 
02E90:  RETURN  
.................... // Returns last position 
.................... unsigned int16 data_get_last_pos() 
.................... { 
*
02214:  PUSH    840
02216:  POP     8A0
02218:  CALL    1CCA
0221C:  MOV     W0,890
....................    unsigned int16 position=fr_read(fr_last_pos); 
....................     
....................    if(debug_mode_fr)  
0221E:  BTSS.B  800.2
02220:  BRA     225E
....................       fprintf(RS232, "Last Position: %u mm\n\r", position); 
02222:  MOV     #0,W1
02224:  MOV     W1,W0
02226:  CALL    484
0222A:  INC     W1,W1
0222C:  MOV     W1,[W15++]
0222E:  BTSC.B  219.1
02230:  BRA     222E
02232:  MOV     W0,21A
02234:  MOV     [--W15],W1
02236:  MOV     #E,W0
02238:  CPSGT   W1,W0
0223A:  BRA     2224
0223C:  MOV     890,W0
0223E:  MOV     #0,W4
02240:  CALL    1572
02244:  MOV     #11,W1
02246:  MOV     W1,W0
02248:  CALL    484
0224C:  INC     W1,W1
0224E:  MOV     W1,[W15++]
02250:  BTSC.B  219.1
02252:  BRA     2250
02254:  MOV     W0,21A
02256:  MOV     [--W15],W1
02258:  MOV     #15,W0
0225A:  CPSGT   W1,W0
0225C:  BRA     2246
....................     
....................    return position; 
0225E:  PUSH    890
02260:  POP     0
.................... } 
02262:  RETURN  
.................... // Returns the position in the given index 
.................... unsigned int16 data_get_pos(unsigned int8 index) 
.................... { 
*
03430:  MOV     W5,[W15++]
03432:  MOV.B   896,W0L
03434:  SL      W0,#1,W0
03436:  ZE      W0,W0
03438:  CLR.B   1
0343A:  MOV     842,W4
0343C:  ADD     W0,W4,W5
0343E:  MOV     W5,8A0
03440:  CALL    1CCA
03444:  MOV     W0,898
....................    unsigned int16 position=fr_read(fr_pos_table+index*2); 
....................     
....................    if(debug_mode_fr) 
03446:  BTSS.B  800.2
03448:  BRA     34AA
....................       fprintf(RS232,"Index: %u, Position: %u mm\n\r", index, position); 
0344A:  MOV     #0,W1
0344C:  MOV     W1,W0
0344E:  CALL    4A8
03452:  INC     W1,W1
03454:  MOV     W1,[W15++]
03456:  BTSC.B  219.1
03458:  BRA     3456
0345A:  MOV     W0,21A
0345C:  MOV     [--W15],W1
0345E:  MOV     #6,W0
03460:  CPSGT   W1,W0
03462:  BRA     344C
03464:  MOV.B   896,W0L
03466:  CLR.B   1
03468:  MOV     #0,W4
0346A:  CALL    1572
0346E:  MOV     #9,W1
03470:  MOV     W1,W0
03472:  CALL    4A8
03476:  INC     W1,W1
03478:  MOV     W1,[W15++]
0347A:  BTSC.B  219.1
0347C:  BRA     347A
0347E:  MOV     W0,21A
03480:  MOV     [--W15],W1
03482:  MOV     #14,W0
03484:  CPSGT   W1,W0
03486:  BRA     3470
03488:  MOV     898,W0
0348A:  MOV     #0,W4
0348C:  CALL    1572
03490:  MOV     #17,W1
03492:  MOV     W1,W0
03494:  CALL    4A8
03498:  INC     W1,W1
0349A:  MOV     W1,[W15++]
0349C:  BTSC.B  219.1
0349E:  BRA     349C
034A0:  MOV     W0,21A
034A2:  MOV     [--W15],W1
034A4:  MOV     #1B,W0
034A6:  CPSGT   W1,W0
034A8:  BRA     3492
....................     
....................    return position; 
034AA:  PUSH    898
034AC:  POP     0
.................... } 
034AE:  MOV     [--W15],W5
034B0:  RETURN  
.................... // Returns position table via RS232 
.................... void data_get_pos_table() 
.................... { 
034B2:  MOV     W5,[W15++]
....................    debug_mode_fr=1; 
034B4:  BSET.B  800.2
....................     
....................    unsigned int input; 
....................    unsigned int i; 
....................    unsigned int index; 
....................     
....................    input=(unsigned)(fgetc(RS232)-48); 
034B6:  BTSS.B  218.0
034B8:  BRA     34B6
034BA:  MOV     21C,W0
034BC:  MOV     #30,W4
034BE:  SUB.B   W0L,W4L,W0L
034C0:  MOV.B   W0L,890
034C2:  CLR.B   891
....................    fputc(input+48,RS232); 
034C4:  MOV     #30,W4
034C6:  MOV     890,W3
034C8:  ADD     W3,W4,W5
034CA:  MOV.B   W5L,W0L
034CC:  BTSC.B  219.1
034CE:  BRA     34CC
034D0:  MOV.B   W0L,21A
034D2:  CLR.B   21B
....................  
....................    if(input>9) 
034D4:  MOV     890,W4
034D6:  CP      W4,#9
034D8:  BRA     LEU,34DE
....................       input=9; 
034DA:  MOV     #9,W4
034DC:  MOV     W4,890
....................  
....................    fprintf(RS232,"\n\r"); 
034DE:  BTSC.B  219.1
034E0:  BRA     34DE
034E2:  MOV     #A,W4
034E4:  MOV     W4,21A
034E6:  BTSC.B  219.1
034E8:  BRA     34E6
034EA:  MOV     #D,W4
034EC:  MOV     W4,21A
....................     
....................    for(i=0; i<10; i++) 
034EE:  CLR     892
034F0:  MOV     892,W4
034F2:  CP      W4,#A
034F4:  BRA     C,3510
....................    { 
....................       index=input*10+i; 
034F6:  MOV     890,W4
034F8:  MUL.UU  W4,#A,W0
034FA:  MOV     W0,W5
034FC:  MOV     W5,W0
034FE:  ADD     892,W0
03500:  MOV     W0,894
....................       data_get_pos(index); 
03502:  MOV.B   894,W0L
03504:  MOV.B   W0L,896
03506:  CALL    3430
....................    } 
0350A:  INC     0892
0350C:  GOTO    34F0
....................     
....................    debug_mode_fr=0; 
03510:  BCLR.B  800.2
.................... } 
03512:  MOV     [--W15],W5
03514:  RETURN  
.................... // Returns all system data via RS232 
.................... void data_get_sys_data() 
.................... { 
....................    fprintf(RS232,"MODESIS LASER POSITIONING SYSTEM\n\n\r"); 
*
03374:  MOV     #0,W1
03376:  MOV     W1,W0
03378:  CALL    4D2
0337C:  INC     W1,W1
0337E:  MOV     W1,[W15++]
03380:  BTSC.B  219.1
03382:  BRA     3380
03384:  MOV     W0,21A
03386:  MOV     [--W15],W1
03388:  MOV     #22,W0
0338A:  CPSGT   W1,W0
0338C:  BRA     3376
....................    debug_mode_fr=1; 
0338E:  BSET.B  800.2
....................    data_get_serial_no(); 
03390:  CALL    32FA
....................    data_get_move_range(); 
03394:  CALL    1CFC
....................    data_get_home_pos(); 
03398:  CALL    1D4C
....................    data_get_end_pos(); 
0339C:  CALL    1D9C
....................    data_get_conv_const(); 
033A0:  CALL    1E80
....................    data_get_backlash(); 
033A4:  CALL    1DEC
....................    data_get_comm_type(); 
033A8:  CALL    2E16
....................    data_get_last_pos(); 
033AC:  CALL    2214
....................    debug_mode_fr=0; 
033B0:  BCLR.B  800.2
....................    fprintf(RS232,"\n\r"); 
033B2:  BTSC.B  219.1
033B4:  BRA     33B2
033B6:  MOV     #A,W4
033B8:  MOV     W4,21A
033BA:  BTSC.B  219.1
033BC:  BRA     33BA
033BE:  MOV     #D,W4
033C0:  MOV     W4,21A
....................    fprintf(RS232,"RCON REGISTER VALUE SIFIRLANIYOR..."); 
033C2:  MOV     #0,W1
033C4:  MOV     W1,W0
033C6:  CALL    502
033CA:  INC     W1,W1
033CC:  MOV     W1,[W15++]
033CE:  BTSC.B  219.1
033D0:  BRA     33CE
033D2:  MOV     W0,21A
033D4:  MOV     [--W15],W1
033D6:  MOV     #22,W0
033D8:  CPSGT   W1,W0
033DA:  BRA     33C4
....................    fprintf(RS232,"\n\r"); 
033DC:  BTSC.B  219.1
033DE:  BRA     33DC
033E0:  MOV     #A,W4
033E2:  MOV     W4,21A
033E4:  BTSC.B  219.1
033E6:  BRA     33E4
033E8:  MOV     #D,W4
033EA:  MOV     W4,21A
....................    fprintf(RS232,"YENI RCON REGISTER VALUE(10'luk Tabanda):"); 
033EC:  MOV     #0,W1
033EE:  MOV     W1,W0
033F0:  CALL    532
033F4:  INC     W1,W1
033F6:  MOV     W1,[W15++]
033F8:  BTSC.B  219.1
033FA:  BRA     33F8
033FC:  MOV     W0,21A
033FE:  MOV     [--W15],W1
03400:  MOV     #28,W0
03402:  CPSGT   W1,W0
03404:  BRA     33EE
....................    fprintf(RS232,"%u",RCON); 
03406:  MOV     740,W0
03408:  MOV     #0,W4
0340A:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
0340E:  BTSC.B  219.1
03410:  BRA     340E
03412:  MOV     #A,W4
03414:  MOV     W4,21A
03416:  BTSC.B  219.1
03418:  BRA     3416
0341A:  MOV     #D,W4
0341C:  MOV     W4,21A
....................    fprintf(RS232,"\n\r"); 
0341E:  BTSC.B  219.1
03420:  BRA     341E
03422:  MOV     #A,W4
03424:  MOV     W4,21A
03426:  BTSC.B  219.1
03428:  BRA     3426
0342A:  MOV     #D,W4
0342C:  MOV     W4,21A
.................... } 
0342E:  RETURN  
....................  
.................... // Sets serial nuber of the device 
.................... void data_set_serial_no() 
.................... { 
*
02E92:  MOV     W5,[W15++]
02E94:  MOV     W6,[W15++]
02E96:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
....................    for(i=0; i<13; i++) 
02E98:  CLR.B   890
02E9A:  MOV     890,W4
02E9C:  CP.B    W4L,#D
02E9E:  BRA     C,2EF0
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02EA0:  MOV     890,W4
02EA2:  CLR.B   9
02EA4:  MOV     #892,W3
02EA6:  ADD     W4,W3,W5
02EA8:  BTSS.B  218.0
02EAA:  BRA     2EA8
02EAC:  MOV     21C,W0
02EAE:  SUB.B   #30,W0L
02EB0:  CLR.B   1
02EB2:  MOV.B   W0L,[W5]
....................       fr_write_byte(fr_serial_no+i, input[i]); 
02EB4:  MOV     890,W4
02EB6:  CLR.B   9
02EB8:  MOV     832,W3
02EBA:  ADD     W3,W4,W5
02EBC:  MOV     890,W4
02EBE:  CLR.B   9
02EC0:  MOV     #892,W3
02EC2:  ADD     W4,W3,W0
02EC4:  MOV.B   [W0],W6L
02EC6:  PUSH    8AE
02EC8:  MOV.B   W6L,[W15-#2]
02ECA:  POP     8AE
02ECC:  MOV     W5,8AC
02ECE:  CALL    2264
....................       fputc(input[i]+48,RS232); 
02ED2:  MOV     890,W4
02ED4:  CLR.B   9
02ED6:  MOV     #892,W3
02ED8:  ADD     W4,W3,W0
02EDA:  MOV     #30,W4
02EDC:  MOV.B   [W0],W3L
02EDE:  ADD.B   W3L,W4L,W5L
02EE0:  MOV.B   W5L,W0L
02EE2:  BTSC.B  219.1
02EE4:  BRA     2EE2
02EE6:  MOV.B   W0L,21A
02EE8:  CLR.B   21B
....................    } 
02EEA:  INC.B   0890
02EEC:  GOTO    2E9A
.................... } 
02EF0:  MOV     [--W15],W6
02EF2:  MOV     [--W15],W5
02EF4:  RETURN  
.................... // Sets movement range of the device 
.................... void data_set_move_range() 
.................... { 
02EF6:  MOV     W5,[W15++]
02EF8:  MOV     W6,[W15++]
02EFA:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0;i<4;i++) 
02EFC:  CLR.B   890
02EFE:  MOV     890,W4
02F00:  CP.B    W4L,#4
02F02:  BRA     C,2F38
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02F04:  MOV.B   890,W0L
02F06:  CLR.B   1
02F08:  SL      W0,#1,W0
02F0A:  MOV     #892,W4
02F0C:  ADD     W0,W4,W5
02F0E:  BTSS.B  218.0
02F10:  BRA     2F0E
02F12:  MOV     21C,W0
02F14:  SUB.B   #30,W0L
02F16:  CLR.B   1
02F18:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
02F1A:  MOV.B   890,W0L
02F1C:  CLR.B   1
02F1E:  SL      W0,#1,W0
02F20:  MOV     #892,W4
02F22:  ADD     W0,W4,W0
02F24:  MOV     [W0],W5
02F26:  ADD     #30,W5
02F28:  MOV.B   W5L,W0L
02F2A:  BTSC.B  219.1
02F2C:  BRA     2F2A
02F2E:  MOV.B   W0L,21A
02F30:  CLR.B   21B
....................    } 
02F32:  INC.B   0890
02F34:  GOTO    2EFE
....................    unsigned int range=1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
02F38:  MOV     #3E8,W4
02F3A:  MOV     892,W3
02F3C:  MUL.UU  W4,W3,W0
02F3E:  MOV     W0,W5
02F40:  MOV     #64,W4
02F42:  MOV     894,W3
02F44:  MUL.UU  W4,W3,W0
02F46:  ADD     W0,W5,W5
02F48:  MOV     896,W4
02F4A:  MUL.UU  W4,#A,W0
02F4C:  ADD     W0,W5,W5
02F4E:  MOV     W5,W0
02F50:  ADD     898,W0
02F52:  MOV     W0,89A
....................     
....................    if(range<400) 
02F54:  MOV     89A,W4
02F56:  MOV     #190,W3
02F58:  CP      W3,W4
02F5A:  BRA     LEU,2F7E
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be smaller than 400 mm. Movement range is set to 400 mm."); 
02F5C:  MOV     #0,W1
02F5E:  MOV     W1,W0
02F60:  CALL    56A
02F64:  INC     W1,W1
02F66:  MOV     W1,[W15++]
02F68:  BTSC.B  219.1
02F6A:  BRA     2F68
02F6C:  MOV     W0,21A
02F6E:  MOV     [--W15],W1
02F70:  MOV     #5E,W0
02F72:  CPSGT   W1,W0
02F74:  BRA     2F5E
....................       range=400; 
02F76:  MOV     #190,W4
02F78:  MOV     W4,89A
....................    } 
....................    else if(range>2000) 
02F7A:  GOTO    2FA4
02F7E:  MOV     89A,W4
02F80:  MOV     #7D0,W3
02F82:  CP      W3,W4
02F84:  BRA     C,2FA4
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be larger than 2000 mm. Movement range is set to 2000 mm."); 
02F86:  MOV     #0,W1
02F88:  MOV     W1,W0
02F8A:  CALL    5C6
02F8E:  INC     W1,W1
02F90:  MOV     W1,[W15++]
02F92:  BTSC.B  219.1
02F94:  BRA     2F92
02F96:  MOV     W0,21A
02F98:  MOV     [--W15],W1
02F9A:  MOV     #5F,W0
02F9C:  CPSGT   W1,W0
02F9E:  BRA     2F88
....................       range=2000; 
02FA0:  MOV     #7D0,W4
02FA2:  MOV     W4,89A
....................    } 
....................     
....................    if(range==2000) 
02FA4:  MOV     89A,W4
02FA6:  MOV     #7D0,W3
02FA8:  CP      W3,W4
02FAA:  BRA     NZ,2FB4
....................       md_min_distance=120; 
02FAC:  MOV     #78,W4
02FAE:  MOV     W4,818
....................    else 
02FB0:  GOTO    2FB8
....................       md_min_distance=70; 
02FB4:  MOV     #46,W4
02FB6:  MOV     W4,818
....................        
....................    fr_write(fr_move_range, range); 
02FB8:  PUSH    834
02FBA:  POP     89E
02FBC:  PUSH    89A
02FBE:  POP     8A0
02FC0:  CALL    2370
....................    md_move_range=range; 
02FC4:  PUSH    89A
02FC6:  POP     80E
.................... } 
02FC8:  MOV     [--W15],W6
02FCA:  MOV     [--W15],W5
02FCC:  RETURN  
.................... // Sets home position 
.................... void data_set_home_pos() 
.................... { 
02FCE:  MOV     W5,[W15++]
02FD0:  MOV     W6,[W15++]
02FD2:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0; i<4; i++) 
02FD4:  CLR.B   890
02FD6:  MOV     890,W4
02FD8:  CP.B    W4L,#4
02FDA:  BRA     C,3010
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02FDC:  MOV.B   890,W0L
02FDE:  CLR.B   1
02FE0:  SL      W0,#1,W0
02FE2:  MOV     #892,W4
02FE4:  ADD     W0,W4,W5
02FE6:  BTSS.B  218.0
02FE8:  BRA     2FE6
02FEA:  MOV     21C,W0
02FEC:  SUB.B   #30,W0L
02FEE:  CLR.B   1
02FF0:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
02FF2:  MOV.B   890,W0L
02FF4:  CLR.B   1
02FF6:  SL      W0,#1,W0
02FF8:  MOV     #892,W4
02FFA:  ADD     W0,W4,W0
02FFC:  MOV     [W0],W5
02FFE:  ADD     #30,W5
03000:  MOV.B   W5L,W0L
03002:  BTSC.B  219.1
03004:  BRA     3002
03006:  MOV.B   W0L,21A
03008:  CLR.B   21B
....................    } 
0300A:  INC.B   0890
0300C:  GOTO    2FD6
....................    unsigned int home_pos = 1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
03010:  MOV     #3E8,W4
03012:  MOV     892,W3
03014:  MUL.UU  W4,W3,W0
03016:  MOV     W0,W5
03018:  MOV     #64,W4
0301A:  MOV     894,W3
0301C:  MUL.UU  W4,W3,W0
0301E:  ADD     W0,W5,W5
03020:  MOV     896,W4
03022:  MUL.UU  W4,#A,W0
03024:  ADD     W0,W5,W5
03026:  MOV     W5,W0
03028:  ADD     898,W0
0302A:  MOV     W0,89A
....................     
....................    if(home_pos<10) 
0302C:  MOV     89A,W4
0302E:  CP      W4,#A
03030:  BRA     C,304E
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Home position cannot be smaller than 10. Home position is not changed"); 
03032:  MOV     #0,W1
03034:  MOV     W1,W0
03036:  CALL    624
0303A:  INC     W1,W1
0303C:  MOV     W1,[W15++]
0303E:  BTSC.B  219.1
03040:  BRA     303E
03042:  MOV     W0,21A
03044:  MOV     [--W15],W1
03046:  MOV     #55,W0
03048:  CPSGT   W1,W0
0304A:  BRA     3034
....................       return; 
0304C:  BRA     305E
....................    } 
....................     
....................    fr_write(fr_home_pos,home_pos); 
0304E:  PUSH    836
03050:  POP     89E
03052:  PUSH    89A
03054:  POP     8A0
03056:  CALL    2370
....................    md_home_pos=home_pos; 
0305A:  PUSH    89A
0305C:  POP     810
.................... } 
0305E:  MOV     [--W15],W6
03060:  MOV     [--W15],W5
03062:  RETURN  
.................... // Sets end position 
.................... void data_set_end_pos() 
.................... { 
03064:  MOV     W5,[W15++]
03066:  MOV     W6,[W15++]
03068:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[5]; 
....................    for(i=0; i<5; i++) 
0306A:  CLR.B   890
0306C:  MOV     890,W4
0306E:  CP.B    W4L,#5
03070:  BRA     C,30A6
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03072:  MOV.B   890,W0L
03074:  CLR.B   1
03076:  SL      W0,#1,W0
03078:  MOV     #892,W4
0307A:  ADD     W0,W4,W5
0307C:  BTSS.B  218.0
0307E:  BRA     307C
03080:  MOV     21C,W0
03082:  SUB.B   #30,W0L
03084:  CLR.B   1
03086:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03088:  MOV.B   890,W0L
0308A:  CLR.B   1
0308C:  SL      W0,#1,W0
0308E:  MOV     #892,W4
03090:  ADD     W0,W4,W0
03092:  MOV     [W0],W5
03094:  ADD     #30,W5
03096:  MOV.B   W5L,W0L
03098:  BTSC.B  219.1
0309A:  BRA     3098
0309C:  MOV.B   W0L,21A
0309E:  CLR.B   21B
....................    } 
030A0:  INC.B   0890
030A2:  GOTO    306C
....................    unsigned int end=10000*input[0]+1000*input[1]+100*input[2]+10*input[3]+1*input[4]; 
030A6:  MOV     #2710,W4
030A8:  MOV     892,W3
030AA:  MUL.UU  W4,W3,W0
030AC:  MOV     W0,W5
030AE:  MOV     #3E8,W4
030B0:  MOV     894,W3
030B2:  MUL.UU  W4,W3,W0
030B4:  ADD     W0,W5,W5
030B6:  MOV     #64,W4
030B8:  MOV     896,W3
030BA:  MUL.UU  W4,W3,W0
030BC:  ADD     W0,W5,W5
030BE:  MOV     898,W4
030C0:  MUL.UU  W4,#A,W0
030C2:  ADD     W0,W5,W5
030C4:  MOV     W5,W0
030C6:  ADD     89A,W0
030C8:  MOV     W0,89C
....................     
....................    if(end<md_home_pos) 
030CA:  MOV     89C,W0
030CC:  MOV     810,W4
030CE:  CP      W4,W0
030D0:  BRA     LEU,30F8
....................    { 
....................       end=data_get_home_pos()+50; 
030D2:  CALL    1D4C
030D6:  MOV     W0,W5
030D8:  MOV     #32,W4
030DA:  ADD     W5,W4,W0
030DC:  MOV     W0,89C
....................       fprintf(RS232, "\n\rInvalid entry: End position cannot be smaller than home position. End position is set to its default."); 
030DE:  MOV     #0,W1
030E0:  MOV     W1,W0
030E2:  CALL    67A
030E6:  INC     W1,W1
030E8:  MOV     W1,[W15++]
030EA:  BTSC.B  219.1
030EC:  BRA     30EA
030EE:  MOV     W0,21A
030F0:  MOV     [--W15],W1
030F2:  MOV     #66,W0
030F4:  CPSGT   W1,W0
030F6:  BRA     30E0
....................    } 
....................     
....................    fr_write(fr_end_pos,end); 
030F8:  PUSH    838
030FA:  POP     89E
030FC:  PUSH    89C
030FE:  POP     8A0
03100:  CALL    2370
....................    md_end_pos=end; 
03104:  PUSH    89C
03106:  POP     812
.................... } 
03108:  MOV     [--W15],W6
0310A:  MOV     [--W15],W5
0310C:  RETURN  
.................... // Sets positioning velocity 
.................... void data_set_conv_const() 
.................... { 
0310E:  MOV     W5,[W15++]
03110:  MOV     W6,[W15++]
....................    md_conv_const = 12500; 
03112:  MOV     #30D4,W4
03114:  MOV     W4,80C
....................    md_cc_step = 0; 
03116:  CLR     82E
....................    md_cc_count = 0; 
03118:  CLR     830
....................     
....................    move_pos(md_min_distance); 
0311A:  PUSH    818
0311C:  POP     894
0311E:  CALL    2AD4
....................  
....................    unsigned int cc_first_count = qei_get_count(); 
03122:  CALL    1F8A
03126:  MOV     W0,890
....................     
....................    reg_md_cc_sample =1; 
03128:  BSET.B  84C.4
....................    move_pos(md_move_range); 
0312A:  PUSH    80E
0312C:  POP     894
0312E:  CALL    2AD4
....................     
....................    unsigned int conv_const = ((float)(cc_first_count - md_cc_count)/(float)md_cc_step)*10000; 
03132:  MOV     890,W4
03134:  MOV     830,W3
03136:  SUB     W4,W3,W0
03138:  CALL    23AA
*
03166:  MOV     W0,892
....................  
....................    fprintf(RS232, "Count: %u counts\n\r", cc_first_count-md_cc_count); 
03168:  MOV     890,W4
0316A:  MOV     830,W3
0316C:  SUB     W4,W3,W5
0316E:  MOV     #0,W1
03170:  MOV     W1,W0
03172:  CALL    6DC
03176:  INC     W1,W1
03178:  MOV     W1,[W15++]
0317A:  BTSC.B  219.1
0317C:  BRA     317A
0317E:  MOV     W0,21A
03180:  MOV     [--W15],W1
03182:  MOV     #6,W0
03184:  CPSGT   W1,W0
03186:  BRA     3170
03188:  MOV     W5,W0
0318A:  MOV     #0,W4
0318C:  CALL    1572
03190:  MOV     #9,W1
03192:  MOV     W1,W0
03194:  CALL    6DC
03198:  INC     W1,W1
0319A:  MOV     W1,[W15++]
0319C:  BTSC.B  219.1
0319E:  BRA     319C
031A0:  MOV     W0,21A
031A2:  MOV     [--W15],W1
031A4:  MOV     #11,W0
031A6:  CPSGT   W1,W0
031A8:  BRA     3192
....................    fprintf(RS232, "Step: %u steps\n\r", md_cc_step); 
031AA:  MOV     #0,W1
031AC:  MOV     W1,W0
031AE:  CALL    6FC
031B2:  INC     W1,W1
031B4:  MOV     W1,[W15++]
031B6:  BTSC.B  219.1
031B8:  BRA     31B6
031BA:  MOV     W0,21A
031BC:  MOV     [--W15],W1
031BE:  MOV     #5,W0
031C0:  CPSGT   W1,W0
031C2:  BRA     31AC
031C4:  MOV     82E,W0
031C6:  MOV     #0,W4
031C8:  CALL    1572
031CC:  MOV     #8,W1
031CE:  MOV     W1,W0
031D0:  CALL    6FC
031D4:  INC     W1,W1
031D6:  MOV     W1,[W15++]
031D8:  BTSC.B  219.1
031DA:  BRA     31D8
031DC:  MOV     W0,21A
031DE:  MOV     [--W15],W1
031E0:  MOV     #F,W0
031E2:  CPSGT   W1,W0
031E4:  BRA     31CE
....................    fprintf(RS232, "Conversion Constant: %u counts\n\r", conv_const); 
031E6:  MOV     #0,W1
031E8:  MOV     W1,W0
031EA:  CALL    71A
031EE:  INC     W1,W1
031F0:  MOV     W1,[W15++]
031F2:  BTSC.B  219.1
031F4:  BRA     31F2
031F6:  MOV     W0,21A
031F8:  MOV     [--W15],W1
031FA:  MOV     #14,W0
031FC:  CPSGT   W1,W0
031FE:  BRA     31E8
03200:  MOV     892,W0
03202:  MOV     #0,W4
03204:  CALL    1572
03208:  MOV     #17,W1
0320A:  MOV     W1,W0
0320C:  CALL    71A
03210:  INC     W1,W1
03212:  MOV     W1,[W15++]
03214:  BTSC.B  219.1
03216:  BRA     3214
03218:  MOV     W0,21A
0321A:  MOV     [--W15],W1
0321C:  MOV     #1F,W0
0321E:  CPSGT   W1,W0
03220:  BRA     320A
....................    
....................    fr_write(fr_conv_const,conv_const); 
03222:  PUSH    83A
03224:  POP     89E
03226:  PUSH    892
03228:  POP     8A0
0322A:  CALL    2370
....................    md_conv_const = conv_const; 
0322E:  PUSH    892
03230:  POP     80C
.................... } 
03232:  MOV     [--W15],W6
03234:  MOV     [--W15],W5
03236:  RETURN  
.................... // Sets backlash 
.................... void data_set_backlash() 
.................... { 
03238:  MOV     W5,[W15++]
0323A:  MOV     W6,[W15++]
0323C:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[2]; 
....................    for(i=0; i<2; i++) 
0323E:  CLR.B   890
03240:  MOV     890,W4
03242:  CP.B    W4L,#2
03244:  BRA     C,327A
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03246:  MOV.B   890,W0L
03248:  CLR.B   1
0324A:  SL      W0,#1,W0
0324C:  MOV     #892,W4
0324E:  ADD     W0,W4,W5
03250:  BTSS.B  218.0
03252:  BRA     3250
03254:  MOV     21C,W0
03256:  SUB.B   #30,W0L
03258:  CLR.B   1
0325A:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
0325C:  MOV.B   890,W0L
0325E:  CLR.B   1
03260:  SL      W0,#1,W0
03262:  MOV     #892,W4
03264:  ADD     W0,W4,W0
03266:  MOV     [W0],W5
03268:  ADD     #30,W5
0326A:  MOV.B   W5L,W0L
0326C:  BTSC.B  219.1
0326E:  BRA     326C
03270:  MOV.B   W0L,21A
03272:  CLR.B   21B
....................    } 
03274:  INC.B   0890
03276:  GOTO    3240
....................    unsigned int backlash = 10*input[0]+1*input[1]; 
0327A:  MOV     892,W4
0327C:  MUL.UU  W4,#A,W0
0327E:  MOV     W0,W5
03280:  MOV     W5,W0
03282:  ADD     894,W0
03284:  MOV     W0,896
....................     
....................    fr_write(fr_backlash,backlash); 
03286:  PUSH    83C
03288:  POP     89E
0328A:  PUSH    896
0328C:  POP     8A0
0328E:  CALL    2370
....................    md_backlash = backlash; 
03292:  PUSH    896
03294:  POP     82C
.................... } 
03296:  MOV     [--W15],W6
03298:  MOV     [--W15],W5
0329A:  RETURN  
.................... // Sets communication type 
.................... void data_set_comm_type() 
.................... { 
0329C:  MOV     W5,[W15++]
0329E:  BTSS.B  218.0
032A0:  BRA     329E
032A2:  MOV     21C,W0
032A4:  MOV     #30,W4
032A6:  SUB.B   W0L,W4L,W0L
032A8:  MOV.B   W0L,890
....................    unsigned int8 input=(unsigned)(fgetc(RS232)-48); 
....................    fputc(input+48,RS232); 
032AA:  MOV     #30,W4
032AC:  MOV     890,W3
032AE:  ADD.B   W3L,W4L,W5L
032B0:  MOV.B   W5L,W0L
032B2:  BTSC.B  219.1
032B4:  BRA     32B2
032B6:  MOV.B   W0L,21A
032B8:  CLR.B   21B
....................    switch (input) 
....................    { 
032BA:  MOV.B   890,W0L
032BC:  CLR.B   1
032BE:  XOR     #1,W0
032C0:  BRA     Z,32C8
032C2:  XOR     #1,W0
032C4:  BRA     Z,32E0
032C6:  BRA     32E0
....................       case 1   :  output_low(PP_ACK); 
032C8:  BCLR.B  2D2.4
032CA:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
032CC:  BCLR.B  2D2.5
032CE:  BCLR.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 1); 
032D0:  MOV.B   #1,W0L
032D2:  MOV.B   W0L,8AE
032D4:  PUSH    83E
032D6:  POP     8AC
032D8:  CALL    2264
....................                   break; 
032DC:  GOTO    32F6
....................       case 0   :     
....................       default  :  output_high(PP_ACK); 
032E0:  BCLR.B  2D2.4
032E2:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
032E4:  BCLR.B  2D2.5
032E6:  BSET.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 0); 
032E8:  CLR.B   8AE
032EA:  PUSH    83E
032EC:  POP     8AC
032EE:  CALL    2264
....................                   break; 
032F2:  GOTO    32F6
....................    } 
.................... } 
032F6:  MOV     [--W15],W5
032F8:  RETURN  
.................... // Sets last position 
.................... void data_set_last_pos(unsigned int16 position) 
.................... { 
....................    fr_write(fr_last_pos, position); 
*
0239C:  PUSH    840
0239E:  POP     89E
023A0:  PUSH    89A
023A2:  POP     8A0
023A4:  CALL    2370
.................... } 
023A8:  RETURN  
.................... // Sets position to given index 
.................... void data_set_pos(unsigned int8 index, unsigned int16 position) 
.................... { 
*
03516:  MOV     W5,[W15++]
....................    fr_write(fr_pos_table+index*2, position); 
03518:  MOV.B   892,W0L
0351A:  SL      W0,#1,W0
0351C:  ZE      W0,W0
0351E:  CLR.B   1
03520:  MOV     842,W4
03522:  ADD     W0,W4,W5
03524:  MOV     W5,89E
03526:  PUSH    894
03528:  POP     8A0
0352A:  CALL    2370
.................... } 
0352E:  MOV     [--W15],W5
03530:  RETURN  
....................  
.................... // Initializes the quadrature encoder interface module by using default values 
.................... void qei_init() 
.................... { 
....................    // Disable QEI module  
....................    QEI_QEICON_QEIM0=0; 
*
01628:  BCLR.B  123.0
....................    QEI_QEICON_QEIM1=0; 
0162A:  BCLR.B  123.1
....................    QEI_QEICON_QEIM2=0; 
0162C:  BCLR.B  123.2
....................    // Clear any count errors 
....................    QEI_QEICON_CNTERR=0; 
0162E:  BCLR.B  123.7
....................    // Continue module operation during sleep 
....................    QEI_QEICON_QEISIDL=0; 
01630:  BCLR.B  123.5
....................    // QEA and QEB not swapped 
....................    QEI_QEICON_SWPAB=0; 
01632:  BCLR.B  122.7
....................    // Normal I/O pin operation 
....................    QEI_QEICON_PCDOUT=0; 
01634:  BCLR.B  122.6
....................    // Timer gated time accumulation disabled 
....................    QEI_QEICON_TQGATE=0; 
01636:  BCLR.B  122.5
....................    // 1:1 timer input clock prescale 
....................    QEI_QEICON_TQCKPS0=0; 
01638:  BCLR.B  122.3
....................    QEI_QEICON_TQCKPS1=0; 
0163A:  BCLR.B  122.4
....................    // Index pulse does not reset the position counter 
....................    QEI_QEICON_POSRES = 0; 
0163C:  BCLR.B  122.2
....................    // Internal clock as timer clock source 
....................    QEI_QEICON_TQCS = 0; 
0163E:  BCLR.B  122.1
....................    // QEI_QEICON_UPDN defines timer counter (QEI_POSCNT) direction 
....................    QEI_QEICON_UDSRC = 0; 
01640:  BCLR.B  122.0
....................     
....................    // Count error interrupts enabled 
....................    QEI_DFLTCON_CEID = 0;  
01642:  BCLR.B  125.0
....................    // Digital filter outputs enabled 
....................    QEI_DFLTCON_QEOUT = 1;  
01644:  BSET.B  124.7
....................    // 1:256 clock divide for digital filter 
....................    QEI_DFLTCON_QECK2 = 1; 
01646:  BSET.B  124.6
....................    QEI_DFLTCON_QECK1 = 1; 
01648:  BSET.B  124.5
....................    QEI_DFLTCON_QECK0 = 1; 
0164A:  BSET.B  124.4
....................     
....................    // Reset position counter 
....................    QEI_POSCNT = 0x0000; 
0164C:  CLR     126
....................     
....................    // Set maximum count 
....................    QEI_MAXCNT = 0xFFFF; 
0164E:  SETM    128
....................     
....................    // QEI module enabled in x4 mode with position counter reset by QEI_MAXCNT match 
....................    QEI_QEICON_QEIM2 = 1; 
01650:  BSET.B  123.2
....................    QEI_QEICON_QEIM1 = 1; 
01652:  BSET.B  123.1
....................    QEI_QEICON_QEIM0 = 1; 
01654:  BSET.B  123.0
....................     
....................    if(debug_mode_qei) 
01656:  BTSS.B  800.5
01658:  BRA     1674
....................       fprintf(RS232,"Quadrature Encoder Initialized\n\n\r"); 
0165A:  MOV     #0,W1
0165C:  MOV     W1,W0
0165E:  CALL    748
01662:  INC     W1,W1
01664:  MOV     W1,[W15++]
01666:  BTSC.B  219.1
01668:  BRA     1666
0166A:  MOV     W0,21A
0166C:  MOV     [--W15],W1
0166E:  MOV     #20,W0
01670:  CPSGT   W1,W0
01672:  BRA     165C
.................... } 
01674:  RETURN  
.................... // Sets the position counter to given value 
.................... void qei_set_count(unsigned int16 value) 
.................... {  
....................    QEI_POSCNT = value; 
*
01F46:  PUSH    8A8
01F48:  POP     126
....................     
....................    if(debug_mode_qei) 
01F4A:  BTSS.B  800.5
01F4C:  BRA     1F88
....................       fprintf(RS232,"Quadrature Encoder Count Set: %u\n\n\r", value); 
01F4E:  MOV     #0,W1
01F50:  MOV     W1,W0
01F52:  CALL    776
01F56:  INC     W1,W1
01F58:  MOV     W1,[W15++]
01F5A:  BTSC.B  219.1
01F5C:  BRA     1F5A
01F5E:  MOV     W0,21A
01F60:  MOV     [--W15],W1
01F62:  MOV     #1D,W0
01F64:  CPSGT   W1,W0
01F66:  BRA     1F50
01F68:  MOV     8A8,W0
01F6A:  MOV     #0,W4
01F6C:  CALL    1572
01F70:  BTSC.B  219.1
01F72:  BRA     1F70
01F74:  MOV     #A,W4
01F76:  MOV     W4,21A
01F78:  BTSC.B  219.1
01F7A:  BRA     1F78
01F7C:  MOV     #A,W4
01F7E:  MOV     W4,21A
01F80:  BTSC.B  219.1
01F82:  BRA     1F80
01F84:  MOV     #D,W4
01F86:  MOV     W4,21A
.................... } 
01F88:  RETURN  
.................... // Sets the maximum count to given value 
.................... void qei_set_max_count(unsigned int16 value) 
.................... {  
....................    QEI_MAXCNT = value; 
*
01E3C:  PUSH    856
01E3E:  POP     128
....................     
....................    if(debug_mode_qei) 
01E40:  BTSS.B  800.5
01E42:  BRA     1E7E
....................       fprintf(RS232,"Quadrature Encoder Maximum Count Set: %u\n\n\r", value); 
01E44:  MOV     #0,W1
01E46:  MOV     W1,W0
01E48:  CALL    7A6
01E4C:  INC     W1,W1
01E4E:  MOV     W1,[W15++]
01E50:  BTSC.B  219.1
01E52:  BRA     1E50
01E54:  MOV     W0,21A
01E56:  MOV     [--W15],W1
01E58:  MOV     #25,W0
01E5A:  CPSGT   W1,W0
01E5C:  BRA     1E46
01E5E:  MOV     856,W0
01E60:  MOV     #0,W4
01E62:  CALL    1572
01E66:  BTSC.B  219.1
01E68:  BRA     1E66
01E6A:  MOV     #A,W4
01E6C:  MOV     W4,21A
01E6E:  BTSC.B  219.1
01E70:  BRA     1E6E
01E72:  MOV     #A,W4
01E74:  MOV     W4,21A
01E76:  BTSC.B  219.1
01E78:  BRA     1E76
01E7A:  MOV     #D,W4
01E7C:  MOV     W4,21A
.................... } 
01E7E:  RETURN  
.................... // Returns the value of the position counter 
.................... unsigned int16 qei_get_count(){ return QEI_POSCNT;} 
*
01F8A:  PUSH    126
01F8C:  POP     0
01F8E:  RETURN  
....................  
.................... // Sets the operating mode of the PWM module 
.................... void pwm_select_mode(unsigned int mode) 
.................... { 
....................    if(mode == FREE) 
*
01676:  CP0     8A8
01678:  BRA     NZ,1682
....................    { 
....................       // Select free running PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
0167A:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 0; 
0167C:  BCLR.B  1C0.0
....................    } 
....................    else if(mode == SINGLE) 
0167E:  GOTO    168C
01682:  MOV     8A8,W4
01684:  CP      W4,#1
01686:  BRA     NZ,168C
....................    { 
....................       // Select single event PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
01688:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 1; 
0168A:  BSET.B  1C0.0
....................    } 
.................... } 
0168C:  RETURN  
.................... // Initializes the PWM module by using default values 
.................... void pwm_init() 
.................... { 
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN       = 0; 
0168E:  BCLR.B  1C1.7
....................     
....................    // Select 1:1 output postscale 
....................    PWM_PTCON_PTOPS3     = 0; 
01690:  BCLR.B  1C0.7
....................    PWM_PTCON_PTOPS2     = 0; 
01692:  BCLR.B  1C0.6
....................    PWM_PTCON_PTOPS1     = 0; 
01694:  BCLR.B  1C0.5
....................    PWM_PTCON_PTOPS0     = 0; 
01696:  BCLR.B  1C0.4
....................    // Select 1:1 input prescale 
....................    PWM_PTCON_PTCKPS1    = 0; 
01698:  BCLR.B  1C0.3
....................    PWM_PTCON_PTCKPS0    = 0; 
0169A:  BCLR.B  1C0.2
....................     
....................    // Set the operating mode of PWM module 
....................    pwm_select_mode(FREE); 
0169C:  CLR     8A8
0169E:  CALL    1676
....................  
....................    // Select independent output mode for PWM1 I/O pair 
....................    PWM_PWMCON1_PMOD1    = 1; 
016A2:  BSET.B  1C9.0
....................    // Set PWM1H pin as PWM output 
....................    PWM_PWMCON1_PEN1H    = 1; 
016A4:  BSET.B  1C8.4
....................     
....................    // Synchronize PDC registers to the PWM time base 
....................    PWM_PWMCON2_IUE      = 0; 
016A6:  BCLR.B  1CA.2
....................    // Enable PWM interrupt 
....................    PWM_IEC2_PWMIE       = 0; 
016A8:  BCLR.B  90.7
....................     
....................    // Set time base period value 
....................    PWM_PTPER            = 0; 
016AA:  CLR     1C4
....................    // Set time base duty cycle 
....................    PWM_PDC1             = 0; 
016AC:  CLR     1D6
....................  
....................    if(debug_mode_md) 
016AE:  BTSS.B  800.3
016B0:  BRA     16CC
....................       fprintf(RS232,"PWM Module Initialized\n\n\r"); 
016B2:  MOV     #0,W1
016B4:  MOV     W1,W0
016B6:  CALL    7E0
016BA:  INC     W1,W1
016BC:  MOV     W1,[W15++]
016BE:  BTSC.B  219.1
016C0:  BRA     16BE
016C2:  MOV     W0,21A
016C4:  MOV     [--W15],W1
016C6:  MOV     #18,W0
016C8:  CPSGT   W1,W0
016CA:  BRA     16B4
.................... } 
016CC:  RETURN  
.................... // Set PWM period time (us) 
.................... void pwm_set_period(unsigned int16 period) 
.................... { 
*
01EE2:  MOV     W5,[W15++]
....................    // PWM period 
....................    unsigned int16 pwm_period;  
....................     
....................    // Set the PWM period 
....................    if(period==0) 
01EE4:  CP0     8AC
01EE6:  BRA     NZ,1EEE
....................       pwm_period = 0; 
01EE8:  CLR     8AE
....................    else 
01EEA:  GOTO    1EF8
....................       pwm_period = 30 * period - 1; 
01EEE:  MOV     8AC,W4
01EF0:  MUL.UU  W4,#1E,W0
01EF2:  MOV     W0,W5
01EF4:  SUB     W5,#1,W0
01EF6:  MOV     W0,8AE
....................     
....................    // Updates from duty cycle and period buffer registers are disabled 
....................    PWM_PWMCON2_UDIS = 1; 
01EF8:  BSET.B  1CA.0
....................    // Set time base period value 
....................    PWM_PTPER        = pwm_period; 
01EFA:  PUSH    8AE
01EFC:  POP     1C4
....................    // Set time base duty cycle if PWM module is enabled (duty cycle > 0%) 
....................    PWM_PDC1         = pwm_period; 
01EFE:  PUSH    8AE
01F00:  POP     1D6
....................    // Updates from duty cycle and period buffer registers are enabled 
....................    PWM_PWMCON2_UDIS = 0; 
01F02:  BCLR.B  1CA.0
.................... } 
01F04:  MOV     [--W15],W5
01F06:  RETURN  
.................... // Disable PWM module 
.................... void pwm_disable() 
.................... { 
....................    // Set duty cycle to zero 
....................    PWM_PDC1=0; 
*
01F18:  CLR     1D6
....................    // Wait for the last signal 
....................    delay_us(PWM_PTPER + 1 / 30); 
01F1A:  MOV     1C4,W0
01F1C:  CALL    1F08
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN = 0; 
01F20:  BCLR.B  1C1.7
....................    // Set duty cycle to its initial value 
....................    PWM_PDC1=PWM_PTPER; 
01F22:  PUSH    1C4
01F24:  POP     1D6
....................     
....................    if(debug_mode_pwm) 
01F26:  BTSS.B  800.4
01F28:  BRA     1F44
....................       fprintf(RS232,"PWM Disabled\n\r"); 
01F2A:  MOV     #0,W1
01F2C:  MOV     W1,W0
01F2E:  CALL    806
01F32:  INC     W1,W1
01F34:  MOV     W1,[W15++]
01F36:  BTSC.B  219.1
01F38:  BRA     1F36
01F3A:  MOV     W0,21A
01F3C:  MOV     [--W15],W1
01F3E:  MOV     #D,W0
01F40:  CPSGT   W1,W0
01F42:  BRA     1F2C
.................... } 
01F44:  RETURN  
.................... // Enable PWM module 
.................... void pwm_enable() 
.................... { 
*
01F90:  MOV     W5,[W15++]
....................    // Disable RS232 receive byte interrupt 
....................    disable_interrupts(INT_RDA2); 
01F92:  BCLR.B  8F.0
....................     
....................    // Enable PWM module 
....................    PWM_PTCON_PTEN = 1; 
01F94:  BSET.B  1C1.7
....................    // Start pwm cycle 
....................    int1 reg_md_running = 1; 
....................    unsigned int md_step_count = 0; 
01F96:  BSET.B  8A2.0
01F98:  CLR     8A4
....................     
....................    while(reg_md_running) 
....................    { 
01F9A:  BTSS.B  8A2.0
01F9C:  BRA     21CA
....................       if(PWM_IFS2_PWMIF) 
01F9E:  BTSS.B  88.7
01FA0:  BRA     21C6
....................       { 
....................          // Clear the flag register 
....................          PWM_IFS2_PWMIF = 0; 
01FA2:  BCLR.B  88.7
....................           
....................          md_step_count++; 
01FA4:  INC     08A4
....................        
....................          switch(md_run_state)  
....................          { 
01FA6:  MOV.B   801,W0L
01FA8:  CLR.B   1
01FAA:  XOR     #0,W0
01FAC:  BRA     Z,1FC0
01FAE:  XOR     #1,W0
01FB0:  BRA     Z,2068
01FB2:  XOR     #2,W0
01FB4:  BRA     Z,20D2
01FB6:  XOR     #1,W0
01FB8:  BRA     Z,20F2
01FBA:  XOR     #6,W0
01FBC:  BRA     Z,213C
01FBE:  BRA     21C6
....................             case HOME: 
....................                if(reg_md_home_return == 0) 
01FC0:  BTSC.B  84C.2
01FC2:  BRA     2042
....................                { 
....................                   if(reg_md_home == 0) 
01FC4:  BTSC.B  84C.1
01FC6:  BRA     2016
....................                   { 
....................                      if(input(MD_SW)) 
01FC8:  BSET.B  2D3.3
01FCA:  BTSS.B  2D5.3
01FCC:  BRA     1FFE
....................                      { 
....................                         if(md_step_count < md_max_acc_lim) 
01FCE:  MOV     8A4,W0
01FD0:  MOV     84E,W4
01FD2:  CP      W4,W0
01FD4:  BRA     LEU,1FEE
....................                         { 
....................                            md_decel_count = md_step_count; 
01FD6:  PUSH    8A4
01FD8:  POP     826
....................                            pwm_set_period(delays[md_step_count]); 
01FDA:  MOV     8A4,W0
01FDC:  SL      W0,#1,W0
01FDE:  CALL    100
01FE2:  MOV     W0,W5
01FE4:  MOV     W5,8AC
01FE6:  CALL    1EE2
....................                         } 
....................                         else 
01FEA:  GOTO    1FFA
....................                         { 
....................                            md_decel_count = md_max_acc_lim; 
01FEE:  PUSH    84E
01FF0:  POP     826
....................                            pwm_set_period(md_min_delay); 
01FF2:  PUSH    820
01FF4:  POP     8AC
01FF6:  CALL    1EE2
....................                         } 
....................                      } 
....................                      else 
01FFA:  GOTO    2012
....................                      { 
....................                         reg_md_home = 1; 
01FFE:  BSET.B  84C.1
....................                         md_decel_count--; 
02000:  DEC     0826
....................                         pwm_set_period(delays[md_decel_count]); 
02002:  MOV     826,W0
02004:  SL      W0,#1,W0
02006:  CALL    100
0200A:  MOV     W0,W5
0200C:  MOV     W5,8AC
0200E:  CALL    1EE2
....................                      } 
....................                   } 
....................                   else 
02012:  GOTO    203E
....................                   { 
....................                      if(md_decel_count == 0) 
02016:  CP0     826
02018:  BRA     NZ,202C
....................                      {   
....................                         reg_md_home_return = 1; 
0201A:  BSET.B  84C.2
....................                         output_low(MD_DIR); 
0201C:  BCLR.B  2D8.4
0201E:  BCLR.B  2DC.4
....................                         pwm_set_period(1000); 
02020:  MOV     #3E8,W4
02022:  MOV     W4,8AC
02024:  CALL    1EE2
....................                      } 
....................                      else 
02028:  GOTO    203E
....................                      { 
....................                         md_decel_count--; 
0202C:  DEC     0826
....................                         pwm_set_period(delays[md_decel_count]); 
0202E:  MOV     826,W0
02030:  SL      W0,#1,W0
02032:  CALL    100
02036:  MOV     W0,W5
02038:  MOV     W5,8AC
0203A:  CALL    1EE2
....................                      } 
....................                   } 
....................                } 
....................                else 
0203E:  GOTO    2064
....................                { 
....................                   if(input(MD_SW)) 
02042:  BSET.B  2D3.3
02044:  BTSS.B  2D5.3
02046:  BRA     2064
....................                   { 
....................                      pwm_disable(); 
02048:  CALL    1F18
....................                      reg_md_running = 0; 
0204C:  BCLR.B  8A2.0
....................                       
....................                      delay_ms(50); 
0204E:  MOV     #32,W0
02050:  CALL    155E
....................                      qei_set_count(md_home_offset); 
02054:  PUSH    816
02056:  POP     8A8
02058:  CALL    1F46
....................                      md_mt_set(mt_percent_rest); 
0205C:  PUSH    80A
0205E:  POP     8A8
02060:  CALL    1B88
....................                   } 
....................                } 
....................                break; 
02064:  GOTO    21C6
....................                 
....................             case ACCEL: 
....................                // Check if we should start deceleration. 
....................                if(md_step_count >= md_accel_lim)  
02068:  MOV     824,W0
0206A:  MOV     8A4,W4
0206C:  CP      W4,W0
0206E:  BRA     NC,20BE
....................                { 
....................                   if(md_step_count == md_decel_lim) 
02070:  MOV     8A4,W0
02072:  CP      822
02074:  BRA     NZ,2090
....................                   { 
....................                      md_decel_count--; 
02076:  DEC     0826
....................                      pwm_set_period(delays[md_decel_count]); 
02078:  MOV     826,W0
0207A:  SL      W0,#1,W0
0207C:  CALL    100
02080:  MOV     W0,W5
02082:  MOV     W5,8AC
02084:  CALL    1EE2
....................                      md_run_state = DECEL; 
02088:  MOV.B   #2,W0L
0208A:  MOV.B   W0L,801
....................                   } 
....................                   else if(md_decel_lim - md_step_count < 2) 
0208C:  GOTO    20BA
02090:  MOV     822,W4
02092:  MOV     8A4,W3
02094:  SUB     W4,W3,W5
02096:  CP      W5,#2
02098:  BRA     C,20AE
....................                   { 
....................                      pwm_set_period(delays[md_step_count]); 
0209A:  MOV     8A4,W0
0209C:  SL      W0,#1,W0
0209E:  CALL    100
020A2:  MOV     W0,W5
020A4:  MOV     W5,8AC
020A6:  CALL    1EE2
....................                   } 
....................                   else 
020AA:  GOTO    20BA
....................                   { 
....................                      pwm_set_period(md_min_delay); 
020AE:  PUSH    820
020B0:  POP     8AC
020B2:  CALL    1EE2
....................                      md_run_state = RUN; 
020B6:  MOV.B   #3,W0L
020B8:  MOV.B   W0L,801
....................                   } 
....................                } 
....................                else 
020BA:  GOTO    20CE
....................                { 
....................                   pwm_set_period(delays[md_step_count]); 
020BE:  MOV     8A4,W0
020C0:  SL      W0,#1,W0
020C2:  CALL    100
020C6:  MOV     W0,W5
020C8:  MOV     W5,8AC
020CA:  CALL    1EE2
....................                } 
....................                break; 
020CE:  GOTO    21C6
....................        
....................             case RUN: 
....................                // Check if we should start decelration. 
....................                if(md_step_count == md_decel_lim)  
020D2:  MOV     8A4,W0
020D4:  CP      822
020D6:  BRA     NZ,20EE
....................                { 
....................                   md_decel_count--; 
020D8:  DEC     0826
....................                   pwm_set_period(delays[md_decel_count]); 
020DA:  MOV     826,W0
020DC:  SL      W0,#1,W0
020DE:  CALL    100
020E2:  MOV     W0,W5
020E4:  MOV     W5,8AC
020E6:  CALL    1EE2
....................                   md_run_state = DECEL; 
020EA:  MOV.B   #2,W0L
020EC:  MOV.B   W0L,801
....................                } 
....................                break; 
020EE:  GOTO    21C6
....................        
....................             case DECEL: 
....................                // Check if we at last step 
....................                if(md_decel_count == 0) 
020F2:  CP0     826
020F4:  BRA     NZ,2126
....................                { 
....................                   pwm_disable(); 
020F6:  CALL    1F18
....................                   md_pos_iter = 0; 
020FA:  CLR     828
....................                   md_run_state = POS; 
020FC:  MOV.B   #4,W0L
020FE:  MOV.B   W0L,801
....................                    
....................                   delay_ms(50); 
02100:  MOV     #32,W0
02102:  CALL    155E
....................  
....................                   md_error = md_target_count - qei_get_count(); 
02106:  CALL    1F8A
0210A:  MOV     81A,W4
0210C:  SUB     W4,W0,W0
0210E:  MOV     W0,82A
....................                    
....................                   if(md_error > 1) 
02110:  MOV     82A,W4
02112:  CP      W4,#1
02114:  BRA     LE,211E
....................                      output_low(MD_DIR); 
02116:  BCLR.B  2D8.4
02118:  BCLR.B  2DC.4
....................                   else 
0211A:  GOTO    2122
....................                      output_high(MD_DIR); 
0211E:  BCLR.B  2D8.4
02120:  BSET.B  2DC.4
....................                } 
....................                else 
02122:  GOTO    2138
....................                { 
....................                   md_decel_count--; 
02126:  DEC     0826
....................                   pwm_set_period(delays[md_decel_count]); 
02128:  MOV     826,W0
0212A:  SL      W0,#1,W0
0212C:  CALL    100
02130:  MOV     W0,W5
02132:  MOV     W5,8AC
02134:  CALL    1EE2
....................                } 
....................                break; 
02138:  GOTO    21C6
....................                 
....................             case POS: 
....................                md_pos_iter++; 
0213C:  INC     0828
....................                 
....................                delay_ms(50); 
0213E:  MOV     #32,W0
02140:  CALL    155E
....................                 
....................                if(reg_md_cc_sample) 
02144:  BTSS.B  84C.4
02146:  BRA     215A
....................                { 
....................                   reg_md_cc_sample = 0; 
02148:  BCLR.B  84C.4
....................                   delay_ms(50); 
0214A:  MOV     #32,W0
0214C:  CALL    155E
....................                   md_cc_step = md_step_count; 
02150:  PUSH    8A4
02152:  POP     82E
....................                   md_cc_count = qei_get_count(); 
02154:  CALL    1F8A
02158:  MOV     W0,830
....................                } 
....................  
....................                int difference; 
....................                 
....................                if(md_error < 1) 
0215A:  MOV     82A,W4
0215C:  CP      W4,#1
0215E:  BRA     GE,2170
....................                   difference = qei_get_count() - md_target_count; 
02160:  CALL    1F8A
02164:  MOV     W0,W5
02166:  MOV     81A,W4
02168:  SUB     W5,W4,W0
0216A:  MOV     W0,8A6
....................                else 
0216C:  GOTO    217A
....................                   difference = md_target_count - qei_get_count(); 
02170:  CALL    1F8A
02174:  MOV     81A,W4
02176:  SUB     W4,W0,W0
02178:  MOV     W0,8A6
....................  
....................                if((difference < 1)||(md_pos_iter > 50)) 
0217A:  MOV     8A6,W4
0217C:  CP      W4,#1
0217E:  BRA     LT,2188
02180:  MOV     828,W4
02182:  MOV     #32,W3
02184:  CP      W3,W4
02186:  BRA     C,219A
....................                { 
....................                   pwm_disable(); 
02188:  CALL    1F18
....................                   reg_md_running = 0; 
0218C:  BCLR.B  8A2.0
....................                   md_mt_set(mt_percent_rest); 
0218E:  PUSH    80A
02190:  POP     8A8
02192:  CALL    1B88
....................                } 
....................                else 
02196:  GOTO    21C2
....................                { 
....................                   if(md_target_count > qei_get_count()) 
0219A:  CALL    1F8A
0219E:  MOV     81A,W4
021A0:  CP      W4,W0
021A2:  BRA     LEU,21AC
....................                      output_low(MD_DIR); 
021A4:  BCLR.B  2D8.4
021A6:  BCLR.B  2DC.4
....................                   else 
021A8:  GOTO    21B0
....................                      output_high(MD_DIR); 
021AC:  BCLR.B  2D8.4
021AE:  BSET.B  2DC.4
....................                          
....................                   pwm_set_period(1000); 
021B0:  MOV     #3E8,W4
021B2:  MOV     W4,8AC
021B4:  CALL    1EE2
....................                   pwm_select_mode(SINGLE); 
021B8:  MOV     #1,W4
021BA:  MOV     W4,8A8
021BC:  CALL    1676
....................                   // Enable PWM module 
....................                   PWM_PTCON_PTEN = 1; 
021C0:  BSET.B  1C1.7
....................                } 
....................                break; 
021C2:  GOTO    21C6
....................          } 
....................       } 
....................    } 
021C6:  GOTO    1F9A
....................  
....................    // Enable RS232 receive byte interrupt 
....................    clear_interrupt(INT_RDA2); 
....................    enable_interrupts(INT_RDA2); 
021CA:  BSET.B  8F.0
....................    reg_rs232_message = 0; 
021CC:  BCLR.B  84C.3
.................... } 
021CE:  MOV     [--W15],W5
021D0:  RETURN  
....................  
.................... // Move to given position (encoder count) 
.................... void move_to(unsigned int count) 
.................... { 
*
0280A:  MOV     W5,[W15++]
0280C:  MOV     W6,[W15++]
0280E:  CALL    1F8A
02812:  MOV     W0,89E
....................    // Calculate the number of steps 
....................    unsigned int displ;             
....................    // Calculate the current motor step by using current encoder count 
....................    unsigned int current_count = qei_get_count(); 
....................    // Calculate the target motor step by using given encoder step 
....................    md_target_count = count;  
02814:  PUSH    89A
02816:  POP     81A
....................     
....................    // Set direction 
....................    if(md_target_count > current_count) 
02818:  MOV     89E,W0
0281A:  MOV     81A,W4
0281C:  CP      W4,W0
0281E:  BRA     LEU,2830
....................    { 
....................       output_low(MD_DIR); 
02820:  BCLR.B  2D8.4
02822:  BCLR.B  2DC.4
....................       displ = md_target_count - current_count; 
02824:  MOV     81A,W4
02826:  MOV     89E,W3
02828:  SUB     W4,W3,W0
0282A:  MOV     W0,89C
....................    } 
....................    else 
0282C:  GOTO    283C
....................    { 
....................       output_high(MD_DIR); 
02830:  BCLR.B  2D8.4
02832:  BSET.B  2DC.4
....................       displ = current_count - md_target_count; 
02834:  MOV     89E,W4
02836:  MOV     81A,W3
02838:  SUB     W4,W3,W0
0283A:  MOV     W0,89C
....................    } 
....................     
....................    displ = (long)displ * 10000 / md_conv_const; 
0283C:  MOV     89C,W5
0283E:  MOV     #0,W6
02840:  MOV     W5,W0
02842:  MOV     W6,W1
02844:  MOV     #2710,W2
02846:  MOV     #0,W3
02848:  CALL    273E
0284C:  MOV     W0,W5
0284E:  MOV     W1,W6
02850:  BCLR.B  43.0
02852:  MOV     W5,W0
02854:  MOV     W6,W1
02856:  MOV     80C,W2
02858:  MOV     #0,W3
0285A:  CALL    2780
0285E:  MOV     W0,89C
....................     
....................    if(debug_mode_pwm) 
02860:  BTSS.B  800.4
02862:  BRA     2896
....................       fprintf(RS232,"Displacement: %u\n\r", displ); 
02864:  MOV     #0,W1
02866:  MOV     W1,W0
02868:  CALL    822
0286C:  INC     W1,W1
0286E:  MOV     W1,[W15++]
02870:  BTSC.B  219.1
02872:  BRA     2870
02874:  MOV     W0,21A
02876:  MOV     [--W15],W1
02878:  MOV     #D,W0
0287A:  CPSGT   W1,W0
0287C:  BRA     2866
0287E:  MOV     89C,W0
02880:  MOV     #0,W4
02882:  CALL    1572
02886:  BTSC.B  219.1
02888:  BRA     2886
0288A:  MOV     #A,W4
0288C:  MOV     W4,21A
0288E:  BTSC.B  219.1
02890:  BRA     288E
02892:  MOV     #D,W4
02894:  MOV     W4,21A
....................     
....................    // If displacement is zero than no need to move 
....................    if(displ == 0) 
02896:  CP0     89C
02898:  BRA     NZ,289C
....................       return; 
0289A:  BRA     29D4
....................        
....................    // Find out after how many steps we must start deceleration. 
....................    md_accel_lim = ((long)displ * md_decel) / (md_accel + md_decel); 
0289C:  MOV     89C,W5
0289E:  MOV     #0,W6
028A0:  MOV     W5,W0
028A2:  MOV     W6,W1
028A4:  MOV     81E,W2
028A6:  MOV     #0,W3
028A8:  CALL    273E
028AC:  MOV     W0,W5
028AE:  MOV     W1,W6
028B0:  MOV     81C,W0
028B2:  ADD     81E,W0
028B4:  BCLR.B  43.0
028B6:  MOV     W6,W1
028B8:  MOV     W0,W2
028BA:  MOV     #0,W3
028BC:  MOV     W5,W0
028BE:  CALL    2780
028C2:  MOV     W0,824
....................    // We must accelerate at least 1 step before we can start deceleration. 
....................    if(md_accel_lim == 0) 
028C4:  CP0     824
028C6:  BRA     NZ,28CC
....................       md_accel_lim = 1; 
028C8:  MOV     #1,W4
028CA:  MOV     W4,824
....................     
....................    // Use the limit we hit first to calc decel. 
....................    if(md_accel_lim >= md_max_acc_lim) 
028CC:  MOV     84E,W0
028CE:  MOV     824,W4
028D0:  CP      W4,W0
028D2:  BRA     NC,2908
....................    { 
....................       md_accel_lim = md_max_acc_lim; 
028D4:  PUSH    84E
028D6:  POP     824
....................        
....................       // Find step to start decleration. 
....................       md_decel_count = ((long)md_max_acc_lim * md_accel) / md_decel; 
028D8:  MOV     84E,W5
028DA:  MOV     #0,W6
028DC:  MOV     W5,W0
028DE:  MOV     W6,W1
028E0:  MOV     81C,W2
028E2:  MOV     #0,W3
028E4:  CALL    273E
028E8:  MOV     W0,W5
028EA:  MOV     W1,W6
028EC:  BCLR.B  43.0
028EE:  MOV     W5,W0
028F0:  MOV     W6,W1
028F2:  MOV     81E,W2
028F4:  MOV     #0,W3
028F6:  CALL    2780
028FA:  MOV     W0,826
....................       md_decel_lim = displ - md_decel_count;  
028FC:  MOV     89C,W4
028FE:  MOV     826,W3
02900:  SUB     W4,W3,W0
02902:  MOV     W0,822
....................    } 
....................    else 
02904:  GOTO    2914
....................    { 
....................       md_decel_lim = displ - md_accel_lim; 
02908:  MOV     89C,W4
0290A:  MOV     824,W3
0290C:  SUB     W4,W3,W0
0290E:  MOV     W0,822
....................       md_decel_count = md_accel_lim; 
02910:  PUSH    824
02912:  POP     826
....................    } 
....................     
....................    // We must decelerate at least 1 step to stop. 
....................    if(md_decel_lim == 0) 
02914:  CP0     822
02916:  BRA     NZ,291C
....................       md_decel_lim = 1; 
02918:  MOV     #1,W4
0291A:  MOV     W4,822
....................  
....................    if(debug_mode_pwm) 
0291C:  BTSS.B  800.4
0291E:  BRA     29B6
....................    { 
....................       fprintf(RS232,"Acceleration Limit: %u\n\r", md_accel_lim); 
02920:  MOV     #0,W1
02922:  MOV     W1,W0
02924:  CALL    842
02928:  INC     W1,W1
0292A:  MOV     W1,[W15++]
0292C:  BTSC.B  219.1
0292E:  BRA     292C
02930:  MOV     W0,21A
02932:  MOV     [--W15],W1
02934:  MOV     #13,W0
02936:  CPSGT   W1,W0
02938:  BRA     2922
0293A:  MOV     824,W0
0293C:  MOV     #0,W4
0293E:  CALL    1572
02942:  BTSC.B  219.1
02944:  BRA     2942
02946:  MOV     #A,W4
02948:  MOV     W4,21A
0294A:  BTSC.B  219.1
0294C:  BRA     294A
0294E:  MOV     #D,W4
02950:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Limit: %u\n\r", md_decel_lim); 
02952:  MOV     #0,W1
02954:  MOV     W1,W0
02956:  CALL    868
0295A:  INC     W1,W1
0295C:  MOV     W1,[W15++]
0295E:  BTSC.B  219.1
02960:  BRA     295E
02962:  MOV     W0,21A
02964:  MOV     [--W15],W1
02966:  MOV     #13,W0
02968:  CPSGT   W1,W0
0296A:  BRA     2954
0296C:  MOV     822,W0
0296E:  MOV     #0,W4
02970:  CALL    1572
02974:  BTSC.B  219.1
02976:  BRA     2974
02978:  MOV     #A,W4
0297A:  MOV     W4,21A
0297C:  BTSC.B  219.1
0297E:  BRA     297C
02980:  MOV     #D,W4
02982:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Count: %u\n\r", md_decel_count); 
02984:  MOV     #0,W1
02986:  MOV     W1,W0
02988:  CALL    88E
0298C:  INC     W1,W1
0298E:  MOV     W1,[W15++]
02990:  BTSC.B  219.1
02992:  BRA     2990
02994:  MOV     W0,21A
02996:  MOV     [--W15],W1
02998:  MOV     #13,W0
0299A:  CPSGT   W1,W0
0299C:  BRA     2986
0299E:  MOV     826,W0
029A0:  MOV     #0,W4
029A2:  CALL    1572
029A6:  BTSC.B  219.1
029A8:  BRA     29A6
029AA:  MOV     #A,W4
029AC:  MOV     W4,21A
029AE:  BTSC.B  219.1
029B0:  BRA     29AE
029B2:  MOV     #D,W4
029B4:  MOV     W4,21A
....................    } 
....................  
....................    md_run_state = ACCEL; 
029B6:  MOV.B   #1,W0L
029B8:  MOV.B   W0L,801
....................    md_mt_set(mt_percent_trip); 
029BA:  PUSH    808
029BC:  POP     8A8
029BE:  CALL    1B88
....................  
....................    pwm_set_period(delays[0]); 
029C2:  MOV     #7D0,W4
029C4:  MOV     W4,8AC
029C6:  CALL    1EE2
....................    pwm_select_mode(FREE); 
029CA:  CLR     8A8
029CC:  CALL    1676
....................    pwm_enable(); 
029D0:  CALL    1F90
.................... } 
029D4:  MOV     [--W15],W6
029D6:  MOV     [--W15],W5
029D8:  RETURN  
.................... // Move to given position (mm) 
.................... void move_pos(unsigned int16 position) 
.................... { 
*
02AD4:  MOV     W5,[W15++]
02AD6:  MOV     #C,W5
02AD8:  REPEAT  #4
02ADA:  MOV     [W5++],[W15++]
....................    if(position>md_move_range) 
02ADC:  MOV     80E,W0
02ADE:  MOV     894,W4
02AE0:  CP      W4,W0
02AE2:  BRA     LEU,2B0A
....................    { 
....................       position=md_move_range; 
02AE4:  PUSH    80E
02AE6:  POP     894
....................       if(debug_mode_md) 
02AE8:  BTSS.B  800.3
02AEA:  BRA     2B06
....................          fprintf(RS232, "Invalid entry: System cannot move to a position beyond the movement range. System will move to maximum possible distance."); 
02AEC:  MOV     #0,W1
02AEE:  MOV     W1,W0
02AF0:  CALL    8B4
02AF4:  INC     W1,W1
02AF6:  MOV     W1,[W15++]
02AF8:  BTSC.B  219.1
02AFA:  BRA     2AF8
02AFC:  MOV     W0,21A
02AFE:  MOV     [--W15],W1
02B00:  MOV     #78,W0
02B02:  CPSGT   W1,W0
02B04:  BRA     2AEE
....................    } 
....................    else if(position<md_min_distance) 
02B06:  GOTO    2B56
02B0A:  MOV     894,W0
02B0C:  MOV     818,W4
02B0E:  CP      W4,W0
02B10:  BRA     LEU,2B56
....................    { 
....................       position=md_min_distance; 
02B12:  PUSH    818
02B14:  POP     894
....................       if(debug_mode_md) 
02B16:  BTSS.B  800.3
02B18:  BRA     2B56
....................          fprintf(RS232, "Invalid entry: System cannot move to a position smaller than %u mm. System will move to minimum possible distance.", md_min_distance); 
02B1A:  MOV     #0,W1
02B1C:  MOV     W1,W0
02B1E:  CALL    922
02B22:  INC     W1,W1
02B24:  MOV     W1,[W15++]
02B26:  BTSC.B  219.1
02B28:  BRA     2B26
02B2A:  MOV     W0,21A
02B2C:  MOV     [--W15],W1
02B2E:  MOV     #3C,W0
02B30:  CPSGT   W1,W0
02B32:  BRA     2B1C
02B34:  MOV     818,W0
02B36:  MOV     #0,W4
02B38:  CALL    1572
02B3C:  MOV     #3F,W1
02B3E:  MOV     W1,W0
02B40:  CALL    922
02B44:  INC     W1,W1
02B46:  MOV     W1,[W15++]
02B48:  BTSC.B  219.1
02B4A:  BRA     2B48
02B4C:  MOV     W0,21A
02B4E:  MOV     [--W15],W1
02B50:  MOV     #71,W0
02B52:  CPSGT   W1,W0
02B54:  BRA     2B3E
....................    } 
....................     
....................    fprintf(RS232,"\n\rTarget Position: %u mm\n\r", position); 
02B56:  MOV     #0,W1
02B58:  MOV     W1,W0
02B5A:  CALL    98C
02B5E:  INC     W1,W1
02B60:  MOV     W1,[W15++]
02B62:  BTSC.B  219.1
02B64:  BRA     2B62
02B66:  MOV     W0,21A
02B68:  MOV     [--W15],W1
02B6A:  MOV     #12,W0
02B6C:  CPSGT   W1,W0
02B6E:  BRA     2B58
02B70:  MOV     894,W0
02B72:  MOV     #0,W4
02B74:  CALL    1572
02B78:  MOV     #15,W1
02B7A:  MOV     W1,W0
02B7C:  CALL    98C
02B80:  INC     W1,W1
02B82:  MOV     W1,[W15++]
02B84:  BTSC.B  219.1
02B86:  BRA     2B84
02B88:  MOV     W0,21A
02B8A:  MOV     [--W15],W1
02B8C:  MOV     #19,W0
02B8E:  CPSGT   W1,W0
02B90:  BRA     2B7A
....................  
....................    data_set_last_pos(position); 
02B92:  PUSH    894
02B94:  POP     89A
02B96:  CALL    239C
....................     
....................    unsigned int16 count = md_end_pos-((float)(position-md_min_distance)/2.0f)*((float)(md_end_pos-md_home_pos)/((float)(md_move_range-md_min_distance)/2.0f)); 
02B9A:  MOV     894,W4
02B9C:  MOV     818,W3
02B9E:  SUB     W4,W3,W0
02BA0:  CALL    23AA
*
02C10:  MOV     W0,896
....................     
....................    if(qei_get_count() < count) 
02C12:  CALL    1F8A
02C16:  MOV     W0,W5
02C18:  MOV     896,W4
02C1A:  CP      W4,W5
02C1C:  BRA     LEU,2C26
....................       count-=md_backlash; 
02C1E:  MOV     896,W4
02C20:  MOV     82C,W3
02C22:  SUB     W4,W3,W0
02C24:  MOV     W0,896
....................     
....................    move_to(count); 
02C26:  PUSH    896
02C28:  POP     89A
02C2A:  CALL    280A
....................     
....................    delay_ms(100); 
02C2E:  MOV     #64,W0
02C30:  CALL    155E
....................     
....................    if(debug_mode_md) 
02C34:  BTSS.B  800.3
02C36:  BRA     2D38
....................    { 
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02C38:  MOV     #0,W1
02C3A:  MOV     W1,W0
02C3C:  CALL    9B4
02C40:  INC     W1,W1
02C42:  MOV     W1,[W15++]
02C44:  BTSC.B  219.1
02C46:  BRA     2C44
02C48:  MOV     W0,21A
02C4A:  MOV     [--W15],W1
02C4C:  MOV     #E,W0
02C4E:  CPSGT   W1,W0
02C50:  BRA     2C3A
02C52:  MOV     82A,W0
02C54:  MOV     #0,W4
02C56:  CALL    29DA
02C5A:  BTSC.B  219.1
02C5C:  BRA     2C5A
02C5E:  MOV     #A,W4
02C60:  MOV     W4,21A
02C62:  BTSC.B  219.1
02C64:  BRA     2C62
02C66:  MOV     #D,W4
02C68:  MOV     W4,21A
....................       fprintf(RS232,"Target Encoder count: %u\n\r",md_target_count); 
02C6A:  MOV     #0,W1
02C6C:  MOV     W1,W0
02C6E:  CALL    9D4
02C72:  INC     W1,W1
02C74:  MOV     W1,[W15++]
02C76:  BTSC.B  219.1
02C78:  BRA     2C76
02C7A:  MOV     W0,21A
02C7C:  MOV     [--W15],W1
02C7E:  MOV     #15,W0
02C80:  CPSGT   W1,W0
02C82:  BRA     2C6C
02C84:  MOV     81A,W0
02C86:  MOV     #0,W4
02C88:  CALL    1572
02C8C:  BTSC.B  219.1
02C8E:  BRA     2C8C
02C90:  MOV     #A,W4
02C92:  MOV     W4,21A
02C94:  BTSC.B  219.1
02C96:  BRA     2C94
02C98:  MOV     #D,W4
02C9A:  MOV     W4,21A
....................       fprintf(RS232,"Current Encoder count: %u\n\r",qei_get_count()); 
02C9C:  CALL    1F8A
02CA0:  MOV     W0,W5
02CA2:  MOV     #0,W1
02CA4:  MOV     W1,W0
02CA6:  CALL    9FC
02CAA:  INC     W1,W1
02CAC:  MOV     W1,[W15++]
02CAE:  BTSC.B  219.1
02CB0:  BRA     2CAE
02CB2:  MOV     W0,21A
02CB4:  MOV     [--W15],W1
02CB6:  MOV     #16,W0
02CB8:  CPSGT   W1,W0
02CBA:  BRA     2CA4
02CBC:  MOV     W5,W0
02CBE:  MOV     #0,W4
02CC0:  CALL    1572
02CC4:  BTSC.B  219.1
02CC6:  BRA     2CC4
02CC8:  MOV     #A,W4
02CCA:  MOV     W4,21A
02CCC:  BTSC.B  219.1
02CCE:  BRA     2CCC
02CD0:  MOV     #D,W4
02CD2:  MOV     W4,21A
....................       fprintf(RS232,"Number of Iterations: %u\n\r",md_pos_iter); 
02CD4:  MOV     #0,W1
02CD6:  MOV     W1,W0
02CD8:  CALL    A24
02CDC:  INC     W1,W1
02CDE:  MOV     W1,[W15++]
02CE0:  BTSC.B  219.1
02CE2:  BRA     2CE0
02CE4:  MOV     W0,21A
02CE6:  MOV     [--W15],W1
02CE8:  MOV     #15,W0
02CEA:  CPSGT   W1,W0
02CEC:  BRA     2CD6
02CEE:  MOV     828,W0
02CF0:  MOV     #0,W4
02CF2:  CALL    1572
02CF6:  BTSC.B  219.1
02CF8:  BRA     2CF6
02CFA:  MOV     #A,W4
02CFC:  MOV     W4,21A
02CFE:  BTSC.B  219.1
02D00:  BRA     2CFE
02D02:  MOV     #D,W4
02D04:  MOV     W4,21A
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02D06:  MOV     #0,W1
02D08:  MOV     W1,W0
02D0A:  CALL    9B4
02D0E:  INC     W1,W1
02D10:  MOV     W1,[W15++]
02D12:  BTSC.B  219.1
02D14:  BRA     2D12
02D16:  MOV     W0,21A
02D18:  MOV     [--W15],W1
02D1A:  MOV     #E,W0
02D1C:  CPSGT   W1,W0
02D1E:  BRA     2D08
02D20:  MOV     82A,W0
02D22:  MOV     #0,W4
02D24:  CALL    29DA
02D28:  BTSC.B  219.1
02D2A:  BRA     2D28
02D2C:  MOV     #A,W4
02D2E:  MOV     W4,21A
02D30:  BTSC.B  219.1
02D32:  BRA     2D30
02D34:  MOV     #D,W4
02D36:  MOV     W4,21A
....................    } 
....................     
....................    fprintf(RS232,"Error: %d\n\r",(int)qei_get_count()-(int)md_target_count); 
02D38:  CALL    1F8A
02D3C:  MOV     W0,W5
02D3E:  MOV     81A,W4
02D40:  SUB     W5,W4,W5
02D42:  MOV     #0,W1
02D44:  MOV     W1,W0
02D46:  CALL    A4C
02D4A:  INC     W1,W1
02D4C:  MOV     W1,[W15++]
02D4E:  BTSC.B  219.1
02D50:  BRA     2D4E
02D52:  MOV     W0,21A
02D54:  MOV     [--W15],W1
02D56:  MOV     #6,W0
02D58:  CPSGT   W1,W0
02D5A:  BRA     2D44
02D5C:  MOV     W5,W0
02D5E:  MOV     #0,W4
02D60:  CALL    29DA
02D64:  BTSC.B  219.1
02D66:  BRA     2D64
02D68:  MOV     #A,W4
02D6A:  MOV     W4,21A
02D6C:  BTSC.B  219.1
02D6E:  BRA     2D6C
02D70:  MOV     #D,W4
02D72:  MOV     W4,21A
.................... } 
02D74:  MOV     #14,W5
02D76:  REPEAT  #4
02D78:  MOV     [--W15],[W5--]
02D7A:  MOV     [--W15],W5
02D7C:  RETURN  
.................... // Homing Function 
.................... void move_home() 
.................... { 
....................    fprintf(RS232,"Homing...\n\r");    
*
021D2:  MOV     #0,W1
021D4:  MOV     W1,W0
021D6:  CALL    A64
021DA:  INC     W1,W1
021DC:  MOV     W1,[W15++]
021DE:  BTSC.B  219.1
021E0:  BRA     21DE
021E2:  MOV     W0,21A
021E4:  MOV     [--W15],W1
021E6:  MOV     #A,W0
021E8:  CPSGT   W1,W0
021EA:  BRA     21D4
....................     
....................    md_run_state = HOME; 
021EC:  CLR.B   801
....................    md_decel_count = 0; 
021EE:  CLR     826
....................    reg_md_home = 0; 
021F0:  BCLR.B  84C.1
....................    reg_md_home_return = 0; 
021F2:  BCLR.B  84C.2
....................     
....................    output_high(MD_DIR); 
021F4:  BCLR.B  2D8.4
021F6:  BSET.B  2DC.4
....................    md_mt_set(mt_percent_trip); 
021F8:  PUSH    808
021FA:  POP     8A8
021FC:  CALL    1B88
....................  
....................    pwm_set_period(delays[0]); 
02200:  MOV     #7D0,W4
02202:  MOV     W4,8AC
02204:  CALL    1EE2
....................    pwm_select_mode(FREE); 
02208:  CLR     8A8
0220A:  CALL    1676
....................    pwm_enable(); 
0220E:  CALL    1F90
.................... } 
02212:  RETURN  
.................... // Initializes the system for movement 
.................... void move_init() 
.................... { 
*
02D7E:  MOV     W5,[W15++]
....................    md_move_range = data_get_move_range(); 
02D80:  CALL    1CFC
02D84:  MOV     W0,80E
....................    md_home_pos = data_get_home_pos(); 
02D86:  CALL    1D4C
02D8A:  MOV     W0,810
....................    md_end_pos = data_get_end_pos(); 
02D8C:  CALL    1D9C
02D90:  MOV     W0,812
....................    md_backlash = data_get_backlash(); 
02D92:  CALL    1DEC
02D96:  MOV     W0,82C
....................    qei_set_max_count(md_end_pos+md_end_offset); 
02D98:  MOV     812,W0
02D9A:  ADD     814,W0
02D9C:  MOV     W0,W5
02D9E:  MOV     W5,856
02DA0:  CALL    1E3C
....................    md_conv_const = data_get_conv_const(); 
02DA4:  CALL    1E80
02DA8:  MOV     W0,80C
....................     
....................    if(md_move_range==2000) 
02DAA:  MOV     80E,W4
02DAC:  MOV     #7D0,W3
02DAE:  CP      W3,W4
02DB0:  BRA     NZ,2DB6
....................       md_min_distance=120; 
02DB2:  MOV     #78,W4
02DB4:  MOV     W4,818
....................           
....................    move_home();                        // Move to home position 
02DB6:  CALL    21D2
....................     
....................    delay_ms(500); 
02DBA:  MOV     #1F4,W0
02DBC:  CALL    155E
....................        
....................    if(debug_mode_md) 
02DC0:  BTSS.B  800.3
02DC2:  BRA     2E06
....................       fprintf(RS232,"Moving Last Position: %u mm\n\r", data_get_last_pos()); 
02DC4:  CALL    2214
02DC8:  MOV     W0,W5
02DCA:  MOV     #0,W1
02DCC:  MOV     W1,W0
02DCE:  CALL    A7C
02DD2:  INC     W1,W1
02DD4:  MOV     W1,[W15++]
02DD6:  BTSC.B  219.1
02DD8:  BRA     2DD6
02DDA:  MOV     W0,21A
02DDC:  MOV     [--W15],W1
02DDE:  MOV     #15,W0
02DE0:  CPSGT   W1,W0
02DE2:  BRA     2DCC
02DE4:  MOV     W5,W0
02DE6:  MOV     #0,W4
02DE8:  CALL    1572
02DEC:  MOV     #18,W1
02DEE:  MOV     W1,W0
02DF0:  CALL    A7C
02DF4:  INC     W1,W1
02DF6:  MOV     W1,[W15++]
02DF8:  BTSC.B  219.1
02DFA:  BRA     2DF8
02DFC:  MOV     W0,21A
02DFE:  MOV     [--W15],W1
02E00:  MOV     #1C,W0
02E02:  CPSGT   W1,W0
02E04:  BRA     2DEE
....................  
....................    move_pos(data_get_last_pos()); 
02E06:  CALL    2214
02E0A:  MOV     W0,W5
02E0C:  MOV     W5,894
02E0E:  CALL    2AD4
.................... } 
02E12:  MOV     [--W15],W5
02E14:  RETURN  
....................  
.................... //Gets byte via parallel port 
.................... unsigned int pp_get_byte() 
.................... { 
*
04092:  MOV     W5,[W15++]
04094:  CLR     854
04096:  CLR     856
04098:  CLR     858
0409A:  CLR     85A
0409C:  CLR     85C
0409E:  CLR     85E
040A0:  CLR     860
040A2:  CLR     862
040A4:  CLR     864
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................     
....................    D7=(!input(PP_D7))*1; 
040A6:  BSET.B  2D2.3
040A8:  CLR     856
040AA:  BTSS.B  2D4.3
040AC:  INC     0856
....................    D6=(!input(PP_D6))*1; 
040AE:  BSET.B  2D2.2
040B0:  CLR     858
040B2:  BTSS.B  2D4.2
040B4:  INC     0858
....................    D5=(!input(PP_D5))*1; 
040B6:  BSET.B  2D2.1
040B8:  CLR     85A
040BA:  BTSS.B  2D4.1
040BC:  INC     085A
....................    D4=(!input(PP_D4))*1; 
040BE:  BSET.B  2CD.6
040C0:  CLR     85C
040C2:  BTSS.B  2CF.6
040C4:  INC     085C
....................    D3=(!input(PP_D3))*1; 
040C6:  BSET.B  2CD.5
040C8:  CLR     85E
040CA:  BTSS.B  2CF.5
040CC:  INC     085E
....................    D2=(!input(PP_D2))*1; 
040CE:  BSET.B  2D2.0
040D0:  CLR     860
040D2:  BTSS.B  2D4.0
040D4:  INC     0860
....................    D1=(!input(PP_D1))*1; 
040D6:  BSET.B  2D3.1
040D8:  CLR     862
040DA:  BTSS.B  2D5.1
040DC:  INC     0862
....................    D0=(!input(PP_D0))*1; 
040DE:  BSET.B  2D3.0
040E0:  CLR     864
040E2:  BTSS.B  2D5.0
040E4:  INC     0864
....................     
....................     
....................     
....................    data=(D7<<7)+(D6<<6)+(D5<<5)+(D4<<4)+(D3<<3)+(D2<<2)+(D1<<1)+D0; 
040E6:  MOV     856,W5
040E8:  SL      W5,#7,W5
040EA:  MOV     858,W0
040EC:  SL      W0,#6,W0
040EE:  ADD     W0,W5,W5
040F0:  MOV     85A,W0
040F2:  SL      W0,#5,W0
040F4:  ADD     W0,W5,W5
040F6:  MOV     85C,W0
040F8:  SL      W0,#4,W0
040FA:  ADD     W0,W5,W5
040FC:  MOV     85E,W0
040FE:  SL      W0,#3,W0
04100:  ADD     W0,W5,W5
04102:  MOV     860,W0
04104:  SL      W0,#2,W0
04106:  ADD     W0,W5,W5
04108:  MOV     862,W0
0410A:  SL      W0,#1,W0
0410C:  ADD     W0,W5,W5
0410E:  MOV     W5,W0
04110:  ADD     864,W0
04112:  MOV     W0,854
....................  
....................    return data; 
04114:  PUSH    854
04116:  POP     0
.................... } 
04118:  MOV     [--W15],W5
0411A:  RETURN  
.................... //Gets BCD byte via parallel port 
.................... unsigned int pp_get_BCD_byte() 
.................... { 
*
041B0:  MOV     W5,[W15++]
041B2:  CLR     85C
041B4:  CLR     85E
041B6:  CLR     860
041B8:  CLR     862
041BA:  CLR     864
041BC:  CLR     866
041BE:  CLR     868
041C0:  CLR     86A
041C2:  CLR     86C
041C4:  CLR     86E
041C6:  CLR     870
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    D7=(!input(PP_D7))*1; 
041C8:  BSET.B  2D2.3
041CA:  CLR     85E
041CC:  BTSS.B  2D4.3
041CE:  INC     085E
....................    D6=(!input(PP_D6))*1; 
041D0:  BSET.B  2D2.2
041D2:  CLR     860
041D4:  BTSS.B  2D4.2
041D6:  INC     0860
....................    D5=(!input(PP_D5))*1; 
041D8:  BSET.B  2D2.1
041DA:  CLR     862
041DC:  BTSS.B  2D4.1
041DE:  INC     0862
....................    D4=(!input(PP_D4))*1; 
041E0:  BSET.B  2CD.6
041E2:  CLR     864
041E4:  BTSS.B  2CF.6
041E6:  INC     0864
....................    D3=(!input(PP_D3))*1; 
041E8:  BSET.B  2CD.5
041EA:  CLR     866
041EC:  BTSS.B  2CF.5
041EE:  INC     0866
....................    D2=(!input(PP_D2))*1; 
041F0:  BSET.B  2D2.0
041F2:  CLR     868
041F4:  BTSS.B  2D4.0
041F6:  INC     0868
....................    D1=(!input(PP_D1))*1; 
041F8:  BSET.B  2D3.1
041FA:  CLR     86A
041FC:  BTSS.B  2D5.1
041FE:  INC     086A
....................    D0=(!input(PP_D0))*1; 
04200:  BSET.B  2D3.0
04202:  CLR     86C
04204:  BTSS.B  2D5.0
04206:  INC     086C
....................     
....................    byte0=8*D7+4*D6+2*D5+D4; 
04208:  MOV     85E,W5
0420A:  SL      W5,#3,W5
0420C:  MOV     860,W0
0420E:  SL      W0,#2,W0
04210:  ADD     W0,W5,W5
04212:  MOV     862,W0
04214:  SL      W0,#1,W0
04216:  ADD     W0,W5,W5
04218:  MOV     W5,W0
0421A:  ADD     864,W0
0421C:  MOV     W0,86E
....................    byte1=8*D3+4*D2+2*D1+D0; 
0421E:  MOV     866,W5
04220:  SL      W5,#3,W5
04222:  MOV     868,W0
04224:  SL      W0,#2,W0
04226:  ADD     W0,W5,W5
04228:  MOV     86A,W0
0422A:  SL      W0,#1,W0
0422C:  ADD     W0,W5,W5
0422E:  MOV     W5,W0
04230:  ADD     86C,W0
04232:  MOV     W0,870
....................    data=byte0*10+byte1; 
04234:  MOV     86E,W4
04236:  MUL.UU  W4,#A,W0
04238:  MOV     W0,W5
0423A:  MOV     W5,W0
0423C:  ADD     870,W0
0423E:  MOV     W0,85C
....................     
....................    return data; 
04240:  PUSH    85C
04242:  POP     0
.................... } 
04244:  MOV     [--W15],W5
04246:  RETURN  
.................... // Returns binary coded decimal byte of the given input 
.................... unsigned int pp_get_BCD_byte(unsigned int input) 
.................... { 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    byte0=8*bit_test(input,7)+4*bit_test(input,6)+2*bit_test(input,5)+bit_test(input,4); 
....................    byte1=8*bit_test(input,3)+4*bit_test(input,2)+2*bit_test(input,1)+bit_test(input,0); 
....................  
....................    return byte0*10+byte1; 
.................... } 
.................... // Pauses parallel port until strobe signal (returns 0) or communication time out (returns 1) 
.................... unsigned int1 pp_comm_pause() 
.................... {  
*
0411C:  MOV     W5,[W15++]
....................    while(true) 
....................    { 
....................       if(reg_pp_strobe) 
0411E:  BTSS.B  84C.0
04120:  BRA     41A4
....................       { 
....................          reg_pp_strobe = 0; 
04122:  BCLR.B  84C.0
....................           
....................          if(debug_mode_pp) 
04124:  BTSS.B  800.1
04126:  BRA     4142
....................             fprintf(RS232,"Strobe received\n\r"); 
04128:  MOV     #0,W1
0412A:  MOV     W1,W0
0412C:  CALL    AA6
04130:  INC     W1,W1
04132:  MOV     W1,[W15++]
04134:  BTSC.B  219.1
04136:  BRA     4134
04138:  MOV     W0,21A
0413A:  MOV     [--W15],W1
0413C:  MOV     #10,W0
0413E:  CPSGT   W1,W0
04140:  BRA     412A
....................  
....................          unsigned int i; 
....................          for(i=0; i<pp_str_check; i++) 
04142:  CLR     85A
04144:  MOV     85A,W0
04146:  MOV     844,W4
04148:  CP      W4,W0
0414A:  BRA     LEU,4182
....................          { 
....................             delay_ms(pp_str_delay); 
0414C:  MOV     846,W0
0414E:  CALL    155E
....................             if(input(PP_STR) == 1) 
04152:  BSET.B  2D3.2
04154:  BTSS.B  2D5.2
04156:  BRA     417C
....................             { 
....................                if(debug_mode_pp) 
04158:  BTSS.B  800.1
0415A:  BRA     4176
....................                   fprintf(RS232,"Strobe signal rejected\n\r"); 
0415C:  MOV     #0,W1
0415E:  MOV     W1,W0
04160:  CALL    AC4
04164:  INC     W1,W1
04166:  MOV     W1,[W15++]
04168:  BTSC.B  219.1
0416A:  BRA     4168
0416C:  MOV     W0,21A
0416E:  MOV     [--W15],W1
04170:  MOV     #17,W0
04172:  CPSGT   W1,W0
04174:  BRA     415E
....................                return 1; 
04176:  MOV.B   #1,W0L
04178:  MOV.B   W0L,0
0417A:  BRA     41AC
....................             } 
....................          } 
0417C:  INC     085A
0417E:  GOTO    4144
....................           
....................          if(debug_mode_pp) 
04182:  BTSS.B  800.1
04184:  BRA     41A0
....................             fprintf(RS232,"Strobe confirmed\n\r"); 
04186:  MOV     #0,W1
04188:  MOV     W1,W0
0418A:  CALL    AEA
0418E:  INC     W1,W1
04190:  MOV     W1,[W15++]
04192:  BTSC.B  219.1
04194:  BRA     4192
04196:  MOV     W0,21A
04198:  MOV     [--W15],W1
0419A:  MOV     #11,W0
0419C:  CPSGT   W1,W0
0419E:  BRA     4188
....................              
....................          return 0; 
041A0:  CLR.B   0
041A2:  BRA     41AC
....................       } 
....................    } 
041A4:  GOTO    411E
....................     
....................    return 1; 
041A8:  MOV.B   #1,W0L
041AA:  MOV.B   W0L,0
.................... } 
041AC:  MOV     [--W15],W5
041AE:  RETURN  
.................... // Sets position given via parallel port 
.................... void pp_set_pos() 
.................... { 
*
04248:  MOV     W5,[W15++]
....................    delay_ms(pp_rdy_delay); 
0424A:  MOV     84A,W0
0424C:  CALL    155E
....................    output_high(PP_RDY); 
04250:  BCLR.B  2D2.5
04252:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
04254:  CALL    411C
04258:  CP0.B   W0L
0425A:  BRA     Z,425E
....................       return; 
0425C:  BRA     4348
....................  
....................    output_low(PP_ACK); 
0425E:  BCLR.B  2D2.4
04260:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04262:  BCLR.B  2D2.5
04264:  BCLR.B  2D6.5
....................    unsigned int index=pp_get_BCD_byte(); 
04266:  CALL    41B0
0426A:  MOV     W0,854
....................    delay_ms(pp_ack_delay); 
0426C:  MOV     848,W0
0426E:  CALL    155E
....................    output_high(PP_ACK); 
04272:  BCLR.B  2D2.4
04274:  BSET.B  2D6.4
....................    delay_ms(pp_rdy_delay); 
04276:  MOV     84A,W0
04278:  CALL    155E
....................    output_high(PP_RDY); 
0427C:  BCLR.B  2D2.5
0427E:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
04280:  CALL    411C
04284:  CP0.B   W0L
04286:  BRA     Z,428A
....................       return; 
04288:  BRA     4348
....................     
....................    output_low(PP_ACK); 
0428A:  BCLR.B  2D2.4
0428C:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
0428E:  BCLR.B  2D2.5
04290:  BCLR.B  2D6.5
....................    unsigned int pos0=pp_get_BCD_byte(); 
04292:  CALL    41B0
04296:  MOV     W0,856
....................    delay_ms(pp_ack_delay); 
04298:  MOV     848,W0
0429A:  CALL    155E
....................    output_high(PP_ACK); 
0429E:  BCLR.B  2D2.4
042A0:  BSET.B  2D6.4
....................    delay_ms(pp_rdy_delay); 
042A2:  MOV     84A,W0
042A4:  CALL    155E
....................    output_high(PP_RDY); 
042A8:  BCLR.B  2D2.5
042AA:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
042AC:  CALL    411C
042B0:  CP0.B   W0L
042B2:  BRA     Z,42B6
....................       return; 
042B4:  BRA     4348
....................  
....................    output_low(PP_ACK); 
042B6:  BCLR.B  2D2.4
042B8:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
042BA:  BCLR.B  2D2.5
042BC:  BCLR.B  2D6.5
....................    unsigned int pos1=pp_get_BCD_byte(); 
042BE:  CALL    41B0
042C2:  MOV     W0,858
....................    delay_ms(pp_ack_delay); 
042C4:  MOV     848,W0
042C6:  CALL    155E
....................    output_high(PP_ACK); 
042CA:  BCLR.B  2D2.4
042CC:  BSET.B  2D6.4
....................  
....................    data_set_pos(index, pos0*100+pos1); 
042CE:  MOV     856,W4
042D0:  MOV     #64,W3
042D2:  MUL.UU  W4,W3,W0
042D4:  MOV     W0,W5
042D6:  MOV     W5,W0
042D8:  ADD     858,W0
042DA:  MOV     W0,W5
042DC:  MOV.B   854,W0L
042DE:  MOV.B   W0L,892
042E0:  MOV     W5,894
042E2:  CALL    3516
....................     
....................    fprintf(RS232,"Position set -> index: %u position: %u\n\r", index, pos0*100+pos1); 
042E6:  MOV     856,W4
042E8:  MOV     #64,W3
042EA:  MUL.UU  W4,W3,W0
042EC:  MOV     W0,W5
042EE:  MOV     W5,W0
042F0:  ADD     858,W0
042F2:  MOV     W0,W5
042F4:  MOV     #0,W1
042F6:  MOV     W1,W0
042F8:  CALL    B0A
042FC:  INC     W1,W1
042FE:  MOV     W1,[W15++]
04300:  BTSC.B  219.1
04302:  BRA     4300
04304:  MOV     W0,21A
04306:  MOV     [--W15],W1
04308:  MOV     #16,W0
0430A:  CPSGT   W1,W0
0430C:  BRA     42F6
0430E:  MOV     854,W0
04310:  MOV     #0,W4
04312:  CALL    1572
04316:  MOV     #19,W1
04318:  MOV     W1,W0
0431A:  CALL    B0A
0431E:  INC     W1,W1
04320:  MOV     W1,[W15++]
04322:  BTSC.B  219.1
04324:  BRA     4322
04326:  MOV     W0,21A
04328:  MOV     [--W15],W1
0432A:  MOV     #23,W0
0432C:  CPSGT   W1,W0
0432E:  BRA     4318
04330:  MOV     W5,W0
04332:  MOV     #0,W4
04334:  CALL    1572
04338:  BTSC.B  219.1
0433A:  BRA     4338
0433C:  MOV     #A,W4
0433E:  MOV     W4,21A
04340:  BTSC.B  219.1
04342:  BRA     4340
04344:  MOV     #D,W4
04346:  MOV     W4,21A
.................... } 
04348:  MOV     [--W15],W5
0434A:  RETURN  
.................... // Moves to position given via parallel port 
.................... void pp_move_pos(unsigned int input) 
.................... { 
0434C:  CALL    41B0
04350:  MOV     W0,856
....................    unsigned int index=pp_get_BCD_byte();; 
....................    unsigned int position=data_get_pos(index); 
04352:  MOV.B   856,W0L
04354:  MOV.B   W0L,896
04356:  CALL    3430
0435A:  MOV     W0,858
....................     
....................    fprintf(RS232,"Move Position -> index: %u position: %u\n\r", index, position); 
0435C:  MOV     #0,W1
0435E:  MOV     W1,W0
04360:  CALL    B40
04364:  INC     W1,W1
04366:  MOV     W1,[W15++]
04368:  BTSC.B  219.1
0436A:  BRA     4368
0436C:  MOV     W0,21A
0436E:  MOV     [--W15],W1
04370:  MOV     #17,W0
04372:  CPSGT   W1,W0
04374:  BRA     435E
04376:  MOV     856,W0
04378:  MOV     #0,W4
0437A:  CALL    1572
0437E:  MOV     #1A,W1
04380:  MOV     W1,W0
04382:  CALL    B40
04386:  INC     W1,W1
04388:  MOV     W1,[W15++]
0438A:  BTSC.B  219.1
0438C:  BRA     438A
0438E:  MOV     W0,21A
04390:  MOV     [--W15],W1
04392:  MOV     #24,W0
04394:  CPSGT   W1,W0
04396:  BRA     4380
04398:  MOV     858,W0
0439A:  MOV     #0,W4
0439C:  CALL    1572
043A0:  BTSC.B  219.1
043A2:  BRA     43A0
043A4:  MOV     #A,W4
043A6:  MOV     W4,21A
043A8:  BTSC.B  219.1
043AA:  BRA     43A8
043AC:  MOV     #D,W4
043AE:  MOV     W4,21A
....................        
....................    move_pos(position); 
043B0:  PUSH    858
043B2:  POP     894
043B4:  CALL    2AD4
.................... } 
043B8:  RETURN  
.................... // Gets command via parallel port when system is idle 
.................... void pp_get_command() 
.................... { 
....................    output_low(PP_ACK); 
043BA:  BCLR.B  2D2.4
043BC:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
043BE:  BCLR.B  2D2.5
043C0:  BCLR.B  2D6.5
....................    unsigned int input=pp_get_byte(); 
043C2:  CALL    4092
043C6:  MOV     W0,852
....................    delay_ms(pp_ack_delay); 
043C8:  MOV     848,W0
043CA:  CALL    155E
....................    output_high(PP_ACK); 
043CE:  BCLR.B  2D2.4
043D0:  BSET.B  2D6.4
....................  
....................    switch (input) 
....................    { 
043D2:  MOV     852,W0
043D4:  XOR     #FE,W0
043D6:  BRA     Z,43EA
043D8:  XOR     #3,W0
043DA:  BRA     Z,440A
043DC:  XOR     #1,W0
043DE:  BRA     Z,442C
043E0:  XOR     #7,W0
043E2:  BRA     Z,4456
043E4:  XOR     #4,W0
043E6:  BRA     Z,4480
043E8:  BRA     44A2
....................       case 0x00FE:   fprintf(RS232,"Emergency Stop Command\n\r"); 
043EA:  MOV     #0,W1
043EC:  MOV     W1,W0
043EE:  CALL    B78
043F2:  INC     W1,W1
043F4:  MOV     W1,[W15++]
043F6:  BTSC.B  219.1
043F8:  BRA     43F6
043FA:  MOV     W0,21A
043FC:  MOV     [--W15],W1
043FE:  MOV     #17,W0
04400:  CPSGT   W1,W0
04402:  BRA     43EC
....................                       
....................                      reg_pp_stop=1; 
04404:  BSET.B  800.7
....................                      break; 
04406:  GOTO    44AE
....................       case 0x00FD:   fprintf(RS232,"Homing Command\n\r"); 
0440A:  MOV     #0,W1
0440C:  MOV     W1,W0
0440E:  CALL    B9E
04412:  INC     W1,W1
04414:  MOV     W1,[W15++]
04416:  BTSC.B  219.1
04418:  BRA     4416
0441A:  MOV     W0,21A
0441C:  MOV     [--W15],W1
0441E:  MOV     #F,W0
04420:  CPSGT   W1,W0
04422:  BRA     440C
....................        
....................                      move_home();    
04424:  CALL    21D2
....................                      break; 
04428:  GOTO    44AE
....................       case 0x00FC:   fprintf(RS232,"Laser Off Command\n\r"); 
0442C:  MOV     #0,W1
0442E:  MOV     W1,W0
04430:  CALL    BBC
04434:  INC     W1,W1
04436:  MOV     W1,[W15++]
04438:  BTSC.B  219.1
0443A:  BRA     4438
0443C:  MOV     W0,21A
0443E:  MOV     [--W15],W1
04440:  MOV     #12,W0
04442:  CPSGT   W1,W0
04444:  BRA     442E
....................                          
....................                      output_low(LAS_1); 
04446:  BCLR.B  2C6.0
04448:  BCLR.B  2CA.0
....................                      output_low(LAS_2); 
0444A:  BCLR.B  2C6.1
0444C:  BCLR.B  2CA.1
....................                      output_low(LAS_3); 
0444E:  BCLR.B  2D2.6
04450:  BCLR.B  2D6.6
....................                      break; 
04452:  GOTO    44AE
....................       case 0x00FB:   fprintf(RS232,"Laser On Command\n\r"); 
04456:  MOV     #0,W1
04458:  MOV     W1,W0
0445A:  CALL    BDC
0445E:  INC     W1,W1
04460:  MOV     W1,[W15++]
04462:  BTSC.B  219.1
04464:  BRA     4462
04466:  MOV     W0,21A
04468:  MOV     [--W15],W1
0446A:  MOV     #11,W0
0446C:  CPSGT   W1,W0
0446E:  BRA     4458
....................                       
....................                      output_high(LAS_1); 
04470:  BCLR.B  2C6.0
04472:  BSET.B  2CA.0
....................                      output_high(LAS_2); 
04474:  BCLR.B  2C6.1
04476:  BSET.B  2CA.1
....................                      output_high(LAS_3); 
04478:  BCLR.B  2D2.6
0447A:  BSET.B  2D6.6
....................                      break;  
0447C:  GOTO    44AE
....................       case 0x00FF:   fprintf(RS232,"Set Position Command\n\r"); 
04480:  MOV     #0,W1
04482:  MOV     W1,W0
04484:  CALL    BFC
04488:  INC     W1,W1
0448A:  MOV     W1,[W15++]
0448C:  BTSC.B  219.1
0448E:  BRA     448C
04490:  MOV     W0,21A
04492:  MOV     [--W15],W1
04494:  MOV     #15,W0
04496:  CPSGT   W1,W0
04498:  BRA     4482
....................                       
....................                      pp_set_pos(); 
0449A:  CALL    4248
....................                      break; 
0449E:  GOTO    44AE
....................       default:       pp_move_pos(input);  
044A2:  PUSH    852
044A4:  POP     854
044A6:  CALL    434C
....................                      break; 
044AA:  GOTO    44AE
....................    } 
....................     
....................    delay_ms(pp_rdy_delay); 
044AE:  MOV     84A,W0
044B0:  CALL    155E
....................    output_high(PP_RDY); 
044B4:  BCLR.B  2D2.5
044B6:  BSET.B  2D6.5
.................... } 
044B8:  RETURN  
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
.................... { 
*
03532:  MOV     W5,[W15++]
03534:  MOV     W6,[W15++]
....................    char input; 
....................     
....................    input=fgetc(RS232); 
03536:  BTSS.B  218.0
03538:  BRA     3536
0353A:  MOV     21C,W0
0353C:  MOV.B   W0L,852
....................    switch (input){ 
0353E:  MOV.B   852,W0L
03540:  CLR.B   1
03542:  XOR     #63,W0
03544:  BRA     Z,3594
03546:  XOR     #10,W0
03548:  BRA     Z,3784
0354A:  XOR     #1,W0
0354C:  BRA     Z,37BE
0354E:  XOR     #1A,W0
03550:  BRA     Z,37F8
03552:  XOR     #D,W0
03554:  BRA     Z,3832
03556:  XOR     #13,W0
03558:  BRA     Z,386C
0355A:  XOR     #14,W0
0355C:  BRA     Z,38A6
0355E:  XOR     #16,W0
03560:  BRA     Z,38E0
03562:  XOR     #1D,W0
03564:  BRA     Z,391A
03566:  XOR     #4,W0
03568:  BRA     Z,3922
0356A:  XOR     #15,W0
0356C:  BRA     Z,3944
0356E:  XOR     #9,W0
03570:  BRA     Z,39DA
03572:  XOR     #1E,W0
03574:  BRA     Z,3B30
03576:  XOR     #3,W0
03578:  BRA     Z,3C24
0357A:  XOR     #8,W0
0357C:  BRA     Z,3D12
0357E:  XOR     #13,W0
03580:  BRA     Z,3F28
03582:  XOR     #D,W0
03584:  BRA     Z,3F64
03586:  XOR     #1C,W0
03588:  BRA     Z,3FFC
0358A:  XOR     #1,W0
0358C:  BRA     Z,4084
0358E:  XOR     #1E,W0
03590:  BRA     Z,4088
03592:  BRA     408C
....................       case 'c':   fprintf(RS232,"\n\rCOMMAND LIST\n\r"); 
03594:  MOV     #0,W1
03596:  MOV     W1,W0
03598:  CALL    C20
0359C:  INC     W1,W1
0359E:  MOV     W1,[W15++]
035A0:  BTSC.B  219.1
035A2:  BRA     35A0
035A4:  MOV     W0,21A
035A6:  MOV     [--W15],W1
035A8:  MOV     #F,W0
035AA:  CPSGT   W1,W0
035AC:  BRA     3596
....................                   fprintf(RS232,"\n\rSet Serial Number\t(s)"); 
035AE:  MOV     #0,W1
035B0:  MOV     W1,W0
035B2:  CALL    C3E
035B6:  INC     W1,W1
035B8:  MOV     W1,[W15++]
035BA:  BTSC.B  219.1
035BC:  BRA     35BA
035BE:  MOV     W0,21A
035C0:  MOV     [--W15],W1
035C2:  MOV     #16,W0
035C4:  CPSGT   W1,W0
035C6:  BRA     35B0
....................                   fprintf(RS232,"\n\rSet Move Range \t\t(r)"); 
035C8:  MOV     #0,W1
035CA:  MOV     W1,W0
035CC:  CALL    C62
035D0:  INC     W1,W1
035D2:  MOV     W1,[W15++]
035D4:  BTSC.B  219.1
035D6:  BRA     35D4
035D8:  MOV     W0,21A
035DA:  MOV     [--W15],W1
035DC:  MOV     #15,W0
035DE:  CPSGT   W1,W0
035E0:  BRA     35CA
....................                   fprintf(RS232,"\n\rSet Homing Distance \t(h)"); 
035E2:  MOV     #0,W1
035E4:  MOV     W1,W0
035E6:  CALL    C86
035EA:  INC     W1,W1
035EC:  MOV     W1,[W15++]
035EE:  BTSC.B  219.1
035F0:  BRA     35EE
035F2:  MOV     W0,21A
035F4:  MOV     [--W15],W1
035F6:  MOV     #19,W0
035F8:  CPSGT   W1,W0
035FA:  BRA     35E4
....................                   fprintf(RS232,"\n\rSet End Distance \t(e)"); 
035FC:  MOV     #0,W1
035FE:  MOV     W1,W0
03600:  CALL    CAE
03604:  INC     W1,W1
03606:  MOV     W1,[W15++]
03608:  BTSC.B  219.1
0360A:  BRA     3608
0360C:  MOV     W0,21A
0360E:  MOV     [--W15],W1
03610:  MOV     #16,W0
03612:  CPSGT   W1,W0
03614:  BRA     35FE
....................                   fprintf(RS232,"\n\rSet Conversion Constant\t(v)"); 
03616:  MOV     #0,W1
03618:  MOV     W1,W0
0361A:  CALL    CD2
0361E:  INC     W1,W1
03620:  MOV     W1,[W15++]
03622:  BTSC.B  219.1
03624:  BRA     3622
03626:  MOV     W0,21A
03628:  MOV     [--W15],W1
0362A:  MOV     #1C,W0
0362C:  CPSGT   W1,W0
0362E:  BRA     3618
....................                   fprintf(RS232,"\n\rSet Backlash \t\t(b)"); 
03630:  MOV     #0,W1
03632:  MOV     W1,W0
03634:  CALL    CFC
03638:  INC     W1,W1
0363A:  MOV     W1,[W15++]
0363C:  BTSC.B  219.1
0363E:  BRA     363C
03640:  MOV     W0,21A
03642:  MOV     [--W15],W1
03644:  MOV     #13,W0
03646:  CPSGT   W1,W0
03648:  BRA     3632
....................                   fprintf(RS232,"\n\rSet Communication Type \t(t)"); 
0364A:  MOV     #0,W1
0364C:  MOV     W1,W0
0364E:  CALL    D1E
03652:  INC     W1,W1
03654:  MOV     W1,[W15++]
03656:  BTSC.B  219.1
03658:  BRA     3656
0365A:  MOV     W0,21A
0365C:  MOV     [--W15],W1
0365E:  MOV     #1C,W0
03660:  CPSGT   W1,W0
03662:  BRA     364C
....................                   fprintf(RS232,"\n\rGet System Data \t(i)"); 
03664:  MOV     #0,W1
03666:  MOV     W1,W0
03668:  CALL    D48
0366C:  INC     W1,W1
0366E:  MOV     W1,[W15++]
03670:  BTSC.B  219.1
03672:  BRA     3670
03674:  MOV     W0,21A
03676:  MOV     [--W15],W1
03678:  MOV     #15,W0
0367A:  CPSGT   W1,W0
0367C:  BRA     3666
....................                   fprintf(RS232,"\n\rGet Position List \t(m)"); 
0367E:  MOV     #0,W1
03680:  MOV     W1,W0
03682:  CALL    D6C
03686:  INC     W1,W1
03688:  MOV     W1,[W15++]
0368A:  BTSC.B  219.1
0368C:  BRA     368A
0368E:  MOV     W0,21A
03690:  MOV     [--W15],W1
03692:  MOV     #17,W0
03694:  CPSGT   W1,W0
03696:  BRA     3680
....................                   fprintf(RS232,"\n\rMove To Position \t(x)"); 
03698:  MOV     #0,W1
0369A:  MOV     W1,W0
0369C:  CALL    D92
036A0:  INC     W1,W1
036A2:  MOV     W1,[W15++]
036A4:  BTSC.B  219.1
036A6:  BRA     36A4
036A8:  MOV     W0,21A
036AA:  MOV     [--W15],W1
036AC:  MOV     #16,W0
036AE:  CPSGT   W1,W0
036B0:  BRA     369A
....................                   fprintf(RS232,"\n\rSet Table Data \t\t(q)"); 
036B2:  MOV     #0,W1
036B4:  MOV     W1,W0
036B6:  CALL    DB6
036BA:  INC     W1,W1
036BC:  MOV     W1,[W15++]
036BE:  BTSC.B  219.1
036C0:  BRA     36BE
036C2:  MOV     W0,21A
036C4:  MOV     [--W15],W1
036C6:  MOV     #15,W0
036C8:  CPSGT   W1,W0
036CA:  BRA     36B4
....................                   fprintf(RS232,"\n\rTest Run (low res) \t(o)"); 
036CC:  MOV     #0,W1
036CE:  MOV     W1,W0
036D0:  CALL    DDA
036D4:  INC     W1,W1
036D6:  MOV     W1,[W15++]
036D8:  BTSC.B  219.1
036DA:  BRA     36D8
036DC:  MOV     W0,21A
036DE:  MOV     [--W15],W1
036E0:  MOV     #18,W0
036E2:  CPSGT   W1,W0
036E4:  BRA     36CE
....................                   fprintf(RS232,"\n\rTest Run (high res) \t(l)"); 
036E6:  MOV     #0,W1
036E8:  MOV     W1,W0
036EA:  CALL    E00
036EE:  INC     W1,W1
036F0:  MOV     W1,[W15++]
036F2:  BTSC.B  219.1
036F4:  BRA     36F2
036F6:  MOV     W0,21A
036F8:  MOV     [--W15],W1
036FA:  MOV     #19,W0
036FC:  CPSGT   W1,W0
036FE:  BRA     36E8
....................                   fprintf(RS232,"\n\rSet Debug State \t(d)"); 
03700:  MOV     #0,W1
03702:  MOV     W1,W0
03704:  CALL    E28
03708:  INC     W1,W1
0370A:  MOV     W1,[W15++]
0370C:  BTSC.B  219.1
0370E:  BRA     370C
03710:  MOV     W0,21A
03712:  MOV     [--W15],W1
03714:  MOV     #15,W0
03716:  CPSGT   W1,W0
03718:  BRA     3702
....................                   fprintf(RS232,"\n\rGet Encoder Count \t(w)"); 
0371A:  MOV     #0,W1
0371C:  MOV     W1,W0
0371E:  CALL    E4C
03722:  INC     W1,W1
03724:  MOV     W1,[W15++]
03726:  BTSC.B  219.1
03728:  BRA     3726
0372A:  MOV     W0,21A
0372C:  MOV     [--W15],W1
0372E:  MOV     #17,W0
03730:  CPSGT   W1,W0
03732:  BRA     371C
....................                   fprintf(RS232,"\n\rStart Memory Test \t(z)"); 
03734:  MOV     #0,W1
03736:  MOV     W1,W0
03738:  CALL    E72
0373C:  INC     W1,W1
0373E:  MOV     W1,[W15++]
03740:  BTSC.B  219.1
03742:  BRA     3740
03744:  MOV     W0,21A
03746:  MOV     [--W15],W1
03748:  MOV     #17,W0
0374A:  CPSGT   W1,W0
0374C:  BRA     3736
....................                   fprintf(RS232,"\n\rClear Memory \t\t(f)"); 
0374E:  MOV     #0,W1
03750:  MOV     W1,W0
03752:  CALL    E98
03756:  INC     W1,W1
03758:  MOV     W1,[W15++]
0375A:  BTSC.B  219.1
0375C:  BRA     375A
0375E:  MOV     W0,21A
03760:  MOV     [--W15],W1
03762:  MOV     #13,W0
03764:  CPSGT   W1,W0
03766:  BRA     3750
....................                   fprintf(RS232,"\n\n\r"); 
03768:  BTSC.B  219.1
0376A:  BRA     3768
0376C:  MOV     #A,W4
0376E:  MOV     W4,21A
03770:  BTSC.B  219.1
03772:  BRA     3770
03774:  MOV     #A,W4
03776:  MOV     W4,21A
03778:  BTSC.B  219.1
0377A:  BRA     3778
0377C:  MOV     #D,W4
0377E:  MOV     W4,21A
....................                   break; 
03780:  GOTO    408C
....................       case 's':   fprintf(RS232,"\n\rSet Serial Number (13 Characters): "); 
03784:  MOV     #0,W1
03786:  MOV     W1,W0
03788:  CALL    EBA
0378C:  INC     W1,W1
0378E:  MOV     W1,[W15++]
03790:  BTSC.B  219.1
03792:  BRA     3790
03794:  MOV     W0,21A
03796:  MOV     [--W15],W1
03798:  MOV     #24,W0
0379A:  CPSGT   W1,W0
0379C:  BRA     3786
....................                   data_set_serial_no(); 
0379E:  CALL    2E92
....................                   fprintf(RS232,"\n\n\r"); 
037A2:  BTSC.B  219.1
037A4:  BRA     37A2
037A6:  MOV     #A,W4
037A8:  MOV     W4,21A
037AA:  BTSC.B  219.1
037AC:  BRA     37AA
037AE:  MOV     #A,W4
037B0:  MOV     W4,21A
037B2:  BTSC.B  219.1
037B4:  BRA     37B2
037B6:  MOV     #D,W4
037B8:  MOV     W4,21A
....................                   break; 
037BA:  GOTO    408C
....................       case 'r':   fprintf(RS232,"\n\rSet Move Range in mm (xxxx): "); 
037BE:  MOV     #0,W1
037C0:  MOV     W1,W0
037C2:  CALL    EEC
037C6:  INC     W1,W1
037C8:  MOV     W1,[W15++]
037CA:  BTSC.B  219.1
037CC:  BRA     37CA
037CE:  MOV     W0,21A
037D0:  MOV     [--W15],W1
037D2:  MOV     #1E,W0
037D4:  CPSGT   W1,W0
037D6:  BRA     37C0
....................                   data_set_move_range(); 
037D8:  CALL    2EF6
....................                   fprintf(RS232,"\n\n\r"); 
037DC:  BTSC.B  219.1
037DE:  BRA     37DC
037E0:  MOV     #A,W4
037E2:  MOV     W4,21A
037E4:  BTSC.B  219.1
037E6:  BRA     37E4
037E8:  MOV     #A,W4
037EA:  MOV     W4,21A
037EC:  BTSC.B  219.1
037EE:  BRA     37EC
037F0:  MOV     #D,W4
037F2:  MOV     W4,21A
....................                   break; 
037F4:  GOTO    408C
....................       case 'h':   fprintf(RS232,"\n\rSet Homing Distance in counts (xxxx): "); 
037F8:  MOV     #0,W1
037FA:  MOV     W1,W0
037FC:  CALL    F18
03800:  INC     W1,W1
03802:  MOV     W1,[W15++]
03804:  BTSC.B  219.1
03806:  BRA     3804
03808:  MOV     W0,21A
0380A:  MOV     [--W15],W1
0380C:  MOV     #27,W0
0380E:  CPSGT   W1,W0
03810:  BRA     37FA
....................                   data_set_home_pos(); 
03812:  CALL    2FCE
....................                   fprintf(RS232,"\n\n\r"); 
03816:  BTSC.B  219.1
03818:  BRA     3816
0381A:  MOV     #A,W4
0381C:  MOV     W4,21A
0381E:  BTSC.B  219.1
03820:  BRA     381E
03822:  MOV     #A,W4
03824:  MOV     W4,21A
03826:  BTSC.B  219.1
03828:  BRA     3826
0382A:  MOV     #D,W4
0382C:  MOV     W4,21A
....................                   break; 
0382E:  GOTO    408C
....................       case 'e':   fprintf(RS232,"\n\rSet End Distance in counts (xxxxx): "); 
03832:  MOV     #0,W1
03834:  MOV     W1,W0
03836:  CALL    F4E
0383A:  INC     W1,W1
0383C:  MOV     W1,[W15++]
0383E:  BTSC.B  219.1
03840:  BRA     383E
03842:  MOV     W0,21A
03844:  MOV     [--W15],W1
03846:  MOV     #25,W0
03848:  CPSGT   W1,W0
0384A:  BRA     3834
....................                   data_set_end_pos(); 
0384C:  CALL    3064
....................                   fprintf(RS232,"\n\n\r"); 
03850:  BTSC.B  219.1
03852:  BRA     3850
03854:  MOV     #A,W4
03856:  MOV     W4,21A
03858:  BTSC.B  219.1
0385A:  BRA     3858
0385C:  MOV     #A,W4
0385E:  MOV     W4,21A
03860:  BTSC.B  219.1
03862:  BRA     3860
03864:  MOV     #D,W4
03866:  MOV     W4,21A
....................                   break; 
03868:  GOTO    408C
....................       case 'v':   fprintf(RS232,"\n\rSet Conversion Constant (xxxxx): "); 
0386C:  MOV     #0,W1
0386E:  MOV     W1,W0
03870:  CALL    F82
03874:  INC     W1,W1
03876:  MOV     W1,[W15++]
03878:  BTSC.B  219.1
0387A:  BRA     3878
0387C:  MOV     W0,21A
0387E:  MOV     [--W15],W1
03880:  MOV     #22,W0
03882:  CPSGT   W1,W0
03884:  BRA     386E
....................                   data_set_conv_const(); 
03886:  CALL    310E
....................                   fprintf(RS232,"\n\n\r"); 
0388A:  BTSC.B  219.1
0388C:  BRA     388A
0388E:  MOV     #A,W4
03890:  MOV     W4,21A
03892:  BTSC.B  219.1
03894:  BRA     3892
03896:  MOV     #A,W4
03898:  MOV     W4,21A
0389A:  BTSC.B  219.1
0389C:  BRA     389A
0389E:  MOV     #D,W4
038A0:  MOV     W4,21A
....................                   break; 
038A2:  GOTO    408C
....................       case 'b':   fprintf(RS232,"\n\rSet Backlash (xx): "); 
038A6:  MOV     #0,W1
038A8:  MOV     W1,W0
038AA:  CALL    FB2
038AE:  INC     W1,W1
038B0:  MOV     W1,[W15++]
038B2:  BTSC.B  219.1
038B4:  BRA     38B2
038B6:  MOV     W0,21A
038B8:  MOV     [--W15],W1
038BA:  MOV     #14,W0
038BC:  CPSGT   W1,W0
038BE:  BRA     38A8
....................                   data_set_backlash(); 
038C0:  CALL    3238
....................                   fprintf(RS232,"\n\n\r"); 
038C4:  BTSC.B  219.1
038C6:  BRA     38C4
038C8:  MOV     #A,W4
038CA:  MOV     W4,21A
038CC:  BTSC.B  219.1
038CE:  BRA     38CC
038D0:  MOV     #A,W4
038D2:  MOV     W4,21A
038D4:  BTSC.B  219.1
038D6:  BRA     38D4
038D8:  MOV     #D,W4
038DA:  MOV     W4,21A
....................                   break; 
038DC:  GOTO    408C
....................       case 't':   fprintf(RS232,"\n\rSet Communication Type (0: Parallel, 1: RS232"); 
038E0:  MOV     #0,W1
038E2:  MOV     W1,W0
038E4:  CALL    FD4
038E8:  INC     W1,W1
038EA:  MOV     W1,[W15++]
038EC:  BTSC.B  219.1
038EE:  BRA     38EC
038F0:  MOV     W0,21A
038F2:  MOV     [--W15],W1
038F4:  MOV     #2E,W0
038F6:  CPSGT   W1,W0
038F8:  BRA     38E2
....................                   data_set_comm_type(); 
038FA:  CALL    329C
....................                   fprintf(RS232,"\n\n\r"); 
038FE:  BTSC.B  219.1
03900:  BRA     38FE
03902:  MOV     #A,W4
03904:  MOV     W4,21A
03906:  BTSC.B  219.1
03908:  BRA     3906
0390A:  MOV     #A,W4
0390C:  MOV     W4,21A
0390E:  BTSC.B  219.1
03910:  BRA     390E
03912:  MOV     #D,W4
03914:  MOV     W4,21A
....................                   break; 
03916:  GOTO    408C
....................       case 'i':   data_get_sys_data(); 
0391A:  CALL    3374
....................                   break; 
0391E:  GOTO    408C
....................       case 'm':   fprintf(RS232,"\n\rGet Position List(0<=X<=9): "); 
03922:  MOV     #0,W1
03924:  MOV     W1,W0
03926:  CALL    1010
0392A:  INC     W1,W1
0392C:  MOV     W1,[W15++]
0392E:  BTSC.B  219.1
03930:  BRA     392E
03932:  MOV     W0,21A
03934:  MOV     [--W15],W1
03936:  MOV     #1D,W0
03938:  CPSGT   W1,W0
0393A:  BRA     3924
....................                   data_get_pos_table(); 
0393C:  CALL    34B2
....................                   break; 
03940:  GOTO    408C
....................       case 'x':   fprintf(RS232,"\n\rMove To(0<=X<=9999): "); 
03944:  MOV     #0,W1
03946:  MOV     W1,W0
03948:  CALL    103C
0394C:  INC     W1,W1
0394E:  MOV     W1,[W15++]
03950:  BTSC.B  219.1
03952:  BRA     3950
03954:  MOV     W0,21A
03956:  MOV     [--W15],W1
03958:  MOV     #16,W0
0395A:  CPSGT   W1,W0
0395C:  BRA     3946
....................                   unsigned int i=0; 
....................                   unsigned int input_step[4]; 
....................                   unsigned int step=0; 
0395E:  CLR     854
03960:  CLR     85E
....................                   for(i=0;i<4;i++){ 
03962:  CLR     854
03964:  MOV     854,W4
03966:  CP      W4,#4
03968:  BRA     C,399A
....................                      input_step[i]=(unsigned)(fgetc(RS232)-48); 
0396A:  MOV     854,W0
0396C:  SL      W0,#1,W0
0396E:  MOV     #856,W4
03970:  ADD     W0,W4,W5
03972:  BTSS.B  218.0
03974:  BRA     3972
03976:  MOV     21C,W0
03978:  SUB.B   #30,W0L
0397A:  CLR.B   1
0397C:  MOV     W0,[W5]
....................                      fputc(input_step[i]+48,RS232); 
0397E:  MOV     854,W0
03980:  SL      W0,#1,W0
03982:  MOV     #856,W4
03984:  ADD     W0,W4,W0
03986:  MOV     [W0],W5
03988:  ADD     #30,W5
0398A:  MOV.B   W5L,W0L
0398C:  BTSC.B  219.1
0398E:  BRA     398C
03990:  MOV.B   W0L,21A
03992:  CLR.B   21B
....................                   } 
03994:  INC     0854
03996:  GOTO    3964
....................                   fprintf(RS232,"\n\n\r"); 
0399A:  BTSC.B  219.1
0399C:  BRA     399A
0399E:  MOV     #A,W4
039A0:  MOV     W4,21A
039A2:  BTSC.B  219.1
039A4:  BRA     39A2
039A6:  MOV     #A,W4
039A8:  MOV     W4,21A
039AA:  BTSC.B  219.1
039AC:  BRA     39AA
039AE:  MOV     #D,W4
039B0:  MOV     W4,21A
....................                    
....................                   step=1000*input_step[0]+100*input_step[1]+10*input_step[2]+1*input_step[3]; 
039B2:  MOV     #3E8,W4
039B4:  MOV     856,W3
039B6:  MUL.UU  W4,W3,W0
039B8:  MOV     W0,W5
039BA:  MOV     #64,W4
039BC:  MOV     858,W3
039BE:  MUL.UU  W4,W3,W0
039C0:  ADD     W0,W5,W5
039C2:  MOV     85A,W4
039C4:  MUL.UU  W4,#A,W0
039C6:  ADD     W0,W5,W5
039C8:  MOV     W5,W0
039CA:  ADD     85C,W0
039CC:  MOV     W0,85E
....................                    
....................                   move_pos(step); 
039CE:  PUSH    85E
039D0:  POP     894
039D2:  CALL    2AD4
....................                   break; 
039D6:  GOTO    408C
....................       case 'q':   fprintf(RS232,"\n\rEnter Table Index (xx): "); 
039DA:  MOV     #0,W1
039DC:  MOV     W1,W0
039DE:  CALL    1060
039E2:  INC     W1,W1
039E4:  MOV     W1,[W15++]
039E6:  BTSC.B  219.1
039E8:  BRA     39E6
039EA:  MOV     W0,21A
039EC:  MOV     [--W15],W1
039EE:  MOV     #19,W0
039F0:  CPSGT   W1,W0
039F2:  BRA     39DC
....................                   unsigned int k=0; 
....................                   unsigned int input_index[2]; 
....................                   unsigned int index=0; 
039F4:  CLR     860
039F6:  CLR     866
....................                   for(k=0;k<2;k++){ 
039F8:  CLR     860
039FA:  MOV     860,W4
039FC:  CP      W4,#2
039FE:  BRA     C,3A30
....................                      input_index[k]=(unsigned)(fgetc(RS232)-48); 
03A00:  MOV     860,W0
03A02:  SL      W0,#1,W0
03A04:  MOV     #862,W4
03A06:  ADD     W0,W4,W5
03A08:  BTSS.B  218.0
03A0A:  BRA     3A08
03A0C:  MOV     21C,W0
03A0E:  SUB.B   #30,W0L
03A10:  CLR.B   1
03A12:  MOV     W0,[W5]
....................                      fputc(input_index[k]+48,RS232); 
03A14:  MOV     860,W0
03A16:  SL      W0,#1,W0
03A18:  MOV     #862,W4
03A1A:  ADD     W0,W4,W0
03A1C:  MOV     [W0],W5
03A1E:  ADD     #30,W5
03A20:  MOV.B   W5L,W0L
03A22:  BTSC.B  219.1
03A24:  BRA     3A22
03A26:  MOV.B   W0L,21A
03A28:  CLR.B   21B
....................                   } 
03A2A:  INC     0860
03A2C:  GOTO    39FA
....................                   fprintf(RS232,"\n\n\r"); 
03A30:  BTSC.B  219.1
03A32:  BRA     3A30
03A34:  MOV     #A,W4
03A36:  MOV     W4,21A
03A38:  BTSC.B  219.1
03A3A:  BRA     3A38
03A3C:  MOV     #A,W4
03A3E:  MOV     W4,21A
03A40:  BTSC.B  219.1
03A42:  BRA     3A40
03A44:  MOV     #D,W4
03A46:  MOV     W4,21A
....................                    
....................                   index=10*input_index[0]+1*input_index[1]; 
03A48:  MOV     862,W4
03A4A:  MUL.UU  W4,#A,W0
03A4C:  MOV     W0,W5
03A4E:  MOV     W5,W0
03A50:  ADD     864,W0
03A52:  MOV     W0,866
....................                    
....................                   fprintf(RS232,"\n\rIndex: %u", index); 
03A54:  MOV     #0,W1
03A56:  MOV     W1,W0
03A58:  CALL    1088
03A5C:  INC     W1,W1
03A5E:  MOV     W1,[W15++]
03A60:  BTSC.B  219.1
03A62:  BRA     3A60
03A64:  MOV     W0,21A
03A66:  MOV     [--W15],W1
03A68:  MOV     #8,W0
03A6A:  CPSGT   W1,W0
03A6C:  BRA     3A56
03A6E:  MOV     866,W0
03A70:  MOV     #0,W4
03A72:  CALL    1572
....................                    
....................                   fprintf(RS232,"\n\rEnter Position (xxxx): "); 
03A76:  MOV     #0,W1
03A78:  MOV     W1,W0
03A7A:  CALL    10A0
03A7E:  INC     W1,W1
03A80:  MOV     W1,[W15++]
03A82:  BTSC.B  219.1
03A84:  BRA     3A82
03A86:  MOV     W0,21A
03A88:  MOV     [--W15],W1
03A8A:  MOV     #18,W0
03A8C:  CPSGT   W1,W0
03A8E:  BRA     3A78
....................                   unsigned int input_pos[2]; 
....................                   unsigned int posi=0; 
03A90:  CLR     86C
....................                   for(k=0;k<4;k++){ 
03A92:  CLR     860
03A94:  MOV     860,W4
03A96:  CP      W4,#4
03A98:  BRA     C,3ACA
....................                      input_pos[k]=(unsigned)(fgetc(RS232)-48); 
03A9A:  MOV     860,W0
03A9C:  SL      W0,#1,W0
03A9E:  MOV     #868,W4
03AA0:  ADD     W0,W4,W5
03AA2:  BTSS.B  218.0
03AA4:  BRA     3AA2
03AA6:  MOV     21C,W0
03AA8:  SUB.B   #30,W0L
03AAA:  CLR.B   1
03AAC:  MOV     W0,[W5]
....................                      fputc(input_pos[k]+48,RS232); 
03AAE:  MOV     860,W0
03AB0:  SL      W0,#1,W0
03AB2:  MOV     #868,W4
03AB4:  ADD     W0,W4,W0
03AB6:  MOV     [W0],W5
03AB8:  ADD     #30,W5
03ABA:  MOV.B   W5L,W0L
03ABC:  BTSC.B  219.1
03ABE:  BRA     3ABC
03AC0:  MOV.B   W0L,21A
03AC2:  CLR.B   21B
....................                   } 
03AC4:  INC     0860
03AC6:  GOTO    3A94
....................                   fprintf(RS232,"\n\n\r"); 
03ACA:  BTSC.B  219.1
03ACC:  BRA     3ACA
03ACE:  MOV     #A,W4
03AD0:  MOV     W4,21A
03AD2:  BTSC.B  219.1
03AD4:  BRA     3AD2
03AD6:  MOV     #A,W4
03AD8:  MOV     W4,21A
03ADA:  BTSC.B  219.1
03ADC:  BRA     3ADA
03ADE:  MOV     #D,W4
03AE0:  MOV     W4,21A
....................                    
....................                   posi=1000*input_pos[0]+100*input_pos[1]+10*input_pos[2]+1*input_pos[3]; 
03AE2:  MOV     #3E8,W4
03AE4:  MOV     868,W3
03AE6:  MUL.UU  W4,W3,W0
03AE8:  MOV     W0,W5
03AEA:  MOV     #64,W4
03AEC:  MOV     86A,W3
03AEE:  MUL.UU  W4,W3,W0
03AF0:  ADD     W0,W5,W5
03AF2:  MOV     86C,W4
03AF4:  MUL.UU  W4,#A,W0
03AF6:  ADD     W0,W5,W5
03AF8:  MOV     W5,W0
03AFA:  ADD     86E,W0
03AFC:  MOV     W0,86C
....................                    
....................                   fprintf(RS232,"\n\rPosition: %u", posi); 
03AFE:  MOV     #0,W1
03B00:  MOV     W1,W0
03B02:  CALL    10C6
03B06:  INC     W1,W1
03B08:  MOV     W1,[W15++]
03B0A:  BTSC.B  219.1
03B0C:  BRA     3B0A
03B0E:  MOV     W0,21A
03B10:  MOV     [--W15],W1
03B12:  MOV     #B,W0
03B14:  CPSGT   W1,W0
03B16:  BRA     3B00
03B18:  MOV     86C,W0
03B1A:  MOV     #0,W4
03B1C:  CALL    1572
....................                    
....................                   data_set_pos(index, posi); 
03B20:  MOV.B   866,W0L
03B22:  MOV.B   W0L,892
03B24:  PUSH    86C
03B26:  POP     894
03B28:  CALL    3516
....................                   break; 
03B2C:  GOTO    408C
....................       case 'o':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
03B30:  MOV     #0,W1
03B32:  MOV     W1,W0
03B34:  CALL    10E2
03B38:  INC     W1,W1
03B3A:  MOV     W1,[W15++]
03B3C:  BTSC.B  219.1
03B3E:  BRA     3B3C
03B40:  MOV     W0,21A
03B42:  MOV     [--W15],W1
03B44:  MOV     #F,W0
03B46:  CPSGT   W1,W0
03B48:  BRA     3B32
....................                   unsigned int r=0; 
....................                   unsigned int input_speed[4]; 
....................                   unsigned int delay=0; 
03B4A:  CLR     86E
03B4C:  CLR     878
....................                   for(r=0;r<4;r++){ 
03B4E:  CLR     86E
03B50:  MOV     86E,W4
03B52:  CP      W4,#4
03B54:  BRA     C,3B86
....................                      input_speed[r]=(unsigned)(fgetc(RS232)-48); 
03B56:  MOV     86E,W0
03B58:  SL      W0,#1,W0
03B5A:  MOV     #870,W4
03B5C:  ADD     W0,W4,W5
03B5E:  BTSS.B  218.0
03B60:  BRA     3B5E
03B62:  MOV     21C,W0
03B64:  SUB.B   #30,W0L
03B66:  CLR.B   1
03B68:  MOV     W0,[W5]
....................                      fputc(input_speed[r]+48,RS232); 
03B6A:  MOV     86E,W0
03B6C:  SL      W0,#1,W0
03B6E:  MOV     #870,W4
03B70:  ADD     W0,W4,W0
03B72:  MOV     [W0],W5
03B74:  ADD     #30,W5
03B76:  MOV.B   W5L,W0L
03B78:  BTSC.B  219.1
03B7A:  BRA     3B78
03B7C:  MOV.B   W0L,21A
03B7E:  CLR.B   21B
....................                   } 
03B80:  INC     086E
03B82:  GOTO    3B50
....................                   fprintf(RS232,"\n\r"); 
03B86:  BTSC.B  219.1
03B88:  BRA     3B86
03B8A:  MOV     #A,W4
03B8C:  MOV     W4,21A
03B8E:  BTSC.B  219.1
03B90:  BRA     3B8E
03B92:  MOV     #D,W4
03B94:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
03B96:  MOV     #3E8,W4
03B98:  MOV     870,W3
03B9A:  MUL.UU  W4,W3,W0
03B9C:  MOV     W0,W5
03B9E:  MOV     #64,W4
03BA0:  MOV     872,W3
03BA2:  MUL.UU  W4,W3,W0
03BA4:  ADD     W0,W5,W5
03BA6:  MOV     874,W4
03BA8:  MUL.UU  W4,#A,W0
03BAA:  ADD     W0,W5,W5
03BAC:  MOV     W5,W0
03BAE:  ADD     876,W0
03BB0:  MOV     W0,878
....................        
....................                   unsigned int m; 
....................                   unsigned int pos_cal=md_min_distance; 
....................                   unsigned int num=(md_move_range-md_min_distance)/40+1; 
03BB2:  PUSH    818
03BB4:  POP     87C
03BB6:  MOV     80E,W4
03BB8:  MOV     818,W3
03BBA:  SUB     W4,W3,W5
03BBC:  MOV     W5,W4
03BBE:  MOV     #28,W3
03BC0:  REPEAT  #11
03BC2:  DIV.U   W4,W3
03BC4:  MOV     W0,W5
03BC6:  ADD     W5,#1,W5
03BC8:  MOV     W5,87E
....................                    
....................                   for(m=0; m<num; m++) 
03BCA:  CLR     87A
03BCC:  MOV     87A,W0
03BCE:  MOV     87E,W4
03BD0:  CP      W4,W0
03BD2:  BRA     LEU,3BF0
....................                   { 
....................                      move_pos(pos_cal+m*40); 
03BD4:  MOV     87A,W4
03BD6:  MOV     #28,W3
03BD8:  MUL.UU  W4,W3,W0
03BDA:  MOV     87C,W4
03BDC:  ADD     W0,W4,W5
03BDE:  MOV     W5,894
03BE0:  CALL    2AD4
....................                      delay_ms(delay); 
03BE4:  MOV     878,W0
03BE6:  CALL    155E
....................                   } 
03BEA:  INC     087A
03BEC:  GOTO    3BCC
....................                    
....................                   pos_cal=pos_cal+(num-1)*40; 
03BF0:  MOV     87E,W4
03BF2:  SUB     W4,#1,W5
03BF4:  MOV     #28,W4
03BF6:  MUL.UU  W5,W4,W0
03BF8:  ADD     87C
....................                    
....................                   for(m=0; m<num; m++) 
03BFA:  CLR     87A
03BFC:  MOV     87A,W0
03BFE:  MOV     87E,W4
03C00:  CP      W4,W0
03C02:  BRA     LEU,3C20
....................                   { 
....................                      move_pos(pos_cal-m*40); 
03C04:  MOV     87A,W4
03C06:  MOV     #28,W3
03C08:  MUL.UU  W4,W3,W0
03C0A:  MOV     87C,W4
03C0C:  SUB     W4,W0,W5
03C0E:  MOV     W5,894
03C10:  CALL    2AD4
....................                      delay_ms(delay); 
03C14:  MOV     878,W0
03C16:  CALL    155E
....................                   } 
03C1A:  INC     087A
03C1C:  GOTO    3BFC
....................                   break; 
03C20:  GOTO    408C
....................       case 'l':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
03C24:  MOV     #0,W1
03C26:  MOV     W1,W0
03C28:  CALL    10E2
03C2C:  INC     W1,W1
03C2E:  MOV     W1,[W15++]
03C30:  BTSC.B  219.1
03C32:  BRA     3C30
03C34:  MOV     W0,21A
03C36:  MOV     [--W15],W1
03C38:  MOV     #F,W0
03C3A:  CPSGT   W1,W0
03C3C:  BRA     3C26
....................                   unsigned int p=0; 
03C3E:  CLR     880
....................                   for(p=0;p<4;p++){ 
03C40:  CLR     880
03C42:  MOV     880,W4
03C44:  CP      W4,#4
03C46:  BRA     C,3C78
....................                      input_speed[p]=(unsigned)(fgetc(RS232)-48); 
03C48:  MOV     880,W0
03C4A:  SL      W0,#1,W0
03C4C:  MOV     #870,W4
03C4E:  ADD     W0,W4,W5
03C50:  BTSS.B  218.0
03C52:  BRA     3C50
03C54:  MOV     21C,W0
03C56:  SUB.B   #30,W0L
03C58:  CLR.B   1
03C5A:  MOV     W0,[W5]
....................                      fputc(input_speed[p]+48,RS232); 
03C5C:  MOV     880,W0
03C5E:  SL      W0,#1,W0
03C60:  MOV     #870,W4
03C62:  ADD     W0,W4,W0
03C64:  MOV     [W0],W5
03C66:  ADD     #30,W5
03C68:  MOV.B   W5L,W0L
03C6A:  BTSC.B  219.1
03C6C:  BRA     3C6A
03C6E:  MOV.B   W0L,21A
03C70:  CLR.B   21B
....................                   } 
03C72:  INC     0880
03C74:  GOTO    3C42
....................                   fprintf(RS232,"\n\r"); 
03C78:  BTSC.B  219.1
03C7A:  BRA     3C78
03C7C:  MOV     #A,W4
03C7E:  MOV     W4,21A
03C80:  BTSC.B  219.1
03C82:  BRA     3C80
03C84:  MOV     #D,W4
03C86:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
03C88:  MOV     #3E8,W4
03C8A:  MOV     870,W3
03C8C:  MUL.UU  W4,W3,W0
03C8E:  MOV     W0,W5
03C90:  MOV     #64,W4
03C92:  MOV     872,W3
03C94:  MUL.UU  W4,W3,W0
03C96:  ADD     W0,W5,W5
03C98:  MOV     874,W4
03C9A:  MUL.UU  W4,#A,W0
03C9C:  ADD     W0,W5,W5
03C9E:  MOV     W5,W0
03CA0:  ADD     876,W0
03CA2:  MOV     W0,878
....................        
....................                   unsigned int l; 
....................                   unsigned int pos_cal_2=md_min_distance; 
....................                   unsigned int num_2=(md_move_range-md_min_distance)/10+1; 
03CA4:  PUSH    818
03CA6:  POP     884
03CA8:  MOV     80E,W4
03CAA:  MOV     818,W3
03CAC:  SUB     W4,W3,W5
03CAE:  MOV     W5,W4
03CB0:  MOV     #A,W3
03CB2:  REPEAT  #11
03CB4:  DIV.U   W4,W3
03CB6:  MOV     W0,W5
03CB8:  ADD     W5,#1,W5
03CBA:  MOV     W5,886
....................                    
....................                   for(l=0; l<num_2; l++) 
03CBC:  CLR     882
03CBE:  MOV     882,W0
03CC0:  MOV     886,W4
03CC2:  CP      W4,W0
03CC4:  BRA     LEU,3CE0
....................                   { 
....................                      move_pos(pos_cal_2+l*10); 
03CC6:  MOV     882,W4
03CC8:  MUL.UU  W4,#A,W0
03CCA:  MOV     884,W4
03CCC:  ADD     W0,W4,W5
03CCE:  MOV     W5,894
03CD0:  CALL    2AD4
....................                      delay_ms(delay); 
03CD4:  MOV     878,W0
03CD6:  CALL    155E
....................                   } 
03CDA:  INC     0882
03CDC:  GOTO    3CBE
....................                    
....................                   pos_cal_2=pos_cal_2+(num_2-1)*10; 
03CE0:  MOV     886,W4
03CE2:  SUB     W4,#1,W5
03CE4:  MOV     W5,W4
03CE6:  MUL.UU  W4,#A,W0
03CE8:  ADD     884
....................                    
....................                   for(l=0; l<num_2; l++) 
03CEA:  CLR     882
03CEC:  MOV     882,W0
03CEE:  MOV     886,W4
03CF0:  CP      W4,W0
03CF2:  BRA     LEU,3D0E
....................                   { 
....................                      move_pos(pos_cal_2-l*10); 
03CF4:  MOV     882,W4
03CF6:  MUL.UU  W4,#A,W0
03CF8:  MOV     884,W4
03CFA:  SUB     W4,W0,W5
03CFC:  MOV     W5,894
03CFE:  CALL    2AD4
....................                      delay_ms(delay); 
03D02:  MOV     878,W0
03D04:  CALL    155E
....................                   } 
03D08:  INC     0882
03D0A:  GOTO    3CEC
....................                   break; 
03D0E:  GOTO    408C
....................       case 'd':   fprintf(RS232,"\n\rSet debug state\n\r"); 
03D12:  MOV     #0,W1
03D14:  MOV     W1,W0
03D16:  CALL    1100
03D1A:  INC     W1,W1
03D1C:  MOV     W1,[W15++]
03D1E:  BTSC.B  219.1
03D20:  BRA     3D1E
03D22:  MOV     W0,21A
03D24:  MOV     [--W15],W1
03D26:  MOV     #12,W0
03D28:  CPSGT   W1,W0
03D2A:  BRA     3D14
....................                   fprintf(RS232,"Digital potentiometer (a)(0 or 1): \n\r"); 
03D2C:  MOV     #0,W1
03D2E:  MOV     W1,W0
03D30:  CALL    1120
03D34:  INC     W1,W1
03D36:  MOV     W1,[W15++]
03D38:  BTSC.B  219.1
03D3A:  BRA     3D38
03D3C:  MOV     W0,21A
03D3E:  MOV     [--W15],W1
03D40:  MOV     #24,W0
03D42:  CPSGT   W1,W0
03D44:  BRA     3D2E
....................                   fprintf(RS232,"Parallel port         (b)(0 or 1): \n\r"); 
03D46:  MOV     #0,W1
03D48:  MOV     W1,W0
03D4A:  CALL    1152
03D4E:  INC     W1,W1
03D50:  MOV     W1,[W15++]
03D52:  BTSC.B  219.1
03D54:  BRA     3D52
03D56:  MOV     W0,21A
03D58:  MOV     [--W15],W1
03D5A:  MOV     #24,W0
03D5C:  CPSGT   W1,W0
03D5E:  BRA     3D48
....................                   fprintf(RS232,"FRAM                  (c)(0 or 1): \n\r"); 
03D60:  MOV     #0,W1
03D62:  MOV     W1,W0
03D64:  CALL    1184
03D68:  INC     W1,W1
03D6A:  MOV     W1,[W15++]
03D6C:  BTSC.B  219.1
03D6E:  BRA     3D6C
03D70:  MOV     W0,21A
03D72:  MOV     [--W15],W1
03D74:  MOV     #24,W0
03D76:  CPSGT   W1,W0
03D78:  BRA     3D62
....................                   fprintf(RS232,"Motor driver          (d)(0 or 1): \n\r"); 
03D7A:  MOV     #0,W1
03D7C:  MOV     W1,W0
03D7E:  CALL    11B6
03D82:  INC     W1,W1
03D84:  MOV     W1,[W15++]
03D86:  BTSC.B  219.1
03D88:  BRA     3D86
03D8A:  MOV     W0,21A
03D8C:  MOV     [--W15],W1
03D8E:  MOV     #24,W0
03D90:  CPSGT   W1,W0
03D92:  BRA     3D7C
....................                   fprintf(RS232,"Encoder               (e)(0 or 1): \n\r"); 
03D94:  MOV     #0,W1
03D96:  MOV     W1,W0
03D98:  CALL    11E8
03D9C:  INC     W1,W1
03D9E:  MOV     W1,[W15++]
03DA0:  BTSC.B  219.1
03DA2:  BRA     3DA0
03DA4:  MOV     W0,21A
03DA6:  MOV     [--W15],W1
03DA8:  MOV     #24,W0
03DAA:  CPSGT   W1,W0
03DAC:  BRA     3D96
....................                   fprintf(RS232,"PWM Module            (f)(0 or 1): \n\r"); 
03DAE:  MOV     #0,W1
03DB0:  MOV     W1,W0
03DB2:  CALL    121A
03DB6:  INC     W1,W1
03DB8:  MOV     W1,[W15++]
03DBA:  BTSC.B  219.1
03DBC:  BRA     3DBA
03DBE:  MOV     W0,21A
03DC0:  MOV     [--W15],W1
03DC2:  MOV     #24,W0
03DC4:  CPSGT   W1,W0
03DC6:  BRA     3DB0
....................                   fprintf(RS232,"All Modes             (g)(0 or 1): \n\r"); 
03DC8:  MOV     #0,W1
03DCA:  MOV     W1,W0
03DCC:  CALL    124C
03DD0:  INC     W1,W1
03DD2:  MOV     W1,[W15++]
03DD4:  BTSC.B  219.1
03DD6:  BRA     3DD4
03DD8:  MOV     W0,21A
03DDA:  MOV     [--W15],W1
03DDC:  MOV     #24,W0
03DDE:  CPSGT   W1,W0
03DE0:  BRA     3DCA
....................                   fprintf(RS232,"Selection (xx): "); 
03DE2:  MOV     #0,W1
03DE4:  MOV     W1,W0
03DE6:  CALL    127E
03DEA:  INC     W1,W1
03DEC:  MOV     W1,[W15++]
03DEE:  BTSC.B  219.1
03DF0:  BRA     3DEE
03DF2:  MOV     W0,21A
03DF4:  MOV     [--W15],W1
03DF6:  MOV     #F,W0
03DF8:  CPSGT   W1,W0
03DFA:  BRA     3DE4
....................                    
....................                   int1 value=0; 
....................                   unsigned int f=0; 
....................                   char input_ds[2]; 
03DFC:  BCLR.B  853.0
03DFE:  CLR     888
....................                   for(f=0;f<2;f++){ 
03E00:  CLR     888
03E02:  MOV     888,W4
03E04:  CP      W4,#2
03E06:  BRA     C,3E2E
....................                      input_ds[f]=fgetc(RS232); 
03E08:  MOV     #88A,W4
03E0A:  MOV     888,W3
03E0C:  ADD     W3,W4,W5
03E0E:  BTSS.B  218.0
03E10:  BRA     3E0E
03E12:  MOV     21C,W0
03E14:  MOV.B   W0L,[W5]
....................                      fputc(input_ds[f],RS232); 
03E16:  MOV     #88A,W4
03E18:  MOV     888,W3
03E1A:  ADD     W3,W4,W0
03E1C:  MOV.B   [W0],W5L
03E1E:  MOV.B   W5L,W0L
03E20:  BTSC.B  219.1
03E22:  BRA     3E20
03E24:  MOV.B   W0L,21A
03E26:  CLR.B   21B
....................                   } 
03E28:  INC     0888
03E2A:  GOTO    3E02
....................                   fprintf(RS232,"\n\n\r"); 
03E2E:  BTSC.B  219.1
03E30:  BRA     3E2E
03E32:  MOV     #A,W4
03E34:  MOV     W4,21A
03E36:  BTSC.B  219.1
03E38:  BRA     3E36
03E3A:  MOV     #A,W4
03E3C:  MOV     W4,21A
03E3E:  BTSC.B  219.1
03E40:  BRA     3E3E
03E42:  MOV     #D,W4
03E44:  MOV     W4,21A
....................                    
....................                   if(input_ds[1]=='0') 
03E46:  MOV     88A,W4
03E48:  LSR     W4,#8,W4
03E4A:  XOR.B   #30,W4L
03E4C:  BRA     NZ,3E54
....................                      value=0; 
03E4E:  BCLR.B  853.0
....................                   else if(input_ds[1]=='1') 
03E50:  GOTO    3E80
03E54:  MOV     88A,W4
03E56:  LSR     W4,#8,W4
03E58:  XOR.B   #31,W4L
03E5A:  BRA     NZ,3E62
....................                      value=1; 
03E5C:  BSET.B  853.0
....................                   else 
03E5E:  GOTO    3E80
....................                   { 
....................                      fprintf(RS232,"Invalid Entry\n\r"); 
03E62:  MOV     #0,W1
03E64:  MOV     W1,W0
03E66:  CALL    129C
03E6A:  INC     W1,W1
03E6C:  MOV     W1,[W15++]
03E6E:  BTSC.B  219.1
03E70:  BRA     3E6E
03E72:  MOV     W0,21A
03E74:  MOV     [--W15],W1
03E76:  MOV     #E,W0
03E78:  CPSGT   W1,W0
03E7A:  BRA     3E64
....................                      break; 
03E7C:  GOTO    408C
....................                   } 
....................  
....................                   switch (input_ds[0]){ 
03E80:  MOV.B   88A,W0L
03E82:  CLR.B   1
03E84:  XOR     #61,W0
03E86:  BRA     Z,3EA2
03E88:  XOR     #3,W0
03E8A:  BRA     Z,3EAC
03E8C:  XOR     #1,W0
03E8E:  BRA     Z,3EB6
03E90:  XOR     #7,W0
03E92:  BRA     Z,3EC0
03E94:  XOR     #1,W0
03E96:  BRA     Z,3ECA
03E98:  XOR     #3,W0
03E9A:  BRA     Z,3ED4
03E9C:  XOR     #1,W0
03E9E:  BRA     Z,3EDE
03EA0:  BRA     3F06
....................                      case 'a':   debug_mode_dp = value; 
03EA2:  BCLR.B  800.0
03EA4:  BTSC.B  853.0
03EA6:  BSET.B  800.0
....................                                  break; 
03EA8:  GOTO    3F24
....................                      case 'b':   debug_mode_pp = value; 
03EAC:  BCLR.B  800.1
03EAE:  BTSC.B  853.0
03EB0:  BSET.B  800.1
....................                                  break; 
03EB2:  GOTO    3F24
....................                      case 'c':   debug_mode_fr = value; 
03EB6:  BCLR.B  800.2
03EB8:  BTSC.B  853.0
03EBA:  BSET.B  800.2
....................                                  break; 
03EBC:  GOTO    3F24
....................                      case 'd':   debug_mode_md = value; 
03EC0:  BCLR.B  800.3
03EC2:  BTSC.B  853.0
03EC4:  BSET.B  800.3
....................                                  break; 
03EC6:  GOTO    3F24
....................                      case 'e':   debug_mode_qei = value; 
03ECA:  BCLR.B  800.5
03ECC:  BTSC.B  853.0
03ECE:  BSET.B  800.5
....................                                  break; 
03ED0:  GOTO    3F24
....................                      case 'f':   debug_mode_pwm = value; 
03ED4:  BCLR.B  800.4
03ED6:  BTSC.B  853.0
03ED8:  BSET.B  800.4
....................                                  break;           
03EDA:  GOTO    3F24
....................                      case 'g':   debug_mode_dp = value; 
03EDE:  BCLR.B  800.0
03EE0:  BTSC.B  853.0
03EE2:  BSET.B  800.0
....................                                  debug_mode_pp = value; 
03EE4:  BCLR.B  800.1
03EE6:  BTSC.B  853.0
03EE8:  BSET.B  800.1
....................                                  debug_mode_fr = value; 
03EEA:  BCLR.B  800.2
03EEC:  BTSC.B  853.0
03EEE:  BSET.B  800.2
....................                                  debug_mode_md = value; 
03EF0:  BCLR.B  800.3
03EF2:  BTSC.B  853.0
03EF4:  BSET.B  800.3
....................                                  debug_mode_qei = value; 
03EF6:  BCLR.B  800.5
03EF8:  BTSC.B  853.0
03EFA:  BSET.B  800.5
....................                                  debug_mode_pwm = value; 
03EFC:  BCLR.B  800.4
03EFE:  BTSC.B  853.0
03F00:  BSET.B  800.4
....................                                  break; 
03F02:  GOTO    3F24
....................                      default:    fprintf(RS232,"Invalid Entry\n\r"); 
03F06:  MOV     #0,W1
03F08:  MOV     W1,W0
03F0A:  CALL    129C
03F0E:  INC     W1,W1
03F10:  MOV     W1,[W15++]
03F12:  BTSC.B  219.1
03F14:  BRA     3F12
03F16:  MOV     W0,21A
03F18:  MOV     [--W15],W1
03F1A:  MOV     #E,W0
03F1C:  CPSGT   W1,W0
03F1E:  BRA     3F08
....................                                  break; 
03F20:  GOTO    3F24
....................                   } 
....................                   break; 
03F24:  GOTO    408C
....................       case 'w':   fprintf(RS232,"\n\rEncoder count %4u\n\r",qei_get_count()); 
03F28:  CALL    1F8A
03F2C:  MOV     W0,W5
03F2E:  MOV     #0,W1
03F30:  MOV     W1,W0
03F32:  CALL    12B8
03F36:  INC     W1,W1
03F38:  MOV     W1,[W15++]
03F3A:  BTSC.B  219.1
03F3C:  BRA     3F3A
03F3E:  MOV     W0,21A
03F40:  MOV     [--W15],W1
03F42:  MOV     #F,W0
03F44:  CPSGT   W1,W0
03F46:  BRA     3F30
03F48:  MOV     W5,W0
03F4A:  MOV     #4,W4
03F4C:  CALL    1572
03F50:  BTSC.B  219.1
03F52:  BRA     3F50
03F54:  MOV     #A,W4
03F56:  MOV     W4,21A
03F58:  BTSC.B  219.1
03F5A:  BRA     3F58
03F5C:  MOV     #D,W4
03F5E:  MOV     W4,21A
....................                   break; 
03F60:  GOTO    408C
....................       case 'z':   fprintf(RS232,"\n\rStart Memory Test (Yes -> 1, No -> 0): "); 
03F64:  MOV     #0,W1
03F66:  MOV     W1,W0
03F68:  CALL    12DA
03F6C:  INC     W1,W1
03F6E:  MOV     W1,[W15++]
03F70:  BTSC.B  219.1
03F72:  BRA     3F70
03F74:  MOV     W0,21A
03F76:  MOV     [--W15],W1
03F78:  MOV     #28,W0
03F7A:  CPSGT   W1,W0
03F7C:  BRA     3F66
....................                   unsigned int input_mem_test=(unsigned)(fgetc(RS232)-48); 
03F7E:  BTSS.B  218.0
03F80:  BRA     3F7E
03F82:  MOV     21C,W0
03F84:  MOV     #30,W4
03F86:  SUB.B   W0L,W4L,W0L
03F88:  MOV.B   W0L,88C
03F8A:  CLR.B   88D
....................                   fputc(input_mem_test+48,RS232); 
03F8C:  MOV     #30,W4
03F8E:  MOV     88C,W3
03F90:  ADD     W3,W4,W5
03F92:  MOV.B   W5L,W0L
03F94:  BTSC.B  219.1
03F96:  BRA     3F94
03F98:  MOV.B   W0L,21A
03F9A:  CLR.B   21B
....................                   
....................                   unsigned int8 mem=0; 
03F9C:  CLR.B   88E
....................                    
....................                   if(input_mem_test == 1) 
03F9E:  MOV     88C,W4
03FA0:  CP      W4,#1
03FA2:  BRA     NZ,3FF8
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
03FA4:  CLR.B   88E
03FA6:  MOV     88E,W4
03FA8:  MOV     #64,W3
03FAA:  CP.B    W3L,W4L
03FAC:  BRA     LEU,3FCC
....................                         data_set_pos(mem, mem+1); 
03FAE:  MOV     88E,W4
03FB0:  ADD.B   W4L,#1,W4L
03FB2:  MOV.B   W4L,W0L
03FB4:  MOV.B   W0L,A
03FB6:  MOV.B   88E,W0L
03FB8:  MOV.B   W0L,892
03FBA:  PUSH    894
03FBC:  MOV.B   W5L,[W15-#2]
03FBE:  POP     894
03FC0:  CLR.B   895
03FC2:  CALL    3516
03FC6:  INC.B   088E
03FC8:  GOTO    3FA6
....................                          
....................                      fprintf(RS232,"\n\r"); 
03FCC:  BTSC.B  219.1
03FCE:  BRA     3FCC
03FD0:  MOV     #A,W4
03FD2:  MOV     W4,21A
03FD4:  BTSC.B  219.1
03FD6:  BRA     3FD4
03FD8:  MOV     #D,W4
03FDA:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
03FDC:  BSET.B  800.2
....................                      for(mem=0; mem<100; mem++) 
03FDE:  CLR.B   88E
03FE0:  MOV     88E,W4
03FE2:  MOV     #64,W3
03FE4:  CP.B    W3L,W4L
03FE6:  BRA     LEU,3FF6
....................                         data_get_pos(mem); 
03FE8:  MOV.B   88E,W0L
03FEA:  MOV.B   W0L,896
03FEC:  CALL    3430
03FF0:  INC.B   088E
03FF2:  GOTO    3FE0
....................                      debug_mode_fr=0; 
03FF6:  BCLR.B  800.2
....................                   } 
....................                   break; 
03FF8:  GOTO    408C
....................       case 'f':   fprintf(RS232,"\n\rClear Memory (Yes -> 1, No -> 0): "); 
03FFC:  MOV     #0,W1
03FFE:  MOV     W1,W0
04000:  CALL    1312
04004:  INC     W1,W1
04006:  MOV     W1,[W15++]
04008:  BTSC.B  219.1
0400A:  BRA     4008
0400C:  MOV     W0,21A
0400E:  MOV     [--W15],W1
04010:  MOV     #23,W0
04012:  CPSGT   W1,W0
04014:  BRA     3FFE
....................                   input_mem_test=(unsigned)(fgetc(RS232)-48); 
04016:  BTSS.B  218.0
04018:  BRA     4016
0401A:  MOV     21C,W0
0401C:  MOV     #30,W4
0401E:  SUB.B   W0L,W4L,W0L
04020:  MOV.B   W0L,88C
04022:  CLR.B   88D
....................                   fputc(input_mem_test+48,RS232); 
04024:  MOV     #30,W4
04026:  MOV     88C,W3
04028:  ADD     W3,W4,W5
0402A:  MOV.B   W5L,W0L
0402C:  BTSC.B  219.1
0402E:  BRA     402C
04030:  MOV.B   W0L,21A
04032:  CLR.B   21B
....................                    
....................                   if(input_mem_test == 1) 
04034:  MOV     88C,W4
04036:  CP      W4,#1
04038:  BRA     NZ,4080
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
0403A:  CLR.B   88E
0403C:  MOV     88E,W4
0403E:  MOV     #64,W3
04040:  CP.B    W3L,W4L
04042:  BRA     LEU,4054
....................                         data_set_pos(mem, 0); 
04044:  MOV.B   88E,W0L
04046:  MOV.B   W0L,892
04048:  CLR     894
0404A:  CALL    3516
0404E:  INC.B   088E
04050:  GOTO    403C
....................                          
....................                      fprintf(RS232,"\n\r"); 
04054:  BTSC.B  219.1
04056:  BRA     4054
04058:  MOV     #A,W4
0405A:  MOV     W4,21A
0405C:  BTSC.B  219.1
0405E:  BRA     405C
04060:  MOV     #D,W4
04062:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
04064:  BSET.B  800.2
....................                      for(mem=0; mem<100; mem++) 
04066:  CLR.B   88E
04068:  MOV     88E,W4
0406A:  MOV     #64,W3
0406C:  CP.B    W3L,W4L
0406E:  BRA     LEU,407E
....................                         data_get_pos(mem); 
04070:  MOV.B   88E,W0L
04072:  MOV.B   W0L,896
04074:  CALL    3430
04078:  INC.B   088E
0407A:  GOTO    4068
....................                      debug_mode_fr=0; 
0407E:  BCLR.B  800.2
....................                   } 
....................                   break; 
04080:  GOTO    408C
....................       case 'g':    
....................                   break; 
04084:  GOTO    408C
....................       case 'y':    
....................                   break; 
04088:  GOTO    408C
....................    } 
....................     
....................    return; 
.................... } 
0408C:  MOV     [--W15],W6
0408E:  MOV     [--W15],W5
04090:  RETURN  
....................  
.................... // Parallel port strobe signal interrupt 
.................... #INT_EXT3 
.................... void isr_pp_strobe() 
.................... { 
*
0151E:  PUSH    42
01520:  PUSH    36
01522:  MOV     W0,[W15++]
01524:  MOV     #2,W0
01526:  REPEAT  #C
01528:  MOV     [W0++],[W15++]
....................    if(reg_comm_type == 0) 
0152A:  BTSC.B  800.6
0152C:  BRA     1530
....................       reg_pp_strobe = 1; 
0152E:  BSET.B  84C.0
.................... } 
.................... // RS232 receive byte interrupt 
01530:  BCLR.B  88.4
01532:  MOV     #1A,W0
01534:  REPEAT  #C
01536:  MOV     [--W15],[W0--]
01538:  MOV     [--W15],W0
0153A:  POP     36
0153C:  POP     42
0153E:  RETFIE  
.................... #INT_RDA2 
.................... void isr_rs232_message() 
.................... { 
01540:  PUSH    42
01542:  PUSH    36
01544:  MOV     W0,[W15++]
01546:  MOV     #2,W0
01548:  REPEAT  #C
0154A:  MOV     [W0++],[W15++]
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1;   
0154C:  BSET.B  84C.3
.................... }  
.................... // Clears RS232 interrupt flags 
0154E:  BCLR.B  87.0
01550:  MOV     #1A,W0
01552:  REPEAT  #C
01554:  MOV     [--W15],[W0--]
01556:  MOV     [--W15],W0
01558:  POP     36
0155A:  POP     42
0155C:  RETFIE  
.................... void rs232_clear() 
.................... { 
....................    UART_IFS0_U1RXIF = 0; 
....................    UART_IFS0_U1TXIF = 0; 
....................    reg_rs232_message = 0; 
.................... } 
....................  
.................... // Main method 
.................... void main() 
.................... { 
*
044BA:  BSET.B  81.7
044BC:  MOV     #8000,W4
044BE:  MOV     W4,20C
044C0:  MOV     #400,W4
044C2:  MOV     W4,20E
044C4:  MOV     #30,W4
044C6:  MOV     W4,214
044C8:  MOV     #8000,W4
044CA:  MOV     W4,216
044CC:  MOV     #400,W4
044CE:  MOV     W4,218
044D0:  MOV     #30,W4
044D2:  MOV     W4,21E
044D4:  BCLR.B  800.0
044D6:  BCLR.B  800.1
044D8:  BCLR.B  800.2
044DA:  BCLR.B  800.3
044DC:  BCLR.B  800.4
044DE:  BCLR.B  800.5
044E0:  MOV     #20,W4
044E2:  MOV     W4,802
044E4:  MOV     #3FF,W4
044E6:  MOV     W4,804
044E8:  MOV     #323,W4
044EA:  MOV     W4,806
044EC:  MOV     #46,W4
044EE:  MOV     W4,808
044F0:  MOV     #1C,W4
044F2:  MOV     W4,80A
044F4:  CLR     80C
044F6:  MOV     #190,W4
044F8:  MOV     W4,80E
044FA:  MOV     #2D,W4
044FC:  MOV     W4,810
044FE:  MOV     #3E8,W4
04500:  MOV     W4,812
04502:  MOV     #32,W4
04504:  MOV     W4,814
04506:  MOV     #64,W4
04508:  MOV     W4,816
0450A:  MOV     #46,W4
0450C:  MOV     W4,818
0450E:  CLR     81A
04510:  MOV     #BB8,W4
04512:  MOV     W4,81C
04514:  MOV     #BB8,W4
04516:  MOV     W4,81E
04518:  MOV     #64,W4
0451A:  MOV     W4,820
0451C:  CLR.B   801
0451E:  CLR     822
04520:  CLR     824
04522:  CLR     826
04524:  CLR     828
04526:  CLR     82A
04528:  CLR     82C
0452A:  CLR     82E
0452C:  CLR     830
0452E:  CLR     832
04530:  MOV     #D,W4
04532:  MOV     W4,834
04534:  MOV     #F,W4
04536:  MOV     W4,836
04538:  MOV     #11,W4
0453A:  MOV     W4,838
0453C:  MOV     #13,W4
0453E:  MOV     W4,83A
04540:  MOV     #15,W4
04542:  MOV     W4,83C
04544:  MOV     #17,W4
04546:  MOV     W4,83E
04548:  MOV     #18,W4
0454A:  MOV     W4,840
0454C:  MOV     #1A,W4
0454E:  MOV     W4,842
04550:  MOV     #A,W4
04552:  MOV     W4,844
04554:  MOV     #1,W4
04556:  MOV     W4,846
04558:  MOV     #64,W4
0455A:  MOV     W4,848
0455C:  MOV     #64,W4
0455E:  MOV     W4,84A
04560:  BCLR.B  800.6
04562:  BCLR.B  800.7
04564:  BCLR.B  84C.0
04566:  BCLR.B  84C.1
04568:  BCLR.B  84C.2
0456A:  BCLR.B  84C.3
0456C:  BCLR.B  84C.4
0456E:  MOV     #58,W4
04570:  MOV     W4,84E
04572:  SETM    2A8
04574:  MOV     #2780,W15
04576:  MOV     #27FF,W0
04578:  MOV     W0,20
0457A:  NOP     
....................    // Set I/O states of the ports 
....................    //           FEDCBA9876543210 
....................    set_tris_b(0b1111111011111100); 
0457C:  MOV     #FEFC,W4
0457E:  MOV     W4,2C6
....................    set_tris_c(0b1111111111111111); 
04580:  SETM    2CC
....................    set_tris_d(0b1111111100001111); 
04582:  MOV     #FF0F,W4
04584:  MOV     W4,2D2
....................    set_tris_e(0b1111111110000000); 
04586:  MOV     #FF80,W4
04588:  MOV     W4,2D8
....................    set_tris_f(0b1111111111111100); 
0458A:  MOV     #FFFC,W4
0458C:  MOV     W4,2DE
....................    set_tris_g(0b1111111100111111); 
0458E:  MOV     #FF3F,W4
04590:  MOV     W4,2E4
....................     
....................    // Set parallel port pins 
....................    output_low(PP_ACK); 
04592:  BCLR.B  2D2.4
04594:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04596:  BCLR.B  2D2.5
04598:  BCLR.B  2D6.5
....................     
....................    // Turn on debug led 
....................    output_high(LED); 
0459A:  BCLR.B  2C7.0
0459C:  BSET.B  2CB.0
....................     
....................    //Turn on lasers 
....................    output_high(LAS_1); 
0459E:  BCLR.B  2C6.0
045A0:  BSET.B  2CA.0
....................    output_high(LAS_2); 
045A2:  BCLR.B  2C6.1
045A4:  BSET.B  2CA.1
....................    output_high(LAS_3); 
045A6:  BCLR.B  2D2.6
045A8:  BSET.B  2D6.6
....................  
....................    // Set A/D converter to read motor torque control voltage 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
045AA:  MOV     #80,W4
045AC:  MOV     W4,2A4
045AE:  MOV     #80E0,W4
045B0:  MOV     W4,2A0
....................    setup_adc_ports(sAN2); 
045B2:  MOV     #FFFB,W4
045B4:  MOV     W4,2A8
045B6:  CLR     2A2
....................    set_adc_channel(2); 
045B8:  MOV     #2,W4
045BA:  MOV     W4,2A6
....................     
....................    delay_ms(500); 
045BC:  MOV     #1F4,W0
045BE:  CALL    155E
....................     
....................    fprintf(RS232,"\n\r"); 
045C2:  BTSC.B  219.1
045C4:  BRA     45C2
045C6:  MOV     #A,W4
045C8:  MOV     W4,21A
045CA:  BTSC.B  219.1
045CC:  BRA     45CA
045CE:  MOV     #D,W4
045D0:  MOV     W4,21A
....................    fprintf(RS232,"______________________________________________________________\n\r"); 
045D2:  MOV.B   #3E,W5L
045D4:  MOV     #5F,W0
045D6:  BTSC.B  219.1
045D8:  BRA     45D6
045DA:  MOV.B   W0L,21A
045DC:  CLR.B   21B
045DE:  DEC.B   000A
045E0:  BTSS.B  42.1
045E2:  BRA     45D4
045E4:  BTSC.B  219.1
045E6:  BRA     45E4
045E8:  MOV     #A,W4
045EA:  MOV     W4,21A
045EC:  BTSC.B  219.1
045EE:  BRA     45EC
045F0:  MOV     #D,W4
045F2:  MOV     W4,21A
....................    fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING SYSTEM\n\n\r"); 
045F4:  MOV     #0,W1
045F6:  MOV     W1,W0
045F8:  CALL    1344
045FC:  INC     W1,W1
045FE:  MOV     W1,[W15++]
04600:  BTSC.B  219.1
04602:  BRA     4600
04604:  MOV     W0,21A
04606:  MOV     [--W15],W1
04608:  MOV     #25,W0
0460A:  CPSGT   W1,W0
0460C:  BRA     45F6
....................    fprintf(RS232,"Press 'c' for command list\n\n\r"); 
0460E:  MOV     #0,W1
04610:  MOV     W1,W0
04612:  CALL    1378
04616:  INC     W1,W1
04618:  MOV     W1,[W15++]
0461A:  BTSC.B  219.1
0461C:  BRA     461A
0461E:  MOV     W0,21A
04620:  MOV     [--W15],W1
04622:  MOV     #1C,W0
04624:  CPSGT   W1,W0
04626:  BRA     4610
....................    fprintf(RS232,"RCON REGISTER VALUE(10'luk Tabanda):  "); 
04628:  MOV     #0,W1
0462A:  MOV     W1,W0
0462C:  CALL    13A2
04630:  INC     W1,W1
04632:  MOV     W1,[W15++]
04634:  BTSC.B  219.1
04636:  BRA     4634
04638:  MOV     W0,21A
0463A:  MOV     [--W15],W1
0463C:  MOV     #25,W0
0463E:  CPSGT   W1,W0
04640:  BRA     462A
....................    fprintf(RS232,"%u",RCON); 
04642:  MOV     740,W0
04644:  MOV     #0,W4
04646:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
0464A:  BTSC.B  219.1
0464C:  BRA     464A
0464E:  MOV     #A,W4
04650:  MOV     W4,21A
04652:  BTSC.B  219.1
04654:  BRA     4652
04656:  MOV     #D,W4
04658:  MOV     W4,21A
....................    fprintf(RS232,"RCON REGISTER BITLERI:"); 
0465A:  MOV     #0,W1
0465C:  MOV     W1,W0
0465E:  CALL    13D6
04662:  INC     W1,W1
04664:  MOV     W1,[W15++]
04666:  BTSC.B  219.1
04668:  BRA     4666
0466A:  MOV     W0,21A
0466C:  MOV     [--W15],W1
0466E:  MOV     #15,W0
04670:  CPSGT   W1,W0
04672:  BRA     465C
....................    fprintf(RS232,"\n\r"); 
04674:  BTSC.B  219.1
04676:  BRA     4674
04678:  MOV     #A,W4
0467A:  MOV     W4,21A
0467C:  BTSC.B  219.1
0467E:  BRA     467C
04680:  MOV     #D,W4
04682:  MOV     W4,21A
....................     
....................    fprintf(RS232,"POR:    "); 
04684:  MOV     #0,W1
04686:  MOV     W1,W0
04688:  CALL    13FA
0468C:  INC     W1,W1
0468E:  MOV     W1,[W15++]
04690:  BTSC.B  219.1
04692:  BRA     4690
04694:  MOV     W0,21A
04696:  MOV     [--W15],W1
04698:  MOV     #7,W0
0469A:  CPSGT   W1,W0
0469C:  BRA     4686
....................    fprintf(RS232,"%u",RCON_POR); 
0469E:  CLR.B   W0
046A0:  BTSC.B  740.0
046A2:  INC     W0,W0
046A4:  MOV.B   W0L,W5L
046A6:  MOV.B   W5L,W0L
046A8:  CLR.B   1
046AA:  MOV     #0,W4
046AC:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
046B0:  BTSC.B  219.1
046B2:  BRA     46B0
046B4:  MOV     #A,W4
046B6:  MOV     W4,21A
046B8:  BTSC.B  219.1
046BA:  BRA     46B8
046BC:  MOV     #D,W4
046BE:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BOR:    "); 
046C0:  MOV     #0,W1
046C2:  MOV     W1,W0
046C4:  CALL    1410
046C8:  INC     W1,W1
046CA:  MOV     W1,[W15++]
046CC:  BTSC.B  219.1
046CE:  BRA     46CC
046D0:  MOV     W0,21A
046D2:  MOV     [--W15],W1
046D4:  MOV     #7,W0
046D6:  CPSGT   W1,W0
046D8:  BRA     46C2
....................    fprintf(RS232,"%u",RCON_BOR); 
046DA:  CLR.B   W0
046DC:  BTSC.B  740.1
046DE:  INC     W0,W0
046E0:  MOV.B   W0L,W5L
046E2:  MOV.B   W5L,W0L
046E4:  CLR.B   1
046E6:  MOV     #0,W4
046E8:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
046EC:  BTSC.B  219.1
046EE:  BRA     46EC
046F0:  MOV     #A,W4
046F2:  MOV     W4,21A
046F4:  BTSC.B  219.1
046F6:  BRA     46F4
046F8:  MOV     #D,W4
046FA:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IDLE:   "); 
046FC:  MOV     #0,W1
046FE:  MOV     W1,W0
04700:  CALL    1426
04704:  INC     W1,W1
04706:  MOV     W1,[W15++]
04708:  BTSC.B  219.1
0470A:  BRA     4708
0470C:  MOV     W0,21A
0470E:  MOV     [--W15],W1
04710:  MOV     #7,W0
04712:  CPSGT   W1,W0
04714:  BRA     46FE
....................    fprintf(RS232,"%u",RCON_IDLE); 
04716:  CLR.B   W0
04718:  BTSC.B  740.2
0471A:  INC     W0,W0
0471C:  MOV.B   W0L,W5L
0471E:  MOV.B   W5L,W0L
04720:  CLR.B   1
04722:  MOV     #0,W4
04724:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04728:  BTSC.B  219.1
0472A:  BRA     4728
0472C:  MOV     #A,W4
0472E:  MOV     W4,21A
04730:  BTSC.B  219.1
04732:  BRA     4730
04734:  MOV     #D,W4
04736:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SLEEP:  "); 
04738:  MOV     #0,W1
0473A:  MOV     W1,W0
0473C:  CALL    143C
04740:  INC     W1,W1
04742:  MOV     W1,[W15++]
04744:  BTSC.B  219.1
04746:  BRA     4744
04748:  MOV     W0,21A
0474A:  MOV     [--W15],W1
0474C:  MOV     #7,W0
0474E:  CPSGT   W1,W0
04750:  BRA     473A
....................    fprintf(RS232,"%u",RCON_SLEEP); 
04752:  CLR.B   W0
04754:  BTSC.B  740.3
04756:  INC     W0,W0
04758:  MOV.B   W0L,W5L
0475A:  MOV.B   W5L,W0L
0475C:  CLR.B   1
0475E:  MOV     #0,W4
04760:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04764:  BTSC.B  219.1
04766:  BRA     4764
04768:  MOV     #A,W4
0476A:  MOV     W4,21A
0476C:  BTSC.B  219.1
0476E:  BRA     476C
04770:  MOV     #D,W4
04772:  MOV     W4,21A
....................     
....................    fprintf(RS232,"WDTO:   "); 
04774:  MOV     #0,W1
04776:  MOV     W1,W0
04778:  CALL    1452
0477C:  INC     W1,W1
0477E:  MOV     W1,[W15++]
04780:  BTSC.B  219.1
04782:  BRA     4780
04784:  MOV     W0,21A
04786:  MOV     [--W15],W1
04788:  MOV     #7,W0
0478A:  CPSGT   W1,W0
0478C:  BRA     4776
....................    fprintf(RS232,"%u",RCON_WDTO); 
0478E:  CLR.B   W0
04790:  BTSC.B  740.4
04792:  INC     W0,W0
04794:  MOV.B   W0L,W5L
04796:  MOV.B   W5L,W0L
04798:  CLR.B   1
0479A:  MOV     #0,W4
0479C:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
047A0:  BTSC.B  219.1
047A2:  BRA     47A0
047A4:  MOV     #A,W4
047A6:  MOV     W4,21A
047A8:  BTSC.B  219.1
047AA:  BRA     47A8
047AC:  MOV     #D,W4
047AE:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWDTEN: "); 
047B0:  MOV     #0,W1
047B2:  MOV     W1,W0
047B4:  CALL    1468
047B8:  INC     W1,W1
047BA:  MOV     W1,[W15++]
047BC:  BTSC.B  219.1
047BE:  BRA     47BC
047C0:  MOV     W0,21A
047C2:  MOV     [--W15],W1
047C4:  MOV     #7,W0
047C6:  CPSGT   W1,W0
047C8:  BRA     47B2
....................    fprintf(RS232,"%u",RCON_SWDTEN); 
047CA:  CLR.B   W0
047CC:  BTSC.B  740.5
047CE:  INC     W0,W0
047D0:  MOV.B   W0L,W5L
047D2:  MOV.B   W5L,W0L
047D4:  CLR.B   1
047D6:  MOV     #0,W4
047D8:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
047DC:  BTSC.B  219.1
047DE:  BRA     47DC
047E0:  MOV     #A,W4
047E2:  MOV     W4,21A
047E4:  BTSC.B  219.1
047E6:  BRA     47E4
047E8:  MOV     #D,W4
047EA:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWR:    "); 
047EC:  MOV     #0,W1
047EE:  MOV     W1,W0
047F0:  CALL    147E
047F4:  INC     W1,W1
047F6:  MOV     W1,[W15++]
047F8:  BTSC.B  219.1
047FA:  BRA     47F8
047FC:  MOV     W0,21A
047FE:  MOV     [--W15],W1
04800:  MOV     #7,W0
04802:  CPSGT   W1,W0
04804:  BRA     47EE
....................    fprintf(RS232,"%u",RCON_SWR); 
04806:  CLR.B   W0
04808:  BTSC.B  740.6
0480A:  INC     W0,W0
0480C:  MOV.B   W0L,W5L
0480E:  MOV.B   W5L,W0L
04810:  CLR.B   1
04812:  MOV     #0,W4
04814:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04818:  BTSC.B  219.1
0481A:  BRA     4818
0481C:  MOV     #A,W4
0481E:  MOV     W4,21A
04820:  BTSC.B  219.1
04822:  BRA     4820
04824:  MOV     #D,W4
04826:  MOV     W4,21A
....................     
....................    fprintf(RS232,"EXTR:   "); 
04828:  MOV     #0,W1
0482A:  MOV     W1,W0
0482C:  CALL    1494
04830:  INC     W1,W1
04832:  MOV     W1,[W15++]
04834:  BTSC.B  219.1
04836:  BRA     4834
04838:  MOV     W0,21A
0483A:  MOV     [--W15],W1
0483C:  MOV     #7,W0
0483E:  CPSGT   W1,W0
04840:  BRA     482A
....................    fprintf(RS232,"%u",RCON_EXTR); 
04842:  CLR.B   W0
04844:  BTSC.B  740.7
04846:  INC     W0,W0
04848:  MOV.B   W0L,W5L
0484A:  MOV.B   W5L,W0L
0484C:  CLR.B   1
0484E:  MOV     #0,W4
04850:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04854:  BTSC.B  219.1
04856:  BRA     4854
04858:  MOV     #A,W4
0485A:  MOV     W4,21A
0485C:  BTSC.B  219.1
0485E:  BRA     485C
04860:  MOV     #D,W4
04862:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BGST:   "); 
04864:  MOV     #0,W1
04866:  MOV     W1,W0
04868:  CALL    14AA
0486C:  INC     W1,W1
0486E:  MOV     W1,[W15++]
04870:  BTSC.B  219.1
04872:  BRA     4870
04874:  MOV     W0,21A
04876:  MOV     [--W15],W1
04878:  MOV     #7,W0
0487A:  CPSGT   W1,W0
0487C:  BRA     4866
....................    fprintf(RS232,"%u",RCON_BGST); 
0487E:  CLR.B   W0
04880:  BTSC.B  741.5
04882:  INC     W0,W0
04884:  MOV.B   W0L,W5L
04886:  MOV.B   W5L,W0L
04888:  CLR.B   1
0488A:  MOV     #0,W4
0488C:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04890:  BTSC.B  219.1
04892:  BRA     4890
04894:  MOV     #A,W4
04896:  MOV     W4,21A
04898:  BTSC.B  219.1
0489A:  BRA     4898
0489C:  MOV     #D,W4
0489E:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IOPUWR: "); 
048A0:  MOV     #0,W1
048A2:  MOV     W1,W0
048A4:  CALL    14C0
048A8:  INC     W1,W1
048AA:  MOV     W1,[W15++]
048AC:  BTSC.B  219.1
048AE:  BRA     48AC
048B0:  MOV     W0,21A
048B2:  MOV     [--W15],W1
048B4:  MOV     #7,W0
048B6:  CPSGT   W1,W0
048B8:  BRA     48A2
....................    fprintf(RS232,"%u",RCON_IOPUWR); 
048BA:  CLR.B   W0
048BC:  BTSC.B  741.6
048BE:  INC     W0,W0
048C0:  MOV.B   W0L,W5L
048C2:  MOV.B   W5L,W0L
048C4:  CLR.B   1
048C6:  MOV     #0,W4
048C8:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
048CC:  BTSC.B  219.1
048CE:  BRA     48CC
048D0:  MOV     #A,W4
048D2:  MOV     W4,21A
048D4:  BTSC.B  219.1
048D6:  BRA     48D4
048D8:  MOV     #D,W4
048DA:  MOV     W4,21A
....................     
....................    fprintf(RS232,"TRAPR:  "); 
048DC:  MOV     #0,W1
048DE:  MOV     W1,W0
048E0:  CALL    14D6
048E4:  INC     W1,W1
048E6:  MOV     W1,[W15++]
048E8:  BTSC.B  219.1
048EA:  BRA     48E8
048EC:  MOV     W0,21A
048EE:  MOV     [--W15],W1
048F0:  MOV     #7,W0
048F2:  CPSGT   W1,W0
048F4:  BRA     48DE
....................    fprintf(RS232,"%u",RCON_TRAPR); 
048F6:  CLR.B   W0
048F8:  BTSC.B  741.7
048FA:  INC     W0,W0
048FC:  MOV.B   W0L,W5L
048FE:  MOV.B   W5L,W0L
04900:  CLR.B   1
04902:  MOV     #0,W4
04904:  CALL    1572
....................    fprintf(RS232,"\n\r"); 
04908:  BTSC.B  219.1
0490A:  BRA     4908
0490C:  MOV     #A,W4
0490E:  MOV     W4,21A
04910:  BTSC.B  219.1
04912:  BRA     4910
04914:  MOV     #D,W4
04916:  MOV     W4,21A
....................     
....................    fprintf(RS232,"Register Ekrana Yazdirilip Sifirlandi"); 
04918:  MOV     #0,W1
0491A:  MOV     W1,W0
0491C:  CALL    14EC
04920:  INC     W1,W1
04922:  MOV     W1,[W15++]
04924:  BTSC.B  219.1
04926:  BRA     4924
04928:  MOV     W0,21A
0492A:  MOV     [--W15],W1
0492C:  MOV     #24,W0
0492E:  CPSGT   W1,W0
04930:  BRA     491A
....................    fprintf(RS232,"\n\r"); 
04932:  BTSC.B  219.1
04934:  BRA     4932
04936:  MOV     #A,W4
04938:  MOV     W4,21A
0493A:  BTSC.B  219.1
0493C:  BRA     493A
0493E:  MOV     #D,W4
04940:  MOV     W4,21A
....................    RCON = 0x0000; 
04942:  CLR     740
....................     
....................    // Initialize components 
....................    qei_init();                            // Initialize quadrature encoder  
04944:  CALL    1628
....................    pwm_init();                            // Initialize PWM module 
04948:  CALL    168E
....................    dp_init();                             // Initialize digital potentiometer 
0494C:  CALL    16CE
....................    md_init();                             // Initialize motor driver 
04950:  CALL    1BF6
....................    fr_init();                             // Initialize FRAM 
04954:  CALL    1C20
....................    move_init();                           // Initializes the system for movement 
04958:  CALL    2D7E
....................     
....................    // Enable RS232 receive byte interrupt 
....................    enable_interrupts(INT_RDA2); 
0495C:  BSET.B  8F.0
....................    // Enable parallel port strobe signal interrupt 
....................    ext_int_edge(3, H_TO_L); 
0495E:  BSET.B  82.3
....................    enable_interrupts(INT_EXT3); 
04960:  BSET.B  90.4
....................     
....................    reg_comm_type = data_get_comm_type();  // Set communication type 
04962:  CALL    2E16
04966:  BCLR.B  800.6
04968:  BTSC.B  0.0
0496A:  BSET.B  800.6
....................     
....................    switch (reg_comm_type) 
....................    { 
0496C:  CLR.B   W0
0496E:  BTSC.B  800.6
04970:  INC     W0,W0
04972:  CLR.B   1
04974:  XOR     #0,W0
04976:  BRA     Z,497E
04978:  XOR     #1,W0
0497A:  BRA     Z,498A
0497C:  BRA     4996
....................       case 0   :  output_high(PP_ACK); 
0497E:  BCLR.B  2D2.4
04980:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04982:  BCLR.B  2D2.5
04984:  BSET.B  2D6.5
....................                   break; 
04986:  GOTO    49AC
....................       case 1   :  output_low(PP_ACK); 
0498A:  BCLR.B  2D2.4
0498C:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
0498E:  BCLR.B  2D2.5
04990:  BCLR.B  2D6.5
....................                   break; 
04992:  GOTO    49AC
....................       default:    output_high(PP_ACK); 
04996:  BCLR.B  2D2.4
04998:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
0499A:  BCLR.B  2D2.5
0499C:  BSET.B  2D6.5
....................                   fr_write_byte(fr_comm_type, 0); 
0499E:  CLR.B   8AE
049A0:  PUSH    83E
049A2:  POP     8AC
049A4:  CALL    2264
....................                   break; 
049A8:  GOTO    49AC
....................    } 
....................     
....................    while(true) 
....................    { 
....................       if(reg_rs232_message) 
049AC:  BTSS.B  84C.3
049AE:  BRA     49BA
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
049B0:  BCLR.B  8F.0
....................  
....................          rs232_message(); 
049B2:  CALL    3532
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
....................          enable_interrupts(INT_RDA2); 
049B6:  BSET.B  8F.0
....................          reg_rs232_message = 0; 
049B8:  BCLR.B  84C.3
....................       } 
....................       if(reg_pp_strobe) 
049BA:  BTSS.B  84C.0
049BC:  BRA     4A42
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
049BE:  BCLR.B  8F.0
....................           
....................          reg_pp_strobe=0; 
049C0:  BCLR.B  84C.0
....................           
....................          if(debug_mode_pp) 
049C2:  BTSS.B  800.1
049C4:  BRA     49E0
....................             fprintf(RS232,"Strobe received\n\r"); 
049C6:  MOV     #0,W1
049C8:  MOV     W1,W0
049CA:  CALL    AA6
049CE:  INC     W1,W1
049D0:  MOV     W1,[W15++]
049D2:  BTSC.B  219.1
049D4:  BRA     49D2
049D6:  MOV     W0,21A
049D8:  MOV     [--W15],W1
049DA:  MOV     #10,W0
049DC:  CPSGT   W1,W0
049DE:  BRA     49C8
....................  
....................          unsigned int i; 
....................          for(i=0; i<pp_str_check; i++) 
049E0:  CLR     850
049E2:  MOV     850,W0
049E4:  MOV     844,W4
049E6:  CP      W4,W0
049E8:  BRA     LEU,4A1C
....................          { 
....................             delay_ms(pp_str_delay); 
049EA:  MOV     846,W0
049EC:  CALL    155E
....................             if(input(PP_STR)==1) 
049F0:  BSET.B  2D3.2
049F2:  BTSS.B  2D5.2
049F4:  BRA     4A16
....................             { 
....................                if(debug_mode_pp) 
049F6:  BTSS.B  800.1
049F8:  BRA     4A14
....................                   fprintf(RS232,"Strobe signal rejected\n\r"); 
049FA:  MOV     #0,W1
049FC:  MOV     W1,W0
049FE:  CALL    AC4
04A02:  INC     W1,W1
04A04:  MOV     W1,[W15++]
04A06:  BTSC.B  219.1
04A08:  BRA     4A06
04A0A:  MOV     W0,21A
04A0C:  MOV     [--W15],W1
04A0E:  MOV     #17,W0
04A10:  CPSGT   W1,W0
04A12:  BRA     49FC
....................                return; 
04A14:  BRA     4A46
....................             } 
....................          } 
04A16:  INC     0850
04A18:  GOTO    49E2
....................           
....................          if(debug_mode_pp) 
04A1C:  BTSS.B  800.1
04A1E:  BRA     4A3A
....................             fprintf(RS232,"Strobe confirmed\n\r"); 
04A20:  MOV     #0,W1
04A22:  MOV     W1,W0
04A24:  CALL    AEA
04A28:  INC     W1,W1
04A2A:  MOV     W1,[W15++]
04A2C:  BTSC.B  219.1
04A2E:  BRA     4A2C
04A30:  MOV     W0,21A
04A32:  MOV     [--W15],W1
04A34:  MOV     #11,W0
04A36:  CPSGT   W1,W0
04A38:  BRA     4A22
....................  
....................          pp_get_command(); 
04A3A:  CALL    43BA
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
....................          enable_interrupts(INT_RDA2); 
04A3E:  BSET.B  8F.0
....................          reg_rs232_message = 0; 
04A40:  BCLR.B  84C.3
....................       } 
....................    } 
04A42:  GOTO    49AC
.................... } 
04A46:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C713   NOCKSFSM HS2_PLL16 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 87B3   PUT64 BROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F   WRTB NOBSS NOEBS NORBS
          H: 0000  
   Word  5L: 330F   NOWRTSS NOSSS NORSS NOESS
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  

CCS PCD C Compiler, Version 4.140, 15496               28-Ara-13 14:42

               Filename:   Z:\Modesis\Proje Dosyalarý\LPS - Lazer Projeksiyon Sistemi\Eski Dosyalar\Software\SLS_6015_Servo_Lazer_Control_v3.5\Control_Card_v2.0.lst

               ROM used:   17546 bytes (18%)
                           Largest free fragment is 47990
               RAM used:   385 (5%) at main() level
                           658 (8%) worst case
               Stack size: 128

*
00000:  GOTO    4164
*
00044:  DATA    5C,13,00
*
0005C:  DATA    3A,13,00
.................... #INCLUDE <30f6015.h>  
.................... //////// Standard Header file for the DSPIC30F6015 device //////////////// 
.................... #device DSPIC30F6015 
.................... #list 
....................  
.................... #DEVICE ADC=10                                                    // Configures the read_adc return size as 10 bit 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                                                      // No Watch Dog Timer  
.................... #FUSES HS2_PLL16                                                  // HS crystal, Freq=16*(Fcryst/2) 
.................... #FUSES NOCKSFSM                                                   // Clock Switching is disabled, fail Safe clock monitor is disabled  
.................... #FUSES BROWNOUT                                                   // Reset when brownout detected  
.................... #FUSES NOPROTECT                                                  // Code not protected from reading  
.................... #FUSES NOWRT                                                      // Program memory not write protected  
.................... #FUSES NODEBUG                                                    // No Debug mode for ICD 
....................  
.................... #USE DELAY(clock=120000000)                                       // delay() func. adjusted for 120Mhz Primary Osc. 
*
0137A:  CP0     W0
0137C:  BTSC.B  42.1
0137E:  BRA     138C
01380:  REPEAT  #352B
01382:  NOP     
01384:  REPEAT  #3FFE
01386:  NOP     
01388:  DEC     W0,W0
0138A:  BRA     NZ,1380
0138C:  RETURN  
*
01CEC:  CP0     W0
01CEE:  BTSC.B  42.1
01CF0:  BRA     1CFA
01CF2:  REPEAT  #19
01CF4:  NOP     
01CF6:  DEC     W0,W0
01CF8:  BRA     NZ,1CF2
01CFA:  RETURN  
.................... #USE RS232(stream=RS485,UART1,baud=38400,parity=N,bits=8,stop=1)  // Set UART1 as RS485 stream 
.................... #USE RS232(stream=RS232,UART2,baud=38400,parity=N,bits=8,stop=1)  // Set UART2 as RS232 stream 
....................  
.................... // Registers of quadrature encoder interface module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD QEI_QEICON        = 0x122           // Control and status register QEICON allows control of the QEI operation and status flags indicating the module state. 
.................... #WORD QEI_DFLTCON       = 0x124           // Digital filter control register DFLTCON allows control of the digital input filter operation. 
.................... #WORD QEI_POSCNT        = 0x126           // Position count register POSCNT allows reading and writing of the 16-bit position counter. 
.................... #WORD QEI_MAXCNT        = 0x128           // Maximum count register MAXCNT holds a value that will be compared to the POSCNT counter in some operations. 
.................... // Bits of the QEICON register 
.................... #BIT QEI_QEICON_CNTERR  = QEI_QEICON.15   // Count error status flag bit 
.................... #BIT QEI_QEICON_QEISIDL = QEI_QEICON.13   // Stop in idle mode bit 
.................... #BIT QEI_QEICON_INDEX   = QEI_QEICON.12   // Index pin state status bit (read only) 
.................... #BIT QEI_QEICON_UPDN    = QEI_QEICON.11   // Position counter direction status bit (read only) 
.................... #BIT QEI_QEICON_QEIM2   = QEI_QEICON.10   // Quadrature encoder interface mode select bits 
.................... #BIT QEI_QEICON_QEIM1   = QEI_QEICON.9 
.................... #BIT QEI_QEICON_QEIM0   = QEI_QEICON.8 
.................... #BIT QEI_QEICON_SWPAB   = QEI_QEICON.7    // Phase A and phase B input swap select bit  
.................... #BIT QEI_QEICON_PCDOUT  = QEI_QEICON.6    // Position counter direction state output rnable bit 
.................... #BIT QEI_QEICON_TQGATE  = QEI_QEICON.5    // Timer gated time accumulation rnable bit 
.................... #BIT QEI_QEICON_TQCKPS1 = QEI_QEICON.4    // Timer input clock prescale select bits 
.................... #BIT QEI_QEICON_TQCKPS0 = QEI_QEICON.3 
.................... #BIT QEI_QEICON_POSRES  = QEI_QEICON.2    // Position counter reset enable bit 
.................... #BIT QEI_QEICON_TQCS    = QEI_QEICON.1    // Timer clock source select bit 
.................... #BIT QEI_QEICON_UDSRC   = QEI_QEICON.0    // Position counter direction selection control bit 
.................... // Bits of the DFLTCON register 
.................... #BIT QEI_DFLTCON_IMV1   = QEI_DFLTCON.10  // Index match value bits 
.................... #BIT QEI_DFLTCON_IMV0   = QEI_DFLTCON.9   // These bits allow the user to specify the state of the QEA and QEB input pins during an Index pulse when the POSCNT register is to be reset. 
.................... #BIT QEI_DFLTCON_CEID   = QEI_DFLTCON.8   // Count error interrupt disable bit 
.................... #BIT QEI_DFLTCON_QEOUT  = QEI_DFLTCON.7   // QEA/QEB/IND digital filter output enable bit  
.................... #BIT QEI_DFLTCON_QECK2  = QEI_DFLTCON.6   // QEA/QEB/IND digital filter clock divide select bits 
.................... #BIT QEI_DFLTCON_QECK1  = QEI_DFLTCON.5      
.................... #BIT QEI_DFLTCON_QECK0  = QEI_DFLTCON.4 
....................  
.................... // Registers of the motor control PWM module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD PWM_PTCON         = 0x1C0           // PWM Time base control register 
.................... #WORD PWM_PTPER         = 0x1C4           // PWM Time base period register 
.................... #WORD PWM_PWMCON1       = 0x1C8           // PWM Control register #1 
.................... #WORD PWM_PWMCON2       = 0x1CA           // PWM Control register #2 
.................... #WORD PWM_PDC1          = 0x1D6           // PWM Duty cycle register #1 
.................... #WORD PWM_IEC2          = 0x090           // PWM Interrupt Enable Control Register 
.................... #WORD PWM_IFS2          = 0x088           // PWM Interrupt Flag Status Register 
.................... // Bits of the PTCON register 
.................... #BIT PWM_PTCON_PTEN     = PWM_PTCON.15    // PWM Time base timer enable bit 
.................... #BIT PWM_PTCON_PTOPS3   = PWM_PTCON.7     // PWM Time base output postscale select bits  
.................... #BIT PWM_PTCON_PTOPS2   = PWM_PTCON.6 
.................... #BIT PWM_PTCON_PTOPS1   = PWM_PTCON.5 
.................... #BIT PWM_PTCON_PTOPS0   = PWM_PTCON.4 
.................... #BIT PWM_PTCON_PTCKPS1  = PWM_PTCON.3     // PWM Time base input clock prescale select bits 
.................... #BIT PWM_PTCON_PTCKPS0  = PWM_PTCON.2     
.................... #BIT PWM_PTCON_PTMOD1   = PWM_PTCON.1     // PWM Time base mode select bits 
.................... #BIT PWM_PTCON_PTMOD0   = PWM_PTCON.0 
.................... // Bits of the PWMCON1 register 
.................... #BIT PWM_PWMCON1_PMOD1  = PWM_PWMCON1.8   // PWM1 I/O pin pair mode bit 
.................... #BIT PWM_PWMCON1_PEN1H  = PWM_PWMCON1.4   // PWM1H I/O pin enable bit 
.................... #BIT PWM_PWMCON1_PEN1L  = PWM_PWMCON1.0   // PWM1L I/O pin enable bit 
.................... // Bits of the PWMCON2 register   
.................... #BIT PWM_PWMCON2_IUE    = PWM_PWMCON2.2   // Immediate update enable bit 
.................... #BIT PWM_PWMCON2_OSYNC  = PWM_PWMCON2.1   // Output override synchronization bit 
.................... #BIT PWM_PWMCON2_UDIS   = PWM_PWMCON2.0   // PWM update disable bit 
.................... // Bits of the IEC2 register 
.................... #BIT PWM_IEC2_PWMIE     = PWM_IEC2.7      // PWM Interrupt enable bit  
.................... // Bits of the IFS2 register 
.................... #BIT PWM_IFS2_PWMIF     = PWM_IFS2.7      // PWM Interrupt flag status bit     
....................  
.................... // Registers of the UART1 module 
.................... #WORD UART_IFS0          = 0x088           // UART Interrupt Flag Status Register 
.................... // Bits of the IFS0 register 
.................... #BIT UART_IFS0_U1RXIF    = UART_IFS0.9     // UART Receiver Interrupt flag status bit   
.................... #BIT UART_IFS0_U1TXIF    = UART_IFS0.10    // UART Transmiter Interrupt flag status bit   
....................  
.................... // Led pins 
.................... #DEFINE LED          PIN_B8               // Led used in debugging 
....................  
.................... // Laser pins 
.................... #DEFINE LAS_1        PIN_B0               // Control pin of the first laser 
.................... #DEFINE LAS_2        PIN_B1               // Control pin of the second laser 
.................... #DEFINE LAS_3        PIN_D6               // Control pin of the third laser 
....................  
.................... //Parallel Port Pin Assignments 
.................... #DEFINE PP_D0        PIN_D8               // Parallel port data pin first bit 
.................... #DEFINE PP_D1        PIN_D9               // Parallel port data pin second bit 
.................... #DEFINE PP_D2        PIN_D0               // Parallel port data pin third bit 
.................... #DEFINE PP_D3        PIN_C13              // Parallel port data pin fourth bit 
.................... #DEFINE PP_D4        PIN_C14              // Parallel port data pin fifth bit 
.................... #DEFINE PP_D5        PIN_D1               // Parallel port data pin sixth bit 
.................... #DEFINE PP_D6        PIN_D2               // Parallel port data pin seventh bit 
.................... #DEFINE PP_D7        PIN_D3               // Parallel port data pin eigth bit 
.................... #DEFINE PP_STR       PIN_D10              // Parallel port strobe pin 
.................... #DEFINE PP_ACK       PIN_D4               // Parallel port acknowledge pin used to  
.................... #DEFINE PP_RDY       PIN_D5               // Parallel port ready pin 
....................  
.................... // Pins used to control digital potentiometer 
.................... #DEFINE DP_CS        PIN_G9               // Digital potentiometer chip select pin assignment (active low) 
.................... #DEFINE DP_UD        PIN_G8               // Digital potentiometer up/down control pin assignment 
....................  
.................... // Pins used to control motor driver 
.................... #DEFINE MD_MS1       PIN_F0               // Step resolution select pin 1 assignment 
.................... #DEFINE MD_MS2       PIN_D7               // Step resolution select pin 2 assignment 
.................... #DEFINE MD_SR        PIN_F1               // Active mode (synchronous rectification) input pin assignment 
.................... #DEFINE MD_RESET     PIN_E0               // Reset input pin assignment (active low) 
.................... #DEFINE MD_STEP      PIN_E1               // Step input pin assignment 
.................... #DEFINE MD_ENABLE    PIN_E2               // Enable input pin assignment (active low) 
.................... #DEFINE MD_SLEEP     PIN_E3               // Sleep input pin assignment (active low) 
.................... #DEFINE MD_DIR       PIN_E4               // Direction input pin assignment 
.................... #DEFINE MD_SW        PIN_D11              // Homing switch input pin assignment 
....................  
.................... // Pins used to control FRAM 
.................... #DEFINE FR_CS        PIN_G7               // FRAM chip select pin assignment (active low) 
.................... #DEFINE FR_WP        PIN_G6               // FRAM write protection pin assignment (active low) 
.................... #DEFINE FR_SCK       PIN_E5               // FRAM serial clock pin assignment 
.................... #DEFINE FR_SI        PIN_E6               // FRAM serial input pin assignment 
.................... #DEFINE FR_SO        PIN_E7               // FRAM serial output pin assignment 
....................  
.................... // Speed ramp states 
.................... #DEFINE HOME         0 
.................... #DEFINE ACCEL        1 
.................... #DEFINE DECEL        2 
.................... #DEFINE RUN          3 
.................... #DEFINE POS          4 
....................  
.................... // PWM module operating modes 
.................... #DEFINE FREE         0 
.................... #DEFINE SINGLE       1 
....................  
.................... int1           debug_mode_dp     = 0;              // Debug state of digital potentiometer 
.................... int1           debug_mode_pp     = 0;              // Debug state of parallel port communication 
.................... int1           debug_mode_fr     = 0;              // Debug state of FRAM 
.................... int1           debug_mode_md     = 0;              // Debug state of motor driver 
.................... int1           debug_mode_pwm    = 0;              // Debug state of motor control PWM module 
.................... int1           debug_mode_qei    = 0;              // Debug state of quadrature encoder 
....................  
.................... unsigned int   dp_tap_limit      = 32;             // Digital potentiometer maximum tap level 
.................... unsigned int   dp_voltage_limit  = 1023;           // Digital potentiometer maximum voltage level 
....................  
.................... unsigned int   mt_voltage_limit  = 803;            // Motor torque control voltage is limited to 4V (which is defined in driver specs) 
.................... unsigned int   mt_percent_trip   = 70;             // Motor torque percent while system is moving 
.................... unsigned int   mt_percent_rest   = 28;             // Motor torque percent while system is stationary 
....................  
.................... unsigned int   md_conv_const     = 0;              // Constant used to convert encoder count to motor step 
.................... unsigned int   md_move_range     = 400;            // Movement range of the device 
.................... unsigned int   md_home_pos       = 45;             // Sets the number of encoder counts between the home position and homing switch position 
.................... unsigned int   md_end_pos        = 1000;           // Sets the number of encoder counts between the home position and the end of movement range 
.................... unsigned int   md_end_offset     = 50;             // Offset of the maximum count number from the end position 
.................... unsigned int   md_home_offset    = 100;            // Offset of the maximum count number from the home position 
.................... unsigned int   md_min_distance   = 70;             // Minimum distance between symmetricaly moving lasers 
.................... unsigned int   md_target_count   = 0;              // Target position count 
....................  
.................... unsigned int   md_accel          = 3000;           // Acceleration of the motor (0.01 mm/s2) 
.................... unsigned int   md_decel          = 3000;           // Deceleration of the motor (0.01 mm/s2) 
....................  
.................... unsigned int   md_min_delay      = 100;            // Minimum time delay (max speed) 
.................... unsigned char  md_run_state      = 0;              // What part of the speed ramp we are in. 
.................... unsigned int   md_decel_lim      = 0;              // What step_pos to start decelaration 
.................... unsigned int   md_accel_lim      = 0;              // What step_pos to end accelaration 
.................... unsigned int   md_decel_count    = 0;              // Counter used when decelerateing to calculate step_delay. 
.................... unsigned int   md_pos_iter       = 0;              // Number of iterations performed during positioning 
.................... int            md_error          = 0;              // Positioning error 
.................... unsigned int   md_backlash       = 0;              // Backlash of the positioning system 
....................  
.................... unsigned int   md_cc_step        = 0;              // Motor count used in conversion constant conversion 
.................... unsigned int   md_cc_count       = 0;              // Encoder count used in conversion constant conversion 
....................  
.................... unsigned int   fr_serial_no      = 0;              // External adress of product serial no 
.................... unsigned int   fr_move_range     = 13;             // External adress of movement range 
.................... unsigned int   fr_home_pos       = 15;             // External adress of home position 
.................... unsigned int   fr_end_pos        = 17;             // External addres of end position 
.................... unsigned int   fr_conv_const     = 19;             // External adress of conversion constant 
.................... unsigned int   fr_backlash       = 21;             // External adress of backlash compensation 
.................... unsigned int   fr_comm_type      = 23;             // External adress of communication type 
.................... unsigned int   fr_last_pos       = 24;             // External adress of last position 
.................... unsigned int   fr_pos_table      = 26;             // External adress of position table 
....................  
.................... unsigned int   pp_str_check      = 10;             // Parallel port strobe signal filter iteration number 
.................... unsigned int   pp_str_delay      = 1;              // Parallel port strobe signal filter pause time (ms) 
.................... unsigned int   pp_ack_delay      = 100;            // Parallel port acknowledge signal pause time (ms) 
.................... unsigned int   pp_rdy_delay      = 100;            // Parallel port ready signal pause time (ms) 
....................  
.................... int1           reg_comm_type     = 0;              // Communication type register 
.................... int1           reg_pp_stop       = 0;              // Parallel port emergency stop signal register 
.................... int1           reg_pp_strobe     = 0;              // Parallel port strobe signal active register 
.................... int1           reg_md_home       = 0;              // Homing action register 
.................... int1           reg_md_home_return= 0;              // Home correction return register 
.................... int1           reg_rs232_message = 0;              // RS232 message flag 
.................... int1           reg_md_cc_sample  = 0;              // Special case register for conversion constant calculation 
....................  
.................... #DEFINE ACC_15 
....................  
.................... #IFDEF ACC_10 
.................... unsigned int   md_max_acc_lim    = 116;             // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... unsigned int const delays[116]={2449,1015,779,656,578,523,481,447,420,397,378,361,346,333,322,311,302,293,285,277,271,264,258,253,247,243,238,234,229,226,222,218,215,212,209,206,203,200,197,195,192,190,188,186,184,182,180, 
.................... 178,176,174,172,171,169,167,166,164,163,162,160,159,157,156,155,154,152,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115, 
.................... 114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_15 
.................... unsigned int   md_max_acc_lim    = 88;             // Number of steps before we hit max speed. acc=15000 dec=15000 
.................... unsigned int const delays[88]={2000,828,636,536,472,427,393,365,343,325,309,295,283,272,263,254,246,239,233,226,221,216,211,206,202,198,194,191,187,184,181,178,175,173,170,168,166,163,161,159,157,155,153,152,150,148,147, 
.................... 145,144,142,141,139,138,137,135,134,133,132,131,130,129,128,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_20 
.................... unsigned int   md_max_acc_lim    = 71;             // Number of steps before we hit max speed. acc=20000 dec=20000  
.................... unsigned int const delays[71]={1732,717,551,464,409,370,340,316,297,281,267,255,245,236,227,220,213,207,201,196,191,187,183,179,175,172,168,165,162,159,157,154,152,150,147,145,143,141,140,138,136,134,133,131,130,128,127, 
.................... 126,124,123,122,121,120,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_25 
.................... unsigned int   md_max_acc_lim    = 59;             // Number of steps before we hit max speed. acc=25000 dec=25000  
.................... unsigned int const delays[59]={1549,642,492,415,366,331,304,283,266,251,239,228,219,211,203,197,191,185,180,175,171,167,163,160,157,153,150,148,145,143,140,138,136,134,132,130,128,126,125,123,122,120,119,117,116,115,114, 
.................... 112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_30 
.................... unsigned int   md_max_acc_lim    = 50;             // Number of steps before we hit max speed. acc=30000 dec=30000  
.................... unsigned int const delays[50]={1414,586,449,379,334,302,278,258,243,229,218,209,200,192,186,180,174,169,164,160,156,153,149,146,143,140,137,135,132,130,128,126,124,122,120,119,117,115,114,113,111,110,108,107,106,105,104, 
.................... 103,102,101}; 
.................... #ENDIF 
....................  
.................... void move_pos(unsigned int16 position); 
.................... unsigned int16 qei_get_count(); 
....................  
.................... // Initializes digital potentiometer 
.................... void dp_init()  
.................... { 
....................    output_high(DP_CS);                       // Chip select is active low so keep it disabled 
*
01430:  BCLR.B  2E5.1
01432:  BSET.B  2E9.1
....................    output_low(DP_UD);                        // Up/down control pin can be in any state 
01434:  BCLR.B  2E5.0
01436:  BCLR.B  2E9.0
.................... } 
01438:  RETURN  
.................... // Increases digital potentiometer by given tap 
.................... void dp_up(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
*
01570:  MOV     8B2,W0
01572:  MOV     998,W4
01574:  CP      W4,W0
01576:  BRA     LEU,157C
....................       tap=dp_tap_limit; 
01578:  PUSH    8B2
0157A:  POP     998
....................        
....................    output_high(DP_UD);        // Set U/D to high before activating digital potentiometer 
0157C:  BCLR.B  2E5.0
0157E:  BSET.B  2E9.0
....................    delay_us(1); 
01580:  REPEAT  #1C
01582:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
01584:  BCLR.B  2E5.1
01586:  BCLR.B  2E9.1
....................    delay_us(1); 
01588:  REPEAT  #1C
0158A:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
0158C:  CLR     99A
0158E:  MOV     99A,W0
01590:  MOV     998,W4
01592:  CP      W4,W0
01594:  BRA     LEU,15B4
....................    { 
....................       output_low(DP_UD);      // Low part of pulse 
01596:  BCLR.B  2E5.0
01598:  BCLR.B  2E9.0
....................       delay_us(1); 
0159A:  REPEAT  #1C
0159C:  NOP     
....................       output_high(DP_UD);     // High part of pulse 
0159E:  BCLR.B  2E5.0
015A0:  BSET.B  2E9.0
....................       delay_us(1); 
015A2:  REPEAT  #1C
015A4:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
015A6:  BCLR.B  2E5.0
015A8:  BCLR.B  2E9.0
....................       delay_us(1);  
015AA:  REPEAT  #1C
015AC:  NOP     
....................    } 
015AE:  INC     099A
015B0:  GOTO    158E
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer   
015B4:  BCLR.B  2E5.1
015B6:  BSET.B  2E9.1
.................... } 
015B8:  RETURN  
.................... // Decreases digital potentiometer by given tap 
.................... void dp_down(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
015BA:  MOV     8B2,W0
015BC:  MOV     998,W4
015BE:  CP      W4,W0
015C0:  BRA     LEU,15C6
....................       tap=dp_tap_limit; 
015C2:  PUSH    8B2
015C4:  POP     998
....................        
....................    output_low(DP_UD);         // Set U/D to low before activating digital potentiometer 
015C6:  BCLR.B  2E5.0
015C8:  BCLR.B  2E9.0
....................    delay_us(1); 
015CA:  REPEAT  #1C
015CC:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
015CE:  BCLR.B  2E5.1
015D0:  BCLR.B  2E9.1
....................    delay_us(1);             
015D2:  REPEAT  #1C
015D4:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
015D6:  CLR     99A
015D8:  MOV     99A,W0
015DA:  MOV     998,W4
015DC:  CP      W4,W0
015DE:  BRA     LEU,15F6
....................    { 
....................       output_high(DP_UD);     // High part of pulse 
015E0:  BCLR.B  2E5.0
015E2:  BSET.B  2E9.0
....................       delay_us(1); 
015E4:  REPEAT  #1C
015E6:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
015E8:  BCLR.B  2E5.0
015EA:  BCLR.B  2E9.0
....................       delay_us(1);   
015EC:  REPEAT  #1C
015EE:  NOP     
....................    } 
015F0:  INC     099A
015F2:  GOTO    15D8
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer 
015F6:  BCLR.B  2E5.1
015F8:  BSET.B  2E9.1
.................... } 
015FA:  RETURN  
.................... // Sets digital potentiometer to given voltage 
.................... void dp_set(unsigned int voltage) 
.................... { 
015FC:  MOV     W5,[W15++]
015FE:  MOV     #3,W4
01600:  MOV     W4,980
01602:  CLR     982
01604:  MOV     #F,W4
01606:  MOV     W4,984
01608:  MOV     97E,W4
0160A:  MOV     8B2,W3
0160C:  MUL.UU  W4,W3,W0
0160E:  MOV     W0,W5
01610:  MOV     W5,W4
01612:  MOV     8B4,W3
01614:  REPEAT  #11
01616:  DIV.U   W4,W3
01618:  MOV     W0,986
0161A:  BCLR.B  2A0.0
0161C:  BSET.B  2A0.1
0161E:  BTSS.B  2A0.0
01620:  BRA     161E
01622:  PUSH    280
01624:  POP     988
01626:  MOV     97E,W4
01628:  MOV     988,W3
0162A:  SUB     W4,W3,W5
0162C:  MOV     W5,W0
0162E:  MOV     W5,98A
....................    unsigned int iteration_limit=3;                                   // Maximum number of iterations to be performed to set voltage 
....................    unsigned int iteration=0;                                         // Number of iterations performed to set voltage 
....................    unsigned int region=15;                                           // We want the voltage to be inside this region (+/-)  
....................    unsigned int tap_desired=voltage*dp_tap_limit/dp_voltage_limit;   // Find the desired potentiometer tap 
....................    unsigned int voltage_current=read_adc();                          // Read the current voltage 
....................    unsigned int voltage_diff=abs(voltage-voltage_current);           // Find the difference between the current and desired voltage  
....................    unsigned int tap_current;                                         // Current tap value 
....................     
....................    if(debug_mode_dp) 
01630:  BTSS.B  8B0.0
01632:  BRA     16F8
....................    { 
....................       fprintf(RS232,"\n\r\tVoltage Desired: %u",voltage); 
01634:  MOV     #0,W1
01636:  MOV     W1,W0
01638:  CLR.B   1
0163A:  CALL    196
0163E:  INC     W1,W1
01640:  BTSC.B  219.1
01642:  BRA     1640
01644:  MOV     W0,21A
01646:  MOV     #13,W0
01648:  CPSGT   W1,W0
0164A:  BRA     1636
0164C:  MOV     97E,W0
0164E:  MOV     #0,W4
01650:  CALL    143A
....................       fprintf(RS232,"\n\r\tTap Desired: %u",dp_tap_limit*voltage/dp_voltage_limit); 
01654:  MOV     8B2,W4
01656:  MOV     97E,W3
01658:  MUL.UU  W4,W3,W0
0165A:  MOV     W0,W5
0165C:  MOV     W5,W4
0165E:  MOV     8B4,W3
01660:  REPEAT  #11
01662:  DIV.U   W4,W3
01664:  MOV     W0,W5
01666:  MOV     #0,W1
01668:  MOV     W1,W0
0166A:  CLR.B   1
0166C:  CALL    1BA
01670:  INC     W1,W1
01672:  BTSC.B  219.1
01674:  BRA     1672
01676:  MOV     W0,21A
01678:  MOV     #F,W0
0167A:  CPSGT   W1,W0
0167C:  BRA     1668
0167E:  MOV     W5,W0
01680:  MOV     #0,W4
01682:  CALL    143A
....................       fprintf(RS232,"\n\r\tVoltage Current: %u",voltage_current); 
01686:  MOV     #0,W1
01688:  MOV     W1,W0
0168A:  CLR.B   1
0168C:  CALL    1DA
01690:  INC     W1,W1
01692:  BTSC.B  219.1
01694:  BRA     1692
01696:  MOV     W0,21A
01698:  MOV     #13,W0
0169A:  CPSGT   W1,W0
0169C:  BRA     1688
0169E:  MOV     988,W0
016A0:  MOV     #0,W4
016A2:  CALL    143A
....................       fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
016A6:  MOV     8B2,W4
016A8:  MOV     988,W3
016AA:  MUL.UU  W4,W3,W0
016AC:  MOV     W0,W5
016AE:  MOV     W5,W4
016B0:  MOV     8B4,W3
016B2:  REPEAT  #11
016B4:  DIV.U   W4,W3
016B6:  MOV     W0,W5
016B8:  MOV     #0,W1
016BA:  MOV     W1,W0
016BC:  CLR.B   1
016BE:  CALL    1FE
016C2:  INC     W1,W1
016C4:  BTSC.B  219.1
016C6:  BRA     16C4
016C8:  MOV     W0,21A
016CA:  MOV     #F,W0
016CC:  CPSGT   W1,W0
016CE:  BRA     16BA
016D0:  MOV     W5,W0
016D2:  MOV     #0,W4
016D4:  CALL    143A
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",voltage_diff); 
016D8:  MOV     #0,W1
016DA:  MOV     W1,W0
016DC:  CLR.B   1
016DE:  CALL    21E
016E2:  INC     W1,W1
016E4:  BTSC.B  219.1
016E6:  BRA     16E4
016E8:  MOV     W0,21A
016EA:  MOV     #16,W0
016EC:  CPSGT   W1,W0
016EE:  BRA     16DA
016F0:  MOV     98A,W0
016F2:  MOV     #0,W4
016F4:  CALL    143A
....................    } 
....................     
....................    while(voltage_diff>region)                                        // Try until voltage is found 
....................    {                                                                 // or iteration limit is reached  
016F8:  MOV     984,W0
016FA:  MOV     98A,W4
016FC:  CP      W4,W0
016FE:  BRA     LEU,1864
....................       if(iteration <iteration_limit)                      
01700:  MOV     982,W0
01702:  MOV     980,W4
01704:  CP      W4,W0
01706:  BRA     LEU,1842
....................       { 
....................          iteration++;                                                // Set iteration number 
01708:  INC     0982
....................          tap_current=dp_tap_limit*voltage_current/dp_voltage_limit;  // Convert new voltage to tap 
0170A:  MOV     8B2,W4
0170C:  MOV     988,W3
0170E:  MUL.UU  W4,W3,W0
01710:  MOV     W0,W5
01712:  MOV     W5,W4
01714:  MOV     8B4,W3
01716:  REPEAT  #11
01718:  DIV.U   W4,W3
0171A:  MOV     W0,98C
....................  
....................          if(tap_desired>tap_current)                                 // Set the digital potentiometer to desired tap 
0171C:  MOV     98C,W0
0171E:  MOV     986,W4
01720:  CP      W4,W0
01722:  BRA     LEU,1734
....................          { 
....................             dp_up(tap_desired-tap_current); 
01724:  MOV     986,W4
01726:  MOV     98C,W3
01728:  SUB     W4,W3,W5
0172A:  MOV     W5,998
0172C:  CALL    1570
....................          } 
....................          else if(tap_desired<tap_current) 
01730:  GOTO    1768
01734:  MOV     986,W0
01736:  MOV     98C,W4
01738:  CP      W4,W0
0173A:  BRA     LEU,174C
....................          { 
....................             dp_down(tap_current-tap_desired); 
0173C:  MOV     98C,W4
0173E:  MOV     986,W3
01740:  SUB     W4,W3,W5
01742:  MOV     W5,998
01744:  CALL    15BA
....................          } 
....................          else                                                        // If tap level is same as the previous one and it still outside the region 
01748:  GOTO    1768
....................          {                                                           // then go one step up or down according to desired voltage 
....................             if(voltage>voltage_current) 
0174C:  MOV     988,W0
0174E:  MOV     97E,W4
01750:  CP      W4,W0
01752:  BRA     LEU,1760
....................                dp_up(1); 
01754:  MOV     #1,W4
01756:  MOV     W4,998
01758:  CALL    1570
....................             else 
0175C:  GOTO    1768
....................                dp_down(1); 
01760:  MOV     #1,W4
01762:  MOV     W4,998
01764:  CALL    15BA
....................          } 
....................           
....................          delay_ms(2); 
01768:  REPEAT  #2A5E
0176A:  NOP     
0176C:  REPEAT  #3FFF
0176E:  NOP     
01770:  REPEAT  #3FFF
01772:  NOP     
01774:  REPEAT  #3FFF
01776:  NOP     
....................              
....................          voltage_current=read_adc();                                 // Read the new voltage 
01778:  BCLR.B  2A0.0
0177A:  BSET.B  2A0.1
0177C:  BTSS.B  2A0.0
0177E:  BRA     177C
01780:  PUSH    280
01782:  POP     988
....................           
....................          if(voltage>voltage_current)                                 // Find the difference between the new and desired voltages for next iteration check 
01784:  MOV     988,W0
01786:  MOV     97E,W4
01788:  CP      W4,W0
0178A:  BRA     LEU,1798
....................             voltage_diff=voltage - voltage_current; 
0178C:  MOV     97E,W4
0178E:  MOV     988,W3
01790:  SUB     W4,W3,W0
01792:  MOV     W0,98A
....................          else 
01794:  GOTO    17A0
....................             voltage_diff=voltage_current - voltage; 
01798:  MOV     988,W4
0179A:  MOV     97E,W3
0179C:  SUB     W4,W3,W0
0179E:  MOV     W0,98A
....................           
....................          if(debug_mode_dp) 
017A0:  BTSS.B  8B0.0
017A2:  BRA     183E
....................          { 
....................             fprintf(RS232,"\n\rITERATION: %u",iteration); 
017A4:  MOV     #0,W1
017A6:  MOV     W1,W0
017A8:  CLR.B   1
017AA:  CALL    244
017AE:  INC     W1,W1
017B0:  BTSC.B  219.1
017B2:  BRA     17B0
017B4:  MOV     W0,21A
017B6:  MOV     #C,W0
017B8:  CPSGT   W1,W0
017BA:  BRA     17A6
017BC:  MOV     982,W0
017BE:  MOV     #0,W4
017C0:  CALL    143A
....................             fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
017C4:  MOV     8B2,W4
017C6:  MOV     988,W3
017C8:  MUL.UU  W4,W3,W0
017CA:  MOV     W0,W5
017CC:  MOV     W5,W4
017CE:  MOV     8B4,W3
017D0:  REPEAT  #11
017D2:  DIV.U   W4,W3
017D4:  MOV     W0,W5
017D6:  MOV     #0,W1
017D8:  MOV     W1,W0
017DA:  CLR.B   1
017DC:  CALL    1FE
017E0:  INC     W1,W1
017E2:  BTSC.B  219.1
017E4:  BRA     17E2
017E6:  MOV     W0,21A
017E8:  MOV     #F,W0
017EA:  CPSGT   W1,W0
017EC:  BRA     17D8
017EE:  MOV     W5,W0
017F0:  MOV     #0,W4
017F2:  CALL    143A
....................             fprintf(RS232,"\n\r\tVoltage Current : %u",voltage_current); 
017F6:  MOV     #0,W1
017F8:  MOV     W1,W0
017FA:  CLR.B   1
017FC:  CALL    260
01800:  INC     W1,W1
01802:  BTSC.B  219.1
01804:  BRA     1802
01806:  MOV     W0,21A
01808:  MOV     #14,W0
0180A:  CPSGT   W1,W0
0180C:  BRA     17F8
0180E:  MOV     988,W0
01810:  MOV     #0,W4
01812:  CALL    143A
....................             fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-voltage_current)); 
01816:  MOV     97E,W4
01818:  MOV     988,W3
0181A:  SUB     W4,W3,W5
0181C:  MOV     W5,W0
0181E:  MOV     #0,W1
01820:  MOV     W1,W0
01822:  CLR.B   1
01824:  CALL    21E
01828:  INC     W1,W1
0182A:  BTSC.B  219.1
0182C:  BRA     182A
0182E:  MOV     W0,21A
01830:  MOV     #16,W0
01832:  CPSGT   W1,W0
01834:  BRA     1820
01836:  MOV     W5,W0
01838:  MOV     #0,W4
0183A:  CALL    143A
....................          } 
....................       } 
....................       else 
0183E:  GOTO    1860
....................       { 
....................          if(debug_mode_dp) 
01842:  BTSS.B  8B0.0
01844:  BRA     185E
....................             fprintf(RS232,"\n\rIteration limit reached"); 
01846:  MOV     #0,W1
01848:  MOV     W1,W0
0184A:  CLR.B   1
0184C:  CALL    284
01850:  INC     W1,W1
01852:  BTSC.B  219.1
01854:  BRA     1852
01856:  MOV     W0,21A
01858:  MOV     #18,W0
0185A:  CPSGT   W1,W0
0185C:  BRA     1848
....................          return; 
0185E:  BRA     190C
....................       } 
....................    } 
01860:  GOTO    16F8
....................     
....................    if(debug_mode_dp) 
01864:  BTSS.B  8B0.0
01866:  BRA     190C
....................    { 
....................       fprintf(RS232,"\n\rFOUND!"); 
01868:  MOV     #0,W1
0186A:  MOV     W1,W0
0186C:  CLR.B   1
0186E:  CALL    2AA
01872:  INC     W1,W1
01874:  BTSC.B  219.1
01876:  BRA     1874
01878:  MOV     W0,21A
0187A:  MOV     #7,W0
0187C:  CPSGT   W1,W0
0187E:  BRA     186A
....................       fprintf(RS232,"\n\r\tTap Current : %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01880:  MOV     8B2,W4
01882:  MOV     988,W3
01884:  MUL.UU  W4,W3,W0
01886:  MOV     W0,W5
01888:  MOV     W5,W4
0188A:  MOV     8B4,W3
0188C:  REPEAT  #11
0188E:  DIV.U   W4,W3
01890:  MOV     W0,W5
01892:  MOV     #0,W1
01894:  MOV     W1,W0
01896:  CLR.B   1
01898:  CALL    2C0
0189C:  INC     W1,W1
0189E:  BTSC.B  219.1
018A0:  BRA     189E
018A2:  MOV     W0,21A
018A4:  MOV     #10,W0
018A6:  CPSGT   W1,W0
018A8:  BRA     1894
018AA:  MOV     W5,W0
018AC:  MOV     #0,W4
018AE:  CALL    143A
....................       fprintf(RS232,"\n\r\tVoltage Current : %u",read_adc()); 
018B2:  BCLR.B  2A0.0
018B4:  BSET.B  2A0.1
018B6:  BTSS.B  2A0.0
018B8:  BRA     18B6
018BA:  MOV     280,W5
018BC:  MOV     #0,W1
018BE:  MOV     W1,W0
018C0:  CLR.B   1
018C2:  CALL    260
018C6:  INC     W1,W1
018C8:  BTSC.B  219.1
018CA:  BRA     18C8
018CC:  MOV     W0,21A
018CE:  MOV     #14,W0
018D0:  CPSGT   W1,W0
018D2:  BRA     18BE
018D4:  MOV     W5,W0
018D6:  MOV     #0,W4
018D8:  CALL    143A
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-read_adc())); 
018DC:  BCLR.B  2A0.0
018DE:  BSET.B  2A0.1
018E0:  BTSS.B  2A0.0
018E2:  BRA     18E0
018E4:  MOV     280,W0
018E6:  MOV     97E,W4
018E8:  SUB     W4,W0,W5
018EA:  MOV     W5,W0
018EC:  MOV     #0,W1
018EE:  MOV     W1,W0
018F0:  CLR.B   1
018F2:  CALL    21E
018F6:  INC     W1,W1
018F8:  BTSC.B  219.1
018FA:  BRA     18F8
018FC:  MOV     W0,21A
018FE:  MOV     #16,W0
01900:  CPSGT   W1,W0
01902:  BRA     18EE
01904:  MOV     W5,W0
01906:  MOV     #0,W4
01908:  CALL    143A
....................    } 
.................... } 
0190C:  MOV     [--W15],W5
0190E:  RETURN  
....................  
.................... // Returns current motor torque in percent (%0-100) 
.................... unsigned int md_mt_get() 
.................... { 
01910:  MOV     W5,[W15++]
01912:  MOV     W6,[W15++]
01914:  BCLR.B  2A0.0
01916:  BSET.B  2A0.1
01918:  BTSS.B  2A0.0
0191A:  BRA     1918
0191C:  PUSH    280
0191E:  POP     97E
01920:  MOV     97E,W0
01922:  MOV     #0,W1
01924:  MOV     W0,W2
01926:  MOV     W1,W3
01928:  MOV     #64,W0
0192A:  MOV     #0,W1
0192C:  CALL    14EC
01930:  MOV     W0,W5
01932:  MOV     W1,W6
01934:  BCLR.B  43.0
01936:  MOV     W5,W0
01938:  MOV     W6,W1
0193A:  MOV     8B6,W2
0193C:  MOV     #0,W3
0193E:  CALL    151C
01942:  MOV     W0,980
....................    unsigned int analog=read_adc();                                         // Read the voltage level 
....................    unsigned int percent=100*(unsigned int32)analog/mt_voltage_limit;       // Convert voltage to percent 
....................     
....................    if(debug_mode_dp) 
01944:  BTSS.B  8B0.0
01946:  BRA     1978
....................       fprintf(RS232,"\n\r\tPercent Current: %u\n\r",percent); 
01948:  MOV     #0,W1
0194A:  MOV     W1,W0
0194C:  CLR.B   1
0194E:  CALL    2E0
01952:  INC     W1,W1
01954:  BTSC.B  219.1
01956:  BRA     1954
01958:  MOV     W0,21A
0195A:  MOV     #13,W0
0195C:  CPSGT   W1,W0
0195E:  BRA     194A
01960:  MOV     980,W0
01962:  MOV     #0,W4
01964:  CALL    143A
01968:  BTSC.B  219.1
0196A:  BRA     1968
0196C:  MOV     #A,W4
0196E:  MOV     W4,21A
01970:  BTSC.B  219.1
01972:  BRA     1970
01974:  MOV     #D,W4
01976:  MOV     W4,21A
....................        
....................    return percent;   
01978:  PUSH    980
0197A:  POP     0
.................... } 
0197C:  MOV     [--W15],W6
0197E:  MOV     [--W15],W5
01980:  RETURN  
.................... // Sets motor torque approximate to desired percent and returns the actual percent (%0-100) 
.................... unsigned int md_mt_set(unsigned int percent) 
.................... { 
01982:  MOV     W5,[W15++]
01984:  MOV     W6,[W15++]
....................    // percent must be between 0 and 100 
....................    if(percent>100) 
01986:  MOV     978,W4
01988:  MOV     #64,W3
0198A:  CP      W3,W4
0198C:  BRA     C,1992
....................       percent=100; 
0198E:  MOV     #64,W4
01990:  MOV     W4,978
....................        
....................    if(debug_mode_dp) 
01992:  BTSS.B  8B0.0
01994:  BRA     19B6
....................    { 
....................       fprintf(RS232,"\n\r\tPercent Desired:"); 
01996:  MOV     #0,W1
01998:  MOV     W1,W0
0199A:  CLR.B   1
0199C:  CALL    306
019A0:  INC     W1,W1
019A2:  BTSC.B  219.1
019A4:  BRA     19A2
019A6:  MOV     W0,21A
019A8:  MOV     #12,W0
019AA:  CPSGT   W1,W0
019AC:  BRA     1998
....................       fprintf(RS232,"%u",percent); 
019AE:  MOV     978,W0
019B0:  MOV     #0,W4
019B2:  CALL    143A
....................    } 
....................     
....................    unsigned int voltage=(unsigned int32)percent*mt_voltage_limit/100;      // convert percent to voltage 
019B6:  MOV     978,W5
019B8:  MOV     #0,W6
019BA:  MOV     W5,W0
019BC:  MOV     W6,W1
019BE:  MOV     8B6,W2
019C0:  MOV     #0,W3
019C2:  CALL    14EC
019C6:  MOV     W0,W5
019C8:  MOV     W1,W6
019CA:  BCLR.B  43.0
019CC:  MOV     W5,W0
019CE:  MOV     W6,W1
019D0:  MOV     #64,W2
019D2:  MOV     #0,W3
019D4:  CALL    151C
019D8:  MOV     W0,97A
....................    dp_set(voltage);                                      // set digital potentiometer 
019DA:  PUSH    97A
019DC:  POP     97E
019DE:  CALL    15FC
....................     
....................    return md_mt_get(); 
019E2:  CALL    1910
019E6:  MOV     W0,0
.................... } 
019E8:  MOV     [--W15],W6
019EA:  MOV     [--W15],W5
019EC:  RETURN  
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_mt_set(mt_percent_rest);               // Set motor torque before initialization of motor driver 
019EE:  PUSH    8BA
019F0:  POP     978
019F2:  CALL    1982
....................  
....................    output_high(MD_RESET);                    // Reset is active low so keep it disabled 
019F6:  BCLR.B  2D8.0
019F8:  BSET.B  2DC.0
....................    output_high(MD_SLEEP);                    // Sleep is active low so keep it disabled 
019FA:  BCLR.B  2D8.3
019FC:  BSET.B  2DC.3
....................    output_low(MD_SR);                        // Activate synchronous rectification 
019FE:  BCLR.B  2DE.1
01A00:  BCLR.B  2E2.1
....................    output_high(MD_DIR);                      // Direction control pin can be in any state 
01A02:  BCLR.B  2D8.4
01A04:  BSET.B  2DC.4
....................    output_high(MD_MS1);                      // MS1 and MS2 high enables 8x microstepping mode 
01A06:  BCLR.B  2DE.0
01A08:  BSET.B  2E2.0
....................    output_high(MD_MS2); 
01A0A:  BCLR.B  2D2.7
01A0C:  BSET.B  2D6.7
....................    output_low(MD_ENABLE);                    // Enable is active so keep it high 
01A0E:  BCLR.B  2D8.2
01A10:  BCLR.B  2DC.2
....................    output_low(MD_STEP);                      // A low-to-high transition advances the motor one increment so keep step input low 
01A12:  BCLR.B  2D8.1
01A14:  BCLR.B  2DC.1
.................... } 
01A16:  RETURN  
....................  
.................... // Initializes external EEPROM (FRAM) 
.................... void fr_init()  
.................... { 
....................    output_high(FR_CS);     // Chip select is active low when it is high the device enters low-power standby mode so initialy keep it high 
01A18:  BCLR.B  2E4.7
01A1A:  BSET.B  2E8.7
....................    output_low(FR_WP);      // Write protection pin is active low and prevents write operations to the status register so initially keep it low 
01A1C:  BCLR.B  2E4.6
01A1E:  BCLR.B  2E8.6
....................    output_low(FR_SI);      // Serial input pin is driven to high logic state during communication so initially keep it low 
01A20:  BCLR.B  2D8.6
01A22:  BCLR.B  2DC.6
....................    output_low(FR_SCK);     // Inputs are latched on the rising edge and outputs occur on the falling edge so initially serial clock can be in any state  
01A24:  BCLR.B  2D8.5
01A26:  BCLR.B  2DC.5
.................... } 
01A28:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... void fr_write_byte(unsigned int16 address, unsigned int8 data)  
.................... { 
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    unsigned int8 wren; 
....................    unsigned int8 write; 
....................    unsigned int8 wrdi; 
....................     
....................    //     76543210     
....................    wren=0b00000110; 
*
02044:  MOV.B   #6,W0L
02046:  MOV.B   W0L,984
....................    //      76543210  
....................    write=0b00000010; 
02048:  MOV.B   #2,W0L
0204A:  MOV.B   W0L,985
....................    //     76543210 
....................    wrdi=0b00000100; 
0204C:  MOV.B   #4,W0L
0204E:  MOV.B   W0L,986
....................     
....................    cmd[0]=data; 
02050:  MOV.B   97E,W0L
02052:  MOV.B   W0L,980
....................    cmd[1]=address; 
02054:  MOV.B   97C,W0L
02056:  MOV.B   W0L,981
....................    cmd[2]=address/256; 
02058:  MOV.B   97D,W0L
0205A:  MOV.B   W0L,982
....................    cmd[3]=write; 
0205C:  MOV.B   985,W0L
0205E:  MOV.B   W0L,983
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    output_low(FR_CS); 
02060:  BCLR.B  2E4.7
02062:  BCLR.B  2E8.7
....................    delay_us(1); 
02064:  REPEAT  #1C
02066:  NOP     
....................    for(i=0; i<8; ++i) 
02068:  CLR.B   97F
0206A:  MOV     97E,W4
0206C:  LSR     W4,#8,W4
0206E:  CP.B    W4L,#8
02070:  BRA     C,20A2
....................    { 
....................       output_bit(FR_SI, shift_left(&wren,1,0)); 
02072:  BCLR.B  42.0
02074:  RLC.B   984
02076:  BRA     C,207C
02078:  BCLR.B  2DC.6
0207A:  BRA     207E
0207C:  BSET.B  2DC.6
0207E:  BCLR.B  2D8.6
....................       delay_us(1); 
02080:  REPEAT  #1C
02082:  NOP     
....................       output_high(FR_SCK); 
02084:  BCLR.B  2D8.5
02086:  BSET.B  2DC.5
....................       delay_us(1); 
02088:  REPEAT  #1C
0208A:  NOP     
....................       output_low(FR_SI); 
0208C:  BCLR.B  2D8.6
0208E:  BCLR.B  2DC.6
....................       delay_us(1); 
02090:  REPEAT  #1C
02092:  NOP     
....................       output_low(FR_SCK); 
02094:  BCLR.B  2D8.5
02096:  BCLR.B  2DC.5
....................       delay_us(1); 
02098:  REPEAT  #1C
0209A:  NOP     
....................    } 
0209C:  INC.B   097F
0209E:  GOTO    206A
....................    delay_us(1); 
020A2:  REPEAT  #1C
020A4:  NOP     
....................    output_high(FR_CS); 
020A6:  BCLR.B  2E4.7
020A8:  BSET.B  2E8.7
....................    delay_us(1); 
020AA:  REPEAT  #1C
020AC:  NOP     
....................     
....................    output_low(FR_CS); 
020AE:  BCLR.B  2E4.7
020B0:  BCLR.B  2E8.7
....................    delay_us(1); 
020B2:  REPEAT  #1C
020B4:  NOP     
....................    for(i=0; i<32; ++i) 
020B6:  CLR.B   97F
020B8:  MOV     97E,W4
020BA:  LSR     W4,#8,W4
020BC:  MOV     #20,W3
020BE:  CP.B    W3L,W4L
020C0:  BRA     LEU,20F4
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,4,0)); 
020C2:  BCLR.B  42.0
020C4:  RLC     980
020C6:  RLC     982
020C8:  BRA     C,20CE
020CA:  BCLR.B  2DC.6
020CC:  BRA     20D0
020CE:  BSET.B  2DC.6
020D0:  BCLR.B  2D8.6
....................       delay_us(1); 
020D2:  REPEAT  #1C
020D4:  NOP     
....................       output_high(FR_SCK); 
020D6:  BCLR.B  2D8.5
020D8:  BSET.B  2DC.5
....................       delay_us(1); 
020DA:  REPEAT  #1C
020DC:  NOP     
....................       output_low(FR_SI); 
020DE:  BCLR.B  2D8.6
020E0:  BCLR.B  2DC.6
....................       delay_us(1); 
020E2:  REPEAT  #1C
020E4:  NOP     
....................       output_low(FR_SCK); 
020E6:  BCLR.B  2D8.5
020E8:  BCLR.B  2DC.5
....................       delay_us(1); 
020EA:  REPEAT  #1C
020EC:  NOP     
....................    } 
020EE:  INC.B   097F
020F0:  GOTO    20B8
....................    delay_us(1); 
020F4:  REPEAT  #1C
020F6:  NOP     
....................    output_high(FR_CS); 
020F8:  BCLR.B  2E4.7
020FA:  BSET.B  2E8.7
....................    delay_us(1); 
020FC:  REPEAT  #1C
020FE:  NOP     
....................     
....................    output_low(FR_CS); 
02100:  BCLR.B  2E4.7
02102:  BCLR.B  2E8.7
....................    delay_us(1); 
02104:  REPEAT  #1C
02106:  NOP     
....................    for(i=0; i<8; ++i) 
02108:  CLR.B   97F
0210A:  MOV     97E,W4
0210C:  LSR     W4,#8,W4
0210E:  CP.B    W4L,#8
02110:  BRA     C,2142
....................    { 
....................       output_bit(FR_SI, shift_left(&wrdi,1,0)); 
02112:  BCLR.B  42.0
02114:  RLC.B   986
02116:  BRA     C,211C
02118:  BCLR.B  2DC.6
0211A:  BRA     211E
0211C:  BSET.B  2DC.6
0211E:  BCLR.B  2D8.6
....................       delay_us(1); 
02120:  REPEAT  #1C
02122:  NOP     
....................       output_high(FR_SCK); 
02124:  BCLR.B  2D8.5
02126:  BSET.B  2DC.5
....................       delay_us(1); 
02128:  REPEAT  #1C
0212A:  NOP     
....................       output_low(FR_SI); 
0212C:  BCLR.B  2D8.6
0212E:  BCLR.B  2DC.6
....................       delay_us(1); 
02130:  REPEAT  #1C
02132:  NOP     
....................       output_low(FR_SCK); 
02134:  BCLR.B  2D8.5
02136:  BCLR.B  2DC.5
....................       delay_us(1); 
02138:  REPEAT  #1C
0213A:  NOP     
....................    } 
0213C:  INC.B   097F
0213E:  GOTO    210A
....................    delay_us(1); 
02142:  REPEAT  #1C
02144:  NOP     
....................    output_high(FR_CS); 
02146:  BCLR.B  2E4.7
02148:  BSET.B  2E8.7
....................    delay_us(1); 
0214A:  REPEAT  #1C
0214C:  NOP     
.................... } 
0214E:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... unsigned int8 fr_read_byte(unsigned int16 address)  
.................... { 
....................    unsigned int8 cmd[3]; 
....................    unsigned int8 i,data; 
....................    unsigned int8 read; 
....................     
....................    //     76543210  
....................    read=0b00000011; 
*
01A2A:  MOV.B   #3,W0L
01A2C:  MOV.B   W0L,987
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Read on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    cmd[0]=address; 
01A2E:  MOV.B   980,W0L
01A30:  MOV.B   W0L,982
....................    cmd[1]=address/256; 
01A32:  MOV.B   981,W0L
01A34:  MOV.B   W0L,983
....................    cmd[2]=read; 
01A36:  MOV.B   987,W0L
01A38:  MOV.B   W0L,984
....................  
....................    output_low(FR_CS); 
01A3A:  BCLR.B  2E4.7
01A3C:  BCLR.B  2E8.7
....................    delay_us(1); 
01A3E:  REPEAT  #1C
01A40:  NOP     
....................    for(i=0; i<24; ++i) 
01A42:  CLR.B   985
01A44:  MOV     984,W4
01A46:  LSR     W4,#8,W4
01A48:  CP.B    W4L,#18
01A4A:  BRA     C,1A7E
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,3,0)); 
01A4C:  BCLR.B  42.0
01A4E:  RLC     982
01A50:  RLC.B   984
01A52:  BRA     C,1A58
01A54:  BCLR.B  2DC.6
01A56:  BRA     1A5A
01A58:  BSET.B  2DC.6
01A5A:  BCLR.B  2D8.6
....................       delay_us(1); 
01A5C:  REPEAT  #1C
01A5E:  NOP     
....................       output_high(FR_SCK); 
01A60:  BCLR.B  2D8.5
01A62:  BSET.B  2DC.5
....................       delay_us(1); 
01A64:  REPEAT  #1C
01A66:  NOP     
....................       output_low(FR_SI); 
01A68:  BCLR.B  2D8.6
01A6A:  BCLR.B  2DC.6
....................       delay_us(1); 
01A6C:  REPEAT  #1C
01A6E:  NOP     
....................       output_low(FR_SCK); 
01A70:  BCLR.B  2D8.5
01A72:  BCLR.B  2DC.5
....................       delay_us(1); 
01A74:  REPEAT  #1C
01A76:  NOP     
....................    } 
01A78:  INC.B   0985
01A7A:  GOTO    1A44
....................    for(i=0; i<8; ++i) 
01A7E:  CLR.B   985
01A80:  MOV     984,W4
01A82:  LSR     W4,#8,W4
01A84:  CP.B    W4L,#8
01A86:  BRA     C,1AB4
....................    { 
....................       delay_us(1); 
01A88:  REPEAT  #1C
01A8A:  NOP     
....................       shift_left(&data,1,input(FR_SO)); 
01A8C:  BSET.B  2D8.7
01A8E:  BTSC.B  2DA.7
01A90:  BRA     1A96
01A92:  BCLR.B  42.0
01A94:  BRA     1A98
01A96:  BSET.B  42.0
01A98:  RLC.B   986
....................       output_high(FR_SCK); 
01A9A:  BCLR.B  2D8.5
01A9C:  BSET.B  2DC.5
....................       delay_us(1); 
01A9E:  REPEAT  #1C
01AA0:  NOP     
....................       delay_us(1); 
01AA2:  REPEAT  #1C
01AA4:  NOP     
....................       output_low(FR_SCK); 
01AA6:  BCLR.B  2D8.5
01AA8:  BCLR.B  2DC.5
....................       delay_us(1); 
01AAA:  REPEAT  #1C
01AAC:  NOP     
....................    } 
01AAE:  INC.B   0985
01AB0:  GOTO    1A80
....................    output_high(FR_CS); 
01AB4:  BCLR.B  2E4.7
01AB6:  BSET.B  2E8.7
....................    delay_us(1); 
01AB8:  REPEAT  #1C
01ABA:  NOP     
....................     
....................    return(data); 
01ABC:  MOV.B   986,W0L
01ABE:  MOV.B   W0L,0
.................... } 
01AC0:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... void fr_write(unsigned int16 address,unsigned int16 data) 
.................... { 
*
02150:  MOV     W5,[W15++]
....................    unsigned int8 data_high; 
....................    unsigned int8 data_low; 
....................    data_low=(unsigned int8)data; 
02152:  MOV.B   972,W0L
02154:  MOV.B   W0L,975
....................    data_high=(unsigned int8)(data>>8); 
02156:  CLR.B   1
02158:  MOV.B   973,W0L
0215A:  MOV.B   W0L,974
....................     
....................    fr_write_byte(address,data_low); 
0215C:  MOV.B   975,W0L
0215E:  MOV.B   W0L,97E
02160:  PUSH    970
02162:  POP     97C
02164:  CALL    2044
....................    fr_write_byte(address+1,data_high); 
02168:  MOV     970,W4
0216A:  ADD     W4,#1,W4
0216C:  MOV     W4,W5
0216E:  MOV.B   974,W0L
02170:  MOV.B   W0L,97E
02172:  MOV     W5,97C
02174:  CALL    2044
....................     
....................    return; 
.................... } 
02178:  MOV     [--W15],W5
0217A:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... unsigned int16 fr_read(unsigned int16 address) 
.................... { 
*
01AC2:  MOV     W5,[W15++]
....................    unsigned int16 data_buffer; 
....................    unsigned int16 data_low; 
....................    unsigned int16 data_high; 
....................     
....................    data_low=fr_read_byte(address); 
01AC4:  PUSH    972
01AC6:  POP     980
01AC8:  CALL    1A2A
01ACC:  MOV.B   W0L,976
01ACE:  CLR.B   977
....................    data_high=fr_read_byte(address+1); 
01AD0:  MOV     972,W4
01AD2:  ADD     W4,#1,W4
01AD4:  MOV     W4,W5
01AD6:  MOV     W5,980
01AD8:  CALL    1A2A
01ADC:  MOV.B   W0L,978
01ADE:  CLR.B   979
....................     
....................    data_buffer=(data_high<<8)+data_low; 
01AE0:  MOV.B   978,W0L
01AE2:  MOV.B   W0L,B
01AE4:  CLR.B   W5
01AE6:  MOV     W5,W0
01AE8:  ADD     976,W0
01AEA:  MOV     W0,974
....................     
....................    return data_buffer; 
01AEC:  PUSH    974
01AEE:  POP     0
.................... } 
01AF0:  MOV     [--W15],W5
01AF2:  RETURN  
....................  
.................... // Returns serial number of the device via RS232 
.................... void data_get_serial_no() 
.................... { 
*
03096:  MOV     W5,[W15++]
03098:  MOV     W6,[W15++]
....................    if(!debug_mode_fr)  
0309A:  BTSC.B  8B0.2
0309C:  BRA     30A0
....................       return; 
0309E:  BRA     3108
....................        
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
030A0:  CLR.B   95C
....................     
....................    fprintf(RS232, "Serial No:"); 
030A2:  MOV     #0,W1
030A4:  MOV     W1,W0
030A6:  CLR.B   1
030A8:  CALL    326
030AC:  INC     W1,W1
030AE:  BTSC.B  219.1
030B0:  BRA     30AE
030B2:  MOV     W0,21A
030B4:  MOV     #9,W0
030B6:  CPSGT   W1,W0
030B8:  BRA     30A4
....................    for(i=0; i<13; i++) 
030BA:  CLR.B   95C
030BC:  MOV     95C,W4
030BE:  CP.B    W4L,#D
030C0:  BRA     C,30F8
....................    { 
....................       input[i]=fr_read_byte(fr_serial_no+i); 
030C2:  MOV     95C,W4
030C4:  CLR.B   9
030C6:  MOV     #95E,W3
030C8:  ADD     W4,W3,W5
030CA:  MOV     95C,W4
030CC:  CLR.B   9
030CE:  MOV     8E2,W3
030D0:  ADD     W3,W4,W6
030D2:  MOV     W6,980
030D4:  CALL    1A2A
030D8:  MOV.B   W0L,[W5]
....................       fputc(input[i]+48,RS232); 
030DA:  MOV     95C,W4
030DC:  CLR.B   9
030DE:  MOV     #95E,W3
030E0:  ADD     W4,W3,W0
030E2:  MOV     #30,W4
030E4:  MOV.B   [W0],W3L
030E6:  ADD.B   W3L,W4L,W5L
030E8:  MOV.B   W5L,W0L
030EA:  BTSC.B  219.1
030EC:  BRA     30EA
030EE:  MOV.B   W0L,21A
030F0:  CLR.B   21B
....................    } 
030F2:  INC.B   095C
030F4:  GOTO    30BC
....................    fprintf(RS232, "\n\r"); 
030F8:  BTSC.B  219.1
030FA:  BRA     30F8
030FC:  MOV     #A,W4
030FE:  MOV     W4,21A
03100:  BTSC.B  219.1
03102:  BRA     3100
03104:  MOV     #D,W4
03106:  MOV     W4,21A
.................... } 
03108:  MOV     [--W15],W6
0310A:  MOV     [--W15],W5
0310C:  RETURN  
.................... // Returns movement range of the device 
.................... unsigned int16 data_get_move_range() 
.................... { 
*
01AF4:  PUSH    8E4
01AF6:  POP     972
01AF8:  CALL    1AC2
01AFC:  MOV     W0,95C
....................    unsigned int16 range = fr_read(fr_move_range); 
....................     
....................    if(debug_mode_fr)  
01AFE:  BTSS.B  8B0.2
01B00:  BRA     1B3A
....................       fprintf(RS232, "Movement Range: %u mm\n\r", range); 
01B02:  MOV     #0,W1
01B04:  MOV     W1,W0
01B06:  CLR.B   1
01B08:  CALL    33E
01B0C:  INC     W1,W1
01B0E:  BTSC.B  219.1
01B10:  BRA     1B0E
01B12:  MOV     W0,21A
01B14:  MOV     #F,W0
01B16:  CPSGT   W1,W0
01B18:  BRA     1B04
01B1A:  MOV     95C,W0
01B1C:  MOV     #0,W4
01B1E:  CALL    143A
01B22:  MOV     #12,W1
01B24:  MOV     W1,W0
01B26:  CLR.B   1
01B28:  CALL    33E
01B2C:  INC     W1,W1
01B2E:  BTSC.B  219.1
01B30:  BRA     1B2E
01B32:  MOV     W0,21A
01B34:  MOV     #16,W0
01B36:  CPSGT   W1,W0
01B38:  BRA     1B24
....................     
....................    return range; 
01B3A:  PUSH    95C
01B3C:  POP     0
.................... } 
01B3E:  RETURN  
.................... // Returns home position 
.................... unsigned int16 data_get_home_pos() 
.................... { 
01B40:  PUSH    8E6
01B42:  POP     972
01B44:  CALL    1AC2
01B48:  MOV     W0,970
....................    unsigned int16 home_pos = fr_read(fr_home_pos); 
....................     
....................    if(debug_mode_fr)  
01B4A:  BTSS.B  8B0.2
01B4C:  BRA     1B86
....................       fprintf(RS232, "Home Distance: %u counts\n\r", home_pos); 
01B4E:  MOV     #0,W1
01B50:  MOV     W1,W0
01B52:  CLR.B   1
01B54:  CALL    362
01B58:  INC     W1,W1
01B5A:  BTSC.B  219.1
01B5C:  BRA     1B5A
01B5E:  MOV     W0,21A
01B60:  MOV     #E,W0
01B62:  CPSGT   W1,W0
01B64:  BRA     1B50
01B66:  MOV     970,W0
01B68:  MOV     #0,W4
01B6A:  CALL    143A
01B6E:  MOV     #11,W1
01B70:  MOV     W1,W0
01B72:  CLR.B   1
01B74:  CALL    362
01B78:  INC     W1,W1
01B7A:  BTSC.B  219.1
01B7C:  BRA     1B7A
01B7E:  MOV     W0,21A
01B80:  MOV     #19,W0
01B82:  CPSGT   W1,W0
01B84:  BRA     1B70
....................        
....................    return home_pos; 
01B86:  PUSH    970
01B88:  POP     0
.................... } 
01B8A:  RETURN  
.................... // Returns end position 
.................... unsigned int16 data_get_end_pos() 
.................... { 
01B8C:  PUSH    8E8
01B8E:  POP     972
01B90:  CALL    1AC2
01B94:  MOV     W0,95C
....................    unsigned int16 end = fr_read(fr_end_pos); 
....................     
....................    if(debug_mode_fr) 
01B96:  BTSS.B  8B0.2
01B98:  BRA     1BD2
....................       fprintf(RS232, "End Distance: %u counts\n\r", end); 
01B9A:  MOV     #0,W1
01B9C:  MOV     W1,W0
01B9E:  CLR.B   1
01BA0:  CALL    38A
01BA4:  INC     W1,W1
01BA6:  BTSC.B  219.1
01BA8:  BRA     1BA6
01BAA:  MOV     W0,21A
01BAC:  MOV     #D,W0
01BAE:  CPSGT   W1,W0
01BB0:  BRA     1B9C
01BB2:  MOV     95C,W0
01BB4:  MOV     #0,W4
01BB6:  CALL    143A
01BBA:  MOV     #10,W1
01BBC:  MOV     W1,W0
01BBE:  CLR.B   1
01BC0:  CALL    38A
01BC4:  INC     W1,W1
01BC6:  BTSC.B  219.1
01BC8:  BRA     1BC6
01BCA:  MOV     W0,21A
01BCC:  MOV     #18,W0
01BCE:  CPSGT   W1,W0
01BD0:  BRA     1BBC
....................     
....................    return end; 
01BD2:  PUSH    95C
01BD4:  POP     0
.................... } 
01BD6:  RETURN  
.................... // Returns positioning velocity 
.................... unsigned int16 data_get_conv_const() 
.................... { 
*
01C66:  PUSH    8EA
01C68:  POP     972
01C6A:  CALL    1AC2
01C6E:  MOV     W0,95C
....................    unsigned int16 conv_const = fr_read(fr_conv_const); 
....................     
....................    if((conv_const < 12000)||(conv_const > 13000)) 
01C70:  MOV     95C,W4
01C72:  MOV     #2EE0,W3
01C74:  CP      W3,W4
01C76:  BRA     GTU,1C80
01C78:  MOV     95C,W4
01C7A:  MOV     #32C8,W3
01C7C:  CP      W3,W4
01C7E:  BRA     C,1C84
....................       conv_const = 12500; 
01C80:  MOV     #30D4,W4
01C82:  MOV     W4,95C
....................     
....................    if(debug_mode_fr)  
01C84:  BTSS.B  8B0.2
01C86:  BRA     1CC0
....................       fprintf(RS232, "Conversion Constant: %u \n\r", conv_const); 
01C88:  MOV     #0,W1
01C8A:  MOV     W1,W0
01C8C:  CLR.B   1
01C8E:  CALL    3B0
01C92:  INC     W1,W1
01C94:  BTSC.B  219.1
01C96:  BRA     1C94
01C98:  MOV     W0,21A
01C9A:  MOV     #14,W0
01C9C:  CPSGT   W1,W0
01C9E:  BRA     1C8A
01CA0:  MOV     95C,W0
01CA2:  MOV     #0,W4
01CA4:  CALL    143A
01CA8:  BTSC.B  219.1
01CAA:  BRA     1CA8
01CAC:  MOV     #20,W4
01CAE:  MOV     W4,21A
01CB0:  BTSC.B  219.1
01CB2:  BRA     1CB0
01CB4:  MOV     #A,W4
01CB6:  MOV     W4,21A
01CB8:  BTSC.B  219.1
01CBA:  BRA     1CB8
01CBC:  MOV     #D,W4
01CBE:  MOV     W4,21A
....................     
....................    return conv_const; 
01CC0:  PUSH    95C
01CC2:  POP     0
.................... } 
01CC4:  RETURN  
.................... // Returns the backlash of the system 
.................... unsigned int16 data_get_backlash() 
.................... { 
*
01BD8:  PUSH    8EC
01BDA:  POP     972
01BDC:  CALL    1AC2
01BE0:  MOV     W0,95C
....................    unsigned int16 backlash = fr_read(fr_backlash); 
....................  
....................    if(debug_mode_fr)  
01BE2:  BTSS.B  8B0.2
01BE4:  BRA     1C1E
....................       fprintf(RS232, "Backlash: %u counts\n\r", backlash); 
01BE6:  MOV     #0,W1
01BE8:  MOV     W1,W0
01BEA:  CLR.B   1
01BEC:  CALL    3D8
01BF0:  INC     W1,W1
01BF2:  BTSC.B  219.1
01BF4:  BRA     1BF2
01BF6:  MOV     W0,21A
01BF8:  MOV     #9,W0
01BFA:  CPSGT   W1,W0
01BFC:  BRA     1BE8
01BFE:  MOV     95C,W0
01C00:  MOV     #0,W4
01C02:  CALL    143A
01C06:  MOV     #C,W1
01C08:  MOV     W1,W0
01C0A:  CLR.B   1
01C0C:  CALL    3D8
01C10:  INC     W1,W1
01C12:  BTSC.B  219.1
01C14:  BRA     1C12
01C16:  MOV     W0,21A
01C18:  MOV     #14,W0
01C1A:  CPSGT   W1,W0
01C1C:  BRA     1C08
....................     
....................    return backlash; 
01C1E:  PUSH    95C
01C20:  POP     0
.................... } 
01C22:  RETURN  
.................... // Returns communication type 
.................... unsigned int8 data_get_comm_type() 
.................... { 
*
02BCE:  PUSH    8EE
02BD0:  POP     980
02BD2:  CALL    1A2A
02BD6:  MOV.B   W0L,95C
....................    unsigned int8 comm_type=fr_read_byte(fr_comm_type); 
....................     
....................    if(debug_mode_fr) 
02BD8:  BTSS.B  8B0.2
02BDA:  BRA     2C3E
....................       switch (comm_type) 
....................       { 
02BDC:  MOV.B   95C,W0L
02BDE:  CLR.B   1
02BE0:  XOR     #0,W0
02BE2:  BRA     Z,2BEA
02BE4:  XOR     #1,W0
02BE6:  BRA     Z,2C06
02BE8:  BRA     2C22
....................          case 0   :  fprintf(RS232,"Communication Type: Parallel Port\n\r"); 
02BEA:  MOV     #0,W1
02BEC:  MOV     W1,W0
02BEE:  CLR.B   1
02BF0:  CALL    3FA
02BF4:  INC     W1,W1
02BF6:  BTSC.B  219.1
02BF8:  BRA     2BF6
02BFA:  MOV     W0,21A
02BFC:  MOV     #22,W0
02BFE:  CPSGT   W1,W0
02C00:  BRA     2BEC
....................                      break; 
02C02:  GOTO    2C3E
....................          case 1   :  fprintf(RS232,"Communication Type: Serial Port\n\r"); 
02C06:  MOV     #0,W1
02C08:  MOV     W1,W0
02C0A:  CLR.B   1
02C0C:  CALL    42A
02C10:  INC     W1,W1
02C12:  BTSC.B  219.1
02C14:  BRA     2C12
02C16:  MOV     W0,21A
02C18:  MOV     #20,W0
02C1A:  CPSGT   W1,W0
02C1C:  BRA     2C08
....................                      break; 
02C1E:  GOTO    2C3E
....................          default  :  fprintf(RS232,"Communication Type: Undefined\n\r"); 
02C22:  MOV     #0,W1
02C24:  MOV     W1,W0
02C26:  CLR.B   1
02C28:  CALL    458
02C2C:  INC     W1,W1
02C2E:  BTSC.B  219.1
02C30:  BRA     2C2E
02C32:  MOV     W0,21A
02C34:  MOV     #1E,W0
02C36:  CPSGT   W1,W0
02C38:  BRA     2C24
....................                      break; 
02C3A:  GOTO    2C3E
....................       } 
....................        
....................    return comm_type; 
02C3E:  MOV.B   95C,W0L
02C40:  MOV.B   W0L,0
.................... } 
02C42:  RETURN  
.................... // Returns last position 
.................... unsigned int16 data_get_last_pos() 
.................... { 
*
01FF8:  PUSH    8F0
01FFA:  POP     972
01FFC:  CALL    1AC2
02000:  MOV     W0,95C
....................    unsigned int16 position=fr_read(fr_last_pos); 
....................     
....................    if(debug_mode_fr)  
02002:  BTSS.B  8B0.2
02004:  BRA     203E
....................       fprintf(RS232, "Last Position: %u mm\n\r", position); 
02006:  MOV     #0,W1
02008:  MOV     W1,W0
0200A:  CLR.B   1
0200C:  CALL    484
02010:  INC     W1,W1
02012:  BTSC.B  219.1
02014:  BRA     2012
02016:  MOV     W0,21A
02018:  MOV     #E,W0
0201A:  CPSGT   W1,W0
0201C:  BRA     2008
0201E:  MOV     95C,W0
02020:  MOV     #0,W4
02022:  CALL    143A
02026:  MOV     #11,W1
02028:  MOV     W1,W0
0202A:  CLR.B   1
0202C:  CALL    484
02030:  INC     W1,W1
02032:  BTSC.B  219.1
02034:  BRA     2032
02036:  MOV     W0,21A
02038:  MOV     #15,W0
0203A:  CPSGT   W1,W0
0203C:  BRA     2028
....................     
....................    return position; 
0203E:  PUSH    95C
02040:  POP     0
.................... } 
02042:  RETURN  
.................... // Returns the position in the given index 
.................... unsigned int16 data_get_pos(unsigned int8 index) 
.................... { 
*
0315C:  MOV     W5,[W15++]
0315E:  MOV.B   964,W0L
03160:  SL      W0,#1,W0
03162:  ZE      W0,W0
03164:  CLR.B   1
03166:  MOV     8F2,W4
03168:  ADD     W0,W4,W5
0316A:  MOV     W5,972
0316C:  CALL    1AC2
03170:  MOV     W0,966
....................    unsigned int16 position=fr_read(fr_pos_table+index*2); 
....................     
....................    if(debug_mode_fr) 
03172:  BTSS.B  8B0.2
03174:  BRA     31D0
....................       fprintf(RS232,"Index: %u, Position: %u mm\n\r", index, position); 
03176:  MOV     #0,W1
03178:  MOV     W1,W0
0317A:  CLR.B   1
0317C:  CALL    4A8
03180:  INC     W1,W1
03182:  BTSC.B  219.1
03184:  BRA     3182
03186:  MOV     W0,21A
03188:  MOV     #6,W0
0318A:  CPSGT   W1,W0
0318C:  BRA     3178
0318E:  MOV.B   964,W0L
03190:  CLR.B   1
03192:  MOV     #0,W4
03194:  CALL    143A
03198:  MOV     #9,W1
0319A:  MOV     W1,W0
0319C:  CLR.B   1
0319E:  CALL    4A8
031A2:  INC     W1,W1
031A4:  BTSC.B  219.1
031A6:  BRA     31A4
031A8:  MOV     W0,21A
031AA:  MOV     #14,W0
031AC:  CPSGT   W1,W0
031AE:  BRA     319A
031B0:  MOV     966,W0
031B2:  MOV     #0,W4
031B4:  CALL    143A
031B8:  MOV     #17,W1
031BA:  MOV     W1,W0
031BC:  CLR.B   1
031BE:  CALL    4A8
031C2:  INC     W1,W1
031C4:  BTSC.B  219.1
031C6:  BRA     31C4
031C8:  MOV     W0,21A
031CA:  MOV     #1B,W0
031CC:  CPSGT   W1,W0
031CE:  BRA     31BA
....................     
....................    return position; 
031D0:  PUSH    966
031D2:  POP     0
.................... } 
031D4:  MOV     [--W15],W5
031D6:  RETURN  
.................... // Returns position table via RS232 
.................... void data_get_pos_table() 
.................... { 
031D8:  MOV     W5,[W15++]
....................    debug_mode_fr=1; 
031DA:  BSET.B  8B0.2
....................     
....................    unsigned int input; 
....................    unsigned int i; 
....................    unsigned int index; 
....................     
....................    input=(unsigned)(fgetc(RS232)-48); 
031DC:  BTSS.B  218.0
031DE:  BRA     31DC
031E0:  MOV     21C,W0
031E2:  SUB.B   #30,W0L
031E4:  MOV.B   W0L,95C
031E6:  CLR.B   95D
....................    fputc(input+48,RS232); 
031E8:  MOV     #30,W4
031EA:  MOV     95C,W3
031EC:  ADD     W3,W4,W5
031EE:  MOV.B   W5L,W0L
031F0:  BTSC.B  219.1
031F2:  BRA     31F0
031F4:  MOV.B   W0L,21A
031F6:  CLR.B   21B
....................  
....................    if(input>9) 
031F8:  MOV     95C,W4
031FA:  CP      W4,#9
031FC:  BRA     LEU,3202
....................       input=9; 
031FE:  MOV     #9,W4
03200:  MOV     W4,95C
....................  
....................    fprintf(RS232,"\n\r"); 
03202:  BTSC.B  219.1
03204:  BRA     3202
03206:  MOV     #A,W4
03208:  MOV     W4,21A
0320A:  BTSC.B  219.1
0320C:  BRA     320A
0320E:  MOV     #D,W4
03210:  MOV     W4,21A
....................     
....................    for(i=0; i<10; i++) 
03212:  CLR     95E
03214:  MOV     95E,W4
03216:  CP      W4,#A
03218:  BRA     C,3234
....................    { 
....................       index=input*10+i; 
0321A:  MOV     95C,W4
0321C:  MUL.UU  W4,#A,W0
0321E:  MOV     W0,W5
03220:  MOV     W5,W0
03222:  ADD     95E,W0
03224:  MOV     W0,960
....................       data_get_pos(index); 
03226:  MOV.B   960,W0L
03228:  MOV.B   W0L,964
0322A:  CALL    315C
....................    } 
0322E:  INC     095E
03230:  GOTO    3214
....................     
....................    debug_mode_fr=0; 
03234:  BCLR.B  8B0.2
.................... } 
03236:  MOV     [--W15],W5
03238:  RETURN  
.................... // Returns all system data via RS232 
.................... void data_get_sys_data() 
.................... { 
....................    fprintf(RS232,"MODESIS LASER POSITIONING SYSTEM\n\n\r"); 
*
0310E:  MOV     #0,W1
03110:  MOV     W1,W0
03112:  CLR.B   1
03114:  CALL    4D2
03118:  INC     W1,W1
0311A:  BTSC.B  219.1
0311C:  BRA     311A
0311E:  MOV     W0,21A
03120:  MOV     #22,W0
03122:  CPSGT   W1,W0
03124:  BRA     3110
....................    debug_mode_fr=1; 
03126:  BSET.B  8B0.2
....................    data_get_serial_no(); 
03128:  CALL    3096
....................    data_get_move_range(); 
0312C:  CALL    1AF4
....................    data_get_home_pos(); 
03130:  CALL    1B40
....................    data_get_end_pos(); 
03134:  CALL    1B8C
....................    data_get_conv_const(); 
03138:  CALL    1C66
....................    data_get_backlash(); 
0313C:  CALL    1BD8
....................    data_get_comm_type(); 
03140:  CALL    2BCE
....................    data_get_last_pos(); 
03144:  CALL    1FF8
....................    debug_mode_fr=0; 
03148:  BCLR.B  8B0.2
....................    fprintf(RS232,"\n\r"); 
0314A:  BTSC.B  219.1
0314C:  BRA     314A
0314E:  MOV     #A,W4
03150:  MOV     W4,21A
03152:  BTSC.B  219.1
03154:  BRA     3152
03156:  MOV     #D,W4
03158:  MOV     W4,21A
.................... } 
0315A:  RETURN  
....................  
.................... // Sets serial nuber of the device 
.................... void data_set_serial_no() 
.................... { 
*
02C44:  MOV     W5,[W15++]
02C46:  MOV     W6,[W15++]
02C48:  CLR.B   95C
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
....................    for(i=0; i<13; i++) 
02C4A:  CLR.B   95C
02C4C:  MOV     95C,W4
02C4E:  CP.B    W4L,#D
02C50:  BRA     C,2CA2
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02C52:  MOV     95C,W4
02C54:  CLR.B   9
02C56:  MOV     #95E,W3
02C58:  ADD     W4,W3,W5
02C5A:  BTSS.B  218.0
02C5C:  BRA     2C5A
02C5E:  MOV     21C,W0
02C60:  SUB.B   #30,W0L
02C62:  CLR.B   1
02C64:  MOV.B   W0L,[W5]
....................       fr_write_byte(fr_serial_no+i, input[i]); 
02C66:  MOV     95C,W4
02C68:  CLR.B   9
02C6A:  MOV     8E2,W3
02C6C:  ADD     W3,W4,W5
02C6E:  MOV     95C,W4
02C70:  CLR.B   9
02C72:  MOV     #95E,W3
02C74:  ADD     W4,W3,W0
02C76:  MOV.B   [W0],W6L
02C78:  PUSH    97E
02C7A:  MOV.B   W6L,[W15-#2]
02C7C:  POP     97E
02C7E:  MOV     W5,97C
02C80:  CALL    2044
....................       fputc(input[i]+48,RS232); 
02C84:  MOV     95C,W4
02C86:  CLR.B   9
02C88:  MOV     #95E,W3
02C8A:  ADD     W4,W3,W0
02C8C:  MOV     #30,W4
02C8E:  MOV.B   [W0],W3L
02C90:  ADD.B   W3L,W4L,W5L
02C92:  MOV.B   W5L,W0L
02C94:  BTSC.B  219.1
02C96:  BRA     2C94
02C98:  MOV.B   W0L,21A
02C9A:  CLR.B   21B
....................    } 
02C9C:  INC.B   095C
02C9E:  GOTO    2C4C
.................... } 
02CA2:  MOV     [--W15],W6
02CA4:  MOV     [--W15],W5
02CA6:  RETURN  
.................... // Sets movement range of the device 
.................... void data_set_move_range() 
.................... { 
02CA8:  MOV     W5,[W15++]
02CAA:  MOV     W6,[W15++]
02CAC:  CLR.B   95C
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0;i<4;i++) 
02CAE:  CLR.B   95C
02CB0:  MOV     95C,W4
02CB2:  CP.B    W4L,#4
02CB4:  BRA     C,2CEA
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02CB6:  MOV.B   95C,W0L
02CB8:  CLR.B   1
02CBA:  SL      W0,#1,W0
02CBC:  MOV     #95E,W4
02CBE:  ADD     W0,W4,W5
02CC0:  BTSS.B  218.0
02CC2:  BRA     2CC0
02CC4:  MOV     21C,W0
02CC6:  SUB.B   #30,W0L
02CC8:  CLR.B   1
02CCA:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
02CCC:  MOV.B   95C,W0L
02CCE:  CLR.B   1
02CD0:  SL      W0,#1,W0
02CD2:  MOV     #95E,W4
02CD4:  ADD     W0,W4,W0
02CD6:  MOV     [W0],W5
02CD8:  ADD     #30,W5
02CDA:  MOV.B   W5L,W0L
02CDC:  BTSC.B  219.1
02CDE:  BRA     2CDC
02CE0:  MOV.B   W0L,21A
02CE2:  CLR.B   21B
....................    } 
02CE4:  INC.B   095C
02CE6:  GOTO    2CB0
....................    unsigned int range=1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
02CEA:  MOV     #3E8,W4
02CEC:  MOV     95E,W3
02CEE:  MUL.UU  W4,W3,W0
02CF0:  MOV     W0,W5
02CF2:  MOV     #64,W4
02CF4:  MOV     960,W3
02CF6:  MUL.UU  W4,W3,W0
02CF8:  ADD     W0,W5,W5
02CFA:  MOV     962,W4
02CFC:  MUL.UU  W4,#A,W0
02CFE:  ADD     W0,W5,W5
02D00:  MOV     W5,W0
02D02:  ADD     964,W0
02D04:  MOV     W0,966
....................     
....................    if(range<400) 
02D06:  MOV     966,W4
02D08:  MOV     #190,W3
02D0A:  CP      W3,W4
02D0C:  BRA     LEU,2D2E
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be smaller than 400 mm. Movement range is set to 400 mm."); 
02D0E:  MOV     #0,W1
02D10:  MOV     W1,W0
02D12:  CLR.B   1
02D14:  CALL    502
02D18:  INC     W1,W1
02D1A:  BTSC.B  219.1
02D1C:  BRA     2D1A
02D1E:  MOV     W0,21A
02D20:  MOV     #5E,W0
02D22:  CPSGT   W1,W0
02D24:  BRA     2D10
....................       range=400; 
02D26:  MOV     #190,W4
02D28:  MOV     W4,966
....................    } 
....................    else if(range>2000) 
02D2A:  GOTO    2D52
02D2E:  MOV     966,W4
02D30:  MOV     #7D0,W3
02D32:  CP      W3,W4
02D34:  BRA     C,2D52
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be larger than 2000 mm. Movement range is set to 2000 mm."); 
02D36:  MOV     #0,W1
02D38:  MOV     W1,W0
02D3A:  CLR.B   1
02D3C:  CALL    55E
02D40:  INC     W1,W1
02D42:  BTSC.B  219.1
02D44:  BRA     2D42
02D46:  MOV     W0,21A
02D48:  MOV     #5F,W0
02D4A:  CPSGT   W1,W0
02D4C:  BRA     2D38
....................       range=2000; 
02D4E:  MOV     #7D0,W4
02D50:  MOV     W4,966
....................    } 
....................     
....................    if(range==2000) 
02D52:  MOV     966,W4
02D54:  MOV     #7D0,W3
02D56:  CP      W3,W4
02D58:  BRA     NZ,2D62
....................       md_min_distance=120; 
02D5A:  MOV     #78,W4
02D5C:  MOV     W4,8C8
....................    else 
02D5E:  GOTO    2D66
....................       md_min_distance=70; 
02D62:  MOV     #46,W4
02D64:  MOV     W4,8C8
....................        
....................    fr_write(fr_move_range, range); 
02D66:  PUSH    8E4
02D68:  POP     970
02D6A:  PUSH    966
02D6C:  POP     972
02D6E:  CALL    2150
....................    md_move_range=range; 
02D72:  PUSH    966
02D74:  POP     8BE
.................... } 
02D76:  MOV     [--W15],W6
02D78:  MOV     [--W15],W5
02D7A:  RETURN  
.................... // Sets home position 
.................... void data_set_home_pos() 
.................... { 
02D7C:  MOV     W5,[W15++]
02D7E:  MOV     W6,[W15++]
02D80:  CLR.B   95C
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0; i<4; i++) 
02D82:  CLR.B   95C
02D84:  MOV     95C,W4
02D86:  CP.B    W4L,#4
02D88:  BRA     C,2DBE
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02D8A:  MOV.B   95C,W0L
02D8C:  CLR.B   1
02D8E:  SL      W0,#1,W0
02D90:  MOV     #95E,W4
02D92:  ADD     W0,W4,W5
02D94:  BTSS.B  218.0
02D96:  BRA     2D94
02D98:  MOV     21C,W0
02D9A:  SUB.B   #30,W0L
02D9C:  CLR.B   1
02D9E:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
02DA0:  MOV.B   95C,W0L
02DA2:  CLR.B   1
02DA4:  SL      W0,#1,W0
02DA6:  MOV     #95E,W4
02DA8:  ADD     W0,W4,W0
02DAA:  MOV     [W0],W5
02DAC:  ADD     #30,W5
02DAE:  MOV.B   W5L,W0L
02DB0:  BTSC.B  219.1
02DB2:  BRA     2DB0
02DB4:  MOV.B   W0L,21A
02DB6:  CLR.B   21B
....................    } 
02DB8:  INC.B   095C
02DBA:  GOTO    2D84
....................    unsigned int home_pos = 1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
02DBE:  MOV     #3E8,W4
02DC0:  MOV     95E,W3
02DC2:  MUL.UU  W4,W3,W0
02DC4:  MOV     W0,W5
02DC6:  MOV     #64,W4
02DC8:  MOV     960,W3
02DCA:  MUL.UU  W4,W3,W0
02DCC:  ADD     W0,W5,W5
02DCE:  MOV     962,W4
02DD0:  MUL.UU  W4,#A,W0
02DD2:  ADD     W0,W5,W5
02DD4:  MOV     W5,W0
02DD6:  ADD     964,W0
02DD8:  MOV     W0,966
....................     
....................    if(home_pos<10) 
02DDA:  MOV     966,W4
02DDC:  CP      W4,#A
02DDE:  BRA     C,2DFA
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Home position cannot be smaller than 10. Home position is not changed"); 
02DE0:  MOV     #0,W1
02DE2:  MOV     W1,W0
02DE4:  CLR.B   1
02DE6:  CALL    5BC
02DEA:  INC     W1,W1
02DEC:  BTSC.B  219.1
02DEE:  BRA     2DEC
02DF0:  MOV     W0,21A
02DF2:  MOV     #55,W0
02DF4:  CPSGT   W1,W0
02DF6:  BRA     2DE2
....................       return; 
02DF8:  BRA     2E0A
....................    } 
....................     
....................    fr_write(fr_home_pos,home_pos); 
02DFA:  PUSH    8E6
02DFC:  POP     970
02DFE:  PUSH    966
02E00:  POP     972
02E02:  CALL    2150
....................    md_home_pos=home_pos; 
02E06:  PUSH    966
02E08:  POP     8C0
.................... } 
02E0A:  MOV     [--W15],W6
02E0C:  MOV     [--W15],W5
02E0E:  RETURN  
.................... // Sets end position 
.................... void data_set_end_pos() 
.................... { 
02E10:  MOV     W5,[W15++]
02E12:  MOV     W6,[W15++]
02E14:  CLR.B   95C
....................    unsigned int8 i=0; 
....................    unsigned int input[5]; 
....................    for(i=0; i<5; i++) 
02E16:  CLR.B   95C
02E18:  MOV     95C,W4
02E1A:  CP.B    W4L,#5
02E1C:  BRA     C,2E52
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02E1E:  MOV.B   95C,W0L
02E20:  CLR.B   1
02E22:  SL      W0,#1,W0
02E24:  MOV     #95E,W4
02E26:  ADD     W0,W4,W5
02E28:  BTSS.B  218.0
02E2A:  BRA     2E28
02E2C:  MOV     21C,W0
02E2E:  SUB.B   #30,W0L
02E30:  CLR.B   1
02E32:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
02E34:  MOV.B   95C,W0L
02E36:  CLR.B   1
02E38:  SL      W0,#1,W0
02E3A:  MOV     #95E,W4
02E3C:  ADD     W0,W4,W0
02E3E:  MOV     [W0],W5
02E40:  ADD     #30,W5
02E42:  MOV.B   W5L,W0L
02E44:  BTSC.B  219.1
02E46:  BRA     2E44
02E48:  MOV.B   W0L,21A
02E4A:  CLR.B   21B
....................    } 
02E4C:  INC.B   095C
02E4E:  GOTO    2E18
....................    unsigned int end=10000*input[0]+1000*input[1]+100*input[2]+10*input[3]+1*input[4]; 
02E52:  MOV     #2710,W4
02E54:  MOV     95E,W3
02E56:  MUL.UU  W4,W3,W0
02E58:  MOV     W0,W5
02E5A:  MOV     #3E8,W4
02E5C:  MOV     960,W3
02E5E:  MUL.UU  W4,W3,W0
02E60:  ADD     W0,W5,W5
02E62:  MOV     #64,W4
02E64:  MOV     962,W3
02E66:  MUL.UU  W4,W3,W0
02E68:  ADD     W0,W5,W5
02E6A:  MOV     964,W4
02E6C:  MUL.UU  W4,#A,W0
02E6E:  ADD     W0,W5,W5
02E70:  MOV     W5,W0
02E72:  ADD     966,W0
02E74:  MOV     W0,968
....................     
....................    if(end<md_home_pos) 
02E76:  MOV     968,W0
02E78:  MOV     8C0,W4
02E7A:  CP      W4,W0
02E7C:  BRA     LEU,2EA2
....................    { 
....................       end=data_get_home_pos()+50; 
02E7E:  CALL    1B40
02E82:  MOV     W0,W5
02E84:  MOV     #32,W4
02E86:  ADD     W5,W4,W0
02E88:  MOV     W0,968
....................       fprintf(RS232, "\n\rInvalid entry: End position cannot be smaller than home position. End position is set to its default."); 
02E8A:  MOV     #0,W1
02E8C:  MOV     W1,W0
02E8E:  CLR.B   1
02E90:  CALL    612
02E94:  INC     W1,W1
02E96:  BTSC.B  219.1
02E98:  BRA     2E96
02E9A:  MOV     W0,21A
02E9C:  MOV     #66,W0
02E9E:  CPSGT   W1,W0
02EA0:  BRA     2E8C
....................    } 
....................     
....................    fr_write(fr_end_pos,end); 
02EA2:  PUSH    8E8
02EA4:  POP     970
02EA6:  PUSH    968
02EA8:  POP     972
02EAA:  CALL    2150
....................    md_end_pos=end; 
02EAE:  PUSH    968
02EB0:  POP     8C2
.................... } 
02EB2:  MOV     [--W15],W6
02EB4:  MOV     [--W15],W5
02EB6:  RETURN  
.................... // Sets positioning velocity 
.................... void data_set_conv_const() 
.................... { 
02EB8:  MOV     W5,[W15++]
02EBA:  MOV     W6,[W15++]
....................    md_conv_const = 12500; 
02EBC:  MOV     #30D4,W4
02EBE:  MOV     W4,8BC
....................    md_cc_step = 0; 
02EC0:  CLR     8DE
....................    md_cc_count = 0; 
02EC2:  CLR     8E0
....................     
....................    move_pos(md_min_distance); 
02EC4:  PUSH    8C8
02EC6:  POP     962
02EC8:  CALL    28A6
....................  
....................    unsigned int cc_first_count = qei_get_count(); 
02ECC:  CALL    1D6A
02ED0:  MOV     W0,95C
....................     
....................    reg_md_cc_sample =1; 
02ED2:  BSET.B  8FC.4
....................    move_pos(md_move_range); 
02ED4:  PUSH    8BE
02ED6:  POP     962
02ED8:  CALL    28A6
....................     
....................    unsigned int conv_const = ((float)(cc_first_count - md_cc_count)/(float)md_cc_step)*10000; 
02EDC:  MOV     95C,W4
02EDE:  MOV     8E0,W3
02EE0:  SUB     W4,W3,W0
02EE2:  CALL    218A
02EE6:  MOV     W0,W5
02EE8:  MOV     W1,W6
02EEA:  MOV     8DE,W0
02EEC:  CALL    218A
02EF0:  MOV     W0,W2
02EF2:  MOV     W1,W3
02EF4:  MOV     W5,W0
02EF6:  MOV     W6,W1
02EF8:  CALL    21C4
02EFC:  MOV     W0,W5
02EFE:  MOV     W1,W6
02F00:  MOV     W5,W0
02F02:  MOV     W6,W1
02F04:  MOV     #4000,W2
02F06:  MOV     #461C,W3
02F08:  CALL    228E
02F0C:  CALL    24FC
02F10:  MOV     W0,95E
....................  
....................    fprintf(RS232, "Count: %u counts\n\r", cc_first_count-md_cc_count); 
02F12:  MOV     95C,W4
02F14:  MOV     8E0,W3
02F16:  SUB     W4,W3,W5
02F18:  MOV     #0,W1
02F1A:  MOV     W1,W0
02F1C:  CLR.B   1
02F1E:  CALL    674
02F22:  INC     W1,W1
02F24:  BTSC.B  219.1
02F26:  BRA     2F24
02F28:  MOV     W0,21A
02F2A:  MOV     #6,W0
02F2C:  CPSGT   W1,W0
02F2E:  BRA     2F1A
02F30:  MOV     W5,W0
02F32:  MOV     #0,W4
02F34:  CALL    143A
02F38:  MOV     #9,W1
02F3A:  MOV     W1,W0
02F3C:  CLR.B   1
02F3E:  CALL    674
02F42:  INC     W1,W1
02F44:  BTSC.B  219.1
02F46:  BRA     2F44
02F48:  MOV     W0,21A
02F4A:  MOV     #11,W0
02F4C:  CPSGT   W1,W0
02F4E:  BRA     2F3A
....................    fprintf(RS232, "Step: %u steps\n\r", md_cc_step); 
02F50:  MOV     #0,W1
02F52:  MOV     W1,W0
02F54:  CLR.B   1
02F56:  CALL    694
02F5A:  INC     W1,W1
02F5C:  BTSC.B  219.1
02F5E:  BRA     2F5C
02F60:  MOV     W0,21A
02F62:  MOV     #5,W0
02F64:  CPSGT   W1,W0
02F66:  BRA     2F52
02F68:  MOV     8DE,W0
02F6A:  MOV     #0,W4
02F6C:  CALL    143A
02F70:  MOV     #8,W1
02F72:  MOV     W1,W0
02F74:  CLR.B   1
02F76:  CALL    694
02F7A:  INC     W1,W1
02F7C:  BTSC.B  219.1
02F7E:  BRA     2F7C
02F80:  MOV     W0,21A
02F82:  MOV     #F,W0
02F84:  CPSGT   W1,W0
02F86:  BRA     2F72
....................    fprintf(RS232, "Conversion Constant: %u counts\n\r", conv_const); 
02F88:  MOV     #0,W1
02F8A:  MOV     W1,W0
02F8C:  CLR.B   1
02F8E:  CALL    6B2
02F92:  INC     W1,W1
02F94:  BTSC.B  219.1
02F96:  BRA     2F94
02F98:  MOV     W0,21A
02F9A:  MOV     #14,W0
02F9C:  CPSGT   W1,W0
02F9E:  BRA     2F8A
02FA0:  MOV     95E,W0
02FA2:  MOV     #0,W4
02FA4:  CALL    143A
02FA8:  MOV     #17,W1
02FAA:  MOV     W1,W0
02FAC:  CLR.B   1
02FAE:  CALL    6B2
02FB2:  INC     W1,W1
02FB4:  BTSC.B  219.1
02FB6:  BRA     2FB4
02FB8:  MOV     W0,21A
02FBA:  MOV     #1F,W0
02FBC:  CPSGT   W1,W0
02FBE:  BRA     2FAA
....................    
....................    fr_write(fr_conv_const,conv_const); 
02FC0:  PUSH    8EA
02FC2:  POP     970
02FC4:  PUSH    95E
02FC6:  POP     972
02FC8:  CALL    2150
....................    md_conv_const = conv_const; 
02FCC:  PUSH    95E
02FCE:  POP     8BC
.................... } 
02FD0:  MOV     [--W15],W6
02FD2:  MOV     [--W15],W5
02FD4:  RETURN  
.................... // Sets backlash 
.................... void data_set_backlash() 
.................... { 
02FD6:  MOV     W5,[W15++]
02FD8:  MOV     W6,[W15++]
02FDA:  CLR.B   95C
....................    unsigned int8 i=0; 
....................    unsigned int input[2]; 
....................    for(i=0; i<2; i++) 
02FDC:  CLR.B   95C
02FDE:  MOV     95C,W4
02FE0:  CP.B    W4L,#2
02FE2:  BRA     C,3018
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02FE4:  MOV.B   95C,W0L
02FE6:  CLR.B   1
02FE8:  SL      W0,#1,W0
02FEA:  MOV     #95E,W4
02FEC:  ADD     W0,W4,W5
02FEE:  BTSS.B  218.0
02FF0:  BRA     2FEE
02FF2:  MOV     21C,W0
02FF4:  SUB.B   #30,W0L
02FF6:  CLR.B   1
02FF8:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
02FFA:  MOV.B   95C,W0L
02FFC:  CLR.B   1
02FFE:  SL      W0,#1,W0
03000:  MOV     #95E,W4
03002:  ADD     W0,W4,W0
03004:  MOV     [W0],W5
03006:  ADD     #30,W5
03008:  MOV.B   W5L,W0L
0300A:  BTSC.B  219.1
0300C:  BRA     300A
0300E:  MOV.B   W0L,21A
03010:  CLR.B   21B
....................    } 
03012:  INC.B   095C
03014:  GOTO    2FDE
....................    unsigned int backlash = 10*input[0]+1*input[1]; 
03018:  MOV     95E,W4
0301A:  MUL.UU  W4,#A,W0
0301C:  MOV     W0,W5
0301E:  MOV     W5,W0
03020:  ADD     960,W0
03022:  MOV     W0,962
....................     
....................    fr_write(fr_backlash,backlash); 
03024:  PUSH    8EC
03026:  POP     970
03028:  PUSH    962
0302A:  POP     972
0302C:  CALL    2150
....................    md_backlash = backlash; 
03030:  PUSH    962
03032:  POP     8DC
.................... } 
03034:  MOV     [--W15],W6
03036:  MOV     [--W15],W5
03038:  RETURN  
.................... // Sets communication type 
.................... void data_set_comm_type() 
.................... { 
0303A:  MOV     W5,[W15++]
0303C:  BTSS.B  218.0
0303E:  BRA     303C
03040:  MOV     21C,W0
03042:  SUB.B   #30,W0L
03044:  MOV.B   W0L,95C
....................    unsigned int8 input=(unsigned)(fgetc(RS232)-48); 
....................    fputc(input+48,RS232); 
03046:  MOV     #30,W4
03048:  MOV     95C,W3
0304A:  ADD.B   W3L,W4L,W5L
0304C:  MOV.B   W5L,W0L
0304E:  BTSC.B  219.1
03050:  BRA     304E
03052:  MOV.B   W0L,21A
03054:  CLR.B   21B
....................    switch (input) 
....................    { 
03056:  MOV.B   95C,W0L
03058:  CLR.B   1
0305A:  XOR     #1,W0
0305C:  BRA     Z,3064
0305E:  XOR     #1,W0
03060:  BRA     Z,307C
03062:  BRA     307C
....................       case 1   :  output_low(PP_ACK); 
03064:  BCLR.B  2D2.4
03066:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
03068:  BCLR.B  2D2.5
0306A:  BCLR.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 1); 
0306C:  MOV.B   #1,W0L
0306E:  MOV.B   W0L,97E
03070:  PUSH    8EE
03072:  POP     97C
03074:  CALL    2044
....................                   break; 
03078:  GOTO    3092
....................       case 0   :     
....................       default  :  output_high(PP_ACK); 
0307C:  BCLR.B  2D2.4
0307E:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
03080:  BCLR.B  2D2.5
03082:  BSET.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 0); 
03084:  CLR.B   97E
03086:  PUSH    8EE
03088:  POP     97C
0308A:  CALL    2044
....................                   break; 
0308E:  GOTO    3092
....................    } 
.................... } 
03092:  MOV     [--W15],W5
03094:  RETURN  
.................... // Sets last position 
.................... void data_set_last_pos(unsigned int16 position) 
.................... { 
....................    fr_write(fr_last_pos, position); 
*
0217C:  PUSH    8F0
0217E:  POP     970
02180:  PUSH    968
02182:  POP     972
02184:  CALL    2150
.................... } 
02188:  RETURN  
.................... // Sets position to given index 
.................... void data_set_pos(unsigned int8 index, unsigned int16 position) 
.................... { 
*
0323A:  MOV     W5,[W15++]
....................    fr_write(fr_pos_table+index*2, position); 
0323C:  MOV.B   95E,W0L
0323E:  SL      W0,#1,W0
03240:  ZE      W0,W0
03242:  CLR.B   1
03244:  MOV     8F2,W4
03246:  ADD     W0,W4,W5
03248:  MOV     W5,970
0324A:  PUSH    960
0324C:  POP     972
0324E:  CALL    2150
.................... } 
03252:  MOV     [--W15],W5
03254:  RETURN  
....................  
.................... // Initializes the quadrature encoder interface module by using default values 
.................... void qei_init() 
.................... { 
....................    // Disable QEI module  
....................    QEI_QEICON_QEIM0=0; 
*
0138E:  BCLR.B  123.0
....................    QEI_QEICON_QEIM1=0; 
01390:  BCLR.B  123.1
....................    QEI_QEICON_QEIM2=0; 
01392:  BCLR.B  123.2
....................    // Clear any count errors 
....................    QEI_QEICON_CNTERR=0; 
01394:  BCLR.B  123.7
....................    // Continue module operation during sleep 
....................    QEI_QEICON_QEISIDL=0; 
01396:  BCLR.B  123.5
....................    // QEA and QEB not swapped 
....................    QEI_QEICON_SWPAB=0; 
01398:  BCLR.B  122.7
....................    // Normal I/O pin operation 
....................    QEI_QEICON_PCDOUT=0; 
0139A:  BCLR.B  122.6
....................    // Timer gated time accumulation disabled 
....................    QEI_QEICON_TQGATE=0; 
0139C:  BCLR.B  122.5
....................    // 1:1 timer input clock prescale 
....................    QEI_QEICON_TQCKPS0=0; 
0139E:  BCLR.B  122.3
....................    QEI_QEICON_TQCKPS1=0; 
013A0:  BCLR.B  122.4
....................    // Index pulse does not reset the position counter 
....................    QEI_QEICON_POSRES = 0; 
013A2:  BCLR.B  122.2
....................    // Internal clock as timer clock source 
....................    QEI_QEICON_TQCS = 0; 
013A4:  BCLR.B  122.1
....................    // QEI_QEICON_UPDN defines timer counter (QEI_POSCNT) direction 
....................    QEI_QEICON_UDSRC = 0; 
013A6:  BCLR.B  122.0
....................     
....................    // Count error interrupts enabled 
....................    QEI_DFLTCON_CEID = 0;  
013A8:  BCLR.B  125.0
....................    // Digital filter outputs enabled 
....................    QEI_DFLTCON_QEOUT = 1;  
013AA:  BSET.B  124.7
....................    // 1:256 clock divide for digital filter 
....................    QEI_DFLTCON_QECK2 = 1; 
013AC:  BSET.B  124.6
....................    QEI_DFLTCON_QECK1 = 1; 
013AE:  BSET.B  124.5
....................    QEI_DFLTCON_QECK0 = 1; 
013B0:  BSET.B  124.4
....................     
....................    // Reset position counter 
....................    QEI_POSCNT = 0x0000; 
013B2:  CLR     126
....................     
....................    // Set maximum count 
....................    QEI_MAXCNT = 0xFFFF; 
013B4:  SETM    128
....................     
....................    // QEI module enabled in x4 mode with position counter reset by QEI_MAXCNT match 
....................    QEI_QEICON_QEIM2 = 1; 
013B6:  BSET.B  123.2
....................    QEI_QEICON_QEIM1 = 1; 
013B8:  BSET.B  123.1
....................    QEI_QEICON_QEIM0 = 1; 
013BA:  BSET.B  123.0
....................     
....................    if(debug_mode_qei) 
013BC:  BTSS.B  8B0.5
013BE:  BRA     13D8
....................       fprintf(RS232,"Quadrature Encoder Initialized\n\n\r"); 
013C0:  MOV     #0,W1
013C2:  MOV     W1,W0
013C4:  CLR.B   1
013C6:  CALL    6E0
013CA:  INC     W1,W1
013CC:  BTSC.B  219.1
013CE:  BRA     13CC
013D0:  MOV     W0,21A
013D2:  MOV     #20,W0
013D4:  CPSGT   W1,W0
013D6:  BRA     13C2
.................... } 
013D8:  RETURN  
.................... // Sets the position counter to given value 
.................... void qei_set_count(unsigned int16 value) 
.................... {  
....................    QEI_POSCNT = value; 
*
01D28:  PUSH    978
01D2A:  POP     126
....................     
....................    if(debug_mode_qei) 
01D2C:  BTSS.B  8B0.5
01D2E:  BRA     1D68
....................       fprintf(RS232,"Quadrature Encoder Count Set: %u\n\n\r", value); 
01D30:  MOV     #0,W1
01D32:  MOV     W1,W0
01D34:  CLR.B   1
01D36:  CALL    70E
01D3A:  INC     W1,W1
01D3C:  BTSC.B  219.1
01D3E:  BRA     1D3C
01D40:  MOV     W0,21A
01D42:  MOV     #1D,W0
01D44:  CPSGT   W1,W0
01D46:  BRA     1D32
01D48:  MOV     978,W0
01D4A:  MOV     #0,W4
01D4C:  CALL    143A
01D50:  BTSC.B  219.1
01D52:  BRA     1D50
01D54:  MOV     #A,W4
01D56:  MOV     W4,21A
01D58:  BTSC.B  219.1
01D5A:  BRA     1D58
01D5C:  MOV     #A,W4
01D5E:  MOV     W4,21A
01D60:  BTSC.B  219.1
01D62:  BRA     1D60
01D64:  MOV     #D,W4
01D66:  MOV     W4,21A
.................... } 
01D68:  RETURN  
.................... // Sets the maximum count to given value 
.................... void qei_set_max_count(unsigned int16 value) 
.................... {  
....................    QEI_MAXCNT = value; 
*
01C24:  PUSH    906
01C26:  POP     128
....................     
....................    if(debug_mode_qei) 
01C28:  BTSS.B  8B0.5
01C2A:  BRA     1C64
....................       fprintf(RS232,"Quadrature Encoder Maximum Count Set: %u\n\n\r", value); 
01C2C:  MOV     #0,W1
01C2E:  MOV     W1,W0
01C30:  CLR.B   1
01C32:  CALL    73E
01C36:  INC     W1,W1
01C38:  BTSC.B  219.1
01C3A:  BRA     1C38
01C3C:  MOV     W0,21A
01C3E:  MOV     #25,W0
01C40:  CPSGT   W1,W0
01C42:  BRA     1C2E
01C44:  MOV     906,W0
01C46:  MOV     #0,W4
01C48:  CALL    143A
01C4C:  BTSC.B  219.1
01C4E:  BRA     1C4C
01C50:  MOV     #A,W4
01C52:  MOV     W4,21A
01C54:  BTSC.B  219.1
01C56:  BRA     1C54
01C58:  MOV     #A,W4
01C5A:  MOV     W4,21A
01C5C:  BTSC.B  219.1
01C5E:  BRA     1C5C
01C60:  MOV     #D,W4
01C62:  MOV     W4,21A
.................... } 
01C64:  RETURN  
.................... // Returns the value of the position counter 
.................... unsigned int16 qei_get_count(){ return QEI_POSCNT;} 
*
01D6A:  PUSH    126
01D6C:  POP     0
01D6E:  RETURN  
....................  
.................... // Sets the operating mode of the PWM module 
.................... void pwm_select_mode(unsigned int mode) 
.................... { 
....................    if(mode == FREE) 
*
013DA:  CP0     978
013DC:  BRA     NZ,13E6
....................    { 
....................       // Select free running PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
013DE:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 0; 
013E0:  BCLR.B  1C0.0
....................    } 
....................    else if(mode == SINGLE) 
013E2:  GOTO    13F0
013E6:  MOV     978,W4
013E8:  CP      W4,#1
013EA:  BRA     NZ,13F0
....................    { 
....................       // Select single event PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
013EC:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 1; 
013EE:  BSET.B  1C0.0
....................    } 
.................... } 
013F0:  RETURN  
.................... // Initializes the PWM module by using default values 
.................... void pwm_init() 
.................... { 
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN       = 0; 
013F2:  BCLR.B  1C1.7
....................     
....................    // Select 1:1 output postscale 
....................    PWM_PTCON_PTOPS3     = 0; 
013F4:  BCLR.B  1C0.7
....................    PWM_PTCON_PTOPS2     = 0; 
013F6:  BCLR.B  1C0.6
....................    PWM_PTCON_PTOPS1     = 0; 
013F8:  BCLR.B  1C0.5
....................    PWM_PTCON_PTOPS0     = 0; 
013FA:  BCLR.B  1C0.4
....................    // Select 1:1 input prescale 
....................    PWM_PTCON_PTCKPS1    = 0; 
013FC:  BCLR.B  1C0.3
....................    PWM_PTCON_PTCKPS0    = 0; 
013FE:  BCLR.B  1C0.2
....................     
....................    // Set the operating mode of PWM module 
....................    pwm_select_mode(FREE); 
01400:  CLR     978
01402:  CALL    13DA
....................  
....................    // Select independent output mode for PWM1 I/O pair 
....................    PWM_PWMCON1_PMOD1    = 1; 
01406:  BSET.B  1C9.0
....................    // Set PWM1H pin as PWM output 
....................    PWM_PWMCON1_PEN1H    = 1; 
01408:  BSET.B  1C8.4
....................     
....................    // Synchronize PDC registers to the PWM time base 
....................    PWM_PWMCON2_IUE      = 0; 
0140A:  BCLR.B  1CA.2
....................    // Enable PWM interrupt 
....................    PWM_IEC2_PWMIE       = 0; 
0140C:  BCLR.B  90.7
....................     
....................    // Set time base period value 
....................    PWM_PTPER            = 0; 
0140E:  CLR     1C4
....................    // Set time base duty cycle 
....................    PWM_PDC1             = 0; 
01410:  CLR     1D6
....................  
....................    if(debug_mode_md) 
01412:  BTSS.B  8B0.3
01414:  BRA     142E
....................       fprintf(RS232,"PWM Module Initialized\n\n\r"); 
01416:  MOV     #0,W1
01418:  MOV     W1,W0
0141A:  CLR.B   1
0141C:  CALL    778
01420:  INC     W1,W1
01422:  BTSC.B  219.1
01424:  BRA     1422
01426:  MOV     W0,21A
01428:  MOV     #18,W0
0142A:  CPSGT   W1,W0
0142C:  BRA     1418
.................... } 
0142E:  RETURN  
.................... // Set PWM period time (us) 
.................... void pwm_set_period(unsigned int16 period) 
.................... { 
*
01CC6:  MOV     W5,[W15++]
....................    // PWM period 
....................    unsigned int16 pwm_period;  
....................     
....................    // Set the PWM period 
....................    if(period==0) 
01CC8:  CP0     97A
01CCA:  BRA     NZ,1CD2
....................       pwm_period = 0; 
01CCC:  CLR     97C
....................    else 
01CCE:  GOTO    1CDC
....................       pwm_period = 30 * period - 1; 
01CD2:  MOV     97A,W4
01CD4:  MUL.UU  W4,#1E,W0
01CD6:  MOV     W0,W5
01CD8:  SUB     W5,#1,W0
01CDA:  MOV     W0,97C
....................     
....................    // Updates from duty cycle and period buffer registers are disabled 
....................    PWM_PWMCON2_UDIS = 1; 
01CDC:  BSET.B  1CA.0
....................    // Set time base period value 
....................    PWM_PTPER        = pwm_period; 
01CDE:  PUSH    97C
01CE0:  POP     1C4
....................    // Set time base duty cycle if PWM module is enabled (duty cycle > 0%) 
....................    PWM_PDC1         = pwm_period; 
01CE2:  PUSH    97C
01CE4:  POP     1D6
....................    // Updates from duty cycle and period buffer registers are enabled 
....................    PWM_PWMCON2_UDIS = 0; 
01CE6:  BCLR.B  1CA.0
.................... } 
01CE8:  MOV     [--W15],W5
01CEA:  RETURN  
.................... // Disable PWM module 
.................... void pwm_disable() 
.................... { 
....................    // Set duty cycle to zero 
....................    PWM_PDC1=0; 
*
01CFC:  CLR     1D6
....................    // Wait for the last signal 
....................    delay_us(PWM_PTPER + 1 / 30); 
01CFE:  MOV     1C4,W0
01D00:  CALL    1CEC
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN = 0; 
01D04:  BCLR.B  1C1.7
....................    // Set duty cycle to its initial value 
....................    PWM_PDC1=PWM_PTPER; 
01D06:  PUSH    1C4
01D08:  POP     1D6
....................     
....................    if(debug_mode_pwm) 
01D0A:  BTSS.B  8B0.4
01D0C:  BRA     1D26
....................       fprintf(RS232,"PWM Disabled\n\r"); 
01D0E:  MOV     #0,W1
01D10:  MOV     W1,W0
01D12:  CLR.B   1
01D14:  CALL    79E
01D18:  INC     W1,W1
01D1A:  BTSC.B  219.1
01D1C:  BRA     1D1A
01D1E:  MOV     W0,21A
01D20:  MOV     #D,W0
01D22:  CPSGT   W1,W0
01D24:  BRA     1D10
.................... } 
01D26:  RETURN  
.................... // Enable PWM module 
.................... void pwm_enable() 
.................... { 
*
01D70:  MOV     W5,[W15++]
....................    // Disable RS232 receive byte interrupt 
....................    disable_interrupts(INT_RDA2); 
01D72:  BCLR.B  8F.0
....................     
....................    // Enable PWM module 
....................    PWM_PTCON_PTEN = 1; 
01D74:  BSET.B  1C1.7
....................    // Start pwm cycle 
....................    int1 reg_md_running = 1; 
....................    unsigned int md_step_count = 0; 
01D76:  BSET.B  970.0
01D78:  CLR     972
....................     
....................    while(reg_md_running) 
....................    { 
01D7A:  BTSS.B  970.0
01D7C:  BRA     1FAA
....................       if(PWM_IFS2_PWMIF) 
01D7E:  BTSS.B  88.7
01D80:  BRA     1FA6
....................       { 
....................          // Clear the flag register 
....................          PWM_IFS2_PWMIF = 0; 
01D82:  BCLR.B  88.7
....................           
....................          md_step_count++; 
01D84:  INC     0972
....................        
....................          switch(md_run_state)  
....................          { 
01D86:  MOV.B   8B1,W0L
01D88:  CLR.B   1
01D8A:  XOR     #0,W0
01D8C:  BRA     Z,1DA0
01D8E:  XOR     #1,W0
01D90:  BRA     Z,1E48
01D92:  XOR     #2,W0
01D94:  BRA     Z,1EB2
01D96:  XOR     #1,W0
01D98:  BRA     Z,1ED2
01D9A:  XOR     #6,W0
01D9C:  BRA     Z,1F1C
01D9E:  BRA     1FA6
....................             case HOME: 
....................                if(reg_md_home_return == 0) 
01DA0:  BTSC.B  8FC.2
01DA2:  BRA     1E22
....................                { 
....................                   if(reg_md_home == 0) 
01DA4:  BTSC.B  8FC.1
01DA6:  BRA     1DF6
....................                   { 
....................                      if(input(MD_SW)) 
01DA8:  BSET.B  2D3.3
01DAA:  BTSS.B  2D5.3
01DAC:  BRA     1DDE
....................                      { 
....................                         if(md_step_count < md_max_acc_lim) 
01DAE:  MOV     972,W0
01DB0:  MOV     8FE,W4
01DB2:  CP      W4,W0
01DB4:  BRA     LEU,1DCE
....................                         { 
....................                            md_decel_count = md_step_count; 
01DB6:  PUSH    972
01DB8:  POP     8D6
....................                            pwm_set_period(delays[md_step_count]); 
01DBA:  MOV     972,W0
01DBC:  SL      W0,#1,W0
01DBE:  CALL    100
01DC2:  MOV     W0,W5
01DC4:  MOV     W5,97A
01DC6:  CALL    1CC6
....................                         } 
....................                         else 
01DCA:  GOTO    1DDA
....................                         { 
....................                            md_decel_count = md_max_acc_lim; 
01DCE:  PUSH    8FE
01DD0:  POP     8D6
....................                            pwm_set_period(md_min_delay); 
01DD2:  PUSH    8D0
01DD4:  POP     97A
01DD6:  CALL    1CC6
....................                         } 
....................                      } 
....................                      else 
01DDA:  GOTO    1DF2
....................                      { 
....................                         reg_md_home = 1; 
01DDE:  BSET.B  8FC.1
....................                         md_decel_count--; 
01DE0:  DEC     08D6
....................                         pwm_set_period(delays[md_decel_count]); 
01DE2:  MOV     8D6,W0
01DE4:  SL      W0,#1,W0
01DE6:  CALL    100
01DEA:  MOV     W0,W5
01DEC:  MOV     W5,97A
01DEE:  CALL    1CC6
....................                      } 
....................                   } 
....................                   else 
01DF2:  GOTO    1E1E
....................                   { 
....................                      if(md_decel_count == 0) 
01DF6:  CP0     8D6
01DF8:  BRA     NZ,1E0C
....................                      {   
....................                         reg_md_home_return = 1; 
01DFA:  BSET.B  8FC.2
....................                         output_low(MD_DIR); 
01DFC:  BCLR.B  2D8.4
01DFE:  BCLR.B  2DC.4
....................                         pwm_set_period(1000); 
01E00:  MOV     #3E8,W4
01E02:  MOV     W4,97A
01E04:  CALL    1CC6
....................                      } 
....................                      else 
01E08:  GOTO    1E1E
....................                      { 
....................                         md_decel_count--; 
01E0C:  DEC     08D6
....................                         pwm_set_period(delays[md_decel_count]); 
01E0E:  MOV     8D6,W0
01E10:  SL      W0,#1,W0
01E12:  CALL    100
01E16:  MOV     W0,W5
01E18:  MOV     W5,97A
01E1A:  CALL    1CC6
....................                      } 
....................                   } 
....................                } 
....................                else 
01E1E:  GOTO    1E44
....................                { 
....................                   if(input(MD_SW)) 
01E22:  BSET.B  2D3.3
01E24:  BTSS.B  2D5.3
01E26:  BRA     1E44
....................                   { 
....................                      pwm_disable(); 
01E28:  CALL    1CFC
....................                      reg_md_running = 0; 
01E2C:  BCLR.B  970.0
....................                       
....................                      delay_ms(50); 
01E2E:  MOV     #32,W0
01E30:  CALL    137A
....................                      qei_set_count(md_home_offset); 
01E34:  PUSH    8C6
01E36:  POP     978
01E38:  CALL    1D28
....................                      md_mt_set(mt_percent_rest); 
01E3C:  PUSH    8BA
01E3E:  POP     978
01E40:  CALL    1982
....................                   } 
....................                } 
....................                break; 
01E44:  GOTO    1FA6
....................                 
....................             case ACCEL: 
....................                // Check if we should start deceleration. 
....................                if(md_step_count >= md_accel_lim)  
01E48:  MOV     8D4,W0
01E4A:  MOV     972,W4
01E4C:  CP      W4,W0
01E4E:  BRA     NC,1E9E
....................                { 
....................                   if(md_step_count == md_decel_lim) 
01E50:  MOV     972,W0
01E52:  CP      8D2
01E54:  BRA     NZ,1E70
....................                   { 
....................                      md_decel_count--; 
01E56:  DEC     08D6
....................                      pwm_set_period(delays[md_decel_count]); 
01E58:  MOV     8D6,W0
01E5A:  SL      W0,#1,W0
01E5C:  CALL    100
01E60:  MOV     W0,W5
01E62:  MOV     W5,97A
01E64:  CALL    1CC6
....................                      md_run_state = DECEL; 
01E68:  MOV.B   #2,W0L
01E6A:  MOV.B   W0L,8B1
....................                   } 
....................                   else if(md_decel_lim - md_step_count < 2) 
01E6C:  GOTO    1E9A
01E70:  MOV     8D2,W4
01E72:  MOV     972,W3
01E74:  SUB     W4,W3,W5
01E76:  CP      W5,#2
01E78:  BRA     C,1E8E
....................                   { 
....................                      pwm_set_period(delays[md_step_count]); 
01E7A:  MOV     972,W0
01E7C:  SL      W0,#1,W0
01E7E:  CALL    100
01E82:  MOV     W0,W5
01E84:  MOV     W5,97A
01E86:  CALL    1CC6
....................                   } 
....................                   else 
01E8A:  GOTO    1E9A
....................                   { 
....................                      pwm_set_period(md_min_delay); 
01E8E:  PUSH    8D0
01E90:  POP     97A
01E92:  CALL    1CC6
....................                      md_run_state = RUN; 
01E96:  MOV.B   #3,W0L
01E98:  MOV.B   W0L,8B1
....................                   } 
....................                } 
....................                else 
01E9A:  GOTO    1EAE
....................                { 
....................                   pwm_set_period(delays[md_step_count]); 
01E9E:  MOV     972,W0
01EA0:  SL      W0,#1,W0
01EA2:  CALL    100
01EA6:  MOV     W0,W5
01EA8:  MOV     W5,97A
01EAA:  CALL    1CC6
....................                } 
....................                break; 
01EAE:  GOTO    1FA6
....................        
....................             case RUN: 
....................                // Check if we should start decelration. 
....................                if(md_step_count == md_decel_lim)  
01EB2:  MOV     972,W0
01EB4:  CP      8D2
01EB6:  BRA     NZ,1ECE
....................                { 
....................                   md_decel_count--; 
01EB8:  DEC     08D6
....................                   pwm_set_period(delays[md_decel_count]); 
01EBA:  MOV     8D6,W0
01EBC:  SL      W0,#1,W0
01EBE:  CALL    100
01EC2:  MOV     W0,W5
01EC4:  MOV     W5,97A
01EC6:  CALL    1CC6
....................                   md_run_state = DECEL; 
01ECA:  MOV.B   #2,W0L
01ECC:  MOV.B   W0L,8B1
....................                } 
....................                break; 
01ECE:  GOTO    1FA6
....................        
....................             case DECEL: 
....................                // Check if we at last step 
....................                if(md_decel_count == 0) 
01ED2:  CP0     8D6
01ED4:  BRA     NZ,1F06
....................                { 
....................                   pwm_disable(); 
01ED6:  CALL    1CFC
....................                   md_pos_iter = 0; 
01EDA:  CLR     8D8
....................                   md_run_state = POS; 
01EDC:  MOV.B   #4,W0L
01EDE:  MOV.B   W0L,8B1
....................                    
....................                   delay_ms(50); 
01EE0:  MOV     #32,W0
01EE2:  CALL    137A
....................  
....................                   md_error = md_target_count - qei_get_count(); 
01EE6:  CALL    1D6A
01EEA:  MOV     8CA,W4
01EEC:  SUB     W4,W0,W0
01EEE:  MOV     W0,8DA
....................                    
....................                   if(md_error > 1) 
01EF0:  MOV     8DA,W4
01EF2:  CP      W4,#1
01EF4:  BRA     LE,1EFE
....................                      output_low(MD_DIR); 
01EF6:  BCLR.B  2D8.4
01EF8:  BCLR.B  2DC.4
....................                   else 
01EFA:  GOTO    1F02
....................                      output_high(MD_DIR); 
01EFE:  BCLR.B  2D8.4
01F00:  BSET.B  2DC.4
....................                } 
....................                else 
01F02:  GOTO    1F18
....................                { 
....................                   md_decel_count--; 
01F06:  DEC     08D6
....................                   pwm_set_period(delays[md_decel_count]); 
01F08:  MOV     8D6,W0
01F0A:  SL      W0,#1,W0
01F0C:  CALL    100
01F10:  MOV     W0,W5
01F12:  MOV     W5,97A
01F14:  CALL    1CC6
....................                } 
....................                break; 
01F18:  GOTO    1FA6
....................                 
....................             case POS: 
....................                md_pos_iter++; 
01F1C:  INC     08D8
....................                 
....................                delay_ms(50); 
01F1E:  MOV     #32,W0
01F20:  CALL    137A
....................                 
....................                if(reg_md_cc_sample) 
01F24:  BTSS.B  8FC.4
01F26:  BRA     1F3A
....................                { 
....................                   reg_md_cc_sample = 0; 
01F28:  BCLR.B  8FC.4
....................                   delay_ms(50); 
01F2A:  MOV     #32,W0
01F2C:  CALL    137A
....................                   md_cc_step = md_step_count; 
01F30:  PUSH    972
01F32:  POP     8DE
....................                   md_cc_count = qei_get_count(); 
01F34:  CALL    1D6A
01F38:  MOV     W0,8E0
....................                } 
....................  
....................                int difference; 
....................                 
....................                if(md_error < 1) 
01F3A:  MOV     8DA,W4
01F3C:  CP      W4,#1
01F3E:  BRA     GE,1F50
....................                   difference = qei_get_count() - md_target_count; 
01F40:  CALL    1D6A
01F44:  MOV     W0,W5
01F46:  MOV     8CA,W4
01F48:  SUB     W5,W4,W0
01F4A:  MOV     W0,974
....................                else 
01F4C:  GOTO    1F5A
....................                   difference = md_target_count - qei_get_count(); 
01F50:  CALL    1D6A
01F54:  MOV     8CA,W4
01F56:  SUB     W4,W0,W0
01F58:  MOV     W0,974
....................  
....................                if((difference < 1)||(md_pos_iter > 50)) 
01F5A:  MOV     974,W4
01F5C:  CP      W4,#1
01F5E:  BRA     LT,1F68
01F60:  MOV     8D8,W4
01F62:  MOV     #32,W3
01F64:  CP      W3,W4
01F66:  BRA     C,1F7A
....................                { 
....................                   pwm_disable(); 
01F68:  CALL    1CFC
....................                   reg_md_running = 0; 
01F6C:  BCLR.B  970.0
....................                   md_mt_set(mt_percent_rest); 
01F6E:  PUSH    8BA
01F70:  POP     978
01F72:  CALL    1982
....................                } 
....................                else 
01F76:  GOTO    1FA2
....................                { 
....................                   if(md_target_count > qei_get_count()) 
01F7A:  CALL    1D6A
01F7E:  MOV     8CA,W4
01F80:  CP      W4,W0
01F82:  BRA     LEU,1F8C
....................                      output_low(MD_DIR); 
01F84:  BCLR.B  2D8.4
01F86:  BCLR.B  2DC.4
....................                   else 
01F88:  GOTO    1F90
....................                      output_high(MD_DIR); 
01F8C:  BCLR.B  2D8.4
01F8E:  BSET.B  2DC.4
....................                          
....................                   pwm_set_period(1000); 
01F90:  MOV     #3E8,W4
01F92:  MOV     W4,97A
01F94:  CALL    1CC6
....................                   pwm_select_mode(SINGLE); 
01F98:  MOV     #1,W4
01F9A:  MOV     W4,978
01F9C:  CALL    13DA
....................                   // Enable PWM module 
....................                   PWM_PTCON_PTEN = 1; 
01FA0:  BSET.B  1C1.7
....................                } 
....................                break; 
01FA2:  GOTO    1FA6
....................          } 
....................       } 
....................    } 
01FA6:  GOTO    1D7A
....................  
....................    // Enable RS232 receive byte interrupt 
....................    clear_interrupt(INT_RDA2); 
01FAA:  REPEAT  #3
01FAC:  MOV     21C,W0
01FAE:  BCLR.B  87.0
....................    enable_interrupts(INT_RDA2); 
01FB0:  BSET.B  8F.0
....................    reg_rs232_message = 0; 
01FB2:  BCLR.B  8FC.3
.................... } 
01FB4:  MOV     [--W15],W5
01FB6:  RETURN  
....................  
.................... // Move to given position (encoder count) 
.................... void move_to(unsigned int count) 
.................... { 
*
025E8:  MOV     W5,[W15++]
025EA:  MOV     W6,[W15++]
025EC:  CALL    1D6A
025F0:  MOV     W0,96C
....................    // Calculate the number of steps 
....................    unsigned int displ;             
....................    // Calculate the current motor step by using current encoder count 
....................    unsigned int current_count = qei_get_count(); 
....................    // Calculate the target motor step by using given encoder step 
....................    md_target_count = count;  
025F2:  PUSH    968
025F4:  POP     8CA
....................     
....................    // Set direction 
....................    if(md_target_count > current_count) 
025F6:  MOV     96C,W0
025F8:  MOV     8CA,W4
025FA:  CP      W4,W0
025FC:  BRA     LEU,260E
....................    { 
....................       output_low(MD_DIR); 
025FE:  BCLR.B  2D8.4
02600:  BCLR.B  2DC.4
....................       displ = md_target_count - current_count; 
02602:  MOV     8CA,W4
02604:  MOV     96C,W3
02606:  SUB     W4,W3,W0
02608:  MOV     W0,96A
....................    } 
....................    else 
0260A:  GOTO    261A
....................    { 
....................       output_high(MD_DIR); 
0260E:  BCLR.B  2D8.4
02610:  BSET.B  2DC.4
....................       displ = current_count - md_target_count; 
02612:  MOV     96C,W4
02614:  MOV     8CA,W3
02616:  SUB     W4,W3,W0
02618:  MOV     W0,96A
....................    } 
....................     
....................    displ = (long)displ * 10000 / md_conv_const; 
0261A:  MOV     96A,W5
0261C:  MOV     #0,W6
0261E:  MOV     W5,W0
02620:  MOV     W6,W1
02622:  MOV     #2710,W2
02624:  MOV     #0,W3
02626:  CALL    2528
0262A:  MOV     W0,W5
0262C:  MOV     W1,W6
0262E:  BCLR.B  43.0
02630:  MOV     W5,W0
02632:  MOV     W6,W1
02634:  MOV     8BC,W2
02636:  MOV     #0,W3
02638:  CALL    256A
0263C:  MOV     W0,96A
....................     
....................    if(debug_mode_pwm) 
0263E:  BTSS.B  8B0.4
02640:  BRA     2672
....................       fprintf(RS232,"Displacement: %u\n\r", displ); 
02642:  MOV     #0,W1
02644:  MOV     W1,W0
02646:  CLR.B   1
02648:  CALL    7BA
0264C:  INC     W1,W1
0264E:  BTSC.B  219.1
02650:  BRA     264E
02652:  MOV     W0,21A
02654:  MOV     #D,W0
02656:  CPSGT   W1,W0
02658:  BRA     2644
0265A:  MOV     96A,W0
0265C:  MOV     #0,W4
0265E:  CALL    143A
02662:  BTSC.B  219.1
02664:  BRA     2662
02666:  MOV     #A,W4
02668:  MOV     W4,21A
0266A:  BTSC.B  219.1
0266C:  BRA     266A
0266E:  MOV     #D,W4
02670:  MOV     W4,21A
....................     
....................    // If displacement is zero than no need to move 
....................    if(displ == 0) 
02672:  CP0     96A
02674:  BRA     NZ,2678
....................       return; 
02676:  BRA     27AA
....................        
....................    // Find out after how many steps we must start deceleration. 
....................    md_accel_lim = ((long)displ * md_decel) / (md_accel + md_decel); 
02678:  MOV     96A,W5
0267A:  MOV     #0,W6
0267C:  MOV     W5,W0
0267E:  MOV     W6,W1
02680:  MOV     8CE,W2
02682:  MOV     #0,W3
02684:  CALL    2528
02688:  MOV     W0,W5
0268A:  MOV     W1,W6
0268C:  MOV     8CC,W0
0268E:  ADD     8CE,W0
02690:  BCLR.B  43.0
02692:  MOV     W6,W1
02694:  MOV     W0,W2
02696:  MOV     #0,W3
02698:  MOV     W5,W0
0269A:  CALL    256A
0269E:  MOV     W0,8D4
....................    // We must accelerate at least 1 step before we can start deceleration. 
....................    if(md_accel_lim == 0) 
026A0:  CP0     8D4
026A2:  BRA     NZ,26A8
....................       md_accel_lim = 1; 
026A4:  MOV     #1,W4
026A6:  MOV     W4,8D4
....................     
....................    // Use the limit we hit first to calc decel. 
....................    if(md_accel_lim >= md_max_acc_lim) 
026A8:  MOV     8FE,W0
026AA:  MOV     8D4,W4
026AC:  CP      W4,W0
026AE:  BRA     NC,26E4
....................    { 
....................       md_accel_lim = md_max_acc_lim; 
026B0:  PUSH    8FE
026B2:  POP     8D4
....................        
....................       // Find step to start decleration. 
....................       md_decel_count = ((long)md_max_acc_lim * md_accel) / md_decel; 
026B4:  MOV     8FE,W5
026B6:  MOV     #0,W6
026B8:  MOV     W5,W0
026BA:  MOV     W6,W1
026BC:  MOV     8CC,W2
026BE:  MOV     #0,W3
026C0:  CALL    2528
026C4:  MOV     W0,W5
026C6:  MOV     W1,W6
026C8:  BCLR.B  43.0
026CA:  MOV     W5,W0
026CC:  MOV     W6,W1
026CE:  MOV     8CE,W2
026D0:  MOV     #0,W3
026D2:  CALL    256A
026D6:  MOV     W0,8D6
....................       md_decel_lim = displ - md_decel_count;  
026D8:  MOV     96A,W4
026DA:  MOV     8D6,W3
026DC:  SUB     W4,W3,W0
026DE:  MOV     W0,8D2
....................    } 
....................    else 
026E0:  GOTO    26F0
....................    { 
....................       md_decel_lim = displ - md_accel_lim; 
026E4:  MOV     96A,W4
026E6:  MOV     8D4,W3
026E8:  SUB     W4,W3,W0
026EA:  MOV     W0,8D2
....................       md_decel_count = md_accel_lim; 
026EC:  PUSH    8D4
026EE:  POP     8D6
....................    } 
....................     
....................    // We must decelerate at least 1 step to stop. 
....................    if(md_decel_lim == 0) 
026F0:  CP0     8D2
026F2:  BRA     NZ,26F8
....................       md_decel_lim = 1; 
026F4:  MOV     #1,W4
026F6:  MOV     W4,8D2
....................  
....................    if(debug_mode_pwm) 
026F8:  BTSS.B  8B0.4
026FA:  BRA     278C
....................    { 
....................       fprintf(RS232,"Acceleration Limit: %u\n\r", md_accel_lim); 
026FC:  MOV     #0,W1
026FE:  MOV     W1,W0
02700:  CLR.B   1
02702:  CALL    7DA
02706:  INC     W1,W1
02708:  BTSC.B  219.1
0270A:  BRA     2708
0270C:  MOV     W0,21A
0270E:  MOV     #13,W0
02710:  CPSGT   W1,W0
02712:  BRA     26FE
02714:  MOV     8D4,W0
02716:  MOV     #0,W4
02718:  CALL    143A
0271C:  BTSC.B  219.1
0271E:  BRA     271C
02720:  MOV     #A,W4
02722:  MOV     W4,21A
02724:  BTSC.B  219.1
02726:  BRA     2724
02728:  MOV     #D,W4
0272A:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Limit: %u\n\r", md_decel_lim); 
0272C:  MOV     #0,W1
0272E:  MOV     W1,W0
02730:  CLR.B   1
02732:  CALL    800
02736:  INC     W1,W1
02738:  BTSC.B  219.1
0273A:  BRA     2738
0273C:  MOV     W0,21A
0273E:  MOV     #13,W0
02740:  CPSGT   W1,W0
02742:  BRA     272E
02744:  MOV     8D2,W0
02746:  MOV     #0,W4
02748:  CALL    143A
0274C:  BTSC.B  219.1
0274E:  BRA     274C
02750:  MOV     #A,W4
02752:  MOV     W4,21A
02754:  BTSC.B  219.1
02756:  BRA     2754
02758:  MOV     #D,W4
0275A:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Count: %u\n\r", md_decel_count); 
0275C:  MOV     #0,W1
0275E:  MOV     W1,W0
02760:  CLR.B   1
02762:  CALL    826
02766:  INC     W1,W1
02768:  BTSC.B  219.1
0276A:  BRA     2768
0276C:  MOV     W0,21A
0276E:  MOV     #13,W0
02770:  CPSGT   W1,W0
02772:  BRA     275E
02774:  MOV     8D6,W0
02776:  MOV     #0,W4
02778:  CALL    143A
0277C:  BTSC.B  219.1
0277E:  BRA     277C
02780:  MOV     #A,W4
02782:  MOV     W4,21A
02784:  BTSC.B  219.1
02786:  BRA     2784
02788:  MOV     #D,W4
0278A:  MOV     W4,21A
....................    } 
....................  
....................    md_run_state = ACCEL; 
0278C:  MOV.B   #1,W0L
0278E:  MOV.B   W0L,8B1
....................    md_mt_set(mt_percent_trip); 
02790:  PUSH    8B8
02792:  POP     978
02794:  CALL    1982
....................  
....................    pwm_set_period(delays[0]); 
02798:  MOV     #7D0,W4
0279A:  MOV     W4,97A
0279C:  CALL    1CC6
....................    pwm_select_mode(FREE); 
027A0:  CLR     978
027A2:  CALL    13DA
....................    pwm_enable(); 
027A6:  CALL    1D70
.................... } 
027AA:  MOV     [--W15],W6
027AC:  MOV     [--W15],W5
027AE:  RETURN  
.................... // Move to given position (mm) 
.................... void move_pos(unsigned int16 position) 
.................... { 
*
028A6:  MOV     W5,[W15++]
028A8:  MOV     #C,W5
028AA:  REPEAT  #4
028AC:  MOV     [W5++],[W15++]
....................    if(position>md_move_range) 
028AE:  MOV     8BE,W0
028B0:  MOV     962,W4
028B2:  CP      W4,W0
028B4:  BRA     LEU,28DA
....................    { 
....................       position=md_move_range; 
028B6:  PUSH    8BE
028B8:  POP     962
....................       if(debug_mode_md) 
028BA:  BTSS.B  8B0.3
028BC:  BRA     28D6
....................          fprintf(RS232, "Invalid entry: System cannot move to a position beyond the movement range. System will move to maximum possible distance."); 
028BE:  MOV     #0,W1
028C0:  MOV     W1,W0
028C2:  CLR.B   1
028C4:  CALL    84C
028C8:  INC     W1,W1
028CA:  BTSC.B  219.1
028CC:  BRA     28CA
028CE:  MOV     W0,21A
028D0:  MOV     #78,W0
028D2:  CPSGT   W1,W0
028D4:  BRA     28C0
....................    } 
....................    else if(position<md_min_distance) 
028D6:  GOTO    2922
028DA:  MOV     962,W0
028DC:  MOV     8C8,W4
028DE:  CP      W4,W0
028E0:  BRA     LEU,2922
....................    { 
....................       position=md_min_distance; 
028E2:  PUSH    8C8
028E4:  POP     962
....................       if(debug_mode_md) 
028E6:  BTSS.B  8B0.3
028E8:  BRA     2922
....................          fprintf(RS232, "Invalid entry: System cannot move to a position smaller than %u mm. System will move to minimum possible distance.", md_min_distance); 
028EA:  MOV     #0,W1
028EC:  MOV     W1,W0
028EE:  CLR.B   1
028F0:  CALL    8BA
028F4:  INC     W1,W1
028F6:  BTSC.B  219.1
028F8:  BRA     28F6
028FA:  MOV     W0,21A
028FC:  MOV     #3C,W0
028FE:  CPSGT   W1,W0
02900:  BRA     28EC
02902:  MOV     8C8,W0
02904:  MOV     #0,W4
02906:  CALL    143A
0290A:  MOV     #3F,W1
0290C:  MOV     W1,W0
0290E:  CLR.B   1
02910:  CALL    8BA
02914:  INC     W1,W1
02916:  BTSC.B  219.1
02918:  BRA     2916
0291A:  MOV     W0,21A
0291C:  MOV     #71,W0
0291E:  CPSGT   W1,W0
02920:  BRA     290C
....................    } 
....................     
....................    fprintf(RS232,"\n\rTarget Position: %u mm\n\r", position); 
02922:  MOV     #0,W1
02924:  MOV     W1,W0
02926:  CLR.B   1
02928:  CALL    924
0292C:  INC     W1,W1
0292E:  BTSC.B  219.1
02930:  BRA     292E
02932:  MOV     W0,21A
02934:  MOV     #12,W0
02936:  CPSGT   W1,W0
02938:  BRA     2924
0293A:  MOV     962,W0
0293C:  MOV     #0,W4
0293E:  CALL    143A
02942:  MOV     #15,W1
02944:  MOV     W1,W0
02946:  CLR.B   1
02948:  CALL    924
0294C:  INC     W1,W1
0294E:  BTSC.B  219.1
02950:  BRA     294E
02952:  MOV     W0,21A
02954:  MOV     #19,W0
02956:  CPSGT   W1,W0
02958:  BRA     2944
....................  
....................    data_set_last_pos(position); 
0295A:  PUSH    962
0295C:  POP     968
0295E:  CALL    217C
....................     
....................    unsigned int16 count = md_end_pos-((float)(position-md_min_distance)/2.0f)*((float)(md_end_pos-md_home_pos)/((float)(md_move_range-md_min_distance)/2.0f)); 
02962:  MOV     962,W4
02964:  MOV     8C8,W3
02966:  SUB     W4,W3,W0
02968:  CALL    218A
0296C:  MOV     W0,W5
0296E:  MOV     W1,W6
02970:  MOV     W5,W0
02972:  MOV     W6,W1
02974:  MOV     #0,W2
02976:  MOV     #4000,W3
02978:  CALL    21C4
0297C:  MOV     W0,W5
0297E:  MOV     W1,W6
02980:  MOV     8C2,W4
02982:  MOV     8C0,W3
02984:  SUB     W4,W3,W0
02986:  CALL    218A
0298A:  MOV     W0,W7
0298C:  MOV     W1,W8
0298E:  MOV     8BE,W4
02990:  MOV     8C8,W3
02992:  SUB     W4,W3,W0
02994:  CALL    218A
02998:  MOV     W0,W9
0299A:  MOV     W1,W10
0299C:  MOV     W9,W0
0299E:  MOV     W10,W1
029A0:  MOV     #0,W2
029A2:  MOV     #4000,W3
029A4:  CALL    21C4
029A8:  MOV     W0,W2
029AA:  MOV     W1,W3
029AC:  MOV     W7,W0
029AE:  MOV     W8,W1
029B0:  CALL    21C4
029B4:  MOV     W0,W2
029B6:  MOV     W1,W3
029B8:  MOV     W5,W0
029BA:  MOV     W6,W1
029BC:  CALL    228E
029C0:  MOV     W0,W5
029C2:  MOV     W1,W6
029C4:  MOV     8C2,W0
029C6:  CALL    218A
029CA:  BSET.B  43.0
029CC:  MOV     W5,W2
029CE:  MOV     W6,W3
029D0:  CALL    2352
029D4:  CALL    24FC
029D8:  MOV     W0,964
....................     
....................    if(qei_get_count() < count) 
029DA:  CALL    1D6A
029DE:  MOV     W0,W5
029E0:  MOV     964,W4
029E2:  CP      W4,W5
029E4:  BRA     LEU,29EE
....................       count-=md_backlash; 
029E6:  MOV     964,W4
029E8:  MOV     8DC,W3
029EA:  SUB     W4,W3,W0
029EC:  MOV     W0,964
....................     
....................    move_to(count); 
029EE:  PUSH    964
029F0:  POP     968
029F2:  CALL    25E8
....................     
....................    delay_ms(100); 
029F6:  MOV     #64,W0
029F8:  CALL    137A
....................     
....................    if(debug_mode_md) 
029FC:  BTSS.B  8B0.3
029FE:  BRA     2AF6
....................    { 
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02A00:  MOV     #0,W1
02A02:  MOV     W1,W0
02A04:  CLR.B   1
02A06:  CALL    94C
02A0A:  INC     W1,W1
02A0C:  BTSC.B  219.1
02A0E:  BRA     2A0C
02A10:  MOV     W0,21A
02A12:  MOV     #E,W0
02A14:  CPSGT   W1,W0
02A16:  BRA     2A02
02A18:  MOV     8DA,W0
02A1A:  MOV     #0,W4
02A1C:  CALL    27B0
02A20:  BTSC.B  219.1
02A22:  BRA     2A20
02A24:  MOV     #A,W4
02A26:  MOV     W4,21A
02A28:  BTSC.B  219.1
02A2A:  BRA     2A28
02A2C:  MOV     #D,W4
02A2E:  MOV     W4,21A
....................       fprintf(RS232,"Target Encoder count: %u\n\r",md_target_count); 
02A30:  MOV     #0,W1
02A32:  MOV     W1,W0
02A34:  CLR.B   1
02A36:  CALL    96C
02A3A:  INC     W1,W1
02A3C:  BTSC.B  219.1
02A3E:  BRA     2A3C
02A40:  MOV     W0,21A
02A42:  MOV     #15,W0
02A44:  CPSGT   W1,W0
02A46:  BRA     2A32
02A48:  MOV     8CA,W0
02A4A:  MOV     #0,W4
02A4C:  CALL    143A
02A50:  BTSC.B  219.1
02A52:  BRA     2A50
02A54:  MOV     #A,W4
02A56:  MOV     W4,21A
02A58:  BTSC.B  219.1
02A5A:  BRA     2A58
02A5C:  MOV     #D,W4
02A5E:  MOV     W4,21A
....................       fprintf(RS232,"Current Encoder count: %u\n\r",qei_get_count()); 
02A60:  CALL    1D6A
02A64:  MOV     W0,W5
02A66:  MOV     #0,W1
02A68:  MOV     W1,W0
02A6A:  CLR.B   1
02A6C:  CALL    994
02A70:  INC     W1,W1
02A72:  BTSC.B  219.1
02A74:  BRA     2A72
02A76:  MOV     W0,21A
02A78:  MOV     #16,W0
02A7A:  CPSGT   W1,W0
02A7C:  BRA     2A68
02A7E:  MOV     W5,W0
02A80:  MOV     #0,W4
02A82:  CALL    143A
02A86:  BTSC.B  219.1
02A88:  BRA     2A86
02A8A:  MOV     #A,W4
02A8C:  MOV     W4,21A
02A8E:  BTSC.B  219.1
02A90:  BRA     2A8E
02A92:  MOV     #D,W4
02A94:  MOV     W4,21A
....................       fprintf(RS232,"Number of Iterations: %u\n\r",md_pos_iter); 
02A96:  MOV     #0,W1
02A98:  MOV     W1,W0
02A9A:  CLR.B   1
02A9C:  CALL    9BC
02AA0:  INC     W1,W1
02AA2:  BTSC.B  219.1
02AA4:  BRA     2AA2
02AA6:  MOV     W0,21A
02AA8:  MOV     #15,W0
02AAA:  CPSGT   W1,W0
02AAC:  BRA     2A98
02AAE:  MOV     8D8,W0
02AB0:  MOV     #0,W4
02AB2:  CALL    143A
02AB6:  BTSC.B  219.1
02AB8:  BRA     2AB6
02ABA:  MOV     #A,W4
02ABC:  MOV     W4,21A
02ABE:  BTSC.B  219.1
02AC0:  BRA     2ABE
02AC2:  MOV     #D,W4
02AC4:  MOV     W4,21A
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02AC6:  MOV     #0,W1
02AC8:  MOV     W1,W0
02ACA:  CLR.B   1
02ACC:  CALL    94C
02AD0:  INC     W1,W1
02AD2:  BTSC.B  219.1
02AD4:  BRA     2AD2
02AD6:  MOV     W0,21A
02AD8:  MOV     #E,W0
02ADA:  CPSGT   W1,W0
02ADC:  BRA     2AC8
02ADE:  MOV     8DA,W0
02AE0:  MOV     #0,W4
02AE2:  CALL    27B0
02AE6:  BTSC.B  219.1
02AE8:  BRA     2AE6
02AEA:  MOV     #A,W4
02AEC:  MOV     W4,21A
02AEE:  BTSC.B  219.1
02AF0:  BRA     2AEE
02AF2:  MOV     #D,W4
02AF4:  MOV     W4,21A
....................    } 
....................     
....................    fprintf(RS232,"Error: %d\n\r",(int)qei_get_count()-(int)md_target_count); 
02AF6:  CALL    1D6A
02AFA:  MOV     W0,W5
02AFC:  MOV     8CA,W4
02AFE:  SUB     W5,W4,W5
02B00:  MOV     #0,W1
02B02:  MOV     W1,W0
02B04:  CLR.B   1
02B06:  CALL    9E4
02B0A:  INC     W1,W1
02B0C:  BTSC.B  219.1
02B0E:  BRA     2B0C
02B10:  MOV     W0,21A
02B12:  MOV     #6,W0
02B14:  CPSGT   W1,W0
02B16:  BRA     2B02
02B18:  MOV     W5,W0
02B1A:  MOV     #0,W4
02B1C:  CALL    27B0
02B20:  BTSC.B  219.1
02B22:  BRA     2B20
02B24:  MOV     #A,W4
02B26:  MOV     W4,21A
02B28:  BTSC.B  219.1
02B2A:  BRA     2B28
02B2C:  MOV     #D,W4
02B2E:  MOV     W4,21A
.................... } 
02B30:  MOV     #14,W5
02B32:  REPEAT  #4
02B34:  MOV     [--W15],[W5--]
02B36:  MOV     [--W15],W5
02B38:  RETURN  
.................... // Homing Function 
.................... void move_home() 
.................... { 
....................    fprintf(RS232,"Homing...\n\r");    
*
01FB8:  MOV     #0,W1
01FBA:  MOV     W1,W0
01FBC:  CLR.B   1
01FBE:  CALL    9FC
01FC2:  INC     W1,W1
01FC4:  BTSC.B  219.1
01FC6:  BRA     1FC4
01FC8:  MOV     W0,21A
01FCA:  MOV     #A,W0
01FCC:  CPSGT   W1,W0
01FCE:  BRA     1FBA
....................     
....................    md_run_state = HOME; 
01FD0:  CLR.B   8B1
....................    md_decel_count = 0; 
01FD2:  CLR     8D6
....................    reg_md_home = 0; 
01FD4:  BCLR.B  8FC.1
....................    reg_md_home_return = 0; 
01FD6:  BCLR.B  8FC.2
....................     
....................    output_high(MD_DIR); 
01FD8:  BCLR.B  2D8.4
01FDA:  BSET.B  2DC.4
....................    md_mt_set(mt_percent_trip); 
01FDC:  PUSH    8B8
01FDE:  POP     978
01FE0:  CALL    1982
....................  
....................    pwm_set_period(delays[0]); 
01FE4:  MOV     #7D0,W4
01FE6:  MOV     W4,97A
01FE8:  CALL    1CC6
....................    pwm_select_mode(FREE); 
01FEC:  CLR     978
01FEE:  CALL    13DA
....................    pwm_enable(); 
01FF2:  CALL    1D70
.................... } 
01FF6:  RETURN  
.................... // Initializes the system for movement 
.................... void move_init() 
.................... { 
*
02B3A:  MOV     W5,[W15++]
....................    md_move_range = data_get_move_range(); 
02B3C:  CALL    1AF4
02B40:  MOV     W0,8BE
....................    md_home_pos = data_get_home_pos(); 
02B42:  CALL    1B40
02B46:  MOV     W0,8C0
....................    md_end_pos = data_get_end_pos(); 
02B48:  CALL    1B8C
02B4C:  MOV     W0,8C2
....................    md_backlash = data_get_backlash(); 
02B4E:  CALL    1BD8
02B52:  MOV     W0,8DC
....................    qei_set_max_count(md_end_pos+md_end_offset); 
02B54:  MOV     8C2,W0
02B56:  ADD     8C4,W0
02B58:  MOV     W0,W5
02B5A:  MOV     W5,906
02B5C:  CALL    1C24
....................    md_conv_const = data_get_conv_const(); 
02B60:  CALL    1C66
02B64:  MOV     W0,8BC
....................     
....................    if(md_move_range==2000) 
02B66:  MOV     8BE,W4
02B68:  MOV     #7D0,W3
02B6A:  CP      W3,W4
02B6C:  BRA     NZ,2B72
....................       md_min_distance=120; 
02B6E:  MOV     #78,W4
02B70:  MOV     W4,8C8
....................           
....................    move_home();                        // Move to home position 
02B72:  CALL    1FB8
....................     
....................    delay_ms(500); 
02B76:  MOV     #1F4,W0
02B78:  CALL    137A
....................        
....................    if(debug_mode_md) 
02B7C:  BTSS.B  8B0.3
02B7E:  BRA     2BBE
....................       fprintf(RS232,"Moving Last Position: %u mm\n\r", data_get_last_pos()); 
02B80:  CALL    1FF8
02B84:  MOV     W0,W5
02B86:  MOV     #0,W1
02B88:  MOV     W1,W0
02B8A:  CLR.B   1
02B8C:  CALL    A14
02B90:  INC     W1,W1
02B92:  BTSC.B  219.1
02B94:  BRA     2B92
02B96:  MOV     W0,21A
02B98:  MOV     #15,W0
02B9A:  CPSGT   W1,W0
02B9C:  BRA     2B88
02B9E:  MOV     W5,W0
02BA0:  MOV     #0,W4
02BA2:  CALL    143A
02BA6:  MOV     #18,W1
02BA8:  MOV     W1,W0
02BAA:  CLR.B   1
02BAC:  CALL    A14
02BB0:  INC     W1,W1
02BB2:  BTSC.B  219.1
02BB4:  BRA     2BB2
02BB6:  MOV     W0,21A
02BB8:  MOV     #1C,W0
02BBA:  CPSGT   W1,W0
02BBC:  BRA     2BA8
....................  
....................    move_pos(data_get_last_pos()); 
02BBE:  CALL    1FF8
02BC2:  MOV     W0,W5
02BC4:  MOV     W5,962
02BC6:  CALL    28A6
.................... } 
02BCA:  MOV     [--W15],W5
02BCC:  RETURN  
....................  
.................... //Gets byte via parallel port 
.................... unsigned int pp_get_byte() 
.................... { 
*
03D54:  MOV     W5,[W15++]
03D56:  CLR     904
03D58:  CLR     906
03D5A:  CLR     908
03D5C:  CLR     90A
03D5E:  CLR     90C
03D60:  CLR     90E
03D62:  CLR     910
03D64:  CLR     912
03D66:  CLR     914
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................     
....................    D7=(!input(PP_D7))*1; 
03D68:  BSET.B  2D2.3
03D6A:  CLR     906
03D6C:  BTSS.B  2D4.3
03D6E:  INC     0906
....................    D6=(!input(PP_D6))*1; 
03D70:  BSET.B  2D2.2
03D72:  CLR     908
03D74:  BTSS.B  2D4.2
03D76:  INC     0908
....................    D5=(!input(PP_D5))*1; 
03D78:  BSET.B  2D2.1
03D7A:  CLR     90A
03D7C:  BTSS.B  2D4.1
03D7E:  INC     090A
....................    D4=(!input(PP_D4))*1; 
03D80:  BSET.B  2CD.6
03D82:  CLR     90C
03D84:  BTSS.B  2CF.6
03D86:  INC     090C
....................    D3=(!input(PP_D3))*1; 
03D88:  BSET.B  2CD.5
03D8A:  CLR     90E
03D8C:  BTSS.B  2CF.5
03D8E:  INC     090E
....................    D2=(!input(PP_D2))*1; 
03D90:  BSET.B  2D2.0
03D92:  CLR     910
03D94:  BTSS.B  2D4.0
03D96:  INC     0910
....................    D1=(!input(PP_D1))*1; 
03D98:  BSET.B  2D3.1
03D9A:  CLR     912
03D9C:  BTSS.B  2D5.1
03D9E:  INC     0912
....................    D0=(!input(PP_D0))*1; 
03DA0:  BSET.B  2D3.0
03DA2:  CLR     914
03DA4:  BTSS.B  2D5.0
03DA6:  INC     0914
....................     
....................     
....................     
....................    data=(D7<<7)+(D6<<6)+(D5<<5)+(D4<<4)+(D3<<3)+(D2<<2)+(D1<<1)+D0; 
03DA8:  MOV     906,W5
03DAA:  SL      W5,#7,W5
03DAC:  MOV     908,W0
03DAE:  SL      W0,#6,W0
03DB0:  ADD     W0,W5,W5
03DB2:  MOV     90A,W0
03DB4:  SL      W0,#5,W0
03DB6:  ADD     W0,W5,W5
03DB8:  MOV     90C,W0
03DBA:  SL      W0,#4,W0
03DBC:  ADD     W0,W5,W5
03DBE:  MOV     90E,W0
03DC0:  SL      W0,#3,W0
03DC2:  ADD     W0,W5,W5
03DC4:  MOV     910,W0
03DC6:  SL      W0,#2,W0
03DC8:  ADD     W0,W5,W5
03DCA:  MOV     912,W0
03DCC:  SL      W0,#1,W0
03DCE:  ADD     W0,W5,W5
03DD0:  MOV     W5,W0
03DD2:  ADD     914,W0
03DD4:  MOV     W0,904
....................  
....................    return data; 
03DD6:  PUSH    904
03DD8:  POP     0
.................... } 
03DDA:  MOV     [--W15],W5
03DDC:  RETURN  
.................... //Gets BCD byte via parallel port 
.................... unsigned int pp_get_BCD_byte() 
.................... { 
*
03E6C:  MOV     W5,[W15++]
03E6E:  CLR     90C
03E70:  CLR     90E
03E72:  CLR     910
03E74:  CLR     912
03E76:  CLR     914
03E78:  CLR     916
03E7A:  CLR     918
03E7C:  CLR     91A
03E7E:  CLR     91C
03E80:  CLR     91E
03E82:  CLR     920
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    D7=(!input(PP_D7))*1; 
03E84:  BSET.B  2D2.3
03E86:  CLR     90E
03E88:  BTSS.B  2D4.3
03E8A:  INC     090E
....................    D6=(!input(PP_D6))*1; 
03E8C:  BSET.B  2D2.2
03E8E:  CLR     910
03E90:  BTSS.B  2D4.2
03E92:  INC     0910
....................    D5=(!input(PP_D5))*1; 
03E94:  BSET.B  2D2.1
03E96:  CLR     912
03E98:  BTSS.B  2D4.1
03E9A:  INC     0912
....................    D4=(!input(PP_D4))*1; 
03E9C:  BSET.B  2CD.6
03E9E:  CLR     914
03EA0:  BTSS.B  2CF.6
03EA2:  INC     0914
....................    D3=(!input(PP_D3))*1; 
03EA4:  BSET.B  2CD.5
03EA6:  CLR     916
03EA8:  BTSS.B  2CF.5
03EAA:  INC     0916
....................    D2=(!input(PP_D2))*1; 
03EAC:  BSET.B  2D2.0
03EAE:  CLR     918
03EB0:  BTSS.B  2D4.0
03EB2:  INC     0918
....................    D1=(!input(PP_D1))*1; 
03EB4:  BSET.B  2D3.1
03EB6:  CLR     91A
03EB8:  BTSS.B  2D5.1
03EBA:  INC     091A
....................    D0=(!input(PP_D0))*1; 
03EBC:  BSET.B  2D3.0
03EBE:  CLR     91C
03EC0:  BTSS.B  2D5.0
03EC2:  INC     091C
....................     
....................    byte0=8*D7+4*D6+2*D5+D4; 
03EC4:  MOV     90E,W5
03EC6:  SL      W5,#3,W5
03EC8:  MOV     910,W0
03ECA:  SL      W0,#2,W0
03ECC:  ADD     W0,W5,W5
03ECE:  MOV     912,W0
03ED0:  SL      W0,#1,W0
03ED2:  ADD     W0,W5,W5
03ED4:  MOV     W5,W0
03ED6:  ADD     914,W0
03ED8:  MOV     W0,91E
....................    byte1=8*D3+4*D2+2*D1+D0; 
03EDA:  MOV     916,W5
03EDC:  SL      W5,#3,W5
03EDE:  MOV     918,W0
03EE0:  SL      W0,#2,W0
03EE2:  ADD     W0,W5,W5
03EE4:  MOV     91A,W0
03EE6:  SL      W0,#1,W0
03EE8:  ADD     W0,W5,W5
03EEA:  MOV     W5,W0
03EEC:  ADD     91C,W0
03EEE:  MOV     W0,920
....................    data=byte0*10+byte1; 
03EF0:  MOV     91E,W4
03EF2:  MUL.UU  W4,#A,W0
03EF4:  MOV     W0,W5
03EF6:  MOV     W5,W0
03EF8:  ADD     920,W0
03EFA:  MOV     W0,90C
....................     
....................    return data; 
03EFC:  PUSH    90C
03EFE:  POP     0
.................... } 
03F00:  MOV     [--W15],W5
03F02:  RETURN  
.................... // Returns binary coded decimal byte of the given input 
.................... unsigned int pp_get_BCD_byte(unsigned int input) 
.................... { 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    byte0=8*bit_test(input,7)+4*bit_test(input,6)+2*bit_test(input,5)+bit_test(input,4); 
....................    byte1=8*bit_test(input,3)+4*bit_test(input,2)+2*bit_test(input,1)+bit_test(input,0); 
....................  
....................    return byte0*10+byte1; 
.................... } 
.................... // Pauses parallel port until strobe signal (returns 0) or communication time out (returns 1) 
.................... unsigned int1 pp_comm_pause() 
.................... {  
*
03DDE:  MOV     W5,[W15++]
....................    while(true) 
....................    { 
....................       if(reg_pp_strobe) 
03DE0:  BTSS.B  8FC.0
03DE2:  BRA     3E60
....................       { 
....................          reg_pp_strobe = 0; 
03DE4:  BCLR.B  8FC.0
....................           
....................          if(debug_mode_pp) 
03DE6:  BTSS.B  8B0.1
03DE8:  BRA     3E02
....................             fprintf(RS232,"Strobe received\n\r"); 
03DEA:  MOV     #0,W1
03DEC:  MOV     W1,W0
03DEE:  CLR.B   1
03DF0:  CALL    A3E
03DF4:  INC     W1,W1
03DF6:  BTSC.B  219.1
03DF8:  BRA     3DF6
03DFA:  MOV     W0,21A
03DFC:  MOV     #10,W0
03DFE:  CPSGT   W1,W0
03E00:  BRA     3DEC
....................  
....................          unsigned int i; 
....................          for(i=0; i<pp_str_check; i++) 
03E02:  CLR     90C
03E04:  MOV     90C,W0
03E06:  MOV     8F4,W4
03E08:  CP      W4,W0
03E0A:  BRA     LEU,3E40
....................          { 
....................             delay_ms(pp_str_delay); 
03E0C:  MOV     8F6,W0
03E0E:  CALL    137A
....................             if(input(PP_STR) == 1) 
03E12:  BSET.B  2D3.2
03E14:  BTSS.B  2D5.2
03E16:  BRA     3E3A
....................             { 
....................                if(debug_mode_pp) 
03E18:  BTSS.B  8B0.1
03E1A:  BRA     3E34
....................                   fprintf(RS232,"Strobe signal rejected\n\r"); 
03E1C:  MOV     #0,W1
03E1E:  MOV     W1,W0
03E20:  CLR.B   1
03E22:  CALL    A5C
03E26:  INC     W1,W1
03E28:  BTSC.B  219.1
03E2A:  BRA     3E28
03E2C:  MOV     W0,21A
03E2E:  MOV     #17,W0
03E30:  CPSGT   W1,W0
03E32:  BRA     3E1E
....................                return 1; 
03E34:  MOV.B   #1,W0L
03E36:  MOV.B   W0L,0
03E38:  BRA     3E68
....................             } 
....................          } 
03E3A:  INC     090C
03E3C:  GOTO    3E04
....................           
....................          if(debug_mode_pp) 
03E40:  BTSS.B  8B0.1
03E42:  BRA     3E5C
....................             fprintf(RS232,"Strobe confirmed\n\r"); 
03E44:  MOV     #0,W1
03E46:  MOV     W1,W0
03E48:  CLR.B   1
03E4A:  CALL    A82
03E4E:  INC     W1,W1
03E50:  BTSC.B  219.1
03E52:  BRA     3E50
03E54:  MOV     W0,21A
03E56:  MOV     #11,W0
03E58:  CPSGT   W1,W0
03E5A:  BRA     3E46
....................              
....................          return 0; 
03E5C:  CLR.B   0
03E5E:  BRA     3E68
....................       } 
....................    } 
03E60:  GOTO    3DE0
....................     
....................    return 1; 
03E64:  MOV.B   #1,W0L
03E66:  MOV.B   W0L,0
.................... } 
03E68:  MOV     [--W15],W5
03E6A:  RETURN  
.................... // Sets position given via parallel port 
.................... void pp_set_pos() 
.................... { 
*
03F04:  MOV     W5,[W15++]
....................    delay_ms(pp_rdy_delay); 
03F06:  MOV     8FA,W0
03F08:  CALL    137A
....................    output_high(PP_RDY); 
03F0C:  BCLR.B  2D2.5
03F0E:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
03F10:  CALL    3DDE
03F14:  CP0.B   W0L
03F16:  BRA     Z,3F1A
....................       return; 
03F18:  BRA     4000
....................  
....................    output_low(PP_ACK); 
03F1A:  BCLR.B  2D2.4
03F1C:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
03F1E:  BCLR.B  2D2.5
03F20:  BCLR.B  2D6.5
....................    unsigned int index=pp_get_BCD_byte(); 
03F22:  CALL    3E6C
03F26:  MOV     W0,904
....................    delay_ms(pp_ack_delay); 
03F28:  MOV     8F8,W0
03F2A:  CALL    137A
....................    output_high(PP_ACK); 
03F2E:  BCLR.B  2D2.4
03F30:  BSET.B  2D6.4
....................    delay_ms(pp_rdy_delay); 
03F32:  MOV     8FA,W0
03F34:  CALL    137A
....................    output_high(PP_RDY); 
03F38:  BCLR.B  2D2.5
03F3A:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
03F3C:  CALL    3DDE
03F40:  CP0.B   W0L
03F42:  BRA     Z,3F46
....................       return; 
03F44:  BRA     4000
....................     
....................    output_low(PP_ACK); 
03F46:  BCLR.B  2D2.4
03F48:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
03F4A:  BCLR.B  2D2.5
03F4C:  BCLR.B  2D6.5
....................    unsigned int pos0=pp_get_BCD_byte(); 
03F4E:  CALL    3E6C
03F52:  MOV     W0,906
....................    delay_ms(pp_ack_delay); 
03F54:  MOV     8F8,W0
03F56:  CALL    137A
....................    output_high(PP_ACK); 
03F5A:  BCLR.B  2D2.4
03F5C:  BSET.B  2D6.4
....................    delay_ms(pp_rdy_delay); 
03F5E:  MOV     8FA,W0
03F60:  CALL    137A
....................    output_high(PP_RDY); 
03F64:  BCLR.B  2D2.5
03F66:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
03F68:  CALL    3DDE
03F6C:  CP0.B   W0L
03F6E:  BRA     Z,3F72
....................       return; 
03F70:  BRA     4000
....................  
....................    output_low(PP_ACK); 
03F72:  BCLR.B  2D2.4
03F74:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
03F76:  BCLR.B  2D2.5
03F78:  BCLR.B  2D6.5
....................    unsigned int pos1=pp_get_BCD_byte(); 
03F7A:  CALL    3E6C
03F7E:  MOV     W0,908
....................    delay_ms(pp_ack_delay); 
03F80:  MOV     8F8,W0
03F82:  CALL    137A
....................    output_high(PP_ACK); 
03F86:  BCLR.B  2D2.4
03F88:  BSET.B  2D6.4
....................  
....................    data_set_pos(index, pos0*100+pos1); 
03F8A:  MOV     906,W4
03F8C:  MOV     #64,W3
03F8E:  MUL.UU  W4,W3,W0
03F90:  MOV     W0,W5
03F92:  MOV     W5,W0
03F94:  ADD     908,W0
03F96:  MOV     W0,W5
03F98:  MOV.B   904,W0L
03F9A:  MOV.B   W0L,95E
03F9C:  MOV     W5,960
03F9E:  CALL    323A
....................     
....................    fprintf(RS232,"Position set -> index: %u position: %u\n\r", index, pos0*100+pos1); 
03FA2:  MOV     906,W4
03FA4:  MOV     #64,W3
03FA6:  MUL.UU  W4,W3,W0
03FA8:  MOV     W0,W5
03FAA:  MOV     W5,W0
03FAC:  ADD     908,W0
03FAE:  MOV     W0,W5
03FB0:  MOV     #0,W1
03FB2:  MOV     W1,W0
03FB4:  CLR.B   1
03FB6:  CALL    AA2
03FBA:  INC     W1,W1
03FBC:  BTSC.B  219.1
03FBE:  BRA     3FBC
03FC0:  MOV     W0,21A
03FC2:  MOV     #16,W0
03FC4:  CPSGT   W1,W0
03FC6:  BRA     3FB2
03FC8:  MOV     904,W0
03FCA:  MOV     #0,W4
03FCC:  CALL    143A
03FD0:  MOV     #19,W1
03FD2:  MOV     W1,W0
03FD4:  CLR.B   1
03FD6:  CALL    AA2
03FDA:  INC     W1,W1
03FDC:  BTSC.B  219.1
03FDE:  BRA     3FDC
03FE0:  MOV     W0,21A
03FE2:  MOV     #23,W0
03FE4:  CPSGT   W1,W0
03FE6:  BRA     3FD2
03FE8:  MOV     W5,W0
03FEA:  MOV     #0,W4
03FEC:  CALL    143A
03FF0:  BTSC.B  219.1
03FF2:  BRA     3FF0
03FF4:  MOV     #A,W4
03FF6:  MOV     W4,21A
03FF8:  BTSC.B  219.1
03FFA:  BRA     3FF8
03FFC:  MOV     #D,W4
03FFE:  MOV     W4,21A
.................... } 
04000:  MOV     [--W15],W5
04002:  RETURN  
.................... // Moves to position given via parallel port 
.................... void pp_move_pos(unsigned int input) 
.................... { 
04004:  CALL    3E6C
04008:  MOV     W0,906
....................    unsigned int index=pp_get_BCD_byte();; 
....................    unsigned int position=data_get_pos(index); 
0400A:  MOV.B   906,W0L
0400C:  MOV.B   W0L,964
0400E:  CALL    315C
04012:  MOV     W0,908
....................     
....................    fprintf(RS232,"Move Position -> index: %u position: %u\n\r", index, position); 
04014:  MOV     #0,W1
04016:  MOV     W1,W0
04018:  CLR.B   1
0401A:  CALL    AD8
0401E:  INC     W1,W1
04020:  BTSC.B  219.1
04022:  BRA     4020
04024:  MOV     W0,21A
04026:  MOV     #17,W0
04028:  CPSGT   W1,W0
0402A:  BRA     4016
0402C:  MOV     906,W0
0402E:  MOV     #0,W4
04030:  CALL    143A
04034:  MOV     #1A,W1
04036:  MOV     W1,W0
04038:  CLR.B   1
0403A:  CALL    AD8
0403E:  INC     W1,W1
04040:  BTSC.B  219.1
04042:  BRA     4040
04044:  MOV     W0,21A
04046:  MOV     #24,W0
04048:  CPSGT   W1,W0
0404A:  BRA     4036
0404C:  MOV     908,W0
0404E:  MOV     #0,W4
04050:  CALL    143A
04054:  BTSC.B  219.1
04056:  BRA     4054
04058:  MOV     #A,W4
0405A:  MOV     W4,21A
0405C:  BTSC.B  219.1
0405E:  BRA     405C
04060:  MOV     #D,W4
04062:  MOV     W4,21A
....................        
....................    move_pos(position); 
04064:  PUSH    908
04066:  POP     962
04068:  CALL    28A6
.................... } 
0406C:  RETURN  
.................... // Gets command via parallel port when system is idle 
.................... void pp_get_command() 
.................... { 
....................    output_low(PP_ACK); 
0406E:  BCLR.B  2D2.4
04070:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04072:  BCLR.B  2D2.5
04074:  BCLR.B  2D6.5
....................    unsigned int input=pp_get_byte(); 
04076:  CALL    3D54
0407A:  MOV     W0,902
....................    delay_ms(pp_ack_delay); 
0407C:  MOV     8F8,W0
0407E:  CALL    137A
....................    output_high(PP_ACK); 
04082:  BCLR.B  2D2.4
04084:  BSET.B  2D6.4
....................  
....................    switch (input) 
....................    { 
04086:  MOV     902,W0
04088:  XOR     #FE,W0
0408A:  BRA     Z,409E
0408C:  XOR     #3,W0
0408E:  BRA     Z,40BC
04090:  XOR     #1,W0
04092:  BRA     Z,40DC
04094:  XOR     #7,W0
04096:  BRA     Z,4104
04098:  XOR     #4,W0
0409A:  BRA     Z,412C
0409C:  BRA     414C
....................       case 0x00FE:   fprintf(RS232,"Emergency Stop Command\n\r"); 
0409E:  MOV     #0,W1
040A0:  MOV     W1,W0
040A2:  CLR.B   1
040A4:  CALL    B10
040A8:  INC     W1,W1
040AA:  BTSC.B  219.1
040AC:  BRA     40AA
040AE:  MOV     W0,21A
040B0:  MOV     #17,W0
040B2:  CPSGT   W1,W0
040B4:  BRA     40A0
....................                       
....................                      reg_pp_stop=1; 
040B6:  BSET.B  8B0.7
....................                      break; 
040B8:  GOTO    4158
....................       case 0x00FD:   fprintf(RS232,"Homing Command\n\r"); 
040BC:  MOV     #0,W1
040BE:  MOV     W1,W0
040C0:  CLR.B   1
040C2:  CALL    B36
040C6:  INC     W1,W1
040C8:  BTSC.B  219.1
040CA:  BRA     40C8
040CC:  MOV     W0,21A
040CE:  MOV     #F,W0
040D0:  CPSGT   W1,W0
040D2:  BRA     40BE
....................        
....................                      move_home();    
040D4:  CALL    1FB8
....................                      break; 
040D8:  GOTO    4158
....................       case 0x00FC:   fprintf(RS232,"Laser Off Command\n\r"); 
040DC:  MOV     #0,W1
040DE:  MOV     W1,W0
040E0:  CLR.B   1
040E2:  CALL    B54
040E6:  INC     W1,W1
040E8:  BTSC.B  219.1
040EA:  BRA     40E8
040EC:  MOV     W0,21A
040EE:  MOV     #12,W0
040F0:  CPSGT   W1,W0
040F2:  BRA     40DE
....................                          
....................                      output_low(LAS_1); 
040F4:  BCLR.B  2C6.0
040F6:  BCLR.B  2CA.0
....................                      output_low(LAS_2); 
040F8:  BCLR.B  2C6.1
040FA:  BCLR.B  2CA.1
....................                      output_low(LAS_3); 
040FC:  BCLR.B  2D2.6
040FE:  BCLR.B  2D6.6
....................                      break; 
04100:  GOTO    4158
....................       case 0x00FB:   fprintf(RS232,"Laser On Command\n\r"); 
04104:  MOV     #0,W1
04106:  MOV     W1,W0
04108:  CLR.B   1
0410A:  CALL    B74
0410E:  INC     W1,W1
04110:  BTSC.B  219.1
04112:  BRA     4110
04114:  MOV     W0,21A
04116:  MOV     #11,W0
04118:  CPSGT   W1,W0
0411A:  BRA     4106
....................                       
....................                      output_high(LAS_1); 
0411C:  BCLR.B  2C6.0
0411E:  BSET.B  2CA.0
....................                      output_high(LAS_2); 
04120:  BCLR.B  2C6.1
04122:  BSET.B  2CA.1
....................                      output_high(LAS_3); 
04124:  BCLR.B  2D2.6
04126:  BSET.B  2D6.6
....................                      break;  
04128:  GOTO    4158
....................       case 0x00FF:   fprintf(RS232,"Set Position Command\n\r"); 
0412C:  MOV     #0,W1
0412E:  MOV     W1,W0
04130:  CLR.B   1
04132:  CALL    B94
04136:  INC     W1,W1
04138:  BTSC.B  219.1
0413A:  BRA     4138
0413C:  MOV     W0,21A
0413E:  MOV     #15,W0
04140:  CPSGT   W1,W0
04142:  BRA     412E
....................                       
....................                      pp_set_pos(); 
04144:  CALL    3F04
....................                      break; 
04148:  GOTO    4158
....................       default:       pp_move_pos(input);  
0414C:  PUSH    902
0414E:  POP     904
04150:  CALL    4004
....................                      break; 
04154:  GOTO    4158
....................    } 
....................     
....................    delay_ms(pp_rdy_delay); 
04158:  MOV     8FA,W0
0415A:  CALL    137A
....................    output_high(PP_RDY); 
0415E:  BCLR.B  2D2.5
04160:  BSET.B  2D6.5
.................... } 
04162:  RETURN  
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
.................... { 
*
03256:  MOV     W5,[W15++]
03258:  MOV     W6,[W15++]
....................    char input; 
....................     
....................    input=fgetc(RS232); 
0325A:  BTSS.B  218.0
0325C:  BRA     325A
0325E:  MOV     21C,W0
03260:  MOV.B   W0L,902
....................    switch (input){ 
03262:  MOV.B   902,W0L
03264:  CLR.B   1
03266:  XOR     #63,W0
03268:  BRA     Z,32B8
0326A:  XOR     #10,W0
0326C:  BRA     Z,3484
0326E:  XOR     #1,W0
03270:  BRA     Z,34BC
03272:  XOR     #1A,W0
03274:  BRA     Z,34F4
03276:  XOR     #D,W0
03278:  BRA     Z,352C
0327A:  XOR     #13,W0
0327C:  BRA     Z,3564
0327E:  XOR     #14,W0
03280:  BRA     Z,359C
03282:  XOR     #16,W0
03284:  BRA     Z,35D4
03286:  XOR     #1D,W0
03288:  BRA     Z,360C
0328A:  XOR     #4,W0
0328C:  BRA     Z,3614
0328E:  XOR     #15,W0
03290:  BRA     Z,3634
03292:  XOR     #9,W0
03294:  BRA     Z,36C8
03296:  XOR     #1E,W0
03298:  BRA     Z,3816
0329A:  XOR     #3,W0
0329C:  BRA     Z,3908
0329E:  XOR     #8,W0
032A0:  BRA     Z,39F4
032A2:  XOR     #13,W0
032A4:  BRA     Z,3BF4
032A6:  XOR     #D,W0
032A8:  BRA     Z,3C2E
032AA:  XOR     #1C,W0
032AC:  BRA     Z,3CC2
032AE:  XOR     #1,W0
032B0:  BRA     Z,3D46
032B2:  XOR     #1E,W0
032B4:  BRA     Z,3D4A
032B6:  BRA     3D4E
....................       case 'c':   fprintf(RS232,"\n\rCOMMAND LIST\n\r"); 
032B8:  MOV     #0,W1
032BA:  MOV     W1,W0
032BC:  CLR.B   1
032BE:  CALL    BB8
032C2:  INC     W1,W1
032C4:  BTSC.B  219.1
032C6:  BRA     32C4
032C8:  MOV     W0,21A
032CA:  MOV     #F,W0
032CC:  CPSGT   W1,W0
032CE:  BRA     32BA
....................                   fprintf(RS232,"\n\rSet Serial Number\t(s)"); 
032D0:  MOV     #0,W1
032D2:  MOV     W1,W0
032D4:  CLR.B   1
032D6:  CALL    BD6
032DA:  INC     W1,W1
032DC:  BTSC.B  219.1
032DE:  BRA     32DC
032E0:  MOV     W0,21A
032E2:  MOV     #16,W0
032E4:  CPSGT   W1,W0
032E6:  BRA     32D2
....................                   fprintf(RS232,"\n\rSet Move Range \t\t(r)"); 
032E8:  MOV     #0,W1
032EA:  MOV     W1,W0
032EC:  CLR.B   1
032EE:  CALL    BFA
032F2:  INC     W1,W1
032F4:  BTSC.B  219.1
032F6:  BRA     32F4
032F8:  MOV     W0,21A
032FA:  MOV     #15,W0
032FC:  CPSGT   W1,W0
032FE:  BRA     32EA
....................                   fprintf(RS232,"\n\rSet Homing Distance \t(h)"); 
03300:  MOV     #0,W1
03302:  MOV     W1,W0
03304:  CLR.B   1
03306:  CALL    C1E
0330A:  INC     W1,W1
0330C:  BTSC.B  219.1
0330E:  BRA     330C
03310:  MOV     W0,21A
03312:  MOV     #19,W0
03314:  CPSGT   W1,W0
03316:  BRA     3302
....................                   fprintf(RS232,"\n\rSet End Distance \t(e)"); 
03318:  MOV     #0,W1
0331A:  MOV     W1,W0
0331C:  CLR.B   1
0331E:  CALL    C46
03322:  INC     W1,W1
03324:  BTSC.B  219.1
03326:  BRA     3324
03328:  MOV     W0,21A
0332A:  MOV     #16,W0
0332C:  CPSGT   W1,W0
0332E:  BRA     331A
....................                   fprintf(RS232,"\n\rSet Conversion Constant\t(v)"); 
03330:  MOV     #0,W1
03332:  MOV     W1,W0
03334:  CLR.B   1
03336:  CALL    C6A
0333A:  INC     W1,W1
0333C:  BTSC.B  219.1
0333E:  BRA     333C
03340:  MOV     W0,21A
03342:  MOV     #1C,W0
03344:  CPSGT   W1,W0
03346:  BRA     3332
....................                   fprintf(RS232,"\n\rSet Backlash \t\t(b)"); 
03348:  MOV     #0,W1
0334A:  MOV     W1,W0
0334C:  CLR.B   1
0334E:  CALL    C94
03352:  INC     W1,W1
03354:  BTSC.B  219.1
03356:  BRA     3354
03358:  MOV     W0,21A
0335A:  MOV     #13,W0
0335C:  CPSGT   W1,W0
0335E:  BRA     334A
....................                   fprintf(RS232,"\n\rSet Communication Type \t(t)"); 
03360:  MOV     #0,W1
03362:  MOV     W1,W0
03364:  CLR.B   1
03366:  CALL    CB6
0336A:  INC     W1,W1
0336C:  BTSC.B  219.1
0336E:  BRA     336C
03370:  MOV     W0,21A
03372:  MOV     #1C,W0
03374:  CPSGT   W1,W0
03376:  BRA     3362
....................                   fprintf(RS232,"\n\rGet System Data \t(i)"); 
03378:  MOV     #0,W1
0337A:  MOV     W1,W0
0337C:  CLR.B   1
0337E:  CALL    CE0
03382:  INC     W1,W1
03384:  BTSC.B  219.1
03386:  BRA     3384
03388:  MOV     W0,21A
0338A:  MOV     #15,W0
0338C:  CPSGT   W1,W0
0338E:  BRA     337A
....................                   fprintf(RS232,"\n\rGet Position List \t(m)"); 
03390:  MOV     #0,W1
03392:  MOV     W1,W0
03394:  CLR.B   1
03396:  CALL    D04
0339A:  INC     W1,W1
0339C:  BTSC.B  219.1
0339E:  BRA     339C
033A0:  MOV     W0,21A
033A2:  MOV     #17,W0
033A4:  CPSGT   W1,W0
033A6:  BRA     3392
....................                   fprintf(RS232,"\n\rMove To Position \t(x)"); 
033A8:  MOV     #0,W1
033AA:  MOV     W1,W0
033AC:  CLR.B   1
033AE:  CALL    D2A
033B2:  INC     W1,W1
033B4:  BTSC.B  219.1
033B6:  BRA     33B4
033B8:  MOV     W0,21A
033BA:  MOV     #16,W0
033BC:  CPSGT   W1,W0
033BE:  BRA     33AA
....................                   fprintf(RS232,"\n\rSet Table Data \t\t(q)"); 
033C0:  MOV     #0,W1
033C2:  MOV     W1,W0
033C4:  CLR.B   1
033C6:  CALL    D4E
033CA:  INC     W1,W1
033CC:  BTSC.B  219.1
033CE:  BRA     33CC
033D0:  MOV     W0,21A
033D2:  MOV     #15,W0
033D4:  CPSGT   W1,W0
033D6:  BRA     33C2
....................                   fprintf(RS232,"\n\rTest Run (low res) \t(o)"); 
033D8:  MOV     #0,W1
033DA:  MOV     W1,W0
033DC:  CLR.B   1
033DE:  CALL    D72
033E2:  INC     W1,W1
033E4:  BTSC.B  219.1
033E6:  BRA     33E4
033E8:  MOV     W0,21A
033EA:  MOV     #18,W0
033EC:  CPSGT   W1,W0
033EE:  BRA     33DA
....................                   fprintf(RS232,"\n\rTest Run (high res) \t(l)"); 
033F0:  MOV     #0,W1
033F2:  MOV     W1,W0
033F4:  CLR.B   1
033F6:  CALL    D98
033FA:  INC     W1,W1
033FC:  BTSC.B  219.1
033FE:  BRA     33FC
03400:  MOV     W0,21A
03402:  MOV     #19,W0
03404:  CPSGT   W1,W0
03406:  BRA     33F2
....................                   fprintf(RS232,"\n\rSet Debug State \t(d)"); 
03408:  MOV     #0,W1
0340A:  MOV     W1,W0
0340C:  CLR.B   1
0340E:  CALL    DC0
03412:  INC     W1,W1
03414:  BTSC.B  219.1
03416:  BRA     3414
03418:  MOV     W0,21A
0341A:  MOV     #15,W0
0341C:  CPSGT   W1,W0
0341E:  BRA     340A
....................                   fprintf(RS232,"\n\rGet Encoder Count \t(w)"); 
03420:  MOV     #0,W1
03422:  MOV     W1,W0
03424:  CLR.B   1
03426:  CALL    DE4
0342A:  INC     W1,W1
0342C:  BTSC.B  219.1
0342E:  BRA     342C
03430:  MOV     W0,21A
03432:  MOV     #17,W0
03434:  CPSGT   W1,W0
03436:  BRA     3422
....................                   fprintf(RS232,"\n\rStart Memory Test \t(z)"); 
03438:  MOV     #0,W1
0343A:  MOV     W1,W0
0343C:  CLR.B   1
0343E:  CALL    E0A
03442:  INC     W1,W1
03444:  BTSC.B  219.1
03446:  BRA     3444
03448:  MOV     W0,21A
0344A:  MOV     #17,W0
0344C:  CPSGT   W1,W0
0344E:  BRA     343A
....................                   fprintf(RS232,"\n\rClear Memory \t\t(f)"); 
03450:  MOV     #0,W1
03452:  MOV     W1,W0
03454:  CLR.B   1
03456:  CALL    E30
0345A:  INC     W1,W1
0345C:  BTSC.B  219.1
0345E:  BRA     345C
03460:  MOV     W0,21A
03462:  MOV     #13,W0
03464:  CPSGT   W1,W0
03466:  BRA     3452
....................                   fprintf(RS232,"\n\n\r"); 
03468:  BTSC.B  219.1
0346A:  BRA     3468
0346C:  MOV     #A,W4
0346E:  MOV     W4,21A
03470:  BTSC.B  219.1
03472:  BRA     3470
03474:  MOV     #A,W4
03476:  MOV     W4,21A
03478:  BTSC.B  219.1
0347A:  BRA     3478
0347C:  MOV     #D,W4
0347E:  MOV     W4,21A
....................                   break; 
03480:  GOTO    3D4E
....................       case 's':   fprintf(RS232,"\n\rSet Serial Number (13 Characters): "); 
03484:  MOV     #0,W1
03486:  MOV     W1,W0
03488:  CLR.B   1
0348A:  CALL    E52
0348E:  INC     W1,W1
03490:  BTSC.B  219.1
03492:  BRA     3490
03494:  MOV     W0,21A
03496:  MOV     #24,W0
03498:  CPSGT   W1,W0
0349A:  BRA     3486
....................                   data_set_serial_no(); 
0349C:  CALL    2C44
....................                   fprintf(RS232,"\n\n\r"); 
034A0:  BTSC.B  219.1
034A2:  BRA     34A0
034A4:  MOV     #A,W4
034A6:  MOV     W4,21A
034A8:  BTSC.B  219.1
034AA:  BRA     34A8
034AC:  MOV     #A,W4
034AE:  MOV     W4,21A
034B0:  BTSC.B  219.1
034B2:  BRA     34B0
034B4:  MOV     #D,W4
034B6:  MOV     W4,21A
....................                   break; 
034B8:  GOTO    3D4E
....................       case 'r':   fprintf(RS232,"\n\rSet Move Range in mm (xxxx): "); 
034BC:  MOV     #0,W1
034BE:  MOV     W1,W0
034C0:  CLR.B   1
034C2:  CALL    E84
034C6:  INC     W1,W1
034C8:  BTSC.B  219.1
034CA:  BRA     34C8
034CC:  MOV     W0,21A
034CE:  MOV     #1E,W0
034D0:  CPSGT   W1,W0
034D2:  BRA     34BE
....................                   data_set_move_range(); 
034D4:  CALL    2CA8
....................                   fprintf(RS232,"\n\n\r"); 
034D8:  BTSC.B  219.1
034DA:  BRA     34D8
034DC:  MOV     #A,W4
034DE:  MOV     W4,21A
034E0:  BTSC.B  219.1
034E2:  BRA     34E0
034E4:  MOV     #A,W4
034E6:  MOV     W4,21A
034E8:  BTSC.B  219.1
034EA:  BRA     34E8
034EC:  MOV     #D,W4
034EE:  MOV     W4,21A
....................                   break; 
034F0:  GOTO    3D4E
....................       case 'h':   fprintf(RS232,"\n\rSet Homing Distance in counts (xxxx): "); 
034F4:  MOV     #0,W1
034F6:  MOV     W1,W0
034F8:  CLR.B   1
034FA:  CALL    EB0
034FE:  INC     W1,W1
03500:  BTSC.B  219.1
03502:  BRA     3500
03504:  MOV     W0,21A
03506:  MOV     #27,W0
03508:  CPSGT   W1,W0
0350A:  BRA     34F6
....................                   data_set_home_pos(); 
0350C:  CALL    2D7C
....................                   fprintf(RS232,"\n\n\r"); 
03510:  BTSC.B  219.1
03512:  BRA     3510
03514:  MOV     #A,W4
03516:  MOV     W4,21A
03518:  BTSC.B  219.1
0351A:  BRA     3518
0351C:  MOV     #A,W4
0351E:  MOV     W4,21A
03520:  BTSC.B  219.1
03522:  BRA     3520
03524:  MOV     #D,W4
03526:  MOV     W4,21A
....................                   break; 
03528:  GOTO    3D4E
....................       case 'e':   fprintf(RS232,"\n\rSet End Distance in counts (xxxxx): "); 
0352C:  MOV     #0,W1
0352E:  MOV     W1,W0
03530:  CLR.B   1
03532:  CALL    EE6
03536:  INC     W1,W1
03538:  BTSC.B  219.1
0353A:  BRA     3538
0353C:  MOV     W0,21A
0353E:  MOV     #25,W0
03540:  CPSGT   W1,W0
03542:  BRA     352E
....................                   data_set_end_pos(); 
03544:  CALL    2E10
....................                   fprintf(RS232,"\n\n\r"); 
03548:  BTSC.B  219.1
0354A:  BRA     3548
0354C:  MOV     #A,W4
0354E:  MOV     W4,21A
03550:  BTSC.B  219.1
03552:  BRA     3550
03554:  MOV     #A,W4
03556:  MOV     W4,21A
03558:  BTSC.B  219.1
0355A:  BRA     3558
0355C:  MOV     #D,W4
0355E:  MOV     W4,21A
....................                   break; 
03560:  GOTO    3D4E
....................       case 'v':   fprintf(RS232,"\n\rSet Conversion Constant (xxxxx): "); 
03564:  MOV     #0,W1
03566:  MOV     W1,W0
03568:  CLR.B   1
0356A:  CALL    F1A
0356E:  INC     W1,W1
03570:  BTSC.B  219.1
03572:  BRA     3570
03574:  MOV     W0,21A
03576:  MOV     #22,W0
03578:  CPSGT   W1,W0
0357A:  BRA     3566
....................                   data_set_conv_const(); 
0357C:  CALL    2EB8
....................                   fprintf(RS232,"\n\n\r"); 
03580:  BTSC.B  219.1
03582:  BRA     3580
03584:  MOV     #A,W4
03586:  MOV     W4,21A
03588:  BTSC.B  219.1
0358A:  BRA     3588
0358C:  MOV     #A,W4
0358E:  MOV     W4,21A
03590:  BTSC.B  219.1
03592:  BRA     3590
03594:  MOV     #D,W4
03596:  MOV     W4,21A
....................                   break; 
03598:  GOTO    3D4E
....................       case 'b':   fprintf(RS232,"\n\rSet Backlash (xx): "); 
0359C:  MOV     #0,W1
0359E:  MOV     W1,W0
035A0:  CLR.B   1
035A2:  CALL    F4A
035A6:  INC     W1,W1
035A8:  BTSC.B  219.1
035AA:  BRA     35A8
035AC:  MOV     W0,21A
035AE:  MOV     #14,W0
035B0:  CPSGT   W1,W0
035B2:  BRA     359E
....................                   data_set_backlash(); 
035B4:  CALL    2FD6
....................                   fprintf(RS232,"\n\n\r"); 
035B8:  BTSC.B  219.1
035BA:  BRA     35B8
035BC:  MOV     #A,W4
035BE:  MOV     W4,21A
035C0:  BTSC.B  219.1
035C2:  BRA     35C0
035C4:  MOV     #A,W4
035C6:  MOV     W4,21A
035C8:  BTSC.B  219.1
035CA:  BRA     35C8
035CC:  MOV     #D,W4
035CE:  MOV     W4,21A
....................                   break; 
035D0:  GOTO    3D4E
....................       case 't':   fprintf(RS232,"\n\rSet Communication Type (0: Parallel, 1: RS232"); 
035D4:  MOV     #0,W1
035D6:  MOV     W1,W0
035D8:  CLR.B   1
035DA:  CALL    F6C
035DE:  INC     W1,W1
035E0:  BTSC.B  219.1
035E2:  BRA     35E0
035E4:  MOV     W0,21A
035E6:  MOV     #2E,W0
035E8:  CPSGT   W1,W0
035EA:  BRA     35D6
....................                   data_set_comm_type(); 
035EC:  CALL    303A
....................                   fprintf(RS232,"\n\n\r"); 
035F0:  BTSC.B  219.1
035F2:  BRA     35F0
035F4:  MOV     #A,W4
035F6:  MOV     W4,21A
035F8:  BTSC.B  219.1
035FA:  BRA     35F8
035FC:  MOV     #A,W4
035FE:  MOV     W4,21A
03600:  BTSC.B  219.1
03602:  BRA     3600
03604:  MOV     #D,W4
03606:  MOV     W4,21A
....................                   break; 
03608:  GOTO    3D4E
....................       case 'i':   data_get_sys_data(); 
0360C:  CALL    310E
....................                   break; 
03610:  GOTO    3D4E
....................       case 'm':   fprintf(RS232,"\n\rGet Position List(0<=X<=9): "); 
03614:  MOV     #0,W1
03616:  MOV     W1,W0
03618:  CLR.B   1
0361A:  CALL    FA8
0361E:  INC     W1,W1
03620:  BTSC.B  219.1
03622:  BRA     3620
03624:  MOV     W0,21A
03626:  MOV     #1D,W0
03628:  CPSGT   W1,W0
0362A:  BRA     3616
....................                   data_get_pos_table(); 
0362C:  CALL    31D8
....................                   break; 
03630:  GOTO    3D4E
....................       case 'x':   fprintf(RS232,"\n\rMove To(0<=X<=9999): "); 
03634:  MOV     #0,W1
03636:  MOV     W1,W0
03638:  CLR.B   1
0363A:  CALL    FD4
0363E:  INC     W1,W1
03640:  BTSC.B  219.1
03642:  BRA     3640
03644:  MOV     W0,21A
03646:  MOV     #16,W0
03648:  CPSGT   W1,W0
0364A:  BRA     3636
....................                   unsigned int i=0; 
....................                   unsigned int input_step[4]; 
....................                   unsigned int step=0; 
0364C:  CLR     904
0364E:  CLR     90E
....................                   for(i=0;i<4;i++){ 
03650:  CLR     904
03652:  MOV     904,W4
03654:  CP      W4,#4
03656:  BRA     C,3688
....................                      input_step[i]=(unsigned)(fgetc(RS232)-48); 
03658:  MOV     904,W0
0365A:  SL      W0,#1,W0
0365C:  MOV     #906,W4
0365E:  ADD     W0,W4,W5
03660:  BTSS.B  218.0
03662:  BRA     3660
03664:  MOV     21C,W0
03666:  SUB.B   #30,W0L
03668:  CLR.B   1
0366A:  MOV     W0,[W5]
....................                      fputc(input_step[i]+48,RS232); 
0366C:  MOV     904,W0
0366E:  SL      W0,#1,W0
03670:  MOV     #906,W4
03672:  ADD     W0,W4,W0
03674:  MOV     [W0],W5
03676:  ADD     #30,W5
03678:  MOV.B   W5L,W0L
0367A:  BTSC.B  219.1
0367C:  BRA     367A
0367E:  MOV.B   W0L,21A
03680:  CLR.B   21B
....................                   } 
03682:  INC     0904
03684:  GOTO    3652
....................                   fprintf(RS232,"\n\n\r"); 
03688:  BTSC.B  219.1
0368A:  BRA     3688
0368C:  MOV     #A,W4
0368E:  MOV     W4,21A
03690:  BTSC.B  219.1
03692:  BRA     3690
03694:  MOV     #A,W4
03696:  MOV     W4,21A
03698:  BTSC.B  219.1
0369A:  BRA     3698
0369C:  MOV     #D,W4
0369E:  MOV     W4,21A
....................                    
....................                   step=1000*input_step[0]+100*input_step[1]+10*input_step[2]+1*input_step[3]; 
036A0:  MOV     #3E8,W4
036A2:  MOV     906,W3
036A4:  MUL.UU  W4,W3,W0
036A6:  MOV     W0,W5
036A8:  MOV     #64,W4
036AA:  MOV     908,W3
036AC:  MUL.UU  W4,W3,W0
036AE:  ADD     W0,W5,W5
036B0:  MOV     90A,W4
036B2:  MUL.UU  W4,#A,W0
036B4:  ADD     W0,W5,W5
036B6:  MOV     W5,W0
036B8:  ADD     90C,W0
036BA:  MOV     W0,90E
....................                    
....................                   move_pos(step); 
036BC:  PUSH    90E
036BE:  POP     962
036C0:  CALL    28A6
....................                   break; 
036C4:  GOTO    3D4E
....................       case 'q':   fprintf(RS232,"\n\rEnter Table Index (xx): "); 
036C8:  MOV     #0,W1
036CA:  MOV     W1,W0
036CC:  CLR.B   1
036CE:  CALL    FF8
036D2:  INC     W1,W1
036D4:  BTSC.B  219.1
036D6:  BRA     36D4
036D8:  MOV     W0,21A
036DA:  MOV     #19,W0
036DC:  CPSGT   W1,W0
036DE:  BRA     36CA
....................                   unsigned int k=0; 
....................                   unsigned int input_index[2]; 
....................                   unsigned int index=0; 
036E0:  CLR     910
036E2:  CLR     916
....................                   for(k=0;k<2;k++){ 
036E4:  CLR     910
036E6:  MOV     910,W4
036E8:  CP      W4,#2
036EA:  BRA     C,371C
....................                      input_index[k]=(unsigned)(fgetc(RS232)-48); 
036EC:  MOV     910,W0
036EE:  SL      W0,#1,W0
036F0:  MOV     #912,W4
036F2:  ADD     W0,W4,W5
036F4:  BTSS.B  218.0
036F6:  BRA     36F4
036F8:  MOV     21C,W0
036FA:  SUB.B   #30,W0L
036FC:  CLR.B   1
036FE:  MOV     W0,[W5]
....................                      fputc(input_index[k]+48,RS232); 
03700:  MOV     910,W0
03702:  SL      W0,#1,W0
03704:  MOV     #912,W4
03706:  ADD     W0,W4,W0
03708:  MOV     [W0],W5
0370A:  ADD     #30,W5
0370C:  MOV.B   W5L,W0L
0370E:  BTSC.B  219.1
03710:  BRA     370E
03712:  MOV.B   W0L,21A
03714:  CLR.B   21B
....................                   } 
03716:  INC     0910
03718:  GOTO    36E6
....................                   fprintf(RS232,"\n\n\r"); 
0371C:  BTSC.B  219.1
0371E:  BRA     371C
03720:  MOV     #A,W4
03722:  MOV     W4,21A
03724:  BTSC.B  219.1
03726:  BRA     3724
03728:  MOV     #A,W4
0372A:  MOV     W4,21A
0372C:  BTSC.B  219.1
0372E:  BRA     372C
03730:  MOV     #D,W4
03732:  MOV     W4,21A
....................                    
....................                   index=10*input_index[0]+1*input_index[1]; 
03734:  MOV     912,W4
03736:  MUL.UU  W4,#A,W0
03738:  MOV     W0,W5
0373A:  MOV     W5,W0
0373C:  ADD     914,W0
0373E:  MOV     W0,916
....................                    
....................                   fprintf(RS232,"\n\rIndex: %u", index); 
03740:  MOV     #0,W1
03742:  MOV     W1,W0
03744:  CLR.B   1
03746:  CALL    1020
0374A:  INC     W1,W1
0374C:  BTSC.B  219.1
0374E:  BRA     374C
03750:  MOV     W0,21A
03752:  MOV     #8,W0
03754:  CPSGT   W1,W0
03756:  BRA     3742
03758:  MOV     916,W0
0375A:  MOV     #0,W4
0375C:  CALL    143A
....................                    
....................                   fprintf(RS232,"\n\rEnter Position (xxxx): "); 
03760:  MOV     #0,W1
03762:  MOV     W1,W0
03764:  CLR.B   1
03766:  CALL    1038
0376A:  INC     W1,W1
0376C:  BTSC.B  219.1
0376E:  BRA     376C
03770:  MOV     W0,21A
03772:  MOV     #18,W0
03774:  CPSGT   W1,W0
03776:  BRA     3762
....................                   unsigned int input_pos[2]; 
....................                   unsigned int posi=0; 
03778:  CLR     91C
....................                   for(k=0;k<4;k++){ 
0377A:  CLR     910
0377C:  MOV     910,W4
0377E:  CP      W4,#4
03780:  BRA     C,37B2
....................                      input_pos[k]=(unsigned)(fgetc(RS232)-48); 
03782:  MOV     910,W0
03784:  SL      W0,#1,W0
03786:  MOV     #918,W4
03788:  ADD     W0,W4,W5
0378A:  BTSS.B  218.0
0378C:  BRA     378A
0378E:  MOV     21C,W0
03790:  SUB.B   #30,W0L
03792:  CLR.B   1
03794:  MOV     W0,[W5]
....................                      fputc(input_pos[k]+48,RS232); 
03796:  MOV     910,W0
03798:  SL      W0,#1,W0
0379A:  MOV     #918,W4
0379C:  ADD     W0,W4,W0
0379E:  MOV     [W0],W5
037A0:  ADD     #30,W5
037A2:  MOV.B   W5L,W0L
037A4:  BTSC.B  219.1
037A6:  BRA     37A4
037A8:  MOV.B   W0L,21A
037AA:  CLR.B   21B
....................                   } 
037AC:  INC     0910
037AE:  GOTO    377C
....................                   fprintf(RS232,"\n\n\r"); 
037B2:  BTSC.B  219.1
037B4:  BRA     37B2
037B6:  MOV     #A,W4
037B8:  MOV     W4,21A
037BA:  BTSC.B  219.1
037BC:  BRA     37BA
037BE:  MOV     #A,W4
037C0:  MOV     W4,21A
037C2:  BTSC.B  219.1
037C4:  BRA     37C2
037C6:  MOV     #D,W4
037C8:  MOV     W4,21A
....................                    
....................                   posi=1000*input_pos[0]+100*input_pos[1]+10*input_pos[2]+1*input_pos[3]; 
037CA:  MOV     #3E8,W4
037CC:  MOV     918,W3
037CE:  MUL.UU  W4,W3,W0
037D0:  MOV     W0,W5
037D2:  MOV     #64,W4
037D4:  MOV     91A,W3
037D6:  MUL.UU  W4,W3,W0
037D8:  ADD     W0,W5,W5
037DA:  MOV     91C,W4
037DC:  MUL.UU  W4,#A,W0
037DE:  ADD     W0,W5,W5
037E0:  MOV     W5,W0
037E2:  ADD     91E,W0
037E4:  MOV     W0,91C
....................                    
....................                   fprintf(RS232,"\n\rPosition: %u", posi); 
037E6:  MOV     #0,W1
037E8:  MOV     W1,W0
037EA:  CLR.B   1
037EC:  CALL    105E
037F0:  INC     W1,W1
037F2:  BTSC.B  219.1
037F4:  BRA     37F2
037F6:  MOV     W0,21A
037F8:  MOV     #B,W0
037FA:  CPSGT   W1,W0
037FC:  BRA     37E8
037FE:  MOV     91C,W0
03800:  MOV     #0,W4
03802:  CALL    143A
....................                    
....................                   data_set_pos(index, posi); 
03806:  MOV.B   916,W0L
03808:  MOV.B   W0L,95E
0380A:  PUSH    91C
0380C:  POP     960
0380E:  CALL    323A
....................                   break; 
03812:  GOTO    3D4E
....................       case 'o':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
03816:  MOV     #0,W1
03818:  MOV     W1,W0
0381A:  CLR.B   1
0381C:  CALL    107A
03820:  INC     W1,W1
03822:  BTSC.B  219.1
03824:  BRA     3822
03826:  MOV     W0,21A
03828:  MOV     #F,W0
0382A:  CPSGT   W1,W0
0382C:  BRA     3818
....................                   unsigned int r=0; 
....................                   unsigned int input_speed[4]; 
....................                   unsigned int delay=0; 
0382E:  CLR     91E
03830:  CLR     928
....................                   for(r=0;r<4;r++){ 
03832:  CLR     91E
03834:  MOV     91E,W4
03836:  CP      W4,#4
03838:  BRA     C,386A
....................                      input_speed[r]=(unsigned)(fgetc(RS232)-48); 
0383A:  MOV     91E,W0
0383C:  SL      W0,#1,W0
0383E:  MOV     #920,W4
03840:  ADD     W0,W4,W5
03842:  BTSS.B  218.0
03844:  BRA     3842
03846:  MOV     21C,W0
03848:  SUB.B   #30,W0L
0384A:  CLR.B   1
0384C:  MOV     W0,[W5]
....................                      fputc(input_speed[r]+48,RS232); 
0384E:  MOV     91E,W0
03850:  SL      W0,#1,W0
03852:  MOV     #920,W4
03854:  ADD     W0,W4,W0
03856:  MOV     [W0],W5
03858:  ADD     #30,W5
0385A:  MOV.B   W5L,W0L
0385C:  BTSC.B  219.1
0385E:  BRA     385C
03860:  MOV.B   W0L,21A
03862:  CLR.B   21B
....................                   } 
03864:  INC     091E
03866:  GOTO    3834
....................                   fprintf(RS232,"\n\r"); 
0386A:  BTSC.B  219.1
0386C:  BRA     386A
0386E:  MOV     #A,W4
03870:  MOV     W4,21A
03872:  BTSC.B  219.1
03874:  BRA     3872
03876:  MOV     #D,W4
03878:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
0387A:  MOV     #3E8,W4
0387C:  MOV     920,W3
0387E:  MUL.UU  W4,W3,W0
03880:  MOV     W0,W5
03882:  MOV     #64,W4
03884:  MOV     922,W3
03886:  MUL.UU  W4,W3,W0
03888:  ADD     W0,W5,W5
0388A:  MOV     924,W4
0388C:  MUL.UU  W4,#A,W0
0388E:  ADD     W0,W5,W5
03890:  MOV     W5,W0
03892:  ADD     926,W0
03894:  MOV     W0,928
....................        
....................                   unsigned int m; 
....................                   unsigned int pos_cal=md_min_distance; 
....................                   unsigned int num=(md_move_range-md_min_distance)/40+1; 
03896:  PUSH    8C8
03898:  POP     92C
0389A:  MOV     8BE,W4
0389C:  MOV     8C8,W3
0389E:  SUB     W4,W3,W5
038A0:  MOV     W5,W4
038A2:  MOV     #28,W3
038A4:  REPEAT  #11
038A6:  DIV.U   W4,W3
038A8:  MOV     W0,W5
038AA:  ADD     W5,#1,W5
038AC:  MOV     W5,92E
....................                    
....................                   for(m=0; m<num; m++) 
038AE:  CLR     92A
038B0:  MOV     92A,W0
038B2:  MOV     92E,W4
038B4:  CP      W4,W0
038B6:  BRA     LEU,38D4
....................                   { 
....................                      move_pos(pos_cal+m*40); 
038B8:  MOV     92A,W4
038BA:  MOV     #28,W3
038BC:  MUL.UU  W4,W3,W0
038BE:  MOV     92C,W4
038C0:  ADD     W0,W4,W5
038C2:  MOV     W5,962
038C4:  CALL    28A6
....................                      delay_ms(delay); 
038C8:  MOV     928,W0
038CA:  CALL    137A
....................                   } 
038CE:  INC     092A
038D0:  GOTO    38B0
....................                    
....................                   pos_cal=pos_cal+(num-1)*40; 
038D4:  MOV     92E,W4
038D6:  SUB     W4,#1,W5
038D8:  MOV     #28,W4
038DA:  MUL.UU  W5,W4,W0
038DC:  ADD     92C
....................                    
....................                   for(m=0; m<num; m++) 
038DE:  CLR     92A
038E0:  MOV     92A,W0
038E2:  MOV     92E,W4
038E4:  CP      W4,W0
038E6:  BRA     LEU,3904
....................                   { 
....................                      move_pos(pos_cal-m*40); 
038E8:  MOV     92A,W4
038EA:  MOV     #28,W3
038EC:  MUL.UU  W4,W3,W0
038EE:  MOV     92C,W4
038F0:  SUB     W4,W0,W5
038F2:  MOV     W5,962
038F4:  CALL    28A6
....................                      delay_ms(delay); 
038F8:  MOV     928,W0
038FA:  CALL    137A
....................                   } 
038FE:  INC     092A
03900:  GOTO    38E0
....................                   break; 
03904:  GOTO    3D4E
....................       case 'l':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
03908:  MOV     #0,W1
0390A:  MOV     W1,W0
0390C:  CLR.B   1
0390E:  CALL    107A
03912:  INC     W1,W1
03914:  BTSC.B  219.1
03916:  BRA     3914
03918:  MOV     W0,21A
0391A:  MOV     #F,W0
0391C:  CPSGT   W1,W0
0391E:  BRA     390A
....................                   unsigned int p=0; 
03920:  CLR     930
....................                   for(p=0;p<4;p++){ 
03922:  CLR     930
03924:  MOV     930,W4
03926:  CP      W4,#4
03928:  BRA     C,395A
....................                      input_speed[p]=(unsigned)(fgetc(RS232)-48); 
0392A:  MOV     930,W0
0392C:  SL      W0,#1,W0
0392E:  MOV     #920,W4
03930:  ADD     W0,W4,W5
03932:  BTSS.B  218.0
03934:  BRA     3932
03936:  MOV     21C,W0
03938:  SUB.B   #30,W0L
0393A:  CLR.B   1
0393C:  MOV     W0,[W5]
....................                      fputc(input_speed[p]+48,RS232); 
0393E:  MOV     930,W0
03940:  SL      W0,#1,W0
03942:  MOV     #920,W4
03944:  ADD     W0,W4,W0
03946:  MOV     [W0],W5
03948:  ADD     #30,W5
0394A:  MOV.B   W5L,W0L
0394C:  BTSC.B  219.1
0394E:  BRA     394C
03950:  MOV.B   W0L,21A
03952:  CLR.B   21B
....................                   } 
03954:  INC     0930
03956:  GOTO    3924
....................                   fprintf(RS232,"\n\r"); 
0395A:  BTSC.B  219.1
0395C:  BRA     395A
0395E:  MOV     #A,W4
03960:  MOV     W4,21A
03962:  BTSC.B  219.1
03964:  BRA     3962
03966:  MOV     #D,W4
03968:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
0396A:  MOV     #3E8,W4
0396C:  MOV     920,W3
0396E:  MUL.UU  W4,W3,W0
03970:  MOV     W0,W5
03972:  MOV     #64,W4
03974:  MOV     922,W3
03976:  MUL.UU  W4,W3,W0
03978:  ADD     W0,W5,W5
0397A:  MOV     924,W4
0397C:  MUL.UU  W4,#A,W0
0397E:  ADD     W0,W5,W5
03980:  MOV     W5,W0
03982:  ADD     926,W0
03984:  MOV     W0,928
....................        
....................                   unsigned int l; 
....................                   unsigned int pos_cal_2=md_min_distance; 
....................                   unsigned int num_2=(md_move_range-md_min_distance)/10+1; 
03986:  PUSH    8C8
03988:  POP     934
0398A:  MOV     8BE,W4
0398C:  MOV     8C8,W3
0398E:  SUB     W4,W3,W5
03990:  MOV     W5,W4
03992:  MOV     #A,W3
03994:  REPEAT  #11
03996:  DIV.U   W4,W3
03998:  MOV     W0,W5
0399A:  ADD     W5,#1,W5
0399C:  MOV     W5,936
....................                    
....................                   for(l=0; l<num_2; l++) 
0399E:  CLR     932
039A0:  MOV     932,W0
039A2:  MOV     936,W4
039A4:  CP      W4,W0
039A6:  BRA     LEU,39C2
....................                   { 
....................                      move_pos(pos_cal_2+l*10); 
039A8:  MOV     932,W4
039AA:  MUL.UU  W4,#A,W0
039AC:  MOV     934,W4
039AE:  ADD     W0,W4,W5
039B0:  MOV     W5,962
039B2:  CALL    28A6
....................                      delay_ms(delay); 
039B6:  MOV     928,W0
039B8:  CALL    137A
....................                   } 
039BC:  INC     0932
039BE:  GOTO    39A0
....................                    
....................                   pos_cal_2=pos_cal_2+(num_2-1)*10; 
039C2:  MOV     936,W4
039C4:  SUB     W4,#1,W5
039C6:  MOV     W5,W4
039C8:  MUL.UU  W4,#A,W0
039CA:  ADD     934
....................                    
....................                   for(l=0; l<num_2; l++) 
039CC:  CLR     932
039CE:  MOV     932,W0
039D0:  MOV     936,W4
039D2:  CP      W4,W0
039D4:  BRA     LEU,39F0
....................                   { 
....................                      move_pos(pos_cal_2-l*10); 
039D6:  MOV     932,W4
039D8:  MUL.UU  W4,#A,W0
039DA:  MOV     934,W4
039DC:  SUB     W4,W0,W5
039DE:  MOV     W5,962
039E0:  CALL    28A6
....................                      delay_ms(delay); 
039E4:  MOV     928,W0
039E6:  CALL    137A
....................                   } 
039EA:  INC     0932
039EC:  GOTO    39CE
....................                   break; 
039F0:  GOTO    3D4E
....................       case 'd':   fprintf(RS232,"\n\rSet debug state\n\r"); 
039F4:  MOV     #0,W1
039F6:  MOV     W1,W0
039F8:  CLR.B   1
039FA:  CALL    1098
039FE:  INC     W1,W1
03A00:  BTSC.B  219.1
03A02:  BRA     3A00
03A04:  MOV     W0,21A
03A06:  MOV     #12,W0
03A08:  CPSGT   W1,W0
03A0A:  BRA     39F6
....................                   fprintf(RS232,"Digital potentiometer (a)(0 or 1): \n\r"); 
03A0C:  MOV     #0,W1
03A0E:  MOV     W1,W0
03A10:  CLR.B   1
03A12:  CALL    10B8
03A16:  INC     W1,W1
03A18:  BTSC.B  219.1
03A1A:  BRA     3A18
03A1C:  MOV     W0,21A
03A1E:  MOV     #24,W0
03A20:  CPSGT   W1,W0
03A22:  BRA     3A0E
....................                   fprintf(RS232,"Parallel port         (b)(0 or 1): \n\r"); 
03A24:  MOV     #0,W1
03A26:  MOV     W1,W0
03A28:  CLR.B   1
03A2A:  CALL    10EA
03A2E:  INC     W1,W1
03A30:  BTSC.B  219.1
03A32:  BRA     3A30
03A34:  MOV     W0,21A
03A36:  MOV     #24,W0
03A38:  CPSGT   W1,W0
03A3A:  BRA     3A26
....................                   fprintf(RS232,"FRAM                  (c)(0 or 1): \n\r"); 
03A3C:  MOV     #0,W1
03A3E:  MOV     W1,W0
03A40:  CLR.B   1
03A42:  CALL    111C
03A46:  INC     W1,W1
03A48:  BTSC.B  219.1
03A4A:  BRA     3A48
03A4C:  MOV     W0,21A
03A4E:  MOV     #24,W0
03A50:  CPSGT   W1,W0
03A52:  BRA     3A3E
....................                   fprintf(RS232,"Motor driver          (d)(0 or 1): \n\r"); 
03A54:  MOV     #0,W1
03A56:  MOV     W1,W0
03A58:  CLR.B   1
03A5A:  CALL    114E
03A5E:  INC     W1,W1
03A60:  BTSC.B  219.1
03A62:  BRA     3A60
03A64:  MOV     W0,21A
03A66:  MOV     #24,W0
03A68:  CPSGT   W1,W0
03A6A:  BRA     3A56
....................                   fprintf(RS232,"Encoder               (e)(0 or 1): \n\r"); 
03A6C:  MOV     #0,W1
03A6E:  MOV     W1,W0
03A70:  CLR.B   1
03A72:  CALL    1180
03A76:  INC     W1,W1
03A78:  BTSC.B  219.1
03A7A:  BRA     3A78
03A7C:  MOV     W0,21A
03A7E:  MOV     #24,W0
03A80:  CPSGT   W1,W0
03A82:  BRA     3A6E
....................                   fprintf(RS232,"PWM Module            (f)(0 or 1): \n\r"); 
03A84:  MOV     #0,W1
03A86:  MOV     W1,W0
03A88:  CLR.B   1
03A8A:  CALL    11B2
03A8E:  INC     W1,W1
03A90:  BTSC.B  219.1
03A92:  BRA     3A90
03A94:  MOV     W0,21A
03A96:  MOV     #24,W0
03A98:  CPSGT   W1,W0
03A9A:  BRA     3A86
....................                   fprintf(RS232,"All Modes             (g)(0 or 1): \n\r"); 
03A9C:  MOV     #0,W1
03A9E:  MOV     W1,W0
03AA0:  CLR.B   1
03AA2:  CALL    11E4
03AA6:  INC     W1,W1
03AA8:  BTSC.B  219.1
03AAA:  BRA     3AA8
03AAC:  MOV     W0,21A
03AAE:  MOV     #24,W0
03AB0:  CPSGT   W1,W0
03AB2:  BRA     3A9E
....................                   fprintf(RS232,"Selection (xx): "); 
03AB4:  MOV     #0,W1
03AB6:  MOV     W1,W0
03AB8:  CLR.B   1
03ABA:  CALL    1216
03ABE:  INC     W1,W1
03AC0:  BTSC.B  219.1
03AC2:  BRA     3AC0
03AC4:  MOV     W0,21A
03AC6:  MOV     #F,W0
03AC8:  CPSGT   W1,W0
03ACA:  BRA     3AB6
....................                    
....................                   int1 value=0; 
....................                   unsigned int f=0; 
....................                   char input_ds[2]; 
03ACC:  BCLR.B  903.0
03ACE:  CLR     938
....................                   for(f=0;f<2;f++){ 
03AD0:  CLR     938
03AD2:  MOV     938,W4
03AD4:  CP      W4,#2
03AD6:  BRA     C,3AFE
....................                      input_ds[f]=fgetc(RS232); 
03AD8:  MOV     #93A,W4
03ADA:  MOV     938,W3
03ADC:  ADD     W3,W4,W5
03ADE:  BTSS.B  218.0
03AE0:  BRA     3ADE
03AE2:  MOV     21C,W0
03AE4:  MOV.B   W0L,[W5]
....................                      fputc(input_ds[f],RS232); 
03AE6:  MOV     #93A,W4
03AE8:  MOV     938,W3
03AEA:  ADD     W3,W4,W0
03AEC:  MOV.B   [W0],W5L
03AEE:  MOV.B   W5L,W0L
03AF0:  BTSC.B  219.1
03AF2:  BRA     3AF0
03AF4:  MOV.B   W0L,21A
03AF6:  CLR.B   21B
....................                   } 
03AF8:  INC     0938
03AFA:  GOTO    3AD2
....................                   fprintf(RS232,"\n\n\r"); 
03AFE:  BTSC.B  219.1
03B00:  BRA     3AFE
03B02:  MOV     #A,W4
03B04:  MOV     W4,21A
03B06:  BTSC.B  219.1
03B08:  BRA     3B06
03B0A:  MOV     #A,W4
03B0C:  MOV     W4,21A
03B0E:  BTSC.B  219.1
03B10:  BRA     3B0E
03B12:  MOV     #D,W4
03B14:  MOV     W4,21A
....................                    
....................                   if(input_ds[1]=='0') 
03B16:  MOV     93A,W4
03B18:  LSR     W4,#8,W4
03B1A:  XOR.B   #30,W4L
03B1C:  BRA     NZ,3B24
....................                      value=0; 
03B1E:  BCLR.B  903.0
....................                   else if(input_ds[1]=='1') 
03B20:  GOTO    3B4E
03B24:  MOV     93A,W4
03B26:  LSR     W4,#8,W4
03B28:  XOR.B   #31,W4L
03B2A:  BRA     NZ,3B32
....................                      value=1; 
03B2C:  BSET.B  903.0
....................                   else 
03B2E:  GOTO    3B4E
....................                   { 
....................                      fprintf(RS232,"Invalid Entry\n\r"); 
03B32:  MOV     #0,W1
03B34:  MOV     W1,W0
03B36:  CLR.B   1
03B38:  CALL    1234
03B3C:  INC     W1,W1
03B3E:  BTSC.B  219.1
03B40:  BRA     3B3E
03B42:  MOV     W0,21A
03B44:  MOV     #E,W0
03B46:  CPSGT   W1,W0
03B48:  BRA     3B34
....................                      break; 
03B4A:  GOTO    3D4E
....................                   } 
....................  
....................                   switch (input_ds[0]){ 
03B4E:  MOV.B   93A,W0L
03B50:  CLR.B   1
03B52:  XOR     #61,W0
03B54:  BRA     Z,3B70
03B56:  XOR     #3,W0
03B58:  BRA     Z,3B7A
03B5A:  XOR     #1,W0
03B5C:  BRA     Z,3B84
03B5E:  XOR     #7,W0
03B60:  BRA     Z,3B8E
03B62:  XOR     #1,W0
03B64:  BRA     Z,3B98
03B66:  XOR     #3,W0
03B68:  BRA     Z,3BA2
03B6A:  XOR     #1,W0
03B6C:  BRA     Z,3BAC
03B6E:  BRA     3BD4
....................                      case 'a':   debug_mode_dp = value; 
03B70:  BCLR.B  8B0.0
03B72:  BTSC.B  903.0
03B74:  BSET.B  8B0.0
....................                                  break; 
03B76:  GOTO    3BF0
....................                      case 'b':   debug_mode_pp = value; 
03B7A:  BCLR.B  8B0.1
03B7C:  BTSC.B  903.0
03B7E:  BSET.B  8B0.1
....................                                  break; 
03B80:  GOTO    3BF0
....................                      case 'c':   debug_mode_fr = value; 
03B84:  BCLR.B  8B0.2
03B86:  BTSC.B  903.0
03B88:  BSET.B  8B0.2
....................                                  break; 
03B8A:  GOTO    3BF0
....................                      case 'd':   debug_mode_md = value; 
03B8E:  BCLR.B  8B0.3
03B90:  BTSC.B  903.0
03B92:  BSET.B  8B0.3
....................                                  break; 
03B94:  GOTO    3BF0
....................                      case 'e':   debug_mode_qei = value; 
03B98:  BCLR.B  8B0.5
03B9A:  BTSC.B  903.0
03B9C:  BSET.B  8B0.5
....................                                  break; 
03B9E:  GOTO    3BF0
....................                      case 'f':   debug_mode_pwm = value; 
03BA2:  BCLR.B  8B0.4
03BA4:  BTSC.B  903.0
03BA6:  BSET.B  8B0.4
....................                                  break;           
03BA8:  GOTO    3BF0
....................                      case 'g':   debug_mode_dp = value; 
03BAC:  BCLR.B  8B0.0
03BAE:  BTSC.B  903.0
03BB0:  BSET.B  8B0.0
....................                                  debug_mode_pp = value; 
03BB2:  BCLR.B  8B0.1
03BB4:  BTSC.B  903.0
03BB6:  BSET.B  8B0.1
....................                                  debug_mode_fr = value; 
03BB8:  BCLR.B  8B0.2
03BBA:  BTSC.B  903.0
03BBC:  BSET.B  8B0.2
....................                                  debug_mode_md = value; 
03BBE:  BCLR.B  8B0.3
03BC0:  BTSC.B  903.0
03BC2:  BSET.B  8B0.3
....................                                  debug_mode_qei = value; 
03BC4:  BCLR.B  8B0.5
03BC6:  BTSC.B  903.0
03BC8:  BSET.B  8B0.5
....................                                  debug_mode_pwm = value; 
03BCA:  BCLR.B  8B0.4
03BCC:  BTSC.B  903.0
03BCE:  BSET.B  8B0.4
....................                                  break; 
03BD0:  GOTO    3BF0
....................                      default:    fprintf(RS232,"Invalid Entry\n\r"); 
03BD4:  MOV     #0,W1
03BD6:  MOV     W1,W0
03BD8:  CLR.B   1
03BDA:  CALL    1234
03BDE:  INC     W1,W1
03BE0:  BTSC.B  219.1
03BE2:  BRA     3BE0
03BE4:  MOV     W0,21A
03BE6:  MOV     #E,W0
03BE8:  CPSGT   W1,W0
03BEA:  BRA     3BD6
....................                                  break; 
03BEC:  GOTO    3BF0
....................                   } 
....................                   break; 
03BF0:  GOTO    3D4E
....................       case 'w':   fprintf(RS232,"\n\rEncoder count %4u\n\r",qei_get_count()); 
03BF4:  CALL    1D6A
03BF8:  MOV     W0,W5
03BFA:  MOV     #0,W1
03BFC:  MOV     W1,W0
03BFE:  CLR.B   1
03C00:  CALL    1250
03C04:  INC     W1,W1
03C06:  BTSC.B  219.1
03C08:  BRA     3C06
03C0A:  MOV     W0,21A
03C0C:  MOV     #F,W0
03C0E:  CPSGT   W1,W0
03C10:  BRA     3BFC
03C12:  MOV     W5,W0
03C14:  MOV     #4,W4
03C16:  CALL    143A
03C1A:  BTSC.B  219.1
03C1C:  BRA     3C1A
03C1E:  MOV     #A,W4
03C20:  MOV     W4,21A
03C22:  BTSC.B  219.1
03C24:  BRA     3C22
03C26:  MOV     #D,W4
03C28:  MOV     W4,21A
....................                   break; 
03C2A:  GOTO    3D4E
....................       case 'z':   fprintf(RS232,"\n\rStart Memory Test (Yes -> 1, No -> 0): "); 
03C2E:  MOV     #0,W1
03C30:  MOV     W1,W0
03C32:  CLR.B   1
03C34:  CALL    1272
03C38:  INC     W1,W1
03C3A:  BTSC.B  219.1
03C3C:  BRA     3C3A
03C3E:  MOV     W0,21A
03C40:  MOV     #28,W0
03C42:  CPSGT   W1,W0
03C44:  BRA     3C30
....................                   unsigned int input_mem_test=(unsigned)(fgetc(RS232)-48); 
03C46:  BTSS.B  218.0
03C48:  BRA     3C46
03C4A:  MOV     21C,W0
03C4C:  SUB.B   #30,W0L
03C4E:  MOV.B   W0L,93C
03C50:  CLR.B   93D
....................                   fputc(input_mem_test+48,RS232); 
03C52:  MOV     #30,W4
03C54:  MOV     93C,W3
03C56:  ADD     W3,W4,W5
03C58:  MOV.B   W5L,W0L
03C5A:  BTSC.B  219.1
03C5C:  BRA     3C5A
03C5E:  MOV.B   W0L,21A
03C60:  CLR.B   21B
....................                   
....................                   unsigned int8 mem=0; 
03C62:  CLR.B   93E
....................                    
....................                   if(input_mem_test == 1) 
03C64:  MOV     93C,W4
03C66:  CP      W4,#1
03C68:  BRA     NZ,3CBE
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
03C6A:  CLR.B   93E
03C6C:  MOV     93E,W4
03C6E:  MOV     #64,W3
03C70:  CP.B    W3L,W4L
03C72:  BRA     LEU,3C92
....................                         data_set_pos(mem, mem+1); 
03C74:  MOV     93E,W4
03C76:  ADD.B   W4L,#1,W4L
03C78:  MOV.B   W4L,W0L
03C7A:  MOV.B   W0L,A
03C7C:  MOV.B   93E,W0L
03C7E:  MOV.B   W0L,95E
03C80:  PUSH    960
03C82:  MOV.B   W5L,[W15-#2]
03C84:  POP     960
03C86:  CLR.B   961
03C88:  CALL    323A
03C8C:  INC.B   093E
03C8E:  GOTO    3C6C
....................                          
....................                      fprintf(RS232,"\n\r"); 
03C92:  BTSC.B  219.1
03C94:  BRA     3C92
03C96:  MOV     #A,W4
03C98:  MOV     W4,21A
03C9A:  BTSC.B  219.1
03C9C:  BRA     3C9A
03C9E:  MOV     #D,W4
03CA0:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
03CA2:  BSET.B  8B0.2
....................                      for(mem=0; mem<100; mem++) 
03CA4:  CLR.B   93E
03CA6:  MOV     93E,W4
03CA8:  MOV     #64,W3
03CAA:  CP.B    W3L,W4L
03CAC:  BRA     LEU,3CBC
....................                         data_get_pos(mem); 
03CAE:  MOV.B   93E,W0L
03CB0:  MOV.B   W0L,964
03CB2:  CALL    315C
03CB6:  INC.B   093E
03CB8:  GOTO    3CA6
....................                      debug_mode_fr=0; 
03CBC:  BCLR.B  8B0.2
....................                   } 
....................                   break; 
03CBE:  GOTO    3D4E
....................       case 'f':   fprintf(RS232,"\n\rClear Memory (Yes -> 1, No -> 0): "); 
03CC2:  MOV     #0,W1
03CC4:  MOV     W1,W0
03CC6:  CLR.B   1
03CC8:  CALL    12AA
03CCC:  INC     W1,W1
03CCE:  BTSC.B  219.1
03CD0:  BRA     3CCE
03CD2:  MOV     W0,21A
03CD4:  MOV     #23,W0
03CD6:  CPSGT   W1,W0
03CD8:  BRA     3CC4
....................                   input_mem_test=(unsigned)(fgetc(RS232)-48); 
03CDA:  BTSS.B  218.0
03CDC:  BRA     3CDA
03CDE:  MOV     21C,W0
03CE0:  SUB.B   #30,W0L
03CE2:  MOV.B   W0L,93C
03CE4:  CLR.B   93D
....................                   fputc(input_mem_test+48,RS232); 
03CE6:  MOV     #30,W4
03CE8:  MOV     93C,W3
03CEA:  ADD     W3,W4,W5
03CEC:  MOV.B   W5L,W0L
03CEE:  BTSC.B  219.1
03CF0:  BRA     3CEE
03CF2:  MOV.B   W0L,21A
03CF4:  CLR.B   21B
....................                    
....................                   if(input_mem_test == 1) 
03CF6:  MOV     93C,W4
03CF8:  CP      W4,#1
03CFA:  BRA     NZ,3D42
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
03CFC:  CLR.B   93E
03CFE:  MOV     93E,W4
03D00:  MOV     #64,W3
03D02:  CP.B    W3L,W4L
03D04:  BRA     LEU,3D16
....................                         data_set_pos(mem, 0); 
03D06:  MOV.B   93E,W0L
03D08:  MOV.B   W0L,95E
03D0A:  CLR     960
03D0C:  CALL    323A
03D10:  INC.B   093E
03D12:  GOTO    3CFE
....................                          
....................                      fprintf(RS232,"\n\r"); 
03D16:  BTSC.B  219.1
03D18:  BRA     3D16
03D1A:  MOV     #A,W4
03D1C:  MOV     W4,21A
03D1E:  BTSC.B  219.1
03D20:  BRA     3D1E
03D22:  MOV     #D,W4
03D24:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
03D26:  BSET.B  8B0.2
....................                      for(mem=0; mem<100; mem++) 
03D28:  CLR.B   93E
03D2A:  MOV     93E,W4
03D2C:  MOV     #64,W3
03D2E:  CP.B    W3L,W4L
03D30:  BRA     LEU,3D40
....................                         data_get_pos(mem); 
03D32:  MOV.B   93E,W0L
03D34:  MOV.B   W0L,964
03D36:  CALL    315C
03D3A:  INC.B   093E
03D3C:  GOTO    3D2A
....................                      debug_mode_fr=0; 
03D40:  BCLR.B  8B0.2
....................                   } 
....................                   break; 
03D42:  GOTO    3D4E
....................       case 'g':    
....................                   break; 
03D46:  GOTO    3D4E
....................       case 'y':    
....................                   break; 
03D4A:  GOTO    3D4E
....................    } 
....................     
....................    return; 
.................... } 
03D4E:  MOV     [--W15],W6
03D50:  MOV     [--W15],W5
03D52:  RETURN  
....................  
.................... // Parallel port strobe signal interrupt 
.................... #INT_EXT3 
.................... void isr_pp_strobe() 
.................... { 
*
0133A:  PUSH    42
0133C:  PUSH    36
0133E:  MOV     W0,[W15++]
01340:  MOV     #2,W0
01342:  REPEAT  #C
01344:  MOV     [W0++],[W15++]
....................    if(reg_comm_type == 0) 
01346:  BTSC.B  8B0.6
01348:  BRA     134C
....................       reg_pp_strobe = 1; 
0134A:  BSET.B  8FC.0
.................... } 
.................... // RS232 receive byte interrupt 
0134C:  BCLR.B  88.4
0134E:  MOV     #1A,W0
01350:  REPEAT  #C
01352:  MOV     [--W15],[W0--]
01354:  MOV     [--W15],W0
01356:  POP     36
01358:  POP     42
0135A:  RETFIE  
.................... #INT_RDA2 
.................... void isr_rs232_message() 
.................... { 
0135C:  PUSH    42
0135E:  PUSH    36
01360:  MOV     W0,[W15++]
01362:  MOV     #2,W0
01364:  REPEAT  #C
01366:  MOV     [W0++],[W15++]
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1;   
01368:  BSET.B  8FC.3
.................... }  
.................... // Clears RS232 interrupt flags 
0136A:  BCLR.B  87.0
0136C:  MOV     #1A,W0
0136E:  REPEAT  #C
01370:  MOV     [--W15],[W0--]
01372:  MOV     [--W15],W0
01374:  POP     36
01376:  POP     42
01378:  RETFIE  
.................... void rs232_clear() 
.................... { 
....................    UART_IFS0_U1RXIF = 0; 
....................    UART_IFS0_U1TXIF = 0; 
....................    reg_rs232_message = 0; 
.................... } 
....................  
.................... // Main method 
.................... void main() 
.................... { 
*
04164:  BSET.B  81.7
04166:  MOV     #8000,W4
04168:  MOV     W4,20C
0416A:  MOV     #400,W4
0416C:  MOV     W4,20E
0416E:  MOV     #30,W4
04170:  MOV     W4,214
04172:  MOV     #8000,W4
04174:  MOV     W4,216
04176:  MOV     #400,W4
04178:  MOV     W4,218
0417A:  MOV     #30,W4
0417C:  MOV     W4,21E
0417E:  BCLR.B  8B0.0
04180:  BCLR.B  8B0.1
04182:  BCLR.B  8B0.2
04184:  BCLR.B  8B0.3
04186:  BCLR.B  8B0.4
04188:  BCLR.B  8B0.5
0418A:  MOV     #20,W4
0418C:  MOV     W4,8B2
0418E:  MOV     #3FF,W4
04190:  MOV     W4,8B4
04192:  MOV     #323,W4
04194:  MOV     W4,8B6
04196:  MOV     #46,W4
04198:  MOV     W4,8B8
0419A:  MOV     #1C,W4
0419C:  MOV     W4,8BA
0419E:  CLR     8BC
041A0:  MOV     #190,W4
041A2:  MOV     W4,8BE
041A4:  MOV     #2D,W4
041A6:  MOV     W4,8C0
041A8:  MOV     #3E8,W4
041AA:  MOV     W4,8C2
041AC:  MOV     #32,W4
041AE:  MOV     W4,8C4
041B0:  MOV     #64,W4
041B2:  MOV     W4,8C6
041B4:  MOV     #46,W4
041B6:  MOV     W4,8C8
041B8:  CLR     8CA
041BA:  MOV     #BB8,W4
041BC:  MOV     W4,8CC
041BE:  MOV     #BB8,W4
041C0:  MOV     W4,8CE
041C2:  MOV     #64,W4
041C4:  MOV     W4,8D0
041C6:  CLR.B   8B1
041C8:  CLR     8D2
041CA:  CLR     8D4
041CC:  CLR     8D6
041CE:  CLR     8D8
041D0:  CLR     8DA
041D2:  CLR     8DC
041D4:  CLR     8DE
041D6:  CLR     8E0
041D8:  CLR     8E2
041DA:  MOV     #D,W4
041DC:  MOV     W4,8E4
041DE:  MOV     #F,W4
041E0:  MOV     W4,8E6
041E2:  MOV     #11,W4
041E4:  MOV     W4,8E8
041E6:  MOV     #13,W4
041E8:  MOV     W4,8EA
041EA:  MOV     #15,W4
041EC:  MOV     W4,8EC
041EE:  MOV     #17,W4
041F0:  MOV     W4,8EE
041F2:  MOV     #18,W4
041F4:  MOV     W4,8F0
041F6:  MOV     #1A,W4
041F8:  MOV     W4,8F2
041FA:  MOV     #A,W4
041FC:  MOV     W4,8F4
041FE:  MOV     #1,W4
04200:  MOV     W4,8F6
04202:  MOV     #64,W4
04204:  MOV     W4,8F8
04206:  MOV     #64,W4
04208:  MOV     W4,8FA
0420A:  BCLR.B  8B0.6
0420C:  BCLR.B  8B0.7
0420E:  BCLR.B  8FC.0
04210:  BCLR.B  8FC.1
04212:  BCLR.B  8FC.2
04214:  BCLR.B  8FC.3
04216:  BCLR.B  8FC.4
04218:  MOV     #58,W4
0421A:  MOV     W4,8FE
0421C:  SETM    2A8
0421E:  MOV     #2780,W15
04220:  MOV     #27FF,W0
04222:  MOV     W0,20
04224:  NOP     
04226:  BRA     42BC
04228:  DATA    C0,06,08
0422A:  DATA    00,00,00
0422C:  DATA    4B,F0,3F
0422E:  DATA    5C,0A,58
04230:  DATA    F6,3B,8F
04232:  DATA    00,C0,3C
04234:  DATA    8B,28,AC
04236:  DATA    3C,BE,F6
04238:  DATA    3F,D2,D5
0423A:  DATA    44,16,8C
0423C:  DATA    15,D7,BF
0423E:  DATA    69,00,5A
04240:  DATA    2E,1B,87
04242:  DATA    99,3F,9A
04244:  DATA    5F,AD,4B
04246:  DATA    91,E4,01
04248:  DATA    C0,5D,11
0424A:  DATA    2F,92,E4
0424C:  DATA    81,FB,3F
0424E:  DATA    38,DA,91
04250:  DATA    80,9D,C5
04252:  DATA    E0,BF,6F
04254:  DATA    12,C0,B4
04256:  DATA    C3,09,AB
04258:  DATA    3F,6B,C1
0425A:  DATA    03,4E,C1
0425C:  DATA    B5,45,BF
0425E:  DATA    F7,40,05
04260:  DATA    FF,00,5A
04262:  DATA    EF,3F,F3
04264:  DATA    A3,E2,F7
04266:  DATA    D7,FF,01
04268:  DATA    40,C0,B4
0426A:  DATA    FF,05,3C
0426C:  DATA    58,FC,3F
0426E:  DATA    3B,D3,C0
04270:  DATA    B5,BA,8C
04272:  DATA    E2,3F,39
04274:  DATA    D3,C7,3D
04276:  DATA    41,79,B2
04278:  DATA    3F,87,0D
0427A:  DATA    3C,50,D0
0427C:  DATA    AF,62,3F
0427E:  DATA    30,4B,8D
04280:  DATA    A2,82,AA
04282:  DATA    04,40,09
04284:  DATA    A0,40,4A
04286:  DATA    05,76,03
04288:  DATA    40,EC,9E
0428A:  DATA    37,88,A6
0428C:  DATA    44,F0,3F
0428E:  DATA    8F,12,8D
04290:  DATA    29,9A,5B
04292:  DATA    C7,3F,0E
04294:  DATA    E0,80,7C
04296:  DATA    A1,D8,86
04298:  DATA    3F,29,4B
0429A:  DATA    FB,95,C2
0429C:  DATA    37,1A,3F
0429E:  DATA    00,00,00
042A0:  INC     W2,W2
042A2:  CP      W2,#1
042A4:  BRA     NZ,42AE
042A6:  TBLRDL  [W1],W3
042A8:  TBLRDH  [W1++],W4
042AA:  MOV.B   6,W0L
042AC:  RETURN  
042AE:  CP      W2,#2
042B0:  BRA     NZ,42B6
042B2:  MOV.B   7,W0L
042B4:  RETURN  
042B6:  MOV.B   8,W0L
042B8:  CLR     W2
042BA:  RETURN  
042BC:  MOV     #0,W6
042BE:  MOV     #0,W0
042C0:  MOV     W0,32
042C2:  MOV     #4228,W0
042C4:  MOV     W0,W1
042C6:  CLR     W2
042C8:  CALL    42A0
042CC:  MOV.B   W0L,B
042CE:  CALL    42A0
042D2:  MOV.B   W0L,A
042D4:  CP0     W5
042D6:  BRA     Z,430A
042D8:  BTSS    W5.F
042DA:  BRA     42EA
042DC:  CALL    42A0
042E0:  MOV.B   W0L,D
042E2:  CALL    42A0
042E6:  MOV.B   W0L,C
042E8:  BCLR    W5.F
042EA:  BTSS    W5.E
042EC:  BRA     42FE
042EE:  BCLR    W5.E
042F0:  DEC     W5,W5
042F2:  CALL    42A0
042F6:  MOV.B   W0L,W7L
042F8:  REPEAT  W5
042FA:  MOV.B   W7L,[W6++]
042FC:  BRA     42C8
042FE:  CALL    42A0
04302:  MOV.B   W0L,[W6++]
04304:  DEC     W5,W5
04306:  BRA     NZ,42FE
04308:  BRA     42C8
....................    // Set I/O states of the ports 
....................    //           FEDCBA9876543210 
....................    set_tris_b(0b1111111011111100); 
0430A:  MOV     #FEFC,W4
0430C:  MOV     W4,2C6
....................    set_tris_c(0b1111111111111111); 
0430E:  SETM    2CC
....................    set_tris_d(0b1111111100001111); 
04310:  MOV     #FF0F,W4
04312:  MOV     W4,2D2
....................    set_tris_e(0b1111111110000000); 
04314:  MOV     #FF80,W4
04316:  MOV     W4,2D8
....................    set_tris_f(0b1111111111111100); 
04318:  MOV     #FFFC,W4
0431A:  MOV     W4,2DE
....................    set_tris_g(0b1111111100111111); 
0431C:  MOV     #FF3F,W4
0431E:  MOV     W4,2E4
....................     
....................    // Set parallel port pins 
....................    output_low(PP_ACK); 
04320:  BCLR.B  2D2.4
04322:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04324:  BCLR.B  2D2.5
04326:  BCLR.B  2D6.5
....................     
....................    // Turn on debug led 
....................    output_high(LED); 
04328:  BCLR.B  2C7.0
0432A:  BSET.B  2CB.0
....................     
....................    //Turn on lasers 
....................    output_high(LAS_1); 
0432C:  BCLR.B  2C6.0
0432E:  BSET.B  2CA.0
....................    output_high(LAS_2); 
04330:  BCLR.B  2C6.1
04332:  BSET.B  2CA.1
....................    output_high(LAS_3); 
04334:  BCLR.B  2D2.6
04336:  BSET.B  2D6.6
....................  
....................    // Set A/D converter to read motor torque control voltage 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
04338:  MOV     #80,W4
0433A:  MOV     W4,2A4
0433C:  MOV     #80E0,W4
0433E:  MOV     W4,2A0
....................    setup_adc_ports(sAN2); 
04340:  MOV     #FFFB,W4
04342:  MOV     W4,2A8
04344:  CLR     2A2
....................    set_adc_channel(2); 
04346:  MOV     #2,W4
04348:  MOV     W4,2A6
....................     
....................    delay_ms(500); 
0434A:  MOV     #1F4,W0
0434C:  CALL    137A
....................     
....................    fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING SYSTEM\n\n\r"); 
04350:  MOV     #0,W1
04352:  MOV     W1,W0
04354:  CLR.B   1
04356:  CALL    12DC
0435A:  INC     W1,W1
0435C:  BTSC.B  219.1
0435E:  BRA     435C
04360:  MOV     W0,21A
04362:  MOV     #25,W0
04364:  CPSGT   W1,W0
04366:  BRA     4352
....................    fprintf(RS232,"Press 'c' for command list\n\n\r"); 
04368:  MOV     #0,W1
0436A:  MOV     W1,W0
0436C:  CLR.B   1
0436E:  CALL    1310
04372:  INC     W1,W1
04374:  BTSC.B  219.1
04376:  BRA     4374
04378:  MOV     W0,21A
0437A:  MOV     #1C,W0
0437C:  CPSGT   W1,W0
0437E:  BRA     436A
....................  
....................    // Initialize components 
....................    qei_init();                            // Initialize quadrature encoder  
04380:  CALL    138E
....................    pwm_init();                            // Initialize PWM module 
04384:  CALL    13F2
....................    dp_init();                             // Initialize digital potentiometer 
04388:  CALL    1430
....................    md_init();                             // Initialize motor driver 
0438C:  CALL    19EE
....................    fr_init();                             // Initialize FRAM 
04390:  CALL    1A18
....................    move_init();                           // Initializes the system for movement 
04394:  CALL    2B3A
....................     
....................    // Enable RS232 receive byte interrupt 
....................    enable_interrupts(INT_RDA2); 
04398:  BSET.B  8F.0
....................    // Enable parallel port strobe signal interrupt 
....................    ext_int_edge(3, H_TO_L); 
0439A:  BSET.B  82.3
....................    enable_interrupts(INT_EXT3); 
0439C:  BSET.B  90.4
....................     
....................    reg_comm_type = data_get_comm_type();  // Set communication type 
0439E:  CALL    2BCE
043A2:  BCLR.B  8B0.6
043A4:  BTSC.B  0.0
043A6:  BSET.B  8B0.6
....................     
....................    switch (reg_comm_type) 
....................    { 
043A8:  CLR.B   W0
043AA:  BTSC.B  8B0.6
043AC:  INC     W0,W0
043AE:  CLR.B   1
043B0:  XOR     #0,W0
043B2:  BRA     Z,43BA
043B4:  XOR     #1,W0
043B6:  BRA     Z,43C6
043B8:  BRA     43D2
....................       case 0   :  output_high(PP_ACK); 
043BA:  BCLR.B  2D2.4
043BC:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
043BE:  BCLR.B  2D2.5
043C0:  BSET.B  2D6.5
....................                   break; 
043C2:  GOTO    43E8
....................       case 1   :  output_low(PP_ACK); 
043C6:  BCLR.B  2D2.4
043C8:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
043CA:  BCLR.B  2D2.5
043CC:  BCLR.B  2D6.5
....................                   break; 
043CE:  GOTO    43E8
....................       default:    output_high(PP_ACK); 
043D2:  BCLR.B  2D2.4
043D4:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
043D6:  BCLR.B  2D2.5
043D8:  BSET.B  2D6.5
....................                   fr_write_byte(fr_comm_type, 0); 
043DA:  CLR.B   97E
043DC:  PUSH    8EE
043DE:  POP     97C
043E0:  CALL    2044
....................                   break; 
043E4:  GOTO    43E8
....................    } 
....................     
....................    while(true) 
....................    { 
....................       if(reg_rs232_message) 
043E8:  BTSS.B  8FC.3
043EA:  BRA     43FC
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
043EC:  BCLR.B  8F.0
....................  
....................          rs232_message(); 
043EE:  CALL    3256
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
043F2:  REPEAT  #3
043F4:  MOV     21C,W0
043F6:  BCLR.B  87.0
....................          enable_interrupts(INT_RDA2); 
043F8:  BSET.B  8F.0
....................          reg_rs232_message = 0; 
043FA:  BCLR.B  8FC.3
....................       } 
....................       if(reg_pp_strobe) 
043FC:  BTSS.B  8FC.0
043FE:  BRA     4484
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04400:  BCLR.B  8F.0
....................           
....................          reg_pp_strobe=0; 
04402:  BCLR.B  8FC.0
....................           
....................          if(debug_mode_pp) 
04404:  BTSS.B  8B0.1
04406:  BRA     4420
....................             fprintf(RS232,"Strobe received\n\r"); 
04408:  MOV     #0,W1
0440A:  MOV     W1,W0
0440C:  CLR.B   1
0440E:  CALL    A3E
04412:  INC     W1,W1
04414:  BTSC.B  219.1
04416:  BRA     4414
04418:  MOV     W0,21A
0441A:  MOV     #10,W0
0441C:  CPSGT   W1,W0
0441E:  BRA     440A
....................  
....................          unsigned int i; 
....................          for(i=0; i<pp_str_check; i++) 
04420:  CLR     900
04422:  MOV     900,W0
04424:  MOV     8F4,W4
04426:  CP      W4,W0
04428:  BRA     LEU,445A
....................          { 
....................             delay_ms(pp_str_delay); 
0442A:  MOV     8F6,W0
0442C:  CALL    137A
....................             if(input(PP_STR)==1) 
04430:  BSET.B  2D3.2
04432:  BTSS.B  2D5.2
04434:  BRA     4454
....................             { 
....................                if(debug_mode_pp) 
04436:  BTSS.B  8B0.1
04438:  BRA     4452
....................                   fprintf(RS232,"Strobe signal rejected\n\r"); 
0443A:  MOV     #0,W1
0443C:  MOV     W1,W0
0443E:  CLR.B   1
04440:  CALL    A5C
04444:  INC     W1,W1
04446:  BTSC.B  219.1
04448:  BRA     4446
0444A:  MOV     W0,21A
0444C:  MOV     #17,W0
0444E:  CPSGT   W1,W0
04450:  BRA     443C
....................                return; 
04452:  BRA     4488
....................             } 
....................          } 
04454:  INC     0900
04456:  GOTO    4422
....................           
....................          if(debug_mode_pp) 
0445A:  BTSS.B  8B0.1
0445C:  BRA     4476
....................             fprintf(RS232,"Strobe confirmed\n\r"); 
0445E:  MOV     #0,W1
04460:  MOV     W1,W0
04462:  CLR.B   1
04464:  CALL    A82
04468:  INC     W1,W1
0446A:  BTSC.B  219.1
0446C:  BRA     446A
0446E:  MOV     W0,21A
04470:  MOV     #11,W0
04472:  CPSGT   W1,W0
04474:  BRA     4460
....................  
....................          pp_get_command(); 
04476:  CALL    406E
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
0447A:  REPEAT  #3
0447C:  MOV     21C,W0
0447E:  BCLR.B  87.0
....................          enable_interrupts(INT_RDA2); 
04480:  BSET.B  8F.0
....................          reg_rs232_message = 0; 
04482:  BCLR.B  8FC.3
....................       } 
....................    } 
04484:  GOTO    43E8
.................... } 
04488:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 8713   HS2_PLL16 NOCKSFSM
          H: FF00  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: FF00  
   Word  3L: 87B3   PUT64 BORRES BROWNOUT LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: FF00  
   Word  4L: 310F   NOWRTB NOBSS NOEBS NORBS
          H: FF00  
   Word  5L: 330F   NOWRTSS NOSSS NOESS NORSS
          H: FF00  
   Word  6L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  7L: C003   ICSP1 NODEBUG
          H: FF00  

CCS PCD C Compiler, Version 4.108, 15145               12-Mar-14 08:33

               Filename: E:\File Server\Modesis\Proje Dosyalarý\LPS - Lazer Projeksiyon Sistemi\Eski Dosyalar\Software\SLS_6015_Servo_Lazer_Control_v3.5 - reset - mclr - ISR\Control_Card_v2.0.lst

               ROM used: 19294 bytes (20%)
                         Largest free fragment is 46242
               RAM used: 209 (3%) at main() level
                         443 (5%) worst case
               Stack:    10 worst case (8 in main + 2 for interrupts)

*
00000:  GOTO    45D0
*
00006:  DATA    EC,15,00
00008:  DATA    A4,15,00
0000A:  DATA    70,15,00
0000C:  DATA    70,15,00
0000E:  DATA    70,15,00
00010:  DATA    70,15,00
00012:  DATA    70,15,00
00014:  DATA    70,15,00
00016:  DATA    70,15,00
00018:  DATA    70,15,00
0001A:  DATA    70,15,00
0001C:  DATA    70,15,00
0001E:  DATA    70,15,00
00020:  DATA    70,15,00
00022:  DATA    70,15,00
00024:  DATA    70,15,00
00026:  DATA    70,15,00
00028:  DATA    70,15,00
0002A:  DATA    70,15,00
0002C:  DATA    70,15,00
0002E:  DATA    70,15,00
00030:  DATA    70,15,00
00032:  DATA    70,15,00
00034:  DATA    70,15,00
00036:  DATA    70,15,00
00038:  DATA    70,15,00
0003A:  DATA    70,15,00
0003C:  DATA    70,15,00
0003E:  DATA    70,15,00
00040:  DATA    70,15,00
00042:  DATA    70,15,00
00044:  DATA    56,16,00
00046:  DATA    70,15,00
00048:  DATA    70,15,00
0004A:  DATA    70,15,00
0004C:  DATA    70,15,00
0004E:  DATA    70,15,00
00050:  DATA    70,15,00
00052:  DATA    70,15,00
00054:  DATA    70,15,00
00056:  DATA    70,15,00
00058:  DATA    70,15,00
0005A:  DATA    70,15,00
0005C:  DATA    34,16,00
0005E:  DATA    70,15,00
00060:  DATA    70,15,00
00062:  DATA    70,15,00
00064:  DATA    70,15,00
00066:  DATA    70,15,00
00068:  DATA    70,15,00
0006A:  DATA    70,15,00
0006C:  DATA    70,15,00
0006E:  DATA    70,15,00
00070:  DATA    70,15,00
00072:  DATA    70,15,00
00074:  DATA    70,15,00
00076:  DATA    70,15,00
00078:  DATA    70,15,00
0007A:  DATA    70,15,00
0007C:  DATA    70,15,00
0007E:  DATA    70,15,00
.................... #INCLUDE <30f6015.h>  
.................... //////// Standard Header file for the DSPIC30F6015 device //////////////// 
.................... #device DSPIC30F6015 
.................... #list 
....................  
.................... #DEVICE ADC=10                                                    // Configures the read_adc return size as 10 bit 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                                                      // No Watch Dog Timer  
.................... #FUSES HS2_PLL16                                                  // HS crystal, Freq=16*(Fcryst/2) 
.................... #FUSES NOCKSFSM                                                   // Clock Switching is disabled, fail Safe clock monitor is disabled  
.................... #FUSES BROWNOUT                                                   // Reset when brownout detected  
.................... #FUSES NOPROTECT                                                  // Code not protected from reading  
.................... #FUSES NOWRT                                                      // Program memory not write protected  
.................... #FUSES NODEBUG                                                    // No Debug mode for ICD 
....................  
.................... #USE DELAY(clock=120000000)                                       // delay() func. adjusted for 120Mhz Primary Osc. 
*
01674:  CP0     W0
01676:  BTSC.B  42.1
01678:  BRA     1686
0167A:  REPEAT  #3529
0167C:  NOP     
0167E:  REPEAT  #3FFF
01680:  NOP     
01682:  DEC     W0,W0
01684:  BRA     1674
01686:  RETURN  
*
0201E:  CP0     W0
02020:  BTSC.B  42.1
02022:  BRA     202C
02024:  REPEAT  #17
02026:  NOP     
02028:  DEC     W0,W0
0202A:  BRA     201E
0202C:  RETURN  
.................... #USE RS232(stream=RS485,UART1,baud=38400,parity=N,bits=8,stop=1)  // Set UART1 as RS485 stream 
.................... #USE RS232(stream=RS232,UART2,baud=38400,parity=N,bits=8,stop=1)  // Set UART2 as RS232 stream 
....................  
....................  
....................  
.................... //Register for Reset Info 
.................... #WORD RCON                 = 0x740           //Reset control register 
.................... #BIT RCON_POR              = RCON.0          //POR 
.................... #BIT RCON_BOR              = RCON.1          //BOR 
.................... #BIT RCON_IDLE             = RCON.2 
.................... #BIT RCON_SLEEP            = RCON.3 
.................... #BIT RCON_WDTO             = RCON.4 
.................... #BIT RCON_SWDTEN           = RCON.5 
.................... #BIT RCON_SWR              = RCON.6 
.................... #BIT RCON_EXTR             = RCON.7         //MCLR Reset during normal operation 
.................... #BIT RCON_BGST             = RCON.13 
.................... #BIT RCON_IOPUWR           = RCON.14 
.................... #BIT RCON_TRAPR            = RCON.15 
....................  
....................  
....................  
.................... // Registers of quadrature encoder interface module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD QEI_QEICON        = 0x122           // Control and status register QEICON allows control of the QEI operation and status flags indicating the module state. 
.................... #WORD QEI_DFLTCON       = 0x124           // Digital filter control register DFLTCON allows control of the digital input filter operation. 
.................... #WORD QEI_POSCNT        = 0x126           // Position count register POSCNT allows reading and writing of the 16-bit position counter. 
.................... #WORD QEI_MAXCNT        = 0x128           // Maximum count register MAXCNT holds a value that will be compared to the POSCNT counter in some operations. 
.................... // Bits of the QEICON register 
.................... #BIT QEI_QEICON_CNTERR  = QEI_QEICON.15   // Count error status flag bit 
.................... #BIT QEI_QEICON_QEISIDL = QEI_QEICON.13   // Stop in idle mode bit 
.................... #BIT QEI_QEICON_INDEX   = QEI_QEICON.12   // Index pin state status bit (read only) 
.................... #BIT QEI_QEICON_UPDN    = QEI_QEICON.11   // Position counter direction status bit (read only) 
.................... #BIT QEI_QEICON_QEIM2   = QEI_QEICON.10   // Quadrature encoder interface mode select bits 
.................... #BIT QEI_QEICON_QEIM1   = QEI_QEICON.9 
.................... #BIT QEI_QEICON_QEIM0   = QEI_QEICON.8 
.................... #BIT QEI_QEICON_SWPAB   = QEI_QEICON.7    // Phase A and phase B input swap select bit  
.................... #BIT QEI_QEICON_PCDOUT  = QEI_QEICON.6    // Position counter direction state output rnable bit 
.................... #BIT QEI_QEICON_TQGATE  = QEI_QEICON.5    // Timer gated time accumulation rnable bit 
.................... #BIT QEI_QEICON_TQCKPS1 = QEI_QEICON.4    // Timer input clock prescale select bits 
.................... #BIT QEI_QEICON_TQCKPS0 = QEI_QEICON.3 
.................... #BIT QEI_QEICON_POSRES  = QEI_QEICON.2    // Position counter reset enable bit 
.................... #BIT QEI_QEICON_TQCS    = QEI_QEICON.1    // Timer clock source select bit 
.................... #BIT QEI_QEICON_UDSRC   = QEI_QEICON.0    // Position counter direction selection control bit 
.................... // Bits of the DFLTCON register 
.................... #BIT QEI_DFLTCON_IMV1   = QEI_DFLTCON.10  // Index match value bits 
.................... #BIT QEI_DFLTCON_IMV0   = QEI_DFLTCON.9   // These bits allow the user to specify the state of the QEA and QEB input pins during an Index pulse when the POSCNT register is to be reset. 
.................... #BIT QEI_DFLTCON_CEID   = QEI_DFLTCON.8   // Count error interrupt disable bit 
.................... #BIT QEI_DFLTCON_QEOUT  = QEI_DFLTCON.7   // QEA/QEB/IND digital filter output enable bit  
.................... #BIT QEI_DFLTCON_QECK2  = QEI_DFLTCON.6   // QEA/QEB/IND digital filter clock divide select bits 
.................... #BIT QEI_DFLTCON_QECK1  = QEI_DFLTCON.5      
.................... #BIT QEI_DFLTCON_QECK0  = QEI_DFLTCON.4 
....................  
.................... // Registers of the motor control PWM module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD PWM_PTCON         = 0x1C0           // PWM Time base control register 
.................... #WORD PWM_PTPER         = 0x1C4           // PWM Time base period register 
.................... #WORD PWM_PWMCON1       = 0x1C8           // PWM Control register #1 
.................... #WORD PWM_PWMCON2       = 0x1CA           // PWM Control register #2 
.................... #WORD PWM_PDC1          = 0x1D6           // PWM Duty cycle register #1 
.................... #WORD PWM_IEC2          = 0x090           // PWM Interrupt Enable Control Register 
.................... #WORD PWM_IFS2          = 0x088           // PWM Interrupt Flag Status Register 
.................... // Bits of the PTCON register 
.................... #BIT PWM_PTCON_PTEN     = PWM_PTCON.15    // PWM Time base timer enable bit 
.................... #BIT PWM_PTCON_PTOPS3   = PWM_PTCON.7     // PWM Time base output postscale select bits  
.................... #BIT PWM_PTCON_PTOPS2   = PWM_PTCON.6 
.................... #BIT PWM_PTCON_PTOPS1   = PWM_PTCON.5 
.................... #BIT PWM_PTCON_PTOPS0   = PWM_PTCON.4 
.................... #BIT PWM_PTCON_PTCKPS1  = PWM_PTCON.3     // PWM Time base input clock prescale select bits 
.................... #BIT PWM_PTCON_PTCKPS0  = PWM_PTCON.2     
.................... #BIT PWM_PTCON_PTMOD1   = PWM_PTCON.1     // PWM Time base mode select bits 
.................... #BIT PWM_PTCON_PTMOD0   = PWM_PTCON.0 
.................... // Bits of the PWMCON1 register 
.................... #BIT PWM_PWMCON1_PMOD1  = PWM_PWMCON1.8   // PWM1 I/O pin pair mode bit 
.................... #BIT PWM_PWMCON1_PEN1H  = PWM_PWMCON1.4   // PWM1H I/O pin enable bit 
.................... #BIT PWM_PWMCON1_PEN1L  = PWM_PWMCON1.0   // PWM1L I/O pin enable bit 
.................... // Bits of the PWMCON2 register   
.................... #BIT PWM_PWMCON2_IUE    = PWM_PWMCON2.2   // Immediate update enable bit 
.................... #BIT PWM_PWMCON2_OSYNC  = PWM_PWMCON2.1   // Output override synchronization bit 
.................... #BIT PWM_PWMCON2_UDIS   = PWM_PWMCON2.0   // PWM update disable bit 
.................... // Bits of the IEC2 register 
.................... #BIT PWM_IEC2_PWMIE     = PWM_IEC2.7      // PWM Interrupt enable bit  
.................... // Bits of the IFS2 register 
.................... #BIT PWM_IFS2_PWMIF     = PWM_IFS2.7      // PWM Interrupt flag status bit     
....................  
.................... // Registers of the UART1 module 
.................... #WORD UART_IFS0          = 0x088           // UART Interrupt Flag Status Register 
.................... // Bits of the IFS0 register 
.................... #BIT UART_IFS0_U1RXIF    = UART_IFS0.9     // UART Receiver Interrupt flag status bit   
.................... #BIT UART_IFS0_U1TXIF    = UART_IFS0.10    // UART Transmiter Interrupt flag status bit   
....................  
.................... // Led pins 
.................... #DEFINE LED          PIN_B8               // Led used in debugging 
....................  
.................... // Laser pins 
.................... #DEFINE LAS_1        PIN_B0               // Control pin of the first laser 
.................... #DEFINE LAS_2        PIN_B1               // Control pin of the second laser 
.................... #DEFINE LAS_3        PIN_D6               // Control pin of the third laser 
....................  
.................... //Parallel Port Pin Assignments 
.................... #DEFINE PP_D0        PIN_D8               // Parallel port data pin first bit 
.................... #DEFINE PP_D1        PIN_D9               // Parallel port data pin second bit 
.................... #DEFINE PP_D2        PIN_D0               // Parallel port data pin third bit 
.................... #DEFINE PP_D3        PIN_C13              // Parallel port data pin fourth bit 
.................... #DEFINE PP_D4        PIN_C14              // Parallel port data pin fifth bit 
.................... #DEFINE PP_D5        PIN_D1               // Parallel port data pin sixth bit 
.................... #DEFINE PP_D6        PIN_D2               // Parallel port data pin seventh bit 
.................... #DEFINE PP_D7        PIN_D3               // Parallel port data pin eigth bit 
.................... #DEFINE PP_STR       PIN_D10              // Parallel port strobe pin 
.................... #DEFINE PP_ACK       PIN_D4               // Parallel port acknowledge pin used to  
.................... #DEFINE PP_RDY       PIN_D5               // Parallel port ready pin 
....................  
.................... // Pins used to control digital potentiometer 
.................... #DEFINE DP_CS        PIN_G9               // Digital potentiometer chip select pin assignment (active low) 
.................... #DEFINE DP_UD        PIN_G8               // Digital potentiometer up/down control pin assignment 
....................  
.................... // Pins used to control motor driver 
.................... #DEFINE MD_MS1       PIN_F0               // Step resolution select pin 1 assignment 
.................... #DEFINE MD_MS2       PIN_D7               // Step resolution select pin 2 assignment 
.................... #DEFINE MD_SR        PIN_F1               // Active mode (synchronous rectification) input pin assignment 
.................... #DEFINE MD_RESET     PIN_E0               // Reset input pin assignment (active low) 
.................... #DEFINE MD_STEP      PIN_E1               // Step input pin assignment 
.................... #DEFINE MD_ENABLE    PIN_E2               // Enable input pin assignment (active low) 
.................... #DEFINE MD_SLEEP     PIN_E3               // Sleep input pin assignment (active low) 
.................... #DEFINE MD_DIR       PIN_E4               // Direction input pin assignment 
.................... #DEFINE MD_SW        PIN_D11              // Homing switch input pin assignment 
....................  
.................... // Pins used to control FRAM 
.................... #DEFINE FR_CS        PIN_G7               // FRAM chip select pin assignment (active low) 
.................... #DEFINE FR_WP        PIN_G6               // FRAM write protection pin assignment (active low) 
.................... #DEFINE FR_SCK       PIN_E5               // FRAM serial clock pin assignment 
.................... #DEFINE FR_SI        PIN_E6               // FRAM serial input pin assignment 
.................... #DEFINE FR_SO        PIN_E7               // FRAM serial output pin assignment 
....................  
.................... // Speed ramp states 
.................... #DEFINE HOME         0 
.................... #DEFINE ACCEL        1 
.................... #DEFINE DECEL        2 
.................... #DEFINE RUN          3 
.................... #DEFINE POS          4 
....................  
.................... // PWM module operating modes 
.................... #DEFINE FREE         0 
.................... #DEFINE SINGLE       1 
....................  
.................... int1           debug_mode_dp     = 0;              // Debug state of digital potentiometer 
.................... int1           debug_mode_pp     = 0;              // Debug state of parallel port communication 
.................... int1           debug_mode_fr     = 0;              // Debug state of FRAM 
.................... int1           debug_mode_md     = 0;              // Debug state of motor driver 
.................... int1           debug_mode_pwm    = 0;              // Debug state of motor control PWM module 
.................... int1           debug_mode_qei    = 0;              // Debug state of quadrature encoder 
....................  
.................... unsigned int   dp_tap_limit      = 32;             // Digital potentiometer maximum tap level 
.................... unsigned int   dp_voltage_limit  = 1023;           // Digital potentiometer maximum voltage level 
....................  
.................... unsigned int   mt_voltage_limit  = 803;            // Motor torque control voltage is limited to 4V (which is defined in driver specs) 
.................... unsigned int   mt_percent_trip   = 70;             // Motor torque percent while system is moving 
.................... unsigned int   mt_percent_rest   = 28;             // Motor torque percent while system is stationary 
....................  
.................... unsigned int   md_conv_const     = 0;              // Constant used to convert encoder count to motor step 
.................... unsigned int   md_move_range     = 400;            // Movement range of the device 
.................... unsigned int   md_home_pos       = 45;             // Sets the number of encoder counts between the home position and homing switch position 
.................... unsigned int   md_end_pos        = 1000;           // Sets the number of encoder counts between the home position and the end of movement range 
.................... unsigned int   md_end_offset     = 50;             // Offset of the maximum count number from the end position 
.................... unsigned int   md_home_offset    = 100;            // Offset of the maximum count number from the home position 
.................... unsigned int   md_min_distance   = 70;             // Minimum distance between symmetricaly moving lasers 
.................... unsigned int   md_target_count   = 0;              // Target position count 
....................  
.................... unsigned int   md_accel          = 3000;           // Acceleration of the motor (0.01 mm/s2) 
.................... unsigned int   md_decel          = 3000;           // Deceleration of the motor (0.01 mm/s2) 
....................  
.................... unsigned int   md_min_delay      = 100;            // Minimum time delay (max speed) 
.................... unsigned char  md_run_state      = 0;              // What part of the speed ramp we are in. 
.................... unsigned int   md_decel_lim      = 0;              // What step_pos to start decelaration 
.................... unsigned int   md_accel_lim      = 0;              // What step_pos to end accelaration 
.................... unsigned int   md_decel_count    = 0;              // Counter used when decelerateing to calculate step_delay. 
.................... unsigned int   md_pos_iter       = 0;              // Number of iterations performed during positioning 
.................... int            md_error          = 0;              // Positioning error 
.................... unsigned int   md_backlash       = 0;              // Backlash of the positioning system 
....................  
.................... unsigned int   md_cc_step        = 0;              // Motor count used in conversion constant conversion 
.................... unsigned int   md_cc_count       = 0;              // Encoder count used in conversion constant conversion 
....................  
.................... unsigned int   fr_serial_no      = 0;              // External adress of product serial no 
.................... unsigned int   fr_move_range     = 13;             // External adress of movement range 
.................... unsigned int   fr_home_pos       = 15;             // External adress of home position 
.................... unsigned int   fr_end_pos        = 17;             // External addres of end position 
.................... unsigned int   fr_conv_const     = 19;             // External adress of conversion constant 
.................... unsigned int   fr_backlash       = 21;             // External adress of backlash compensation 
.................... unsigned int   fr_comm_type      = 23;             // External adress of communication type 
.................... unsigned int   fr_last_pos       = 24;             // External adress of last position 
.................... unsigned int   fr_pos_table      = 26;             // External adress of position table 
....................  
.................... unsigned int   pp_str_check      = 10;             // Parallel port strobe signal filter iteration number 
.................... unsigned int   pp_str_delay      = 1;              // Parallel port strobe signal filter pause time (ms) 
.................... unsigned int   pp_ack_delay      = 100;            // Parallel port acknowledge signal pause time (ms) 
.................... unsigned int   pp_rdy_delay      = 100;            // Parallel port ready signal pause time (ms) 
....................  
.................... int1           reg_comm_type     = 0;              // Communication type register 
.................... int1           reg_pp_stop       = 0;              // Parallel port emergency stop signal register 
.................... int1           reg_pp_strobe     = 0;              // Parallel port strobe signal active register 
.................... int1           reg_md_home       = 0;              // Homing action register 
.................... int1           reg_md_home_return= 0;              // Home correction return register 
.................... int1           reg_rs232_message = 0;              // RS232 message flag 
.................... int1           reg_md_cc_sample  = 0;              // Special case register for conversion constant calculation 
....................  
.................... #DEFINE ACC_15 
....................  
.................... #IFDEF ACC_10 
.................... unsigned int   md_max_acc_lim    = 116;             // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... unsigned int const delays[116]={2449,1015,779,656,578,523,481,447,420,397,378,361,346,333,322,311,302,293,285,277,271,264,258,253,247,243,238,234,229,226,222,218,215,212,209,206,203,200,197,195,192,190,188,186,184,182,180, 
.................... 178,176,174,172,171,169,167,166,164,163,162,160,159,157,156,155,154,152,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115, 
.................... 114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_15 
.................... unsigned int   md_max_acc_lim    = 88;             // Number of steps before we hit max speed. acc=15000 dec=15000 
.................... unsigned int const delays[88]={2000,828,636,536,472,427,393,365,343,325,309,295,283,272,263,254,246,239,233,226,221,216,211,206,202,198,194,191,187,184,181,178,175,173,170,168,166,163,161,159,157,155,153,152,150,148,147, 
.................... 145,144,142,141,139,138,137,135,134,133,132,131,130,129,128,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_20 
.................... unsigned int   md_max_acc_lim    = 71;             // Number of steps before we hit max speed. acc=20000 dec=20000  
.................... unsigned int const delays[71]={1732,717,551,464,409,370,340,316,297,281,267,255,245,236,227,220,213,207,201,196,191,187,183,179,175,172,168,165,162,159,157,154,152,150,147,145,143,141,140,138,136,134,133,131,130,128,127, 
.................... 126,124,123,122,121,120,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_25 
.................... unsigned int   md_max_acc_lim    = 59;             // Number of steps before we hit max speed. acc=25000 dec=25000  
.................... unsigned int const delays[59]={1549,642,492,415,366,331,304,283,266,251,239,228,219,211,203,197,191,185,180,175,171,167,163,160,157,153,150,148,145,143,140,138,136,134,132,130,128,126,125,123,122,120,119,117,116,115,114, 
.................... 112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_30 
.................... unsigned int   md_max_acc_lim    = 50;             // Number of steps before we hit max speed. acc=30000 dec=30000  
.................... unsigned int const delays[50]={1414,586,449,379,334,302,278,258,243,229,218,209,200,192,186,180,174,169,164,160,156,153,149,146,143,140,137,135,132,130,128,126,124,122,120,119,117,115,114,113,111,110,108,107,106,105,104, 
.................... 103,102,101}; 
.................... #ENDIF 
....................  
.................... void move_pos(unsigned int16 position); 
.................... unsigned int16 qei_get_count(); 
....................  
.................... // Initializes digital potentiometer 
.................... void dp_init()  
.................... { 
....................    output_high(DP_CS);                       // Chip select is active low so keep it disabled 
*
017E4:  BCLR.B  2E5.1
017E6:  BSET.B  2E9.1
....................    output_low(DP_UD);                        // Up/down control pin can be in any state 
017E8:  BCLR.B  2E5.0
017EA:  BCLR.B  2E9.0
.................... } 
017EC:  RETURN  
.................... // Increases digital potentiometer by given tap 
.................... void dp_up(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
*
01872:  MOV     802,W0
01874:  MOV     8C4,W4
01876:  CP      W4,W0
01878:  BRA     LEU,187E
....................       tap=dp_tap_limit; 
0187A:  PUSH    802
0187C:  POP     8C4
....................        
....................    output_high(DP_UD);        // Set U/D to high before activating digital potentiometer 
0187E:  BCLR.B  2E5.0
01880:  BSET.B  2E9.0
....................    delay_us(1); 
01882:  REPEAT  #1C
01884:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
01886:  BCLR.B  2E5.1
01888:  BCLR.B  2E9.1
....................    delay_us(1); 
0188A:  REPEAT  #1C
0188C:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
0188E:  CLR     8C6
01890:  MOV     8C6,W0
01892:  MOV     8C4,W4
01894:  CP      W4,W0
01896:  BRA     LEU,18B6
....................    { 
....................       output_low(DP_UD);      // Low part of pulse 
01898:  BCLR.B  2E5.0
0189A:  BCLR.B  2E9.0
....................       delay_us(1); 
0189C:  REPEAT  #1C
0189E:  NOP     
....................       output_high(DP_UD);     // High part of pulse 
018A0:  BCLR.B  2E5.0
018A2:  BSET.B  2E9.0
....................       delay_us(1); 
018A4:  REPEAT  #1C
018A6:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
018A8:  BCLR.B  2E5.0
018AA:  BCLR.B  2E9.0
....................       delay_us(1);  
018AC:  REPEAT  #1C
018AE:  NOP     
....................    } 
018B0:  INC     08C6
018B2:  GOTO    1890
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer   
018B6:  BCLR.B  2E5.1
018B8:  BSET.B  2E9.1
.................... } 
018BA:  RETURN  
.................... // Decreases digital potentiometer by given tap 
.................... void dp_down(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
018BC:  MOV     802,W0
018BE:  MOV     8C4,W4
018C0:  CP      W4,W0
018C2:  BRA     LEU,18C8
....................       tap=dp_tap_limit; 
018C4:  PUSH    802
018C6:  POP     8C4
....................        
....................    output_low(DP_UD);         // Set U/D to low before activating digital potentiometer 
018C8:  BCLR.B  2E5.0
018CA:  BCLR.B  2E9.0
....................    delay_us(1); 
018CC:  REPEAT  #1C
018CE:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
018D0:  BCLR.B  2E5.1
018D2:  BCLR.B  2E9.1
....................    delay_us(1);             
018D4:  REPEAT  #1C
018D6:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
018D8:  CLR     8C6
018DA:  MOV     8C6,W0
018DC:  MOV     8C4,W4
018DE:  CP      W4,W0
018E0:  BRA     LEU,18F8
....................    { 
....................       output_high(DP_UD);     // High part of pulse 
018E2:  BCLR.B  2E5.0
018E4:  BSET.B  2E9.0
....................       delay_us(1); 
018E6:  REPEAT  #1C
018E8:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
018EA:  BCLR.B  2E5.0
018EC:  BCLR.B  2E9.0
....................       delay_us(1);   
018EE:  REPEAT  #1C
018F0:  NOP     
....................    } 
018F2:  INC     08C6
018F4:  GOTO    18DA
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer 
018F8:  BCLR.B  2E5.1
018FA:  BSET.B  2E9.1
.................... } 
018FC:  RETURN  
.................... // Sets digital potentiometer to given voltage 
.................... void dp_set(unsigned int voltage) 
.................... { 
018FE:  MOV     W5,[W15++]
01900:  MOV     #3,W4
01902:  MOV     W4,8B0
01904:  CLR     8B2
01906:  MOV     #F,W4
01908:  MOV     W4,8B4
0190A:  MOV     8AE,W4
0190C:  MOV     802,W3
0190E:  MUL.UU  W4,W3,W0
01910:  MOV     W0,W5
01912:  MOV     W5,W4
01914:  MOV     804,W3
01916:  REPEAT  #11
01918:  DIV.U   W4,W3
0191A:  MOV     W0,8B6
0191C:  BCLR.B  2A0.0
0191E:  BSET.B  2A0.1
01920:  BTSS.B  2A0.0
01922:  BRA     1920
01924:  PUSH    280
01926:  POP     8B8
01928:  MOV     8AE,W4
0192A:  MOV     8B8,W3
0192C:  SUB     W4,W3,W5
0192E:  MOV     W5,W0
01930:  MOV     W5,8BA
....................    unsigned int iteration_limit=3;                                   // Maximum number of iterations to be performed to set voltage 
....................    unsigned int iteration=0;                                         // Number of iterations performed to set voltage 
....................    unsigned int region=15;                                           // We want the voltage to be inside this region (+/-)  
....................    unsigned int tap_desired=voltage*dp_tap_limit/dp_voltage_limit;   // Find the desired potentiometer tap 
....................    unsigned int voltage_current=read_adc();                          // Read the current voltage 
....................    unsigned int voltage_diff=abs(voltage-voltage_current);           // Find the difference between the current and desired voltage  
....................    unsigned int tap_current;                                         // Current tap value 
....................     
....................    if(debug_mode_dp) 
01932:  BTSS.B  800.0
01934:  BRA     1A04
....................    { 
....................       fprintf(RS232,"\n\r\tVoltage Desired: %u",voltage); 
01936:  MOV     #0,W1
01938:  MOV     W1,W0
0193A:  CALL    196
0193E:  INC     W1,W1
01940:  MOV     W1,[W15++]
01942:  BTSC.B  219.1
01944:  BRA     1942
01946:  MOV     W0,21A
01948:  MOV     [--W15],W1
0194A:  MOV     #13,W0
0194C:  CPSGT   W1,W0
0194E:  BRA     1938
01950:  MOV     8AE,W0
01952:  MOV     #0,W4
01954:  CALL    1688
....................       fprintf(RS232,"\n\r\tTap Desired: %u",dp_tap_limit*voltage/dp_voltage_limit); 
01958:  MOV     802,W4
0195A:  MOV     8AE,W3
0195C:  MUL.UU  W4,W3,W0
0195E:  MOV     W0,W5
01960:  MOV     W5,W4
01962:  MOV     804,W3
01964:  REPEAT  #11
01966:  DIV.U   W4,W3
01968:  MOV     W0,W5
0196A:  MOV     #0,W1
0196C:  MOV     W1,W0
0196E:  CALL    1BA
01972:  INC     W1,W1
01974:  MOV     W1,[W15++]
01976:  BTSC.B  219.1
01978:  BRA     1976
0197A:  MOV     W0,21A
0197C:  MOV     [--W15],W1
0197E:  MOV     #F,W0
01980:  CPSGT   W1,W0
01982:  BRA     196C
01984:  MOV     W5,W0
01986:  MOV     #0,W4
01988:  CALL    1688
....................       fprintf(RS232,"\n\r\tVoltage Current: %u",voltage_current); 
0198C:  MOV     #0,W1
0198E:  MOV     W1,W0
01990:  CALL    1DA
01994:  INC     W1,W1
01996:  MOV     W1,[W15++]
01998:  BTSC.B  219.1
0199A:  BRA     1998
0199C:  MOV     W0,21A
0199E:  MOV     [--W15],W1
019A0:  MOV     #13,W0
019A2:  CPSGT   W1,W0
019A4:  BRA     198E
019A6:  MOV     8B8,W0
019A8:  MOV     #0,W4
019AA:  CALL    1688
....................       fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
019AE:  MOV     802,W4
019B0:  MOV     8B8,W3
019B2:  MUL.UU  W4,W3,W0
019B4:  MOV     W0,W5
019B6:  MOV     W5,W4
019B8:  MOV     804,W3
019BA:  REPEAT  #11
019BC:  DIV.U   W4,W3
019BE:  MOV     W0,W5
019C0:  MOV     #0,W1
019C2:  MOV     W1,W0
019C4:  CALL    1FE
019C8:  INC     W1,W1
019CA:  MOV     W1,[W15++]
019CC:  BTSC.B  219.1
019CE:  BRA     19CC
019D0:  MOV     W0,21A
019D2:  MOV     [--W15],W1
019D4:  MOV     #F,W0
019D6:  CPSGT   W1,W0
019D8:  BRA     19C2
019DA:  MOV     W5,W0
019DC:  MOV     #0,W4
019DE:  CALL    1688
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",voltage_diff); 
019E2:  MOV     #0,W1
019E4:  MOV     W1,W0
019E6:  CALL    21E
019EA:  INC     W1,W1
019EC:  MOV     W1,[W15++]
019EE:  BTSC.B  219.1
019F0:  BRA     19EE
019F2:  MOV     W0,21A
019F4:  MOV     [--W15],W1
019F6:  MOV     #16,W0
019F8:  CPSGT   W1,W0
019FA:  BRA     19E4
019FC:  MOV     8BA,W0
019FE:  MOV     #0,W4
01A00:  CALL    1688
....................    } 
....................     
....................    while(voltage_diff>region)                                        // Try until voltage is found 
....................    {                                                                 // or iteration limit is reached  
01A04:  MOV     8B4,W0
01A06:  MOV     8BA,W4
01A08:  CP      W4,W0
01A0A:  BRA     LEU,1B7A
....................       if(iteration <iteration_limit)                      
01A0C:  MOV     8B2,W0
01A0E:  MOV     8B0,W4
01A10:  CP      W4,W0
01A12:  BRA     LEU,1B56
....................       { 
....................          iteration++;                                                // Set iteration number 
01A14:  INC     08B2
....................          tap_current=dp_tap_limit*voltage_current/dp_voltage_limit;  // Convert new voltage to tap 
01A16:  MOV     802,W4
01A18:  MOV     8B8,W3
01A1A:  MUL.UU  W4,W3,W0
01A1C:  MOV     W0,W5
01A1E:  MOV     W5,W4
01A20:  MOV     804,W3
01A22:  REPEAT  #11
01A24:  DIV.U   W4,W3
01A26:  MOV     W0,8BC
....................  
....................          if(tap_desired>tap_current)                                 // Set the digital potentiometer to desired tap 
01A28:  MOV     8BC,W0
01A2A:  MOV     8B6,W4
01A2C:  CP      W4,W0
01A2E:  BRA     LEU,1A40
....................          { 
....................             dp_up(tap_desired-tap_current); 
01A30:  MOV     8B6,W4
01A32:  MOV     8BC,W3
01A34:  SUB     W4,W3,W5
01A36:  MOV     W5,8C4
01A38:  CALL    1872
....................          } 
....................          else if(tap_desired<tap_current) 
01A3C:  GOTO    1A74
01A40:  MOV     8B6,W0
01A42:  MOV     8BC,W4
01A44:  CP      W4,W0
01A46:  BRA     LEU,1A58
....................          { 
....................             dp_down(tap_current-tap_desired); 
01A48:  MOV     8BC,W4
01A4A:  MOV     8B6,W3
01A4C:  SUB     W4,W3,W5
01A4E:  MOV     W5,8C4
01A50:  CALL    18BC
....................          } 
....................          else                                                        // If tap level is same as the previous one and it still outside the region 
01A54:  GOTO    1A74
....................          {                                                           // then go one step up or down according to desired voltage 
....................             if(voltage>voltage_current) 
01A58:  MOV     8B8,W0
01A5A:  MOV     8AE,W4
01A5C:  CP      W4,W0
01A5E:  BRA     LEU,1A6C
....................                dp_up(1); 
01A60:  MOV     #1,W4
01A62:  MOV     W4,8C4
01A64:  CALL    1872
....................             else 
01A68:  GOTO    1A74
....................                dp_down(1); 
01A6C:  MOV     #1,W4
01A6E:  MOV     W4,8C4
01A70:  CALL    18BC
....................          } 
....................           
....................          delay_ms(2); 
01A74:  REPEAT  #2A5E
01A76:  NOP     
01A78:  REPEAT  #3FFF
01A7A:  NOP     
01A7C:  REPEAT  #3FFF
01A7E:  NOP     
01A80:  REPEAT  #3FFF
01A82:  NOP     
....................              
....................          voltage_current=read_adc();                                 // Read the new voltage 
01A84:  BCLR.B  2A0.0
01A86:  BSET.B  2A0.1
01A88:  BTSS.B  2A0.0
01A8A:  BRA     1A88
01A8C:  PUSH    280
01A8E:  POP     8B8
....................           
....................          if(voltage>voltage_current)                                 // Find the difference between the new and desired voltages for next iteration check 
01A90:  MOV     8B8,W0
01A92:  MOV     8AE,W4
01A94:  CP      W4,W0
01A96:  BRA     LEU,1AA4
....................             voltage_diff=voltage - voltage_current; 
01A98:  MOV     8AE,W4
01A9A:  MOV     8B8,W3
01A9C:  SUB     W4,W3,W0
01A9E:  MOV     W0,8BA
....................          else 
01AA0:  GOTO    1AAC
....................             voltage_diff=voltage_current - voltage; 
01AA4:  MOV     8B8,W4
01AA6:  MOV     8AE,W3
01AA8:  SUB     W4,W3,W0
01AAA:  MOV     W0,8BA
....................           
....................          if(debug_mode_dp) 
01AAC:  BTSS.B  800.0
01AAE:  BRA     1B52
....................          { 
....................             fprintf(RS232,"\n\rITERATION: %u",iteration); 
01AB0:  MOV     #0,W1
01AB2:  MOV     W1,W0
01AB4:  CALL    244
01AB8:  INC     W1,W1
01ABA:  MOV     W1,[W15++]
01ABC:  BTSC.B  219.1
01ABE:  BRA     1ABC
01AC0:  MOV     W0,21A
01AC2:  MOV     [--W15],W1
01AC4:  MOV     #C,W0
01AC6:  CPSGT   W1,W0
01AC8:  BRA     1AB2
01ACA:  MOV     8B2,W0
01ACC:  MOV     #0,W4
01ACE:  CALL    1688
....................             fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01AD2:  MOV     802,W4
01AD4:  MOV     8B8,W3
01AD6:  MUL.UU  W4,W3,W0
01AD8:  MOV     W0,W5
01ADA:  MOV     W5,W4
01ADC:  MOV     804,W3
01ADE:  REPEAT  #11
01AE0:  DIV.U   W4,W3
01AE2:  MOV     W0,W5
01AE4:  MOV     #0,W1
01AE6:  MOV     W1,W0
01AE8:  CALL    1FE
01AEC:  INC     W1,W1
01AEE:  MOV     W1,[W15++]
01AF0:  BTSC.B  219.1
01AF2:  BRA     1AF0
01AF4:  MOV     W0,21A
01AF6:  MOV     [--W15],W1
01AF8:  MOV     #F,W0
01AFA:  CPSGT   W1,W0
01AFC:  BRA     1AE6
01AFE:  MOV     W5,W0
01B00:  MOV     #0,W4
01B02:  CALL    1688
....................             fprintf(RS232,"\n\r\tVoltage Current : %u",voltage_current); 
01B06:  MOV     #0,W1
01B08:  MOV     W1,W0
01B0A:  CALL    260
01B0E:  INC     W1,W1
01B10:  MOV     W1,[W15++]
01B12:  BTSC.B  219.1
01B14:  BRA     1B12
01B16:  MOV     W0,21A
01B18:  MOV     [--W15],W1
01B1A:  MOV     #14,W0
01B1C:  CPSGT   W1,W0
01B1E:  BRA     1B08
01B20:  MOV     8B8,W0
01B22:  MOV     #0,W4
01B24:  CALL    1688
....................             fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-voltage_current)); 
01B28:  MOV     8AE,W4
01B2A:  MOV     8B8,W3
01B2C:  SUB     W4,W3,W5
01B2E:  MOV     W5,W0
01B30:  MOV     #0,W1
01B32:  MOV     W1,W0
01B34:  CALL    21E
01B38:  INC     W1,W1
01B3A:  MOV     W1,[W15++]
01B3C:  BTSC.B  219.1
01B3E:  BRA     1B3C
01B40:  MOV     W0,21A
01B42:  MOV     [--W15],W1
01B44:  MOV     #16,W0
01B46:  CPSGT   W1,W0
01B48:  BRA     1B32
01B4A:  MOV     W5,W0
01B4C:  MOV     #0,W4
01B4E:  CALL    1688
....................          } 
....................       } 
....................       else 
01B52:  GOTO    1B76
....................       { 
....................          if(debug_mode_dp) 
01B56:  BTSS.B  800.0
01B58:  BRA     1B74
....................             fprintf(RS232,"\n\rIteration limit reached"); 
01B5A:  MOV     #0,W1
01B5C:  MOV     W1,W0
01B5E:  CALL    284
01B62:  INC     W1,W1
01B64:  MOV     W1,[W15++]
01B66:  BTSC.B  219.1
01B68:  BRA     1B66
01B6A:  MOV     W0,21A
01B6C:  MOV     [--W15],W1
01B6E:  MOV     #18,W0
01B70:  CPSGT   W1,W0
01B72:  BRA     1B5C
....................          return; 
01B74:  BRA     1C2A
....................       } 
....................    } 
01B76:  GOTO    1A04
....................     
....................    if(debug_mode_dp) 
01B7A:  BTSS.B  800.0
01B7C:  BRA     1C2A
....................    { 
....................       fprintf(RS232,"\n\rFOUND!"); 
01B7E:  MOV     #0,W1
01B80:  MOV     W1,W0
01B82:  CALL    2AA
01B86:  INC     W1,W1
01B88:  MOV     W1,[W15++]
01B8A:  BTSC.B  219.1
01B8C:  BRA     1B8A
01B8E:  MOV     W0,21A
01B90:  MOV     [--W15],W1
01B92:  MOV     #7,W0
01B94:  CPSGT   W1,W0
01B96:  BRA     1B80
....................       fprintf(RS232,"\n\r\tTap Current : %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01B98:  MOV     802,W4
01B9A:  MOV     8B8,W3
01B9C:  MUL.UU  W4,W3,W0
01B9E:  MOV     W0,W5
01BA0:  MOV     W5,W4
01BA2:  MOV     804,W3
01BA4:  REPEAT  #11
01BA6:  DIV.U   W4,W3
01BA8:  MOV     W0,W5
01BAA:  MOV     #0,W1
01BAC:  MOV     W1,W0
01BAE:  CALL    2C0
01BB2:  INC     W1,W1
01BB4:  MOV     W1,[W15++]
01BB6:  BTSC.B  219.1
01BB8:  BRA     1BB6
01BBA:  MOV     W0,21A
01BBC:  MOV     [--W15],W1
01BBE:  MOV     #10,W0
01BC0:  CPSGT   W1,W0
01BC2:  BRA     1BAC
01BC4:  MOV     W5,W0
01BC6:  MOV     #0,W4
01BC8:  CALL    1688
....................       fprintf(RS232,"\n\r\tVoltage Current : %u",read_adc()); 
01BCC:  BCLR.B  2A0.0
01BCE:  BSET.B  2A0.1
01BD0:  BTSS.B  2A0.0
01BD2:  BRA     1BD0
01BD4:  MOV     280,W5
01BD6:  MOV     #0,W1
01BD8:  MOV     W1,W0
01BDA:  CALL    260
01BDE:  INC     W1,W1
01BE0:  MOV     W1,[W15++]
01BE2:  BTSC.B  219.1
01BE4:  BRA     1BE2
01BE6:  MOV     W0,21A
01BE8:  MOV     [--W15],W1
01BEA:  MOV     #14,W0
01BEC:  CPSGT   W1,W0
01BEE:  BRA     1BD8
01BF0:  MOV     W5,W0
01BF2:  MOV     #0,W4
01BF4:  CALL    1688
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-read_adc())); 
01BF8:  BCLR.B  2A0.0
01BFA:  BSET.B  2A0.1
01BFC:  BTSS.B  2A0.0
01BFE:  BRA     1BFC
01C00:  MOV     280,W0
01C02:  MOV     8AE,W4
01C04:  SUB     W4,W0,W5
01C06:  MOV     W5,W0
01C08:  MOV     #0,W1
01C0A:  MOV     W1,W0
01C0C:  CALL    21E
01C10:  INC     W1,W1
01C12:  MOV     W1,[W15++]
01C14:  BTSC.B  219.1
01C16:  BRA     1C14
01C18:  MOV     W0,21A
01C1A:  MOV     [--W15],W1
01C1C:  MOV     #16,W0
01C1E:  CPSGT   W1,W0
01C20:  BRA     1C0A
01C22:  MOV     W5,W0
01C24:  MOV     #0,W4
01C26:  CALL    1688
....................    } 
.................... } 
01C2A:  MOV     [--W15],W5
01C2C:  RETURN  
....................  
.................... // Returns current motor torque in percent (%0-100) 
.................... unsigned int md_mt_get() 
.................... { 
01C2E:  MOV     W5,[W15++]
01C30:  MOV     W6,[W15++]
01C32:  BCLR.B  2A0.0
01C34:  BSET.B  2A0.1
01C36:  BTSS.B  2A0.0
01C38:  BRA     1C36
01C3A:  MOV     280,W0
01C3C:  MOV     #0,W1
01C3E:  MOV     W0,W2
01C40:  MOV     W1,W3
01C42:  MOV     #64,W0
01C44:  MOV     #0,W1
01C46:  CALL    17EE
01C4A:  MOV     W0,W5
01C4C:  MOV     W1,W6
01C4E:  BCLR.B  43.0
01C50:  MOV     W5,W0
01C52:  MOV     W6,W1
01C54:  MOV     806,W2
01C56:  MOV     #0,W3
01C58:  CALL    181E
01C5C:  MOV     W0,8B0
....................    unsigned int analog=read_adc();                                         // Read the voltage level 
....................    unsigned int percent=100*(unsigned int32)analog/mt_voltage_limit;       // Convert voltage to percent 
....................     
....................    if(debug_mode_dp) 
01C5E:  BTSS.B  800.0
01C60:  BRA     1C94
....................       fprintf(RS232,"\n\r\tPercent Current: %u\n\r",percent); 
01C62:  MOV     #0,W1
01C64:  MOV     W1,W0
01C66:  CALL    2E0
01C6A:  INC     W1,W1
01C6C:  MOV     W1,[W15++]
01C6E:  BTSC.B  219.1
01C70:  BRA     1C6E
01C72:  MOV     W0,21A
01C74:  MOV     [--W15],W1
01C76:  MOV     #13,W0
01C78:  CPSGT   W1,W0
01C7A:  BRA     1C64
01C7C:  MOV     8B0,W0
01C7E:  MOV     #0,W4
01C80:  CALL    1688
01C84:  BTSC.B  219.1
01C86:  BRA     1C84
01C88:  MOV     #A,W4
01C8A:  MOV     W4,21A
01C8C:  BTSC.B  219.1
01C8E:  BRA     1C8C
01C90:  MOV     #D,W4
01C92:  MOV     W4,21A
....................        
....................    return percent;   
01C94:  PUSH    8B0
01C96:  POP     0
.................... } 
01C98:  MOV     [--W15],W6
01C9A:  MOV     [--W15],W5
01C9C:  RETURN  
.................... // Sets motor torque approximate to desired percent and returns the actual percent (%0-100) 
.................... unsigned int md_mt_set(unsigned int percent) 
.................... { 
01C9E:  MOV     W5,[W15++]
01CA0:  MOV     W6,[W15++]
....................    // percent must be between 0 and 100 
....................    if(percent>100) 
01CA2:  MOV     8A8,W4
01CA4:  MOV     #64,W3
01CA6:  CP      W3,W4
01CA8:  BRA     C,1CAE
....................       percent=100; 
01CAA:  MOV     #64,W4
01CAC:  MOV     W4,8A8
....................        
....................    if(debug_mode_dp) 
01CAE:  BTSS.B  800.0
01CB0:  BRA     1CD4
....................    { 
....................       fprintf(RS232,"\n\r\tPercent Desired:"); 
01CB2:  MOV     #0,W1
01CB4:  MOV     W1,W0
01CB6:  CALL    306
01CBA:  INC     W1,W1
01CBC:  MOV     W1,[W15++]
01CBE:  BTSC.B  219.1
01CC0:  BRA     1CBE
01CC2:  MOV     W0,21A
01CC4:  MOV     [--W15],W1
01CC6:  MOV     #12,W0
01CC8:  CPSGT   W1,W0
01CCA:  BRA     1CB4
....................       fprintf(RS232,"%u",percent); 
01CCC:  MOV     8A8,W0
01CCE:  MOV     #0,W4
01CD0:  CALL    1688
....................    } 
....................     
....................    unsigned int voltage=(unsigned int32)percent*mt_voltage_limit/100;      // convert percent to voltage 
01CD4:  MOV     8A8,W5
01CD6:  MOV     #0,W6
01CD8:  MOV     W5,W0
01CDA:  MOV     W6,W1
01CDC:  MOV     806,W2
01CDE:  MOV     #0,W3
01CE0:  CALL    17EE
01CE4:  MOV     W0,W5
01CE6:  MOV     W1,W6
01CE8:  BCLR.B  43.0
01CEA:  MOV     W5,W0
01CEC:  MOV     W6,W1
01CEE:  MOV     #64,W2
01CF0:  MOV     #0,W3
01CF2:  CALL    181E
01CF6:  MOV     W0,8AA
....................    dp_set(voltage);                                      // set digital potentiometer 
01CF8:  PUSH    8AA
01CFA:  POP     8AE
01CFC:  CALL    18FE
....................     
....................    return md_mt_get(); 
01D00:  CALL    1C2E
01D04:  MOV     W0,0
.................... } 
01D06:  MOV     [--W15],W6
01D08:  MOV     [--W15],W5
01D0A:  RETURN  
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_mt_set(mt_percent_rest);               // Set motor torque before initialization of motor driver 
01D0C:  PUSH    80A
01D0E:  POP     8A8
01D10:  CALL    1C9E
....................  
....................    output_high(MD_RESET);                    // Reset is active low so keep it disabled 
01D14:  BCLR.B  2D8.0
01D16:  BSET.B  2DC.0
....................    output_high(MD_SLEEP);                    // Sleep is active low so keep it disabled 
01D18:  BCLR.B  2D8.3
01D1A:  BSET.B  2DC.3
....................    output_low(MD_SR);                        // Activate synchronous rectification 
01D1C:  BCLR.B  2DE.1
01D1E:  BCLR.B  2E2.1
....................    output_high(MD_DIR);                      // Direction control pin can be in any state 
01D20:  BCLR.B  2D8.4
01D22:  BSET.B  2DC.4
....................    output_high(MD_MS1);                      // MS1 and MS2 high enables 8x microstepping mode 
01D24:  BCLR.B  2DE.0
01D26:  BSET.B  2E2.0
....................    output_high(MD_MS2); 
01D28:  BCLR.B  2D2.7
01D2A:  BSET.B  2D6.7
....................    output_low(MD_ENABLE);                    // Enable is active so keep it high 
01D2C:  BCLR.B  2D8.2
01D2E:  BCLR.B  2DC.2
....................    output_low(MD_STEP);                      // A low-to-high transition advances the motor one increment so keep step input low 
01D30:  BCLR.B  2D8.1
01D32:  BCLR.B  2DC.1
.................... } 
01D34:  RETURN  
....................  
.................... // Initializes external EEPROM (FRAM) 
.................... void fr_init()  
.................... { 
....................    output_high(FR_CS);     // Chip select is active low when it is high the device enters low-power standby mode so initialy keep it high 
01D36:  BCLR.B  2E4.7
01D38:  BSET.B  2E8.7
....................    output_low(FR_WP);      // Write protection pin is active low and prevents write operations to the status register so initially keep it low 
01D3A:  BCLR.B  2E4.6
01D3C:  BCLR.B  2E8.6
....................    output_low(FR_SI);      // Serial input pin is driven to high logic state during communication so initially keep it low 
01D3E:  BCLR.B  2D8.6
01D40:  BCLR.B  2DC.6
....................    output_low(FR_SCK);     // Inputs are latched on the rising edge and outputs occur on the falling edge so initially serial clock can be in any state  
01D42:  BCLR.B  2D8.5
01D44:  BCLR.B  2DC.5
.................... } 
01D46:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... void fr_write_byte(unsigned int16 address, unsigned int8 data)  
.................... { 
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    unsigned int8 wren; 
....................    unsigned int8 write; 
....................    unsigned int8 wrdi; 
....................     
....................    //     76543210     
....................    wren=0b00000110; 
*
0237A:  MOV.B   #6,W0L
0237C:  MOV.B   W0L,8B4
....................    //      76543210  
....................    write=0b00000010; 
0237E:  MOV.B   #2,W0L
02380:  MOV.B   W0L,8B5
....................    //     76543210 
....................    wrdi=0b00000100; 
02382:  MOV.B   #4,W0L
02384:  MOV.B   W0L,8B6
....................     
....................    cmd[0]=data; 
02386:  MOV.B   8AE,W0L
02388:  MOV.B   W0L,8B0
....................    cmd[1]=address; 
0238A:  MOV.B   8AC,W0L
0238C:  MOV.B   W0L,8B1
....................    cmd[2]=address/256; 
0238E:  MOV.B   8AD,W0L
02390:  MOV.B   W0L,8B2
....................    cmd[3]=write; 
02392:  MOV.B   8B5,W0L
02394:  MOV.B   W0L,8B3
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    output_low(FR_CS); 
02396:  BCLR.B  2E4.7
02398:  BCLR.B  2E8.7
....................    delay_us(1); 
0239A:  REPEAT  #1C
0239C:  NOP     
....................    for(i=0; i<8; ++i) 
0239E:  CLR.B   8AF
023A0:  MOV     8AE,W4
023A2:  LSR     W4,#8,W4
023A4:  CP.B    W4L,#8
023A6:  BRA     C,23D8
....................    { 
....................       output_bit(FR_SI, shift_left(&wren,1,0)); 
023A8:  BCLR.B  42.0
023AA:  RLC.B   8B4
023AC:  BRA     C,23B2
023AE:  BCLR.B  2DC.6
023B0:  BRA     23B4
023B2:  BSET.B  2DC.6
023B4:  BCLR.B  2D8.6
....................       delay_us(1); 
023B6:  REPEAT  #1C
023B8:  NOP     
....................       output_high(FR_SCK); 
023BA:  BCLR.B  2D8.5
023BC:  BSET.B  2DC.5
....................       delay_us(1); 
023BE:  REPEAT  #1C
023C0:  NOP     
....................       output_low(FR_SI); 
023C2:  BCLR.B  2D8.6
023C4:  BCLR.B  2DC.6
....................       delay_us(1); 
023C6:  REPEAT  #1C
023C8:  NOP     
....................       output_low(FR_SCK); 
023CA:  BCLR.B  2D8.5
023CC:  BCLR.B  2DC.5
....................       delay_us(1); 
023CE:  REPEAT  #1C
023D0:  NOP     
....................    } 
023D2:  INC.B   08AF
023D4:  GOTO    23A0
....................    delay_us(1); 
023D8:  REPEAT  #1C
023DA:  NOP     
....................    output_high(FR_CS); 
023DC:  BCLR.B  2E4.7
023DE:  BSET.B  2E8.7
....................    delay_us(1); 
023E0:  REPEAT  #1C
023E2:  NOP     
....................     
....................    output_low(FR_CS); 
023E4:  BCLR.B  2E4.7
023E6:  BCLR.B  2E8.7
....................    delay_us(1); 
023E8:  REPEAT  #1C
023EA:  NOP     
....................    for(i=0; i<32; ++i) 
023EC:  CLR.B   8AF
023EE:  MOV     8AE,W4
023F0:  LSR     W4,#8,W4
023F2:  MOV     #20,W3
023F4:  CP.B    W3L,W4L
023F6:  BRA     LEU,242A
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,4,0)); 
023F8:  BCLR.B  42.0
023FA:  RLC     8B0
023FC:  RLC     8B2
023FE:  BRA     C,2404
02400:  BCLR.B  2DC.6
02402:  BRA     2406
02404:  BSET.B  2DC.6
02406:  BCLR.B  2D8.6
....................       delay_us(1); 
02408:  REPEAT  #1C
0240A:  NOP     
....................       output_high(FR_SCK); 
0240C:  BCLR.B  2D8.5
0240E:  BSET.B  2DC.5
....................       delay_us(1); 
02410:  REPEAT  #1C
02412:  NOP     
....................       output_low(FR_SI); 
02414:  BCLR.B  2D8.6
02416:  BCLR.B  2DC.6
....................       delay_us(1); 
02418:  REPEAT  #1C
0241A:  NOP     
....................       output_low(FR_SCK); 
0241C:  BCLR.B  2D8.5
0241E:  BCLR.B  2DC.5
....................       delay_us(1); 
02420:  REPEAT  #1C
02422:  NOP     
....................    } 
02424:  INC.B   08AF
02426:  GOTO    23EE
....................    delay_us(1); 
0242A:  REPEAT  #1C
0242C:  NOP     
....................    output_high(FR_CS); 
0242E:  BCLR.B  2E4.7
02430:  BSET.B  2E8.7
....................    delay_us(1); 
02432:  REPEAT  #1C
02434:  NOP     
....................     
....................    output_low(FR_CS); 
02436:  BCLR.B  2E4.7
02438:  BCLR.B  2E8.7
....................    delay_us(1); 
0243A:  REPEAT  #1C
0243C:  NOP     
....................    for(i=0; i<8; ++i) 
0243E:  CLR.B   8AF
02440:  MOV     8AE,W4
02442:  LSR     W4,#8,W4
02444:  CP.B    W4L,#8
02446:  BRA     C,2478
....................    { 
....................       output_bit(FR_SI, shift_left(&wrdi,1,0)); 
02448:  BCLR.B  42.0
0244A:  RLC.B   8B6
0244C:  BRA     C,2452
0244E:  BCLR.B  2DC.6
02450:  BRA     2454
02452:  BSET.B  2DC.6
02454:  BCLR.B  2D8.6
....................       delay_us(1); 
02456:  REPEAT  #1C
02458:  NOP     
....................       output_high(FR_SCK); 
0245A:  BCLR.B  2D8.5
0245C:  BSET.B  2DC.5
....................       delay_us(1); 
0245E:  REPEAT  #1C
02460:  NOP     
....................       output_low(FR_SI); 
02462:  BCLR.B  2D8.6
02464:  BCLR.B  2DC.6
....................       delay_us(1); 
02466:  REPEAT  #1C
02468:  NOP     
....................       output_low(FR_SCK); 
0246A:  BCLR.B  2D8.5
0246C:  BCLR.B  2DC.5
....................       delay_us(1); 
0246E:  REPEAT  #1C
02470:  NOP     
....................    } 
02472:  INC.B   08AF
02474:  GOTO    2440
....................    delay_us(1); 
02478:  REPEAT  #1C
0247A:  NOP     
....................    output_high(FR_CS); 
0247C:  BCLR.B  2E4.7
0247E:  BSET.B  2E8.7
....................    delay_us(1); 
02480:  REPEAT  #1C
02482:  NOP     
.................... } 
02484:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... unsigned int8 fr_read_byte(unsigned int16 address)  
.................... { 
....................    unsigned int8 cmd[3]; 
....................    unsigned int8 i,data; 
....................    unsigned int8 read; 
....................     
....................    //     76543210  
....................    read=0b00000011; 
*
01D48:  MOV.B   #3,W0L
01D4A:  MOV.B   W0L,8B5
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Read on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    cmd[0]=address; 
01D4C:  MOV.B   8AE,W0L
01D4E:  MOV.B   W0L,8B0
....................    cmd[1]=address/256; 
01D50:  MOV.B   8AF,W0L
01D52:  MOV.B   W0L,8B1
....................    cmd[2]=read; 
01D54:  MOV.B   8B5,W0L
01D56:  MOV.B   W0L,8B2
....................  
....................    output_low(FR_CS); 
01D58:  BCLR.B  2E4.7
01D5A:  BCLR.B  2E8.7
....................    delay_us(1); 
01D5C:  REPEAT  #1C
01D5E:  NOP     
....................    for(i=0; i<24; ++i) 
01D60:  CLR.B   8B3
01D62:  MOV     8B2,W4
01D64:  LSR     W4,#8,W4
01D66:  CP.B    W4L,#18
01D68:  BRA     C,1D9C
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,3,0)); 
01D6A:  BCLR.B  42.0
01D6C:  RLC     8B0
01D6E:  RLC.B   8B2
01D70:  BRA     C,1D76
01D72:  BCLR.B  2DC.6
01D74:  BRA     1D78
01D76:  BSET.B  2DC.6
01D78:  BCLR.B  2D8.6
....................       delay_us(1); 
01D7A:  REPEAT  #1C
01D7C:  NOP     
....................       output_high(FR_SCK); 
01D7E:  BCLR.B  2D8.5
01D80:  BSET.B  2DC.5
....................       delay_us(1); 
01D82:  REPEAT  #1C
01D84:  NOP     
....................       output_low(FR_SI); 
01D86:  BCLR.B  2D8.6
01D88:  BCLR.B  2DC.6
....................       delay_us(1); 
01D8A:  REPEAT  #1C
01D8C:  NOP     
....................       output_low(FR_SCK); 
01D8E:  BCLR.B  2D8.5
01D90:  BCLR.B  2DC.5
....................       delay_us(1); 
01D92:  REPEAT  #1C
01D94:  NOP     
....................    } 
01D96:  INC.B   08B3
01D98:  GOTO    1D62
....................    for(i=0; i<8; ++i) 
01D9C:  CLR.B   8B3
01D9E:  MOV     8B2,W4
01DA0:  LSR     W4,#8,W4
01DA2:  CP.B    W4L,#8
01DA4:  BRA     C,1DD2
....................    { 
....................       delay_us(1); 
01DA6:  REPEAT  #1C
01DA8:  NOP     
....................       shift_left(&data,1,input(FR_SO)); 
01DAA:  BSET.B  2D8.7
01DAC:  BTSC.B  2DA.7
01DAE:  BRA     1DB4
01DB0:  BCLR.B  42.0
01DB2:  BRA     1DB6
01DB4:  BSET.B  42.0
01DB6:  RLC.B   8B4
....................       output_high(FR_SCK); 
01DB8:  BCLR.B  2D8.5
01DBA:  BSET.B  2DC.5
....................       delay_us(1); 
01DBC:  REPEAT  #1C
01DBE:  NOP     
....................       delay_us(1); 
01DC0:  REPEAT  #1C
01DC2:  NOP     
....................       output_low(FR_SCK); 
01DC4:  BCLR.B  2D8.5
01DC6:  BCLR.B  2DC.5
....................       delay_us(1); 
01DC8:  REPEAT  #1C
01DCA:  NOP     
....................    } 
01DCC:  INC.B   08B3
01DCE:  GOTO    1D9E
....................    output_high(FR_CS); 
01DD2:  BCLR.B  2E4.7
01DD4:  BSET.B  2E8.7
....................    delay_us(1); 
01DD6:  REPEAT  #1C
01DD8:  NOP     
....................     
....................    return(data); 
01DDA:  MOV.B   8B4,W0L
01DDC:  MOV.B   W0L,0
.................... } 
01DDE:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... void fr_write(unsigned int16 address,unsigned int16 data) 
.................... { 
*
02486:  MOV     W5,[W15++]
....................    unsigned int8 data_high; 
....................    unsigned int8 data_low; 
....................    data_low=(unsigned int8)data; 
02488:  MOV.B   8A0,W0L
0248A:  MOV.B   W0L,8A3
....................    data_high=(unsigned int8)(data>>8); 
0248C:  MOV.B   8A1,W0L
0248E:  CLR.B   1
02490:  MOV.B   W0L,8A2
....................     
....................    fr_write_byte(address,data_low); 
02492:  MOV.B   8A3,W0L
02494:  MOV.B   W0L,8AE
02496:  PUSH    89E
02498:  POP     8AC
0249A:  CALL    237A
....................    fr_write_byte(address+1,data_high); 
0249E:  MOV     89E,W4
024A0:  ADD     W4,#1,W4
024A2:  MOV     W4,W5
024A4:  MOV.B   8A2,W0L
024A6:  MOV.B   W0L,8AE
024A8:  MOV     W5,8AC
024AA:  CALL    237A
....................     
....................    return; 
.................... } 
024AE:  MOV     [--W15],W5
024B0:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... unsigned int16 fr_read(unsigned int16 address) 
.................... { 
*
01DE0:  MOV     W5,[W15++]
....................    unsigned int16 data_buffer; 
....................    unsigned int16 data_low; 
....................    unsigned int16 data_high; 
....................     
....................    data_low=fr_read_byte(address); 
01DE2:  PUSH    8A0
01DE4:  POP     8AE
01DE6:  CALL    1D48
01DEA:  MOV.B   W0L,8A4
01DEC:  CLR.B   8A5
....................    data_high=fr_read_byte(address+1); 
01DEE:  MOV     8A0,W4
01DF0:  ADD     W4,#1,W4
01DF2:  MOV     W4,W5
01DF4:  MOV     W5,8AE
01DF6:  CALL    1D48
01DFA:  MOV.B   W0L,8A6
01DFC:  CLR.B   8A7
....................     
....................    data_buffer=(data_high<<8)+data_low; 
01DFE:  MOV.B   8A6,W0L
01E00:  MOV.B   W0L,B
01E02:  CLR.B   W5
01E04:  MOV     W5,W0
01E06:  ADD     8A4,W0
01E08:  MOV     W0,8A2
....................     
....................    return data_buffer; 
01E0A:  PUSH    8A2
01E0C:  POP     0
.................... } 
01E0E:  MOV     [--W15],W5
01E10:  RETURN  
....................  
.................... // Returns serial number of the device via RS232 
.................... void data_get_serial_no() 
.................... { 
*
03410:  MOV     W5,[W15++]
03412:  MOV     W6,[W15++]
....................    if(!debug_mode_fr)  
03414:  BTSC.B  800.2
03416:  BRA     341A
....................       return; 
03418:  BRA     3484
....................        
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
0341A:  CLR.B   890
....................     
....................    fprintf(RS232, "Serial No:"); 
0341C:  MOV     #0,W1
0341E:  MOV     W1,W0
03420:  CALL    326
03424:  INC     W1,W1
03426:  MOV     W1,[W15++]
03428:  BTSC.B  219.1
0342A:  BRA     3428
0342C:  MOV     W0,21A
0342E:  MOV     [--W15],W1
03430:  MOV     #9,W0
03432:  CPSGT   W1,W0
03434:  BRA     341E
....................    for(i=0; i<13; i++) 
03436:  CLR.B   890
03438:  MOV     890,W4
0343A:  CP.B    W4L,#D
0343C:  BRA     C,3474
....................    { 
....................       input[i]=fr_read_byte(fr_serial_no+i); 
0343E:  MOV     890,W4
03440:  CLR.B   9
03442:  MOV     #892,W3
03444:  ADD     W4,W3,W5
03446:  MOV     890,W4
03448:  CLR.B   9
0344A:  MOV     832,W3
0344C:  ADD     W3,W4,W6
0344E:  MOV     W6,8AE
03450:  CALL    1D48
03454:  MOV.B   W0L,[W5]
....................       fputc(input[i]+48,RS232); 
03456:  MOV     890,W4
03458:  CLR.B   9
0345A:  MOV     #892,W3
0345C:  ADD     W4,W3,W0
0345E:  MOV     #30,W4
03460:  MOV.B   [W0],W3L
03462:  ADD.B   W3L,W4L,W5L
03464:  MOV.B   W5L,W0L
03466:  BTSC.B  219.1
03468:  BRA     3466
0346A:  MOV.B   W0L,21A
0346C:  CLR.B   21B
....................    } 
0346E:  INC.B   0890
03470:  GOTO    3438
....................    fprintf(RS232, "\n\r"); 
03474:  BTSC.B  219.1
03476:  BRA     3474
03478:  MOV     #A,W4
0347A:  MOV     W4,21A
0347C:  BTSC.B  219.1
0347E:  BRA     347C
03480:  MOV     #D,W4
03482:  MOV     W4,21A
.................... } 
03484:  MOV     [--W15],W6
03486:  MOV     [--W15],W5
03488:  RETURN  
.................... // Returns movement range of the device 
.................... unsigned int16 data_get_move_range() 
.................... { 
*
01E12:  PUSH    834
01E14:  POP     8A0
01E16:  CALL    1DE0
01E1A:  MOV     W0,890
....................    unsigned int16 range = fr_read(fr_move_range); 
....................     
....................    if(debug_mode_fr)  
01E1C:  BTSS.B  800.2
01E1E:  BRA     1E5C
....................       fprintf(RS232, "Movement Range: %u mm\n\r", range); 
01E20:  MOV     #0,W1
01E22:  MOV     W1,W0
01E24:  CALL    33E
01E28:  INC     W1,W1
01E2A:  MOV     W1,[W15++]
01E2C:  BTSC.B  219.1
01E2E:  BRA     1E2C
01E30:  MOV     W0,21A
01E32:  MOV     [--W15],W1
01E34:  MOV     #F,W0
01E36:  CPSGT   W1,W0
01E38:  BRA     1E22
01E3A:  MOV     890,W0
01E3C:  MOV     #0,W4
01E3E:  CALL    1688
01E42:  MOV     #12,W1
01E44:  MOV     W1,W0
01E46:  CALL    33E
01E4A:  INC     W1,W1
01E4C:  MOV     W1,[W15++]
01E4E:  BTSC.B  219.1
01E50:  BRA     1E4E
01E52:  MOV     W0,21A
01E54:  MOV     [--W15],W1
01E56:  MOV     #16,W0
01E58:  CPSGT   W1,W0
01E5A:  BRA     1E44
....................     
....................    return range; 
01E5C:  PUSH    890
01E5E:  POP     0
.................... } 
01E60:  RETURN  
.................... // Returns home position 
.................... unsigned int16 data_get_home_pos() 
.................... { 
01E62:  PUSH    836
01E64:  POP     8A0
01E66:  CALL    1DE0
01E6A:  MOV     W0,89E
....................    unsigned int16 home_pos = fr_read(fr_home_pos); 
....................     
....................    if(debug_mode_fr)  
01E6C:  BTSS.B  800.2
01E6E:  BRA     1EAC
....................       fprintf(RS232, "Home Distance: %u counts\n\r", home_pos); 
01E70:  MOV     #0,W1
01E72:  MOV     W1,W0
01E74:  CALL    362
01E78:  INC     W1,W1
01E7A:  MOV     W1,[W15++]
01E7C:  BTSC.B  219.1
01E7E:  BRA     1E7C
01E80:  MOV     W0,21A
01E82:  MOV     [--W15],W1
01E84:  MOV     #E,W0
01E86:  CPSGT   W1,W0
01E88:  BRA     1E72
01E8A:  MOV     89E,W0
01E8C:  MOV     #0,W4
01E8E:  CALL    1688
01E92:  MOV     #11,W1
01E94:  MOV     W1,W0
01E96:  CALL    362
01E9A:  INC     W1,W1
01E9C:  MOV     W1,[W15++]
01E9E:  BTSC.B  219.1
01EA0:  BRA     1E9E
01EA2:  MOV     W0,21A
01EA4:  MOV     [--W15],W1
01EA6:  MOV     #19,W0
01EA8:  CPSGT   W1,W0
01EAA:  BRA     1E94
....................        
....................    return home_pos; 
01EAC:  PUSH    89E
01EAE:  POP     0
.................... } 
01EB0:  RETURN  
.................... // Returns end position 
.................... unsigned int16 data_get_end_pos() 
.................... { 
01EB2:  PUSH    838
01EB4:  POP     8A0
01EB6:  CALL    1DE0
01EBA:  MOV     W0,890
....................    unsigned int16 end = fr_read(fr_end_pos); 
....................     
....................    if(debug_mode_fr) 
01EBC:  BTSS.B  800.2
01EBE:  BRA     1EFC
....................       fprintf(RS232, "End Distance: %u counts\n\r", end); 
01EC0:  MOV     #0,W1
01EC2:  MOV     W1,W0
01EC4:  CALL    38A
01EC8:  INC     W1,W1
01ECA:  MOV     W1,[W15++]
01ECC:  BTSC.B  219.1
01ECE:  BRA     1ECC
01ED0:  MOV     W0,21A
01ED2:  MOV     [--W15],W1
01ED4:  MOV     #D,W0
01ED6:  CPSGT   W1,W0
01ED8:  BRA     1EC2
01EDA:  MOV     890,W0
01EDC:  MOV     #0,W4
01EDE:  CALL    1688
01EE2:  MOV     #10,W1
01EE4:  MOV     W1,W0
01EE6:  CALL    38A
01EEA:  INC     W1,W1
01EEC:  MOV     W1,[W15++]
01EEE:  BTSC.B  219.1
01EF0:  BRA     1EEE
01EF2:  MOV     W0,21A
01EF4:  MOV     [--W15],W1
01EF6:  MOV     #18,W0
01EF8:  CPSGT   W1,W0
01EFA:  BRA     1EE4
....................     
....................    return end; 
01EFC:  PUSH    890
01EFE:  POP     0
.................... } 
01F00:  RETURN  
.................... // Returns positioning velocity 
.................... unsigned int16 data_get_conv_const() 
.................... { 
*
01F96:  PUSH    83A
01F98:  POP     8A0
01F9A:  CALL    1DE0
01F9E:  MOV     W0,890
....................    unsigned int16 conv_const = fr_read(fr_conv_const); 
....................     
....................    if((conv_const < 12000)||(conv_const > 13000)) 
01FA0:  MOV     890,W4
01FA2:  MOV     #2EE0,W3
01FA4:  CP      W3,W4
01FA6:  BRA     GTU,1FB0
01FA8:  MOV     890,W4
01FAA:  MOV     #32C8,W3
01FAC:  CP      W3,W4
01FAE:  BRA     C,1FB4
....................       conv_const = 12500; 
01FB0:  MOV     #30D4,W4
01FB2:  MOV     W4,890
....................     
....................    if(debug_mode_fr)  
01FB4:  BTSS.B  800.2
01FB6:  BRA     1FF2
....................       fprintf(RS232, "Conversion Constant: %u \n\r", conv_const); 
01FB8:  MOV     #0,W1
01FBA:  MOV     W1,W0
01FBC:  CALL    3B0
01FC0:  INC     W1,W1
01FC2:  MOV     W1,[W15++]
01FC4:  BTSC.B  219.1
01FC6:  BRA     1FC4
01FC8:  MOV     W0,21A
01FCA:  MOV     [--W15],W1
01FCC:  MOV     #14,W0
01FCE:  CPSGT   W1,W0
01FD0:  BRA     1FBA
01FD2:  MOV     890,W0
01FD4:  MOV     #0,W4
01FD6:  CALL    1688
01FDA:  BTSC.B  219.1
01FDC:  BRA     1FDA
01FDE:  MOV     #20,W4
01FE0:  MOV     W4,21A
01FE2:  BTSC.B  219.1
01FE4:  BRA     1FE2
01FE6:  MOV     #A,W4
01FE8:  MOV     W4,21A
01FEA:  BTSC.B  219.1
01FEC:  BRA     1FEA
01FEE:  MOV     #D,W4
01FF0:  MOV     W4,21A
....................     
....................    return conv_const; 
01FF2:  PUSH    890
01FF4:  POP     0
.................... } 
01FF6:  RETURN  
.................... // Returns the backlash of the system 
.................... unsigned int16 data_get_backlash() 
.................... { 
*
01F02:  PUSH    83C
01F04:  POP     8A0
01F06:  CALL    1DE0
01F0A:  MOV     W0,890
....................    unsigned int16 backlash = fr_read(fr_backlash); 
....................  
....................    if(debug_mode_fr)  
01F0C:  BTSS.B  800.2
01F0E:  BRA     1F4C
....................       fprintf(RS232, "Backlash: %u counts\n\r", backlash); 
01F10:  MOV     #0,W1
01F12:  MOV     W1,W0
01F14:  CALL    3D8
01F18:  INC     W1,W1
01F1A:  MOV     W1,[W15++]
01F1C:  BTSC.B  219.1
01F1E:  BRA     1F1C
01F20:  MOV     W0,21A
01F22:  MOV     [--W15],W1
01F24:  MOV     #9,W0
01F26:  CPSGT   W1,W0
01F28:  BRA     1F12
01F2A:  MOV     890,W0
01F2C:  MOV     #0,W4
01F2E:  CALL    1688
01F32:  MOV     #C,W1
01F34:  MOV     W1,W0
01F36:  CALL    3D8
01F3A:  INC     W1,W1
01F3C:  MOV     W1,[W15++]
01F3E:  BTSC.B  219.1
01F40:  BRA     1F3E
01F42:  MOV     W0,21A
01F44:  MOV     [--W15],W1
01F46:  MOV     #14,W0
01F48:  CPSGT   W1,W0
01F4A:  BRA     1F34
....................     
....................    return backlash; 
01F4C:  PUSH    890
01F4E:  POP     0
.................... } 
01F50:  RETURN  
.................... // Returns communication type 
.................... unsigned int8 data_get_comm_type() 
.................... { 
*
02F2C:  PUSH    83E
02F2E:  POP     8AE
02F30:  CALL    1D48
02F34:  MOV.B   W0L,890
....................    unsigned int8 comm_type=fr_read_byte(fr_comm_type); 
....................     
....................    if(debug_mode_fr) 
02F36:  BTSS.B  800.2
02F38:  BRA     2FA2
....................       switch (comm_type) 
....................       { 
02F3A:  MOV.B   890,W0L
02F3C:  CLR.B   1
02F3E:  XOR     #0,W0
02F40:  BRA     Z,2F48
02F42:  XOR     #1,W0
02F44:  BRA     Z,2F66
02F46:  BRA     2F84
....................          case 0   :  fprintf(RS232,"Communication Type: Parallel Port\n\r"); 
02F48:  MOV     #0,W1
02F4A:  MOV     W1,W0
02F4C:  CALL    3FA
02F50:  INC     W1,W1
02F52:  MOV     W1,[W15++]
02F54:  BTSC.B  219.1
02F56:  BRA     2F54
02F58:  MOV     W0,21A
02F5A:  MOV     [--W15],W1
02F5C:  MOV     #22,W0
02F5E:  CPSGT   W1,W0
02F60:  BRA     2F4A
....................                      break; 
02F62:  GOTO    2FA2
....................          case 1   :  fprintf(RS232,"Communication Type: Serial Port\n\r"); 
02F66:  MOV     #0,W1
02F68:  MOV     W1,W0
02F6A:  CALL    42A
02F6E:  INC     W1,W1
02F70:  MOV     W1,[W15++]
02F72:  BTSC.B  219.1
02F74:  BRA     2F72
02F76:  MOV     W0,21A
02F78:  MOV     [--W15],W1
02F7A:  MOV     #20,W0
02F7C:  CPSGT   W1,W0
02F7E:  BRA     2F68
....................                      break; 
02F80:  GOTO    2FA2
....................          default  :  fprintf(RS232,"Communication Type: Undefined\n\r"); 
02F84:  MOV     #0,W1
02F86:  MOV     W1,W0
02F88:  CALL    458
02F8C:  INC     W1,W1
02F8E:  MOV     W1,[W15++]
02F90:  BTSC.B  219.1
02F92:  BRA     2F90
02F94:  MOV     W0,21A
02F96:  MOV     [--W15],W1
02F98:  MOV     #1E,W0
02F9A:  CPSGT   W1,W0
02F9C:  BRA     2F86
....................                      break; 
02F9E:  GOTO    2FA2
....................       } 
....................        
....................    return comm_type; 
02FA2:  MOV.B   890,W0L
02FA4:  MOV.B   W0L,0
.................... } 
02FA6:  RETURN  
.................... // Returns last position 
.................... unsigned int16 data_get_last_pos() 
.................... { 
*
0232A:  PUSH    840
0232C:  POP     8A0
0232E:  CALL    1DE0
02332:  MOV     W0,890
....................    unsigned int16 position=fr_read(fr_last_pos); 
....................     
....................    if(debug_mode_fr)  
02334:  BTSS.B  800.2
02336:  BRA     2374
....................       fprintf(RS232, "Last Position: %u mm\n\r", position); 
02338:  MOV     #0,W1
0233A:  MOV     W1,W0
0233C:  CALL    484
02340:  INC     W1,W1
02342:  MOV     W1,[W15++]
02344:  BTSC.B  219.1
02346:  BRA     2344
02348:  MOV     W0,21A
0234A:  MOV     [--W15],W1
0234C:  MOV     #E,W0
0234E:  CPSGT   W1,W0
02350:  BRA     233A
02352:  MOV     890,W0
02354:  MOV     #0,W4
02356:  CALL    1688
0235A:  MOV     #11,W1
0235C:  MOV     W1,W0
0235E:  CALL    484
02362:  INC     W1,W1
02364:  MOV     W1,[W15++]
02366:  BTSC.B  219.1
02368:  BRA     2366
0236A:  MOV     W0,21A
0236C:  MOV     [--W15],W1
0236E:  MOV     #15,W0
02370:  CPSGT   W1,W0
02372:  BRA     235C
....................     
....................    return position; 
02374:  PUSH    890
02376:  POP     0
.................... } 
02378:  RETURN  
.................... // Returns the position in the given index 
.................... unsigned int16 data_get_pos(unsigned int8 index) 
.................... { 
*
03546:  MOV     W5,[W15++]
03548:  MOV.B   896,W0L
0354A:  SL      W0,#1,W0
0354C:  ZE      W0,W0
0354E:  CLR.B   1
03550:  MOV     842,W4
03552:  ADD     W0,W4,W5
03554:  MOV     W5,8A0
03556:  CALL    1DE0
0355A:  MOV     W0,898
....................    unsigned int16 position=fr_read(fr_pos_table+index*2); 
....................     
....................    if(debug_mode_fr) 
0355C:  BTSS.B  800.2
0355E:  BRA     35C0
....................       fprintf(RS232,"Index: %u, Position: %u mm\n\r", index, position); 
03560:  MOV     #0,W1
03562:  MOV     W1,W0
03564:  CALL    4A8
03568:  INC     W1,W1
0356A:  MOV     W1,[W15++]
0356C:  BTSC.B  219.1
0356E:  BRA     356C
03570:  MOV     W0,21A
03572:  MOV     [--W15],W1
03574:  MOV     #6,W0
03576:  CPSGT   W1,W0
03578:  BRA     3562
0357A:  MOV.B   896,W0L
0357C:  CLR.B   1
0357E:  MOV     #0,W4
03580:  CALL    1688
03584:  MOV     #9,W1
03586:  MOV     W1,W0
03588:  CALL    4A8
0358C:  INC     W1,W1
0358E:  MOV     W1,[W15++]
03590:  BTSC.B  219.1
03592:  BRA     3590
03594:  MOV     W0,21A
03596:  MOV     [--W15],W1
03598:  MOV     #14,W0
0359A:  CPSGT   W1,W0
0359C:  BRA     3586
0359E:  MOV     898,W0
035A0:  MOV     #0,W4
035A2:  CALL    1688
035A6:  MOV     #17,W1
035A8:  MOV     W1,W0
035AA:  CALL    4A8
035AE:  INC     W1,W1
035B0:  MOV     W1,[W15++]
035B2:  BTSC.B  219.1
035B4:  BRA     35B2
035B6:  MOV     W0,21A
035B8:  MOV     [--W15],W1
035BA:  MOV     #1B,W0
035BC:  CPSGT   W1,W0
035BE:  BRA     35A8
....................     
....................    return position; 
035C0:  PUSH    898
035C2:  POP     0
.................... } 
035C4:  MOV     [--W15],W5
035C6:  RETURN  
.................... // Returns position table via RS232 
.................... void data_get_pos_table() 
.................... { 
035C8:  MOV     W5,[W15++]
....................    debug_mode_fr=1; 
035CA:  BSET.B  800.2
....................     
....................    unsigned int input; 
....................    unsigned int i; 
....................    unsigned int index; 
....................     
....................    input=(unsigned)(fgetc(RS232)-48); 
035CC:  BTSS.B  218.0
035CE:  BRA     35CC
035D0:  MOV     21C,W0
035D2:  MOV     #30,W4
035D4:  SUB.B   W0L,W4L,W0L
035D6:  MOV.B   W0L,890
035D8:  CLR.B   891
....................    fputc(input+48,RS232); 
035DA:  MOV     #30,W4
035DC:  MOV     890,W3
035DE:  ADD     W3,W4,W5
035E0:  MOV.B   W5L,W0L
035E2:  BTSC.B  219.1
035E4:  BRA     35E2
035E6:  MOV.B   W0L,21A
035E8:  CLR.B   21B
....................  
....................    if(input>9) 
035EA:  MOV     890,W4
035EC:  CP      W4,#9
035EE:  BRA     LEU,35F4
....................       input=9; 
035F0:  MOV     #9,W4
035F2:  MOV     W4,890
....................  
....................    fprintf(RS232,"\n\r"); 
035F4:  BTSC.B  219.1
035F6:  BRA     35F4
035F8:  MOV     #A,W4
035FA:  MOV     W4,21A
035FC:  BTSC.B  219.1
035FE:  BRA     35FC
03600:  MOV     #D,W4
03602:  MOV     W4,21A
....................     
....................    for(i=0; i<10; i++) 
03604:  CLR     892
03606:  MOV     892,W4
03608:  CP      W4,#A
0360A:  BRA     C,3626
....................    { 
....................       index=input*10+i; 
0360C:  MOV     890,W4
0360E:  MUL.UU  W4,#A,W0
03610:  MOV     W0,W5
03612:  MOV     W5,W0
03614:  ADD     892,W0
03616:  MOV     W0,894
....................       data_get_pos(index); 
03618:  MOV.B   894,W0L
0361A:  MOV.B   W0L,896
0361C:  CALL    3546
....................    } 
03620:  INC     0892
03622:  GOTO    3606
....................     
....................    debug_mode_fr=0; 
03626:  BCLR.B  800.2
.................... } 
03628:  MOV     [--W15],W5
0362A:  RETURN  
.................... // Returns all system data via RS232 
.................... void data_get_sys_data() 
.................... { 
....................    fprintf(RS232,"MODESIS LASER POSITIONING SYSTEM\n\n\r"); 
*
0348A:  MOV     #0,W1
0348C:  MOV     W1,W0
0348E:  CALL    4D2
03492:  INC     W1,W1
03494:  MOV     W1,[W15++]
03496:  BTSC.B  219.1
03498:  BRA     3496
0349A:  MOV     W0,21A
0349C:  MOV     [--W15],W1
0349E:  MOV     #22,W0
034A0:  CPSGT   W1,W0
034A2:  BRA     348C
....................    debug_mode_fr=1; 
034A4:  BSET.B  800.2
....................    data_get_serial_no(); 
034A6:  CALL    3410
....................    data_get_move_range(); 
034AA:  CALL    1E12
....................    data_get_home_pos(); 
034AE:  CALL    1E62
....................    data_get_end_pos(); 
034B2:  CALL    1EB2
....................    data_get_conv_const(); 
034B6:  CALL    1F96
....................    data_get_backlash(); 
034BA:  CALL    1F02
....................    data_get_comm_type(); 
034BE:  CALL    2F2C
....................    data_get_last_pos(); 
034C2:  CALL    232A
....................    debug_mode_fr=0; 
034C6:  BCLR.B  800.2
....................    fprintf(RS232,"\n\r"); 
034C8:  BTSC.B  219.1
034CA:  BRA     34C8
034CC:  MOV     #A,W4
034CE:  MOV     W4,21A
034D0:  BTSC.B  219.1
034D2:  BRA     34D0
034D4:  MOV     #D,W4
034D6:  MOV     W4,21A
....................    fprintf(RS232,"RCON REGISTER VALUE SIFIRLANIYOR..."); 
034D8:  MOV     #0,W1
034DA:  MOV     W1,W0
034DC:  CALL    502
034E0:  INC     W1,W1
034E2:  MOV     W1,[W15++]
034E4:  BTSC.B  219.1
034E6:  BRA     34E4
034E8:  MOV     W0,21A
034EA:  MOV     [--W15],W1
034EC:  MOV     #22,W0
034EE:  CPSGT   W1,W0
034F0:  BRA     34DA
....................    fprintf(RS232,"\n\r"); 
034F2:  BTSC.B  219.1
034F4:  BRA     34F2
034F6:  MOV     #A,W4
034F8:  MOV     W4,21A
034FA:  BTSC.B  219.1
034FC:  BRA     34FA
034FE:  MOV     #D,W4
03500:  MOV     W4,21A
....................    fprintf(RS232,"YENI RCON REGISTER VALUE(10'luk Tabanda):"); 
03502:  MOV     #0,W1
03504:  MOV     W1,W0
03506:  CALL    532
0350A:  INC     W1,W1
0350C:  MOV     W1,[W15++]
0350E:  BTSC.B  219.1
03510:  BRA     350E
03512:  MOV     W0,21A
03514:  MOV     [--W15],W1
03516:  MOV     #28,W0
03518:  CPSGT   W1,W0
0351A:  BRA     3504
....................    fprintf(RS232,"%u",RCON); 
0351C:  MOV     740,W0
0351E:  MOV     #0,W4
03520:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
03524:  BTSC.B  219.1
03526:  BRA     3524
03528:  MOV     #A,W4
0352A:  MOV     W4,21A
0352C:  BTSC.B  219.1
0352E:  BRA     352C
03530:  MOV     #D,W4
03532:  MOV     W4,21A
....................    fprintf(RS232,"\n\r"); 
03534:  BTSC.B  219.1
03536:  BRA     3534
03538:  MOV     #A,W4
0353A:  MOV     W4,21A
0353C:  BTSC.B  219.1
0353E:  BRA     353C
03540:  MOV     #D,W4
03542:  MOV     W4,21A
.................... } 
03544:  RETURN  
....................  
.................... // Sets serial nuber of the device 
.................... void data_set_serial_no() 
.................... { 
*
02FA8:  MOV     W5,[W15++]
02FAA:  MOV     W6,[W15++]
02FAC:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
....................    for(i=0; i<13; i++) 
02FAE:  CLR.B   890
02FB0:  MOV     890,W4
02FB2:  CP.B    W4L,#D
02FB4:  BRA     C,3006
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
02FB6:  MOV     890,W4
02FB8:  CLR.B   9
02FBA:  MOV     #892,W3
02FBC:  ADD     W4,W3,W5
02FBE:  BTSS.B  218.0
02FC0:  BRA     2FBE
02FC2:  MOV     21C,W0
02FC4:  SUB.B   #30,W0L
02FC6:  CLR.B   1
02FC8:  MOV.B   W0L,[W5]
....................       fr_write_byte(fr_serial_no+i, input[i]); 
02FCA:  MOV     890,W4
02FCC:  CLR.B   9
02FCE:  MOV     832,W3
02FD0:  ADD     W3,W4,W5
02FD2:  MOV     890,W4
02FD4:  CLR.B   9
02FD6:  MOV     #892,W3
02FD8:  ADD     W4,W3,W0
02FDA:  MOV.B   [W0],W6L
02FDC:  PUSH    8AE
02FDE:  MOV.B   W6L,[W15-#2]
02FE0:  POP     8AE
02FE2:  MOV     W5,8AC
02FE4:  CALL    237A
....................       fputc(input[i]+48,RS232); 
02FE8:  MOV     890,W4
02FEA:  CLR.B   9
02FEC:  MOV     #892,W3
02FEE:  ADD     W4,W3,W0
02FF0:  MOV     #30,W4
02FF2:  MOV.B   [W0],W3L
02FF4:  ADD.B   W3L,W4L,W5L
02FF6:  MOV.B   W5L,W0L
02FF8:  BTSC.B  219.1
02FFA:  BRA     2FF8
02FFC:  MOV.B   W0L,21A
02FFE:  CLR.B   21B
....................    } 
03000:  INC.B   0890
03002:  GOTO    2FB0
.................... } 
03006:  MOV     [--W15],W6
03008:  MOV     [--W15],W5
0300A:  RETURN  
.................... // Sets movement range of the device 
.................... void data_set_move_range() 
.................... { 
0300C:  MOV     W5,[W15++]
0300E:  MOV     W6,[W15++]
03010:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0;i<4;i++) 
03012:  CLR.B   890
03014:  MOV     890,W4
03016:  CP.B    W4L,#4
03018:  BRA     C,304E
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
0301A:  MOV.B   890,W0L
0301C:  CLR.B   1
0301E:  SL      W0,#1,W0
03020:  MOV     #892,W4
03022:  ADD     W0,W4,W5
03024:  BTSS.B  218.0
03026:  BRA     3024
03028:  MOV     21C,W0
0302A:  SUB.B   #30,W0L
0302C:  CLR.B   1
0302E:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03030:  MOV.B   890,W0L
03032:  CLR.B   1
03034:  SL      W0,#1,W0
03036:  MOV     #892,W4
03038:  ADD     W0,W4,W0
0303A:  MOV     [W0],W5
0303C:  ADD     #30,W5
0303E:  MOV.B   W5L,W0L
03040:  BTSC.B  219.1
03042:  BRA     3040
03044:  MOV.B   W0L,21A
03046:  CLR.B   21B
....................    } 
03048:  INC.B   0890
0304A:  GOTO    3014
....................    unsigned int range=1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
0304E:  MOV     #3E8,W4
03050:  MOV     892,W3
03052:  MUL.UU  W4,W3,W0
03054:  MOV     W0,W5
03056:  MOV     #64,W4
03058:  MOV     894,W3
0305A:  MUL.UU  W4,W3,W0
0305C:  ADD     W0,W5,W5
0305E:  MOV     896,W4
03060:  MUL.UU  W4,#A,W0
03062:  ADD     W0,W5,W5
03064:  MOV     W5,W0
03066:  ADD     898,W0
03068:  MOV     W0,89A
....................     
....................    if(range<400) 
0306A:  MOV     89A,W4
0306C:  MOV     #190,W3
0306E:  CP      W3,W4
03070:  BRA     LEU,3094
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be smaller than 400 mm. Movement range is set to 400 mm."); 
03072:  MOV     #0,W1
03074:  MOV     W1,W0
03076:  CALL    56A
0307A:  INC     W1,W1
0307C:  MOV     W1,[W15++]
0307E:  BTSC.B  219.1
03080:  BRA     307E
03082:  MOV     W0,21A
03084:  MOV     [--W15],W1
03086:  MOV     #5E,W0
03088:  CPSGT   W1,W0
0308A:  BRA     3074
....................       range=400; 
0308C:  MOV     #190,W4
0308E:  MOV     W4,89A
....................    } 
....................    else if(range>2000) 
03090:  GOTO    30BA
03094:  MOV     89A,W4
03096:  MOV     #7D0,W3
03098:  CP      W3,W4
0309A:  BRA     C,30BA
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be larger than 2000 mm. Movement range is set to 2000 mm."); 
0309C:  MOV     #0,W1
0309E:  MOV     W1,W0
030A0:  CALL    5C6
030A4:  INC     W1,W1
030A6:  MOV     W1,[W15++]
030A8:  BTSC.B  219.1
030AA:  BRA     30A8
030AC:  MOV     W0,21A
030AE:  MOV     [--W15],W1
030B0:  MOV     #5F,W0
030B2:  CPSGT   W1,W0
030B4:  BRA     309E
....................       range=2000; 
030B6:  MOV     #7D0,W4
030B8:  MOV     W4,89A
....................    } 
....................     
....................    if(range==2000) 
030BA:  MOV     89A,W4
030BC:  MOV     #7D0,W3
030BE:  CP      W3,W4
030C0:  BRA     NZ,30CA
....................       md_min_distance=120; 
030C2:  MOV     #78,W4
030C4:  MOV     W4,818
....................    else 
030C6:  GOTO    30CE
....................       md_min_distance=70; 
030CA:  MOV     #46,W4
030CC:  MOV     W4,818
....................        
....................    fr_write(fr_move_range, range); 
030CE:  PUSH    834
030D0:  POP     89E
030D2:  PUSH    89A
030D4:  POP     8A0
030D6:  CALL    2486
....................    md_move_range=range; 
030DA:  PUSH    89A
030DC:  POP     80E
.................... } 
030DE:  MOV     [--W15],W6
030E0:  MOV     [--W15],W5
030E2:  RETURN  
.................... // Sets home position 
.................... void data_set_home_pos() 
.................... { 
030E4:  MOV     W5,[W15++]
030E6:  MOV     W6,[W15++]
030E8:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0; i<4; i++) 
030EA:  CLR.B   890
030EC:  MOV     890,W4
030EE:  CP.B    W4L,#4
030F0:  BRA     C,3126
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
030F2:  MOV.B   890,W0L
030F4:  CLR.B   1
030F6:  SL      W0,#1,W0
030F8:  MOV     #892,W4
030FA:  ADD     W0,W4,W5
030FC:  BTSS.B  218.0
030FE:  BRA     30FC
03100:  MOV     21C,W0
03102:  SUB.B   #30,W0L
03104:  CLR.B   1
03106:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03108:  MOV.B   890,W0L
0310A:  CLR.B   1
0310C:  SL      W0,#1,W0
0310E:  MOV     #892,W4
03110:  ADD     W0,W4,W0
03112:  MOV     [W0],W5
03114:  ADD     #30,W5
03116:  MOV.B   W5L,W0L
03118:  BTSC.B  219.1
0311A:  BRA     3118
0311C:  MOV.B   W0L,21A
0311E:  CLR.B   21B
....................    } 
03120:  INC.B   0890
03122:  GOTO    30EC
....................    unsigned int home_pos = 1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
03126:  MOV     #3E8,W4
03128:  MOV     892,W3
0312A:  MUL.UU  W4,W3,W0
0312C:  MOV     W0,W5
0312E:  MOV     #64,W4
03130:  MOV     894,W3
03132:  MUL.UU  W4,W3,W0
03134:  ADD     W0,W5,W5
03136:  MOV     896,W4
03138:  MUL.UU  W4,#A,W0
0313A:  ADD     W0,W5,W5
0313C:  MOV     W5,W0
0313E:  ADD     898,W0
03140:  MOV     W0,89A
....................     
....................    if(home_pos<10) 
03142:  MOV     89A,W4
03144:  CP      W4,#A
03146:  BRA     C,3164
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Home position cannot be smaller than 10. Home position is not changed"); 
03148:  MOV     #0,W1
0314A:  MOV     W1,W0
0314C:  CALL    624
03150:  INC     W1,W1
03152:  MOV     W1,[W15++]
03154:  BTSC.B  219.1
03156:  BRA     3154
03158:  MOV     W0,21A
0315A:  MOV     [--W15],W1
0315C:  MOV     #55,W0
0315E:  CPSGT   W1,W0
03160:  BRA     314A
....................       return; 
03162:  BRA     3174
....................    } 
....................     
....................    fr_write(fr_home_pos,home_pos); 
03164:  PUSH    836
03166:  POP     89E
03168:  PUSH    89A
0316A:  POP     8A0
0316C:  CALL    2486
....................    md_home_pos=home_pos; 
03170:  PUSH    89A
03172:  POP     810
.................... } 
03174:  MOV     [--W15],W6
03176:  MOV     [--W15],W5
03178:  RETURN  
.................... // Sets end position 
.................... void data_set_end_pos() 
.................... { 
0317A:  MOV     W5,[W15++]
0317C:  MOV     W6,[W15++]
0317E:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[5]; 
....................    for(i=0; i<5; i++) 
03180:  CLR.B   890
03182:  MOV     890,W4
03184:  CP.B    W4L,#5
03186:  BRA     C,31BC
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03188:  MOV.B   890,W0L
0318A:  CLR.B   1
0318C:  SL      W0,#1,W0
0318E:  MOV     #892,W4
03190:  ADD     W0,W4,W5
03192:  BTSS.B  218.0
03194:  BRA     3192
03196:  MOV     21C,W0
03198:  SUB.B   #30,W0L
0319A:  CLR.B   1
0319C:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
0319E:  MOV.B   890,W0L
031A0:  CLR.B   1
031A2:  SL      W0,#1,W0
031A4:  MOV     #892,W4
031A6:  ADD     W0,W4,W0
031A8:  MOV     [W0],W5
031AA:  ADD     #30,W5
031AC:  MOV.B   W5L,W0L
031AE:  BTSC.B  219.1
031B0:  BRA     31AE
031B2:  MOV.B   W0L,21A
031B4:  CLR.B   21B
....................    } 
031B6:  INC.B   0890
031B8:  GOTO    3182
....................    unsigned int end=10000*input[0]+1000*input[1]+100*input[2]+10*input[3]+1*input[4]; 
031BC:  MOV     #2710,W4
031BE:  MOV     892,W3
031C0:  MUL.UU  W4,W3,W0
031C2:  MOV     W0,W5
031C4:  MOV     #3E8,W4
031C6:  MOV     894,W3
031C8:  MUL.UU  W4,W3,W0
031CA:  ADD     W0,W5,W5
031CC:  MOV     #64,W4
031CE:  MOV     896,W3
031D0:  MUL.UU  W4,W3,W0
031D2:  ADD     W0,W5,W5
031D4:  MOV     898,W4
031D6:  MUL.UU  W4,#A,W0
031D8:  ADD     W0,W5,W5
031DA:  MOV     W5,W0
031DC:  ADD     89A,W0
031DE:  MOV     W0,89C
....................     
....................    if(end<md_home_pos) 
031E0:  MOV     89C,W0
031E2:  MOV     810,W4
031E4:  CP      W4,W0
031E6:  BRA     LEU,320E
....................    { 
....................       end=data_get_home_pos()+50; 
031E8:  CALL    1E62
031EC:  MOV     W0,W5
031EE:  MOV     #32,W4
031F0:  ADD     W5,W4,W0
031F2:  MOV     W0,89C
....................       fprintf(RS232, "\n\rInvalid entry: End position cannot be smaller than home position. End position is set to its default."); 
031F4:  MOV     #0,W1
031F6:  MOV     W1,W0
031F8:  CALL    67A
031FC:  INC     W1,W1
031FE:  MOV     W1,[W15++]
03200:  BTSC.B  219.1
03202:  BRA     3200
03204:  MOV     W0,21A
03206:  MOV     [--W15],W1
03208:  MOV     #66,W0
0320A:  CPSGT   W1,W0
0320C:  BRA     31F6
....................    } 
....................     
....................    fr_write(fr_end_pos,end); 
0320E:  PUSH    838
03210:  POP     89E
03212:  PUSH    89C
03214:  POP     8A0
03216:  CALL    2486
....................    md_end_pos=end; 
0321A:  PUSH    89C
0321C:  POP     812
.................... } 
0321E:  MOV     [--W15],W6
03220:  MOV     [--W15],W5
03222:  RETURN  
.................... // Sets positioning velocity 
.................... void data_set_conv_const() 
.................... { 
03224:  MOV     W5,[W15++]
03226:  MOV     W6,[W15++]
....................    md_conv_const = 12500; 
03228:  MOV     #30D4,W4
0322A:  MOV     W4,80C
....................    md_cc_step = 0; 
0322C:  CLR     82E
....................    md_cc_count = 0; 
0322E:  CLR     830
....................     
....................    move_pos(md_min_distance); 
03230:  PUSH    818
03232:  POP     894
03234:  CALL    2BEA
....................  
....................    unsigned int cc_first_count = qei_get_count(); 
03238:  CALL    20A0
0323C:  MOV     W0,890
....................     
....................    reg_md_cc_sample =1; 
0323E:  BSET.B  84C.4
....................    move_pos(md_move_range); 
03240:  PUSH    80E
03242:  POP     894
03244:  CALL    2BEA
....................     
....................    unsigned int conv_const = ((float)(cc_first_count - md_cc_count)/(float)md_cc_step)*10000; 
03248:  MOV     890,W4
0324A:  MOV     830,W3
0324C:  SUB     W4,W3,W0
0324E:  CALL    24C0
*
0327C:  MOV     W0,892
....................  
....................    fprintf(RS232, "Count: %u counts\n\r", cc_first_count-md_cc_count); 
0327E:  MOV     890,W4
03280:  MOV     830,W3
03282:  SUB     W4,W3,W5
03284:  MOV     #0,W1
03286:  MOV     W1,W0
03288:  CALL    6DC
0328C:  INC     W1,W1
0328E:  MOV     W1,[W15++]
03290:  BTSC.B  219.1
03292:  BRA     3290
03294:  MOV     W0,21A
03296:  MOV     [--W15],W1
03298:  MOV     #6,W0
0329A:  CPSGT   W1,W0
0329C:  BRA     3286
0329E:  MOV     W5,W0
032A0:  MOV     #0,W4
032A2:  CALL    1688
032A6:  MOV     #9,W1
032A8:  MOV     W1,W0
032AA:  CALL    6DC
032AE:  INC     W1,W1
032B0:  MOV     W1,[W15++]
032B2:  BTSC.B  219.1
032B4:  BRA     32B2
032B6:  MOV     W0,21A
032B8:  MOV     [--W15],W1
032BA:  MOV     #11,W0
032BC:  CPSGT   W1,W0
032BE:  BRA     32A8
....................    fprintf(RS232, "Step: %u steps\n\r", md_cc_step); 
032C0:  MOV     #0,W1
032C2:  MOV     W1,W0
032C4:  CALL    6FC
032C8:  INC     W1,W1
032CA:  MOV     W1,[W15++]
032CC:  BTSC.B  219.1
032CE:  BRA     32CC
032D0:  MOV     W0,21A
032D2:  MOV     [--W15],W1
032D4:  MOV     #5,W0
032D6:  CPSGT   W1,W0
032D8:  BRA     32C2
032DA:  MOV     82E,W0
032DC:  MOV     #0,W4
032DE:  CALL    1688
032E2:  MOV     #8,W1
032E4:  MOV     W1,W0
032E6:  CALL    6FC
032EA:  INC     W1,W1
032EC:  MOV     W1,[W15++]
032EE:  BTSC.B  219.1
032F0:  BRA     32EE
032F2:  MOV     W0,21A
032F4:  MOV     [--W15],W1
032F6:  MOV     #F,W0
032F8:  CPSGT   W1,W0
032FA:  BRA     32E4
....................    fprintf(RS232, "Conversion Constant: %u counts\n\r", conv_const); 
032FC:  MOV     #0,W1
032FE:  MOV     W1,W0
03300:  CALL    71A
03304:  INC     W1,W1
03306:  MOV     W1,[W15++]
03308:  BTSC.B  219.1
0330A:  BRA     3308
0330C:  MOV     W0,21A
0330E:  MOV     [--W15],W1
03310:  MOV     #14,W0
03312:  CPSGT   W1,W0
03314:  BRA     32FE
03316:  MOV     892,W0
03318:  MOV     #0,W4
0331A:  CALL    1688
0331E:  MOV     #17,W1
03320:  MOV     W1,W0
03322:  CALL    71A
03326:  INC     W1,W1
03328:  MOV     W1,[W15++]
0332A:  BTSC.B  219.1
0332C:  BRA     332A
0332E:  MOV     W0,21A
03330:  MOV     [--W15],W1
03332:  MOV     #1F,W0
03334:  CPSGT   W1,W0
03336:  BRA     3320
....................    
....................    fr_write(fr_conv_const,conv_const); 
03338:  PUSH    83A
0333A:  POP     89E
0333C:  PUSH    892
0333E:  POP     8A0
03340:  CALL    2486
....................    md_conv_const = conv_const; 
03344:  PUSH    892
03346:  POP     80C
.................... } 
03348:  MOV     [--W15],W6
0334A:  MOV     [--W15],W5
0334C:  RETURN  
.................... // Sets backlash 
.................... void data_set_backlash() 
.................... { 
0334E:  MOV     W5,[W15++]
03350:  MOV     W6,[W15++]
03352:  CLR.B   890
....................    unsigned int8 i=0; 
....................    unsigned int input[2]; 
....................    for(i=0; i<2; i++) 
03354:  CLR.B   890
03356:  MOV     890,W4
03358:  CP.B    W4L,#2
0335A:  BRA     C,3390
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
0335C:  MOV.B   890,W0L
0335E:  CLR.B   1
03360:  SL      W0,#1,W0
03362:  MOV     #892,W4
03364:  ADD     W0,W4,W5
03366:  BTSS.B  218.0
03368:  BRA     3366
0336A:  MOV     21C,W0
0336C:  SUB.B   #30,W0L
0336E:  CLR.B   1
03370:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03372:  MOV.B   890,W0L
03374:  CLR.B   1
03376:  SL      W0,#1,W0
03378:  MOV     #892,W4
0337A:  ADD     W0,W4,W0
0337C:  MOV     [W0],W5
0337E:  ADD     #30,W5
03380:  MOV.B   W5L,W0L
03382:  BTSC.B  219.1
03384:  BRA     3382
03386:  MOV.B   W0L,21A
03388:  CLR.B   21B
....................    } 
0338A:  INC.B   0890
0338C:  GOTO    3356
....................    unsigned int backlash = 10*input[0]+1*input[1]; 
03390:  MOV     892,W4
03392:  MUL.UU  W4,#A,W0
03394:  MOV     W0,W5
03396:  MOV     W5,W0
03398:  ADD     894,W0
0339A:  MOV     W0,896
....................     
....................    fr_write(fr_backlash,backlash); 
0339C:  PUSH    83C
0339E:  POP     89E
033A0:  PUSH    896
033A2:  POP     8A0
033A4:  CALL    2486
....................    md_backlash = backlash; 
033A8:  PUSH    896
033AA:  POP     82C
.................... } 
033AC:  MOV     [--W15],W6
033AE:  MOV     [--W15],W5
033B0:  RETURN  
.................... // Sets communication type 
.................... void data_set_comm_type() 
.................... { 
033B2:  MOV     W5,[W15++]
033B4:  BTSS.B  218.0
033B6:  BRA     33B4
033B8:  MOV     21C,W0
033BA:  MOV     #30,W4
033BC:  SUB.B   W0L,W4L,W0L
033BE:  MOV.B   W0L,890
....................    unsigned int8 input=(unsigned)(fgetc(RS232)-48); 
....................    fputc(input+48,RS232); 
033C0:  MOV     #30,W4
033C2:  MOV     890,W3
033C4:  ADD.B   W3L,W4L,W5L
033C6:  MOV.B   W5L,W0L
033C8:  BTSC.B  219.1
033CA:  BRA     33C8
033CC:  MOV.B   W0L,21A
033CE:  CLR.B   21B
....................    switch (input) 
....................    { 
033D0:  MOV.B   890,W0L
033D2:  CLR.B   1
033D4:  XOR     #1,W0
033D6:  BRA     Z,33DE
033D8:  XOR     #1,W0
033DA:  BRA     Z,33F6
033DC:  BRA     33F6
....................       case 1   :  output_low(PP_ACK); 
033DE:  BCLR.B  2D2.4
033E0:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
033E2:  BCLR.B  2D2.5
033E4:  BCLR.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 1); 
033E6:  MOV.B   #1,W0L
033E8:  MOV.B   W0L,8AE
033EA:  PUSH    83E
033EC:  POP     8AC
033EE:  CALL    237A
....................                   break; 
033F2:  GOTO    340C
....................       case 0   :     
....................       default  :  output_high(PP_ACK); 
033F6:  BCLR.B  2D2.4
033F8:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
033FA:  BCLR.B  2D2.5
033FC:  BSET.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 0); 
033FE:  CLR.B   8AE
03400:  PUSH    83E
03402:  POP     8AC
03404:  CALL    237A
....................                   break; 
03408:  GOTO    340C
....................    } 
.................... } 
0340C:  MOV     [--W15],W5
0340E:  RETURN  
.................... // Sets last position 
.................... void data_set_last_pos(unsigned int16 position) 
.................... { 
....................    fr_write(fr_last_pos, position); 
*
024B2:  PUSH    840
024B4:  POP     89E
024B6:  PUSH    89A
024B8:  POP     8A0
024BA:  CALL    2486
.................... } 
024BE:  RETURN  
.................... // Sets position to given index 
.................... void data_set_pos(unsigned int8 index, unsigned int16 position) 
.................... { 
*
0362C:  MOV     W5,[W15++]
....................    fr_write(fr_pos_table+index*2, position); 
0362E:  MOV.B   892,W0L
03630:  SL      W0,#1,W0
03632:  ZE      W0,W0
03634:  CLR.B   1
03636:  MOV     842,W4
03638:  ADD     W0,W4,W5
0363A:  MOV     W5,89E
0363C:  PUSH    894
0363E:  POP     8A0
03640:  CALL    2486
.................... } 
03644:  MOV     [--W15],W5
03646:  RETURN  
....................  
.................... // Initializes the quadrature encoder interface module by using default values 
.................... void qei_init() 
.................... { 
....................    // Disable QEI module  
....................    QEI_QEICON_QEIM0=0; 
*
0173E:  BCLR.B  123.0
....................    QEI_QEICON_QEIM1=0; 
01740:  BCLR.B  123.1
....................    QEI_QEICON_QEIM2=0; 
01742:  BCLR.B  123.2
....................    // Clear any count errors 
....................    QEI_QEICON_CNTERR=0; 
01744:  BCLR.B  123.7
....................    // Continue module operation during sleep 
....................    QEI_QEICON_QEISIDL=0; 
01746:  BCLR.B  123.5
....................    // QEA and QEB not swapped 
....................    QEI_QEICON_SWPAB=0; 
01748:  BCLR.B  122.7
....................    // Normal I/O pin operation 
....................    QEI_QEICON_PCDOUT=0; 
0174A:  BCLR.B  122.6
....................    // Timer gated time accumulation disabled 
....................    QEI_QEICON_TQGATE=0; 
0174C:  BCLR.B  122.5
....................    // 1:1 timer input clock prescale 
....................    QEI_QEICON_TQCKPS0=0; 
0174E:  BCLR.B  122.3
....................    QEI_QEICON_TQCKPS1=0; 
01750:  BCLR.B  122.4
....................    // Index pulse does not reset the position counter 
....................    QEI_QEICON_POSRES = 0; 
01752:  BCLR.B  122.2
....................    // Internal clock as timer clock source 
....................    QEI_QEICON_TQCS = 0; 
01754:  BCLR.B  122.1
....................    // QEI_QEICON_UPDN defines timer counter (QEI_POSCNT) direction 
....................    QEI_QEICON_UDSRC = 0; 
01756:  BCLR.B  122.0
....................     
....................    // Count error interrupts enabled 
....................    QEI_DFLTCON_CEID = 0;  
01758:  BCLR.B  125.0
....................    // Digital filter outputs enabled 
....................    QEI_DFLTCON_QEOUT = 1;  
0175A:  BSET.B  124.7
....................    // 1:256 clock divide for digital filter 
....................    QEI_DFLTCON_QECK2 = 1; 
0175C:  BSET.B  124.6
....................    QEI_DFLTCON_QECK1 = 1; 
0175E:  BSET.B  124.5
....................    QEI_DFLTCON_QECK0 = 1; 
01760:  BSET.B  124.4
....................     
....................    // Reset position counter 
....................    QEI_POSCNT = 0x0000; 
01762:  CLR     126
....................     
....................    // Set maximum count 
....................    QEI_MAXCNT = 0xFFFF; 
01764:  SETM    128
....................     
....................    // QEI module enabled in x4 mode with position counter reset by QEI_MAXCNT match 
....................    QEI_QEICON_QEIM2 = 1; 
01766:  BSET.B  123.2
....................    QEI_QEICON_QEIM1 = 1; 
01768:  BSET.B  123.1
....................    QEI_QEICON_QEIM0 = 1; 
0176A:  BSET.B  123.0
....................     
....................    if(debug_mode_qei) 
0176C:  BTSS.B  800.5
0176E:  BRA     178A
....................       fprintf(RS232,"Quadrature Encoder Initialized\n\n\r"); 
01770:  MOV     #0,W1
01772:  MOV     W1,W0
01774:  CALL    748
01778:  INC     W1,W1
0177A:  MOV     W1,[W15++]
0177C:  BTSC.B  219.1
0177E:  BRA     177C
01780:  MOV     W0,21A
01782:  MOV     [--W15],W1
01784:  MOV     #20,W0
01786:  CPSGT   W1,W0
01788:  BRA     1772
.................... } 
0178A:  RETURN  
.................... // Sets the position counter to given value 
.................... void qei_set_count(unsigned int16 value) 
.................... {  
....................    QEI_POSCNT = value; 
*
0205C:  PUSH    8A8
0205E:  POP     126
....................     
....................    if(debug_mode_qei) 
02060:  BTSS.B  800.5
02062:  BRA     209E
....................       fprintf(RS232,"Quadrature Encoder Count Set: %u\n\n\r", value); 
02064:  MOV     #0,W1
02066:  MOV     W1,W0
02068:  CALL    776
0206C:  INC     W1,W1
0206E:  MOV     W1,[W15++]
02070:  BTSC.B  219.1
02072:  BRA     2070
02074:  MOV     W0,21A
02076:  MOV     [--W15],W1
02078:  MOV     #1D,W0
0207A:  CPSGT   W1,W0
0207C:  BRA     2066
0207E:  MOV     8A8,W0
02080:  MOV     #0,W4
02082:  CALL    1688
02086:  BTSC.B  219.1
02088:  BRA     2086
0208A:  MOV     #A,W4
0208C:  MOV     W4,21A
0208E:  BTSC.B  219.1
02090:  BRA     208E
02092:  MOV     #A,W4
02094:  MOV     W4,21A
02096:  BTSC.B  219.1
02098:  BRA     2096
0209A:  MOV     #D,W4
0209C:  MOV     W4,21A
.................... } 
0209E:  RETURN  
.................... // Sets the maximum count to given value 
.................... void qei_set_max_count(unsigned int16 value) 
.................... {  
....................    QEI_MAXCNT = value; 
*
01F52:  PUSH    856
01F54:  POP     128
....................     
....................    if(debug_mode_qei) 
01F56:  BTSS.B  800.5
01F58:  BRA     1F94
....................       fprintf(RS232,"Quadrature Encoder Maximum Count Set: %u\n\n\r", value); 
01F5A:  MOV     #0,W1
01F5C:  MOV     W1,W0
01F5E:  CALL    7A6
01F62:  INC     W1,W1
01F64:  MOV     W1,[W15++]
01F66:  BTSC.B  219.1
01F68:  BRA     1F66
01F6A:  MOV     W0,21A
01F6C:  MOV     [--W15],W1
01F6E:  MOV     #25,W0
01F70:  CPSGT   W1,W0
01F72:  BRA     1F5C
01F74:  MOV     856,W0
01F76:  MOV     #0,W4
01F78:  CALL    1688
01F7C:  BTSC.B  219.1
01F7E:  BRA     1F7C
01F80:  MOV     #A,W4
01F82:  MOV     W4,21A
01F84:  BTSC.B  219.1
01F86:  BRA     1F84
01F88:  MOV     #A,W4
01F8A:  MOV     W4,21A
01F8C:  BTSC.B  219.1
01F8E:  BRA     1F8C
01F90:  MOV     #D,W4
01F92:  MOV     W4,21A
.................... } 
01F94:  RETURN  
.................... // Returns the value of the position counter 
.................... unsigned int16 qei_get_count(){ return QEI_POSCNT;} 
*
020A0:  PUSH    126
020A2:  POP     0
020A4:  RETURN  
....................  
.................... // Sets the operating mode of the PWM module 
.................... void pwm_select_mode(unsigned int mode) 
.................... { 
....................    if(mode == FREE) 
*
0178C:  CP0     8A8
0178E:  BRA     NZ,1798
....................    { 
....................       // Select free running PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
01790:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 0; 
01792:  BCLR.B  1C0.0
....................    } 
....................    else if(mode == SINGLE) 
01794:  GOTO    17A2
01798:  MOV     8A8,W4
0179A:  CP      W4,#1
0179C:  BRA     NZ,17A2
....................    { 
....................       // Select single event PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
0179E:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 1; 
017A0:  BSET.B  1C0.0
....................    } 
.................... } 
017A2:  RETURN  
.................... // Initializes the PWM module by using default values 
.................... void pwm_init() 
.................... { 
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN       = 0; 
017A4:  BCLR.B  1C1.7
....................     
....................    // Select 1:1 output postscale 
....................    PWM_PTCON_PTOPS3     = 0; 
017A6:  BCLR.B  1C0.7
....................    PWM_PTCON_PTOPS2     = 0; 
017A8:  BCLR.B  1C0.6
....................    PWM_PTCON_PTOPS1     = 0; 
017AA:  BCLR.B  1C0.5
....................    PWM_PTCON_PTOPS0     = 0; 
017AC:  BCLR.B  1C0.4
....................    // Select 1:1 input prescale 
....................    PWM_PTCON_PTCKPS1    = 0; 
017AE:  BCLR.B  1C0.3
....................    PWM_PTCON_PTCKPS0    = 0; 
017B0:  BCLR.B  1C0.2
....................     
....................    // Set the operating mode of PWM module 
....................    pwm_select_mode(FREE); 
017B2:  CLR     8A8
017B4:  CALL    178C
....................  
....................    // Select independent output mode for PWM1 I/O pair 
....................    PWM_PWMCON1_PMOD1    = 1; 
017B8:  BSET.B  1C9.0
....................    // Set PWM1H pin as PWM output 
....................    PWM_PWMCON1_PEN1H    = 1; 
017BA:  BSET.B  1C8.4
....................     
....................    // Synchronize PDC registers to the PWM time base 
....................    PWM_PWMCON2_IUE      = 0; 
017BC:  BCLR.B  1CA.2
....................    // Enable PWM interrupt 
....................    PWM_IEC2_PWMIE       = 0; 
017BE:  BCLR.B  90.7
....................     
....................    // Set time base period value 
....................    PWM_PTPER            = 0; 
017C0:  CLR     1C4
....................    // Set time base duty cycle 
....................    PWM_PDC1             = 0; 
017C2:  CLR     1D6
....................  
....................    if(debug_mode_md) 
017C4:  BTSS.B  800.3
017C6:  BRA     17E2
....................       fprintf(RS232,"PWM Module Initialized\n\n\r"); 
017C8:  MOV     #0,W1
017CA:  MOV     W1,W0
017CC:  CALL    7E0
017D0:  INC     W1,W1
017D2:  MOV     W1,[W15++]
017D4:  BTSC.B  219.1
017D6:  BRA     17D4
017D8:  MOV     W0,21A
017DA:  MOV     [--W15],W1
017DC:  MOV     #18,W0
017DE:  CPSGT   W1,W0
017E0:  BRA     17CA
.................... } 
017E2:  RETURN  
.................... // Set PWM period time (us) 
.................... void pwm_set_period(unsigned int16 period) 
.................... { 
*
01FF8:  MOV     W5,[W15++]
....................    // PWM period 
....................    unsigned int16 pwm_period;  
....................     
....................    // Set the PWM period 
....................    if(period==0) 
01FFA:  CP0     8AC
01FFC:  BRA     NZ,2004
....................       pwm_period = 0; 
01FFE:  CLR     8AE
....................    else 
02000:  GOTO    200E
....................       pwm_period = 30 * period - 1; 
02004:  MOV     8AC,W4
02006:  MUL.UU  W4,#1E,W0
02008:  MOV     W0,W5
0200A:  SUB     W5,#1,W0
0200C:  MOV     W0,8AE
....................     
....................    // Updates from duty cycle and period buffer registers are disabled 
....................    PWM_PWMCON2_UDIS = 1; 
0200E:  BSET.B  1CA.0
....................    // Set time base period value 
....................    PWM_PTPER        = pwm_period; 
02010:  PUSH    8AE
02012:  POP     1C4
....................    // Set time base duty cycle if PWM module is enabled (duty cycle > 0%) 
....................    PWM_PDC1         = pwm_period; 
02014:  PUSH    8AE
02016:  POP     1D6
....................    // Updates from duty cycle and period buffer registers are enabled 
....................    PWM_PWMCON2_UDIS = 0; 
02018:  BCLR.B  1CA.0
.................... } 
0201A:  MOV     [--W15],W5
0201C:  RETURN  
.................... // Disable PWM module 
.................... void pwm_disable() 
.................... { 
....................    // Set duty cycle to zero 
....................    PWM_PDC1=0; 
*
0202E:  CLR     1D6
....................    // Wait for the last signal 
....................    delay_us(PWM_PTPER + 1 / 30); 
02030:  MOV     1C4,W0
02032:  CALL    201E
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN = 0; 
02036:  BCLR.B  1C1.7
....................    // Set duty cycle to its initial value 
....................    PWM_PDC1=PWM_PTPER; 
02038:  PUSH    1C4
0203A:  POP     1D6
....................     
....................    if(debug_mode_pwm) 
0203C:  BTSS.B  800.4
0203E:  BRA     205A
....................       fprintf(RS232,"PWM Disabled\n\r"); 
02040:  MOV     #0,W1
02042:  MOV     W1,W0
02044:  CALL    806
02048:  INC     W1,W1
0204A:  MOV     W1,[W15++]
0204C:  BTSC.B  219.1
0204E:  BRA     204C
02050:  MOV     W0,21A
02052:  MOV     [--W15],W1
02054:  MOV     #D,W0
02056:  CPSGT   W1,W0
02058:  BRA     2042
.................... } 
0205A:  RETURN  
.................... // Enable PWM module 
.................... void pwm_enable() 
.................... { 
*
020A6:  MOV     W5,[W15++]
....................    // Disable RS232 receive byte interrupt 
....................    disable_interrupts(INT_RDA2); 
020A8:  BCLR.B  8F.0
....................     
....................    // Enable PWM module 
....................    PWM_PTCON_PTEN = 1; 
020AA:  BSET.B  1C1.7
....................    // Start pwm cycle 
....................    int1 reg_md_running = 1; 
....................    unsigned int md_step_count = 0; 
020AC:  BSET.B  8A2.0
020AE:  CLR     8A4
....................     
....................    while(reg_md_running) 
....................    { 
020B0:  BTSS.B  8A2.0
020B2:  BRA     22E0
....................       if(PWM_IFS2_PWMIF) 
020B4:  BTSS.B  88.7
020B6:  BRA     22DC
....................       { 
....................          // Clear the flag register 
....................          PWM_IFS2_PWMIF = 0; 
020B8:  BCLR.B  88.7
....................           
....................          md_step_count++; 
020BA:  INC     08A4
....................        
....................          switch(md_run_state)  
....................          { 
020BC:  MOV.B   801,W0L
020BE:  CLR.B   1
020C0:  XOR     #0,W0
020C2:  BRA     Z,20D6
020C4:  XOR     #1,W0
020C6:  BRA     Z,217E
020C8:  XOR     #2,W0
020CA:  BRA     Z,21E8
020CC:  XOR     #1,W0
020CE:  BRA     Z,2208
020D0:  XOR     #6,W0
020D2:  BRA     Z,2252
020D4:  BRA     22DC
....................             case HOME: 
....................                if(reg_md_home_return == 0) 
020D6:  BTSC.B  84C.2
020D8:  BRA     2158
....................                { 
....................                   if(reg_md_home == 0) 
020DA:  BTSC.B  84C.1
020DC:  BRA     212C
....................                   { 
....................                      if(input(MD_SW)) 
020DE:  BSET.B  2D3.3
020E0:  BTSS.B  2D5.3
020E2:  BRA     2114
....................                      { 
....................                         if(md_step_count < md_max_acc_lim) 
020E4:  MOV     8A4,W0
020E6:  MOV     84E,W4
020E8:  CP      W4,W0
020EA:  BRA     LEU,2104
....................                         { 
....................                            md_decel_count = md_step_count; 
020EC:  PUSH    8A4
020EE:  POP     826
....................                            pwm_set_period(delays[md_step_count]); 
020F0:  MOV     8A4,W0
020F2:  SL      W0,#1,W0
020F4:  CALL    100
020F8:  MOV     W0,W5
020FA:  MOV     W5,8AC
020FC:  CALL    1FF8
....................                         } 
....................                         else 
02100:  GOTO    2110
....................                         { 
....................                            md_decel_count = md_max_acc_lim; 
02104:  PUSH    84E
02106:  POP     826
....................                            pwm_set_period(md_min_delay); 
02108:  PUSH    820
0210A:  POP     8AC
0210C:  CALL    1FF8
....................                         } 
....................                      } 
....................                      else 
02110:  GOTO    2128
....................                      { 
....................                         reg_md_home = 1; 
02114:  BSET.B  84C.1
....................                         md_decel_count--; 
02116:  DEC     0826
....................                         pwm_set_period(delays[md_decel_count]); 
02118:  MOV     826,W0
0211A:  SL      W0,#1,W0
0211C:  CALL    100
02120:  MOV     W0,W5
02122:  MOV     W5,8AC
02124:  CALL    1FF8
....................                      } 
....................                   } 
....................                   else 
02128:  GOTO    2154
....................                   { 
....................                      if(md_decel_count == 0) 
0212C:  CP0     826
0212E:  BRA     NZ,2142
....................                      {   
....................                         reg_md_home_return = 1; 
02130:  BSET.B  84C.2
....................                         output_low(MD_DIR); 
02132:  BCLR.B  2D8.4
02134:  BCLR.B  2DC.4
....................                         pwm_set_period(1000); 
02136:  MOV     #3E8,W4
02138:  MOV     W4,8AC
0213A:  CALL    1FF8
....................                      } 
....................                      else 
0213E:  GOTO    2154
....................                      { 
....................                         md_decel_count--; 
02142:  DEC     0826
....................                         pwm_set_period(delays[md_decel_count]); 
02144:  MOV     826,W0
02146:  SL      W0,#1,W0
02148:  CALL    100
0214C:  MOV     W0,W5
0214E:  MOV     W5,8AC
02150:  CALL    1FF8
....................                      } 
....................                   } 
....................                } 
....................                else 
02154:  GOTO    217A
....................                { 
....................                   if(input(MD_SW)) 
02158:  BSET.B  2D3.3
0215A:  BTSS.B  2D5.3
0215C:  BRA     217A
....................                   { 
....................                      pwm_disable(); 
0215E:  CALL    202E
....................                      reg_md_running = 0; 
02162:  BCLR.B  8A2.0
....................                       
....................                      delay_ms(50); 
02164:  MOV     #32,W0
02166:  CALL    1674
....................                      qei_set_count(md_home_offset); 
0216A:  PUSH    816
0216C:  POP     8A8
0216E:  CALL    205C
....................                      md_mt_set(mt_percent_rest); 
02172:  PUSH    80A
02174:  POP     8A8
02176:  CALL    1C9E
....................                   } 
....................                } 
....................                break; 
0217A:  GOTO    22DC
....................                 
....................             case ACCEL: 
....................                // Check if we should start deceleration. 
....................                if(md_step_count >= md_accel_lim)  
0217E:  MOV     824,W0
02180:  MOV     8A4,W4
02182:  CP      W4,W0
02184:  BRA     NC,21D4
....................                { 
....................                   if(md_step_count == md_decel_lim) 
02186:  MOV     8A4,W0
02188:  CP      822
0218A:  BRA     NZ,21A6
....................                   { 
....................                      md_decel_count--; 
0218C:  DEC     0826
....................                      pwm_set_period(delays[md_decel_count]); 
0218E:  MOV     826,W0
02190:  SL      W0,#1,W0
02192:  CALL    100
02196:  MOV     W0,W5
02198:  MOV     W5,8AC
0219A:  CALL    1FF8
....................                      md_run_state = DECEL; 
0219E:  MOV.B   #2,W0L
021A0:  MOV.B   W0L,801
....................                   } 
....................                   else if(md_decel_lim - md_step_count < 2) 
021A2:  GOTO    21D0
021A6:  MOV     822,W4
021A8:  MOV     8A4,W3
021AA:  SUB     W4,W3,W5
021AC:  CP      W5,#2
021AE:  BRA     C,21C4
....................                   { 
....................                      pwm_set_period(delays[md_step_count]); 
021B0:  MOV     8A4,W0
021B2:  SL      W0,#1,W0
021B4:  CALL    100
021B8:  MOV     W0,W5
021BA:  MOV     W5,8AC
021BC:  CALL    1FF8
....................                   } 
....................                   else 
021C0:  GOTO    21D0
....................                   { 
....................                      pwm_set_period(md_min_delay); 
021C4:  PUSH    820
021C6:  POP     8AC
021C8:  CALL    1FF8
....................                      md_run_state = RUN; 
021CC:  MOV.B   #3,W0L
021CE:  MOV.B   W0L,801
....................                   } 
....................                } 
....................                else 
021D0:  GOTO    21E4
....................                { 
....................                   pwm_set_period(delays[md_step_count]); 
021D4:  MOV     8A4,W0
021D6:  SL      W0,#1,W0
021D8:  CALL    100
021DC:  MOV     W0,W5
021DE:  MOV     W5,8AC
021E0:  CALL    1FF8
....................                } 
....................                break; 
021E4:  GOTO    22DC
....................        
....................             case RUN: 
....................                // Check if we should start decelration. 
....................                if(md_step_count == md_decel_lim)  
021E8:  MOV     8A4,W0
021EA:  CP      822
021EC:  BRA     NZ,2204
....................                { 
....................                   md_decel_count--; 
021EE:  DEC     0826
....................                   pwm_set_period(delays[md_decel_count]); 
021F0:  MOV     826,W0
021F2:  SL      W0,#1,W0
021F4:  CALL    100
021F8:  MOV     W0,W5
021FA:  MOV     W5,8AC
021FC:  CALL    1FF8
....................                   md_run_state = DECEL; 
02200:  MOV.B   #2,W0L
02202:  MOV.B   W0L,801
....................                } 
....................                break; 
02204:  GOTO    22DC
....................        
....................             case DECEL: 
....................                // Check if we at last step 
....................                if(md_decel_count == 0) 
02208:  CP0     826
0220A:  BRA     NZ,223C
....................                { 
....................                   pwm_disable(); 
0220C:  CALL    202E
....................                   md_pos_iter = 0; 
02210:  CLR     828
....................                   md_run_state = POS; 
02212:  MOV.B   #4,W0L
02214:  MOV.B   W0L,801
....................                    
....................                   delay_ms(50); 
02216:  MOV     #32,W0
02218:  CALL    1674
....................  
....................                   md_error = md_target_count - qei_get_count(); 
0221C:  CALL    20A0
02220:  MOV     81A,W4
02222:  SUB     W4,W0,W0
02224:  MOV     W0,82A
....................                    
....................                   if(md_error > 1) 
02226:  MOV     82A,W4
02228:  CP      W4,#1
0222A:  BRA     LE,2234
....................                      output_low(MD_DIR); 
0222C:  BCLR.B  2D8.4
0222E:  BCLR.B  2DC.4
....................                   else 
02230:  GOTO    2238
....................                      output_high(MD_DIR); 
02234:  BCLR.B  2D8.4
02236:  BSET.B  2DC.4
....................                } 
....................                else 
02238:  GOTO    224E
....................                { 
....................                   md_decel_count--; 
0223C:  DEC     0826
....................                   pwm_set_period(delays[md_decel_count]); 
0223E:  MOV     826,W0
02240:  SL      W0,#1,W0
02242:  CALL    100
02246:  MOV     W0,W5
02248:  MOV     W5,8AC
0224A:  CALL    1FF8
....................                } 
....................                break; 
0224E:  GOTO    22DC
....................                 
....................             case POS: 
....................                md_pos_iter++; 
02252:  INC     0828
....................                 
....................                delay_ms(50); 
02254:  MOV     #32,W0
02256:  CALL    1674
....................                 
....................                if(reg_md_cc_sample) 
0225A:  BTSS.B  84C.4
0225C:  BRA     2270
....................                { 
....................                   reg_md_cc_sample = 0; 
0225E:  BCLR.B  84C.4
....................                   delay_ms(50); 
02260:  MOV     #32,W0
02262:  CALL    1674
....................                   md_cc_step = md_step_count; 
02266:  PUSH    8A4
02268:  POP     82E
....................                   md_cc_count = qei_get_count(); 
0226A:  CALL    20A0
0226E:  MOV     W0,830
....................                } 
....................  
....................                int difference; 
....................                 
....................                if(md_error < 1) 
02270:  MOV     82A,W4
02272:  CP      W4,#1
02274:  BRA     GE,2286
....................                   difference = qei_get_count() - md_target_count; 
02276:  CALL    20A0
0227A:  MOV     W0,W5
0227C:  MOV     81A,W4
0227E:  SUB     W5,W4,W0
02280:  MOV     W0,8A6
....................                else 
02282:  GOTO    2290
....................                   difference = md_target_count - qei_get_count(); 
02286:  CALL    20A0
0228A:  MOV     81A,W4
0228C:  SUB     W4,W0,W0
0228E:  MOV     W0,8A6
....................  
....................                if((difference < 1)||(md_pos_iter > 50)) 
02290:  MOV     8A6,W4
02292:  CP      W4,#1
02294:  BRA     LT,229E
02296:  MOV     828,W4
02298:  MOV     #32,W3
0229A:  CP      W3,W4
0229C:  BRA     C,22B0
....................                { 
....................                   pwm_disable(); 
0229E:  CALL    202E
....................                   reg_md_running = 0; 
022A2:  BCLR.B  8A2.0
....................                   md_mt_set(mt_percent_rest); 
022A4:  PUSH    80A
022A6:  POP     8A8
022A8:  CALL    1C9E
....................                } 
....................                else 
022AC:  GOTO    22D8
....................                { 
....................                   if(md_target_count > qei_get_count()) 
022B0:  CALL    20A0
022B4:  MOV     81A,W4
022B6:  CP      W4,W0
022B8:  BRA     LEU,22C2
....................                      output_low(MD_DIR); 
022BA:  BCLR.B  2D8.4
022BC:  BCLR.B  2DC.4
....................                   else 
022BE:  GOTO    22C6
....................                      output_high(MD_DIR); 
022C2:  BCLR.B  2D8.4
022C4:  BSET.B  2DC.4
....................                          
....................                   pwm_set_period(1000); 
022C6:  MOV     #3E8,W4
022C8:  MOV     W4,8AC
022CA:  CALL    1FF8
....................                   pwm_select_mode(SINGLE); 
022CE:  MOV     #1,W4
022D0:  MOV     W4,8A8
022D2:  CALL    178C
....................                   // Enable PWM module 
....................                   PWM_PTCON_PTEN = 1; 
022D6:  BSET.B  1C1.7
....................                } 
....................                break; 
022D8:  GOTO    22DC
....................          } 
....................       } 
....................    } 
022DC:  GOTO    20B0
....................  
....................    // Enable RS232 receive byte interrupt 
....................    clear_interrupt(INT_RDA2); 
....................    enable_interrupts(INT_RDA2); 
022E0:  BSET.B  8F.0
....................    reg_rs232_message = 0; 
022E2:  BCLR.B  84C.3
.................... } 
022E4:  MOV     [--W15],W5
022E6:  RETURN  
....................  
.................... // Move to given position (encoder count) 
.................... void move_to(unsigned int count) 
.................... { 
*
02920:  MOV     W5,[W15++]
02922:  MOV     W6,[W15++]
02924:  CALL    20A0
02928:  MOV     W0,89E
....................    // Calculate the number of steps 
....................    unsigned int displ;             
....................    // Calculate the current motor step by using current encoder count 
....................    unsigned int current_count = qei_get_count(); 
....................    // Calculate the target motor step by using given encoder step 
....................    md_target_count = count;  
0292A:  PUSH    89A
0292C:  POP     81A
....................     
....................    // Set direction 
....................    if(md_target_count > current_count) 
0292E:  MOV     89E,W0
02930:  MOV     81A,W4
02932:  CP      W4,W0
02934:  BRA     LEU,2946
....................    { 
....................       output_low(MD_DIR); 
02936:  BCLR.B  2D8.4
02938:  BCLR.B  2DC.4
....................       displ = md_target_count - current_count; 
0293A:  MOV     81A,W4
0293C:  MOV     89E,W3
0293E:  SUB     W4,W3,W0
02940:  MOV     W0,89C
....................    } 
....................    else 
02942:  GOTO    2952
....................    { 
....................       output_high(MD_DIR); 
02946:  BCLR.B  2D8.4
02948:  BSET.B  2DC.4
....................       displ = current_count - md_target_count; 
0294A:  MOV     89E,W4
0294C:  MOV     81A,W3
0294E:  SUB     W4,W3,W0
02950:  MOV     W0,89C
....................    } 
....................     
....................    displ = (long)displ * 10000 / md_conv_const; 
02952:  MOV     89C,W5
02954:  MOV     #0,W6
02956:  MOV     W5,W0
02958:  MOV     W6,W1
0295A:  MOV     #2710,W2
0295C:  MOV     #0,W3
0295E:  CALL    2854
02962:  MOV     W0,W5
02964:  MOV     W1,W6
02966:  BCLR.B  43.0
02968:  MOV     W5,W0
0296A:  MOV     W6,W1
0296C:  MOV     80C,W2
0296E:  MOV     #0,W3
02970:  CALL    2896
02974:  MOV     W0,89C
....................     
....................    if(debug_mode_pwm) 
02976:  BTSS.B  800.4
02978:  BRA     29AC
....................       fprintf(RS232,"Displacement: %u\n\r", displ); 
0297A:  MOV     #0,W1
0297C:  MOV     W1,W0
0297E:  CALL    822
02982:  INC     W1,W1
02984:  MOV     W1,[W15++]
02986:  BTSC.B  219.1
02988:  BRA     2986
0298A:  MOV     W0,21A
0298C:  MOV     [--W15],W1
0298E:  MOV     #D,W0
02990:  CPSGT   W1,W0
02992:  BRA     297C
02994:  MOV     89C,W0
02996:  MOV     #0,W4
02998:  CALL    1688
0299C:  BTSC.B  219.1
0299E:  BRA     299C
029A0:  MOV     #A,W4
029A2:  MOV     W4,21A
029A4:  BTSC.B  219.1
029A6:  BRA     29A4
029A8:  MOV     #D,W4
029AA:  MOV     W4,21A
....................     
....................    // If displacement is zero than no need to move 
....................    if(displ == 0) 
029AC:  CP0     89C
029AE:  BRA     NZ,29B2
....................       return; 
029B0:  BRA     2AEA
....................        
....................    // Find out after how many steps we must start deceleration. 
....................    md_accel_lim = ((long)displ * md_decel) / (md_accel + md_decel); 
029B2:  MOV     89C,W5
029B4:  MOV     #0,W6
029B6:  MOV     W5,W0
029B8:  MOV     W6,W1
029BA:  MOV     81E,W2
029BC:  MOV     #0,W3
029BE:  CALL    2854
029C2:  MOV     W0,W5
029C4:  MOV     W1,W6
029C6:  MOV     81C,W0
029C8:  ADD     81E,W0
029CA:  BCLR.B  43.0
029CC:  MOV     W6,W1
029CE:  MOV     W0,W2
029D0:  MOV     #0,W3
029D2:  MOV     W5,W0
029D4:  CALL    2896
029D8:  MOV     W0,824
....................    // We must accelerate at least 1 step before we can start deceleration. 
....................    if(md_accel_lim == 0) 
029DA:  CP0     824
029DC:  BRA     NZ,29E2
....................       md_accel_lim = 1; 
029DE:  MOV     #1,W4
029E0:  MOV     W4,824
....................     
....................    // Use the limit we hit first to calc decel. 
....................    if(md_accel_lim >= md_max_acc_lim) 
029E2:  MOV     84E,W0
029E4:  MOV     824,W4
029E6:  CP      W4,W0
029E8:  BRA     NC,2A1E
....................    { 
....................       md_accel_lim = md_max_acc_lim; 
029EA:  PUSH    84E
029EC:  POP     824
....................        
....................       // Find step to start decleration. 
....................       md_decel_count = ((long)md_max_acc_lim * md_accel) / md_decel; 
029EE:  MOV     84E,W5
029F0:  MOV     #0,W6
029F2:  MOV     W5,W0
029F4:  MOV     W6,W1
029F6:  MOV     81C,W2
029F8:  MOV     #0,W3
029FA:  CALL    2854
029FE:  MOV     W0,W5
02A00:  MOV     W1,W6
02A02:  BCLR.B  43.0
02A04:  MOV     W5,W0
02A06:  MOV     W6,W1
02A08:  MOV     81E,W2
02A0A:  MOV     #0,W3
02A0C:  CALL    2896
02A10:  MOV     W0,826
....................       md_decel_lim = displ - md_decel_count;  
02A12:  MOV     89C,W4
02A14:  MOV     826,W3
02A16:  SUB     W4,W3,W0
02A18:  MOV     W0,822
....................    } 
....................    else 
02A1A:  GOTO    2A2A
....................    { 
....................       md_decel_lim = displ - md_accel_lim; 
02A1E:  MOV     89C,W4
02A20:  MOV     824,W3
02A22:  SUB     W4,W3,W0
02A24:  MOV     W0,822
....................       md_decel_count = md_accel_lim; 
02A26:  PUSH    824
02A28:  POP     826
....................    } 
....................     
....................    // We must decelerate at least 1 step to stop. 
....................    if(md_decel_lim == 0) 
02A2A:  CP0     822
02A2C:  BRA     NZ,2A32
....................       md_decel_lim = 1; 
02A2E:  MOV     #1,W4
02A30:  MOV     W4,822
....................  
....................    if(debug_mode_pwm) 
02A32:  BTSS.B  800.4
02A34:  BRA     2ACC
....................    { 
....................       fprintf(RS232,"Acceleration Limit: %u\n\r", md_accel_lim); 
02A36:  MOV     #0,W1
02A38:  MOV     W1,W0
02A3A:  CALL    842
02A3E:  INC     W1,W1
02A40:  MOV     W1,[W15++]
02A42:  BTSC.B  219.1
02A44:  BRA     2A42
02A46:  MOV     W0,21A
02A48:  MOV     [--W15],W1
02A4A:  MOV     #13,W0
02A4C:  CPSGT   W1,W0
02A4E:  BRA     2A38
02A50:  MOV     824,W0
02A52:  MOV     #0,W4
02A54:  CALL    1688
02A58:  BTSC.B  219.1
02A5A:  BRA     2A58
02A5C:  MOV     #A,W4
02A5E:  MOV     W4,21A
02A60:  BTSC.B  219.1
02A62:  BRA     2A60
02A64:  MOV     #D,W4
02A66:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Limit: %u\n\r", md_decel_lim); 
02A68:  MOV     #0,W1
02A6A:  MOV     W1,W0
02A6C:  CALL    868
02A70:  INC     W1,W1
02A72:  MOV     W1,[W15++]
02A74:  BTSC.B  219.1
02A76:  BRA     2A74
02A78:  MOV     W0,21A
02A7A:  MOV     [--W15],W1
02A7C:  MOV     #13,W0
02A7E:  CPSGT   W1,W0
02A80:  BRA     2A6A
02A82:  MOV     822,W0
02A84:  MOV     #0,W4
02A86:  CALL    1688
02A8A:  BTSC.B  219.1
02A8C:  BRA     2A8A
02A8E:  MOV     #A,W4
02A90:  MOV     W4,21A
02A92:  BTSC.B  219.1
02A94:  BRA     2A92
02A96:  MOV     #D,W4
02A98:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Count: %u\n\r", md_decel_count); 
02A9A:  MOV     #0,W1
02A9C:  MOV     W1,W0
02A9E:  CALL    88E
02AA2:  INC     W1,W1
02AA4:  MOV     W1,[W15++]
02AA6:  BTSC.B  219.1
02AA8:  BRA     2AA6
02AAA:  MOV     W0,21A
02AAC:  MOV     [--W15],W1
02AAE:  MOV     #13,W0
02AB0:  CPSGT   W1,W0
02AB2:  BRA     2A9C
02AB4:  MOV     826,W0
02AB6:  MOV     #0,W4
02AB8:  CALL    1688
02ABC:  BTSC.B  219.1
02ABE:  BRA     2ABC
02AC0:  MOV     #A,W4
02AC2:  MOV     W4,21A
02AC4:  BTSC.B  219.1
02AC6:  BRA     2AC4
02AC8:  MOV     #D,W4
02ACA:  MOV     W4,21A
....................    } 
....................  
....................    md_run_state = ACCEL; 
02ACC:  MOV.B   #1,W0L
02ACE:  MOV.B   W0L,801
....................    md_mt_set(mt_percent_trip); 
02AD0:  PUSH    808
02AD2:  POP     8A8
02AD4:  CALL    1C9E
....................  
....................    pwm_set_period(delays[0]); 
02AD8:  MOV     #7D0,W4
02ADA:  MOV     W4,8AC
02ADC:  CALL    1FF8
....................    pwm_select_mode(FREE); 
02AE0:  CLR     8A8
02AE2:  CALL    178C
....................    pwm_enable(); 
02AE6:  CALL    20A6
.................... } 
02AEA:  MOV     [--W15],W6
02AEC:  MOV     [--W15],W5
02AEE:  RETURN  
.................... // Move to given position (mm) 
.................... void move_pos(unsigned int16 position) 
.................... { 
*
02BEA:  MOV     W5,[W15++]
02BEC:  MOV     #C,W5
02BEE:  REPEAT  #4
02BF0:  MOV     [W5++],[W15++]
....................    if(position>md_move_range) 
02BF2:  MOV     80E,W0
02BF4:  MOV     894,W4
02BF6:  CP      W4,W0
02BF8:  BRA     LEU,2C20
....................    { 
....................       position=md_move_range; 
02BFA:  PUSH    80E
02BFC:  POP     894
....................       if(debug_mode_md) 
02BFE:  BTSS.B  800.3
02C00:  BRA     2C1C
....................          fprintf(RS232, "Invalid entry: System cannot move to a position beyond the movement range. System will move to maximum possible distance."); 
02C02:  MOV     #0,W1
02C04:  MOV     W1,W0
02C06:  CALL    8B4
02C0A:  INC     W1,W1
02C0C:  MOV     W1,[W15++]
02C0E:  BTSC.B  219.1
02C10:  BRA     2C0E
02C12:  MOV     W0,21A
02C14:  MOV     [--W15],W1
02C16:  MOV     #78,W0
02C18:  CPSGT   W1,W0
02C1A:  BRA     2C04
....................    } 
....................    else if(position<md_min_distance) 
02C1C:  GOTO    2C6C
02C20:  MOV     894,W0
02C22:  MOV     818,W4
02C24:  CP      W4,W0
02C26:  BRA     LEU,2C6C
....................    { 
....................       position=md_min_distance; 
02C28:  PUSH    818
02C2A:  POP     894
....................       if(debug_mode_md) 
02C2C:  BTSS.B  800.3
02C2E:  BRA     2C6C
....................          fprintf(RS232, "Invalid entry: System cannot move to a position smaller than %u mm. System will move to minimum possible distance.", md_min_distance); 
02C30:  MOV     #0,W1
02C32:  MOV     W1,W0
02C34:  CALL    922
02C38:  INC     W1,W1
02C3A:  MOV     W1,[W15++]
02C3C:  BTSC.B  219.1
02C3E:  BRA     2C3C
02C40:  MOV     W0,21A
02C42:  MOV     [--W15],W1
02C44:  MOV     #3C,W0
02C46:  CPSGT   W1,W0
02C48:  BRA     2C32
02C4A:  MOV     818,W0
02C4C:  MOV     #0,W4
02C4E:  CALL    1688
02C52:  MOV     #3F,W1
02C54:  MOV     W1,W0
02C56:  CALL    922
02C5A:  INC     W1,W1
02C5C:  MOV     W1,[W15++]
02C5E:  BTSC.B  219.1
02C60:  BRA     2C5E
02C62:  MOV     W0,21A
02C64:  MOV     [--W15],W1
02C66:  MOV     #71,W0
02C68:  CPSGT   W1,W0
02C6A:  BRA     2C54
....................    } 
....................     
....................    fprintf(RS232,"\n\rTarget Position: %u mm\n\r", position); 
02C6C:  MOV     #0,W1
02C6E:  MOV     W1,W0
02C70:  CALL    98C
02C74:  INC     W1,W1
02C76:  MOV     W1,[W15++]
02C78:  BTSC.B  219.1
02C7A:  BRA     2C78
02C7C:  MOV     W0,21A
02C7E:  MOV     [--W15],W1
02C80:  MOV     #12,W0
02C82:  CPSGT   W1,W0
02C84:  BRA     2C6E
02C86:  MOV     894,W0
02C88:  MOV     #0,W4
02C8A:  CALL    1688
02C8E:  MOV     #15,W1
02C90:  MOV     W1,W0
02C92:  CALL    98C
02C96:  INC     W1,W1
02C98:  MOV     W1,[W15++]
02C9A:  BTSC.B  219.1
02C9C:  BRA     2C9A
02C9E:  MOV     W0,21A
02CA0:  MOV     [--W15],W1
02CA2:  MOV     #19,W0
02CA4:  CPSGT   W1,W0
02CA6:  BRA     2C90
....................  
....................    data_set_last_pos(position); 
02CA8:  PUSH    894
02CAA:  POP     89A
02CAC:  CALL    24B2
....................     
....................    unsigned int16 count = md_end_pos-((float)(position-md_min_distance)/2.0f)*((float)(md_end_pos-md_home_pos)/((float)(md_move_range-md_min_distance)/2.0f)); 
02CB0:  MOV     894,W4
02CB2:  MOV     818,W3
02CB4:  SUB     W4,W3,W0
02CB6:  CALL    24C0
*
02D26:  MOV     W0,896
....................     
....................    if(qei_get_count() < count) 
02D28:  CALL    20A0
02D2C:  MOV     W0,W5
02D2E:  MOV     896,W4
02D30:  CP      W4,W5
02D32:  BRA     LEU,2D3C
....................       count-=md_backlash; 
02D34:  MOV     896,W4
02D36:  MOV     82C,W3
02D38:  SUB     W4,W3,W0
02D3A:  MOV     W0,896
....................     
....................    move_to(count); 
02D3C:  PUSH    896
02D3E:  POP     89A
02D40:  CALL    2920
....................     
....................    delay_ms(100); 
02D44:  MOV     #64,W0
02D46:  CALL    1674
....................     
....................    if(debug_mode_md) 
02D4A:  BTSS.B  800.3
02D4C:  BRA     2E4E
....................    { 
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02D4E:  MOV     #0,W1
02D50:  MOV     W1,W0
02D52:  CALL    9B4
02D56:  INC     W1,W1
02D58:  MOV     W1,[W15++]
02D5A:  BTSC.B  219.1
02D5C:  BRA     2D5A
02D5E:  MOV     W0,21A
02D60:  MOV     [--W15],W1
02D62:  MOV     #E,W0
02D64:  CPSGT   W1,W0
02D66:  BRA     2D50
02D68:  MOV     82A,W0
02D6A:  MOV     #0,W4
02D6C:  CALL    2AF0
02D70:  BTSC.B  219.1
02D72:  BRA     2D70
02D74:  MOV     #A,W4
02D76:  MOV     W4,21A
02D78:  BTSC.B  219.1
02D7A:  BRA     2D78
02D7C:  MOV     #D,W4
02D7E:  MOV     W4,21A
....................       fprintf(RS232,"Target Encoder count: %u\n\r",md_target_count); 
02D80:  MOV     #0,W1
02D82:  MOV     W1,W0
02D84:  CALL    9D4
02D88:  INC     W1,W1
02D8A:  MOV     W1,[W15++]
02D8C:  BTSC.B  219.1
02D8E:  BRA     2D8C
02D90:  MOV     W0,21A
02D92:  MOV     [--W15],W1
02D94:  MOV     #15,W0
02D96:  CPSGT   W1,W0
02D98:  BRA     2D82
02D9A:  MOV     81A,W0
02D9C:  MOV     #0,W4
02D9E:  CALL    1688
02DA2:  BTSC.B  219.1
02DA4:  BRA     2DA2
02DA6:  MOV     #A,W4
02DA8:  MOV     W4,21A
02DAA:  BTSC.B  219.1
02DAC:  BRA     2DAA
02DAE:  MOV     #D,W4
02DB0:  MOV     W4,21A
....................       fprintf(RS232,"Current Encoder count: %u\n\r",qei_get_count()); 
02DB2:  CALL    20A0
02DB6:  MOV     W0,W5
02DB8:  MOV     #0,W1
02DBA:  MOV     W1,W0
02DBC:  CALL    9FC
02DC0:  INC     W1,W1
02DC2:  MOV     W1,[W15++]
02DC4:  BTSC.B  219.1
02DC6:  BRA     2DC4
02DC8:  MOV     W0,21A
02DCA:  MOV     [--W15],W1
02DCC:  MOV     #16,W0
02DCE:  CPSGT   W1,W0
02DD0:  BRA     2DBA
02DD2:  MOV     W5,W0
02DD4:  MOV     #0,W4
02DD6:  CALL    1688
02DDA:  BTSC.B  219.1
02DDC:  BRA     2DDA
02DDE:  MOV     #A,W4
02DE0:  MOV     W4,21A
02DE2:  BTSC.B  219.1
02DE4:  BRA     2DE2
02DE6:  MOV     #D,W4
02DE8:  MOV     W4,21A
....................       fprintf(RS232,"Number of Iterations: %u\n\r",md_pos_iter); 
02DEA:  MOV     #0,W1
02DEC:  MOV     W1,W0
02DEE:  CALL    A24
02DF2:  INC     W1,W1
02DF4:  MOV     W1,[W15++]
02DF6:  BTSC.B  219.1
02DF8:  BRA     2DF6
02DFA:  MOV     W0,21A
02DFC:  MOV     [--W15],W1
02DFE:  MOV     #15,W0
02E00:  CPSGT   W1,W0
02E02:  BRA     2DEC
02E04:  MOV     828,W0
02E06:  MOV     #0,W4
02E08:  CALL    1688
02E0C:  BTSC.B  219.1
02E0E:  BRA     2E0C
02E10:  MOV     #A,W4
02E12:  MOV     W4,21A
02E14:  BTSC.B  219.1
02E16:  BRA     2E14
02E18:  MOV     #D,W4
02E1A:  MOV     W4,21A
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02E1C:  MOV     #0,W1
02E1E:  MOV     W1,W0
02E20:  CALL    9B4
02E24:  INC     W1,W1
02E26:  MOV     W1,[W15++]
02E28:  BTSC.B  219.1
02E2A:  BRA     2E28
02E2C:  MOV     W0,21A
02E2E:  MOV     [--W15],W1
02E30:  MOV     #E,W0
02E32:  CPSGT   W1,W0
02E34:  BRA     2E1E
02E36:  MOV     82A,W0
02E38:  MOV     #0,W4
02E3A:  CALL    2AF0
02E3E:  BTSC.B  219.1
02E40:  BRA     2E3E
02E42:  MOV     #A,W4
02E44:  MOV     W4,21A
02E46:  BTSC.B  219.1
02E48:  BRA     2E46
02E4A:  MOV     #D,W4
02E4C:  MOV     W4,21A
....................    } 
....................     
....................    fprintf(RS232,"Error: %d\n\r",(int)qei_get_count()-(int)md_target_count); 
02E4E:  CALL    20A0
02E52:  MOV     W0,W5
02E54:  MOV     81A,W4
02E56:  SUB     W5,W4,W5
02E58:  MOV     #0,W1
02E5A:  MOV     W1,W0
02E5C:  CALL    A4C
02E60:  INC     W1,W1
02E62:  MOV     W1,[W15++]
02E64:  BTSC.B  219.1
02E66:  BRA     2E64
02E68:  MOV     W0,21A
02E6A:  MOV     [--W15],W1
02E6C:  MOV     #6,W0
02E6E:  CPSGT   W1,W0
02E70:  BRA     2E5A
02E72:  MOV     W5,W0
02E74:  MOV     #0,W4
02E76:  CALL    2AF0
02E7A:  BTSC.B  219.1
02E7C:  BRA     2E7A
02E7E:  MOV     #A,W4
02E80:  MOV     W4,21A
02E82:  BTSC.B  219.1
02E84:  BRA     2E82
02E86:  MOV     #D,W4
02E88:  MOV     W4,21A
.................... } 
02E8A:  MOV     #14,W5
02E8C:  REPEAT  #4
02E8E:  MOV     [--W15],[W5--]
02E90:  MOV     [--W15],W5
02E92:  RETURN  
.................... // Homing Function 
.................... void move_home() 
.................... { 
....................    fprintf(RS232,"Homing...\n\r");    
*
022E8:  MOV     #0,W1
022EA:  MOV     W1,W0
022EC:  CALL    A64
022F0:  INC     W1,W1
022F2:  MOV     W1,[W15++]
022F4:  BTSC.B  219.1
022F6:  BRA     22F4
022F8:  MOV     W0,21A
022FA:  MOV     [--W15],W1
022FC:  MOV     #A,W0
022FE:  CPSGT   W1,W0
02300:  BRA     22EA
....................     
....................    md_run_state = HOME; 
02302:  CLR.B   801
....................    md_decel_count = 0; 
02304:  CLR     826
....................    reg_md_home = 0; 
02306:  BCLR.B  84C.1
....................    reg_md_home_return = 0; 
02308:  BCLR.B  84C.2
....................     
....................    output_high(MD_DIR); 
0230A:  BCLR.B  2D8.4
0230C:  BSET.B  2DC.4
....................    md_mt_set(mt_percent_trip); 
0230E:  PUSH    808
02310:  POP     8A8
02312:  CALL    1C9E
....................  
....................    pwm_set_period(delays[0]); 
02316:  MOV     #7D0,W4
02318:  MOV     W4,8AC
0231A:  CALL    1FF8
....................    pwm_select_mode(FREE); 
0231E:  CLR     8A8
02320:  CALL    178C
....................    pwm_enable(); 
02324:  CALL    20A6
.................... } 
02328:  RETURN  
.................... // Initializes the system for movement 
.................... void move_init() 
.................... { 
*
02E94:  MOV     W5,[W15++]
....................    md_move_range = data_get_move_range(); 
02E96:  CALL    1E12
02E9A:  MOV     W0,80E
....................    md_home_pos = data_get_home_pos(); 
02E9C:  CALL    1E62
02EA0:  MOV     W0,810
....................    md_end_pos = data_get_end_pos(); 
02EA2:  CALL    1EB2
02EA6:  MOV     W0,812
....................    md_backlash = data_get_backlash(); 
02EA8:  CALL    1F02
02EAC:  MOV     W0,82C
....................    qei_set_max_count(md_end_pos+md_end_offset); 
02EAE:  MOV     812,W0
02EB0:  ADD     814,W0
02EB2:  MOV     W0,W5
02EB4:  MOV     W5,856
02EB6:  CALL    1F52
....................    md_conv_const = data_get_conv_const(); 
02EBA:  CALL    1F96
02EBE:  MOV     W0,80C
....................     
....................    if(md_move_range==2000) 
02EC0:  MOV     80E,W4
02EC2:  MOV     #7D0,W3
02EC4:  CP      W3,W4
02EC6:  BRA     NZ,2ECC
....................       md_min_distance=120; 
02EC8:  MOV     #78,W4
02ECA:  MOV     W4,818
....................           
....................    move_home();                        // Move to home position 
02ECC:  CALL    22E8
....................     
....................    delay_ms(500); 
02ED0:  MOV     #1F4,W0
02ED2:  CALL    1674
....................        
....................    if(debug_mode_md) 
02ED6:  BTSS.B  800.3
02ED8:  BRA     2F1C
....................       fprintf(RS232,"Moving Last Position: %u mm\n\r", data_get_last_pos()); 
02EDA:  CALL    232A
02EDE:  MOV     W0,W5
02EE0:  MOV     #0,W1
02EE2:  MOV     W1,W0
02EE4:  CALL    A7C
02EE8:  INC     W1,W1
02EEA:  MOV     W1,[W15++]
02EEC:  BTSC.B  219.1
02EEE:  BRA     2EEC
02EF0:  MOV     W0,21A
02EF2:  MOV     [--W15],W1
02EF4:  MOV     #15,W0
02EF6:  CPSGT   W1,W0
02EF8:  BRA     2EE2
02EFA:  MOV     W5,W0
02EFC:  MOV     #0,W4
02EFE:  CALL    1688
02F02:  MOV     #18,W1
02F04:  MOV     W1,W0
02F06:  CALL    A7C
02F0A:  INC     W1,W1
02F0C:  MOV     W1,[W15++]
02F0E:  BTSC.B  219.1
02F10:  BRA     2F0E
02F12:  MOV     W0,21A
02F14:  MOV     [--W15],W1
02F16:  MOV     #1C,W0
02F18:  CPSGT   W1,W0
02F1A:  BRA     2F04
....................  
....................    move_pos(data_get_last_pos()); 
02F1C:  CALL    232A
02F20:  MOV     W0,W5
02F22:  MOV     W5,894
02F24:  CALL    2BEA
.................... } 
02F28:  MOV     [--W15],W5
02F2A:  RETURN  
....................  
.................... //Gets byte via parallel port 
.................... unsigned int pp_get_byte() 
.................... { 
*
041A8:  MOV     W5,[W15++]
041AA:  CLR     854
041AC:  CLR     856
041AE:  CLR     858
041B0:  CLR     85A
041B2:  CLR     85C
041B4:  CLR     85E
041B6:  CLR     860
041B8:  CLR     862
041BA:  CLR     864
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................     
....................    D7=(!input(PP_D7))*1; 
041BC:  BSET.B  2D2.3
041BE:  CLR     856
041C0:  BTSS.B  2D4.3
041C2:  INC     0856
....................    D6=(!input(PP_D6))*1; 
041C4:  BSET.B  2D2.2
041C6:  CLR     858
041C8:  BTSS.B  2D4.2
041CA:  INC     0858
....................    D5=(!input(PP_D5))*1; 
041CC:  BSET.B  2D2.1
041CE:  CLR     85A
041D0:  BTSS.B  2D4.1
041D2:  INC     085A
....................    D4=(!input(PP_D4))*1; 
041D4:  BSET.B  2CD.6
041D6:  CLR     85C
041D8:  BTSS.B  2CF.6
041DA:  INC     085C
....................    D3=(!input(PP_D3))*1; 
041DC:  BSET.B  2CD.5
041DE:  CLR     85E
041E0:  BTSS.B  2CF.5
041E2:  INC     085E
....................    D2=(!input(PP_D2))*1; 
041E4:  BSET.B  2D2.0
041E6:  CLR     860
041E8:  BTSS.B  2D4.0
041EA:  INC     0860
....................    D1=(!input(PP_D1))*1; 
041EC:  BSET.B  2D3.1
041EE:  CLR     862
041F0:  BTSS.B  2D5.1
041F2:  INC     0862
....................    D0=(!input(PP_D0))*1; 
041F4:  BSET.B  2D3.0
041F6:  CLR     864
041F8:  BTSS.B  2D5.0
041FA:  INC     0864
....................     
....................     
....................     
....................    data=(D7<<7)+(D6<<6)+(D5<<5)+(D4<<4)+(D3<<3)+(D2<<2)+(D1<<1)+D0; 
041FC:  MOV     856,W5
041FE:  SL      W5,#7,W5
04200:  MOV     858,W0
04202:  SL      W0,#6,W0
04204:  ADD     W0,W5,W5
04206:  MOV     85A,W0
04208:  SL      W0,#5,W0
0420A:  ADD     W0,W5,W5
0420C:  MOV     85C,W0
0420E:  SL      W0,#4,W0
04210:  ADD     W0,W5,W5
04212:  MOV     85E,W0
04214:  SL      W0,#3,W0
04216:  ADD     W0,W5,W5
04218:  MOV     860,W0
0421A:  SL      W0,#2,W0
0421C:  ADD     W0,W5,W5
0421E:  MOV     862,W0
04220:  SL      W0,#1,W0
04222:  ADD     W0,W5,W5
04224:  MOV     W5,W0
04226:  ADD     864,W0
04228:  MOV     W0,854
....................  
....................    return data; 
0422A:  PUSH    854
0422C:  POP     0
.................... } 
0422E:  MOV     [--W15],W5
04230:  RETURN  
.................... //Gets BCD byte via parallel port 
.................... unsigned int pp_get_BCD_byte() 
.................... { 
*
042C6:  MOV     W5,[W15++]
042C8:  CLR     85C
042CA:  CLR     85E
042CC:  CLR     860
042CE:  CLR     862
042D0:  CLR     864
042D2:  CLR     866
042D4:  CLR     868
042D6:  CLR     86A
042D8:  CLR     86C
042DA:  CLR     86E
042DC:  CLR     870
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    D7=(!input(PP_D7))*1; 
042DE:  BSET.B  2D2.3
042E0:  CLR     85E
042E2:  BTSS.B  2D4.3
042E4:  INC     085E
....................    D6=(!input(PP_D6))*1; 
042E6:  BSET.B  2D2.2
042E8:  CLR     860
042EA:  BTSS.B  2D4.2
042EC:  INC     0860
....................    D5=(!input(PP_D5))*1; 
042EE:  BSET.B  2D2.1
042F0:  CLR     862
042F2:  BTSS.B  2D4.1
042F4:  INC     0862
....................    D4=(!input(PP_D4))*1; 
042F6:  BSET.B  2CD.6
042F8:  CLR     864
042FA:  BTSS.B  2CF.6
042FC:  INC     0864
....................    D3=(!input(PP_D3))*1; 
042FE:  BSET.B  2CD.5
04300:  CLR     866
04302:  BTSS.B  2CF.5
04304:  INC     0866
....................    D2=(!input(PP_D2))*1; 
04306:  BSET.B  2D2.0
04308:  CLR     868
0430A:  BTSS.B  2D4.0
0430C:  INC     0868
....................    D1=(!input(PP_D1))*1; 
0430E:  BSET.B  2D3.1
04310:  CLR     86A
04312:  BTSS.B  2D5.1
04314:  INC     086A
....................    D0=(!input(PP_D0))*1; 
04316:  BSET.B  2D3.0
04318:  CLR     86C
0431A:  BTSS.B  2D5.0
0431C:  INC     086C
....................     
....................    byte0=8*D7+4*D6+2*D5+D4; 
0431E:  MOV     85E,W5
04320:  SL      W5,#3,W5
04322:  MOV     860,W0
04324:  SL      W0,#2,W0
04326:  ADD     W0,W5,W5
04328:  MOV     862,W0
0432A:  SL      W0,#1,W0
0432C:  ADD     W0,W5,W5
0432E:  MOV     W5,W0
04330:  ADD     864,W0
04332:  MOV     W0,86E
....................    byte1=8*D3+4*D2+2*D1+D0; 
04334:  MOV     866,W5
04336:  SL      W5,#3,W5
04338:  MOV     868,W0
0433A:  SL      W0,#2,W0
0433C:  ADD     W0,W5,W5
0433E:  MOV     86A,W0
04340:  SL      W0,#1,W0
04342:  ADD     W0,W5,W5
04344:  MOV     W5,W0
04346:  ADD     86C,W0
04348:  MOV     W0,870
....................    data=byte0*10+byte1; 
0434A:  MOV     86E,W4
0434C:  MUL.UU  W4,#A,W0
0434E:  MOV     W0,W5
04350:  MOV     W5,W0
04352:  ADD     870,W0
04354:  MOV     W0,85C
....................     
....................    return data; 
04356:  PUSH    85C
04358:  POP     0
.................... } 
0435A:  MOV     [--W15],W5
0435C:  RETURN  
.................... // Returns binary coded decimal byte of the given input 
.................... unsigned int pp_get_BCD_byte(unsigned int input) 
.................... { 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    byte0=8*bit_test(input,7)+4*bit_test(input,6)+2*bit_test(input,5)+bit_test(input,4); 
....................    byte1=8*bit_test(input,3)+4*bit_test(input,2)+2*bit_test(input,1)+bit_test(input,0); 
....................  
....................    return byte0*10+byte1; 
.................... } 
.................... // Pauses parallel port until strobe signal (returns 0) or communication time out (returns 1) 
.................... unsigned int1 pp_comm_pause() 
.................... {  
*
04232:  MOV     W5,[W15++]
....................    while(true) 
....................    { 
....................       if(reg_pp_strobe) 
04234:  BTSS.B  84C.0
04236:  BRA     42BA
....................       { 
....................          reg_pp_strobe = 0; 
04238:  BCLR.B  84C.0
....................           
....................          if(debug_mode_pp) 
0423A:  BTSS.B  800.1
0423C:  BRA     4258
....................             fprintf(RS232,"Strobe received\n\r"); 
0423E:  MOV     #0,W1
04240:  MOV     W1,W0
04242:  CALL    AA6
04246:  INC     W1,W1
04248:  MOV     W1,[W15++]
0424A:  BTSC.B  219.1
0424C:  BRA     424A
0424E:  MOV     W0,21A
04250:  MOV     [--W15],W1
04252:  MOV     #10,W0
04254:  CPSGT   W1,W0
04256:  BRA     4240
....................  
....................          unsigned int i; 
....................          for(i=0; i<pp_str_check; i++) 
04258:  CLR     85A
0425A:  MOV     85A,W0
0425C:  MOV     844,W4
0425E:  CP      W4,W0
04260:  BRA     LEU,4298
....................          { 
....................             delay_ms(pp_str_delay); 
04262:  MOV     846,W0
04264:  CALL    1674
....................             if(input(PP_STR) == 1) 
04268:  BSET.B  2D3.2
0426A:  BTSS.B  2D5.2
0426C:  BRA     4292
....................             { 
....................                if(debug_mode_pp) 
0426E:  BTSS.B  800.1
04270:  BRA     428C
....................                   fprintf(RS232,"Strobe signal rejected\n\r"); 
04272:  MOV     #0,W1
04274:  MOV     W1,W0
04276:  CALL    AC4
0427A:  INC     W1,W1
0427C:  MOV     W1,[W15++]
0427E:  BTSC.B  219.1
04280:  BRA     427E
04282:  MOV     W0,21A
04284:  MOV     [--W15],W1
04286:  MOV     #17,W0
04288:  CPSGT   W1,W0
0428A:  BRA     4274
....................                return 1; 
0428C:  MOV.B   #1,W0L
0428E:  MOV.B   W0L,0
04290:  BRA     42C2
....................             } 
....................          } 
04292:  INC     085A
04294:  GOTO    425A
....................           
....................          if(debug_mode_pp) 
04298:  BTSS.B  800.1
0429A:  BRA     42B6
....................             fprintf(RS232,"Strobe confirmed\n\r"); 
0429C:  MOV     #0,W1
0429E:  MOV     W1,W0
042A0:  CALL    AEA
042A4:  INC     W1,W1
042A6:  MOV     W1,[W15++]
042A8:  BTSC.B  219.1
042AA:  BRA     42A8
042AC:  MOV     W0,21A
042AE:  MOV     [--W15],W1
042B0:  MOV     #11,W0
042B2:  CPSGT   W1,W0
042B4:  BRA     429E
....................              
....................          return 0; 
042B6:  CLR.B   0
042B8:  BRA     42C2
....................       } 
....................    } 
042BA:  GOTO    4234
....................     
....................    return 1; 
042BE:  MOV.B   #1,W0L
042C0:  MOV.B   W0L,0
.................... } 
042C2:  MOV     [--W15],W5
042C4:  RETURN  
.................... // Sets position given via parallel port 
.................... void pp_set_pos() 
.................... { 
*
0435E:  MOV     W5,[W15++]
....................    delay_ms(pp_rdy_delay); 
04360:  MOV     84A,W0
04362:  CALL    1674
....................    output_high(PP_RDY); 
04366:  BCLR.B  2D2.5
04368:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
0436A:  CALL    4232
0436E:  CP0.B   W0L
04370:  BRA     Z,4374
....................       return; 
04372:  BRA     445E
....................  
....................    output_low(PP_ACK); 
04374:  BCLR.B  2D2.4
04376:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04378:  BCLR.B  2D2.5
0437A:  BCLR.B  2D6.5
....................    unsigned int index=pp_get_BCD_byte(); 
0437C:  CALL    42C6
04380:  MOV     W0,854
....................    delay_ms(pp_ack_delay); 
04382:  MOV     848,W0
04384:  CALL    1674
....................    output_high(PP_ACK); 
04388:  BCLR.B  2D2.4
0438A:  BSET.B  2D6.4
....................    delay_ms(pp_rdy_delay); 
0438C:  MOV     84A,W0
0438E:  CALL    1674
....................    output_high(PP_RDY); 
04392:  BCLR.B  2D2.5
04394:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
04396:  CALL    4232
0439A:  CP0.B   W0L
0439C:  BRA     Z,43A0
....................       return; 
0439E:  BRA     445E
....................     
....................    output_low(PP_ACK); 
043A0:  BCLR.B  2D2.4
043A2:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
043A4:  BCLR.B  2D2.5
043A6:  BCLR.B  2D6.5
....................    unsigned int pos0=pp_get_BCD_byte(); 
043A8:  CALL    42C6
043AC:  MOV     W0,856
....................    delay_ms(pp_ack_delay); 
043AE:  MOV     848,W0
043B0:  CALL    1674
....................    output_high(PP_ACK); 
043B4:  BCLR.B  2D2.4
043B6:  BSET.B  2D6.4
....................    delay_ms(pp_rdy_delay); 
043B8:  MOV     84A,W0
043BA:  CALL    1674
....................    output_high(PP_RDY); 
043BE:  BCLR.B  2D2.5
043C0:  BSET.B  2D6.5
....................     
....................    if(pp_comm_pause()) 
043C2:  CALL    4232
043C6:  CP0.B   W0L
043C8:  BRA     Z,43CC
....................       return; 
043CA:  BRA     445E
....................  
....................    output_low(PP_ACK); 
043CC:  BCLR.B  2D2.4
043CE:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
043D0:  BCLR.B  2D2.5
043D2:  BCLR.B  2D6.5
....................    unsigned int pos1=pp_get_BCD_byte(); 
043D4:  CALL    42C6
043D8:  MOV     W0,858
....................    delay_ms(pp_ack_delay); 
043DA:  MOV     848,W0
043DC:  CALL    1674
....................    output_high(PP_ACK); 
043E0:  BCLR.B  2D2.4
043E2:  BSET.B  2D6.4
....................  
....................    data_set_pos(index, pos0*100+pos1); 
043E4:  MOV     856,W4
043E6:  MOV     #64,W3
043E8:  MUL.UU  W4,W3,W0
043EA:  MOV     W0,W5
043EC:  MOV     W5,W0
043EE:  ADD     858,W0
043F0:  MOV     W0,W5
043F2:  MOV.B   854,W0L
043F4:  MOV.B   W0L,892
043F6:  MOV     W5,894
043F8:  CALL    362C
....................     
....................    fprintf(RS232,"Position set -> index: %u position: %u\n\r", index, pos0*100+pos1); 
043FC:  MOV     856,W4
043FE:  MOV     #64,W3
04400:  MUL.UU  W4,W3,W0
04402:  MOV     W0,W5
04404:  MOV     W5,W0
04406:  ADD     858,W0
04408:  MOV     W0,W5
0440A:  MOV     #0,W1
0440C:  MOV     W1,W0
0440E:  CALL    B0A
04412:  INC     W1,W1
04414:  MOV     W1,[W15++]
04416:  BTSC.B  219.1
04418:  BRA     4416
0441A:  MOV     W0,21A
0441C:  MOV     [--W15],W1
0441E:  MOV     #16,W0
04420:  CPSGT   W1,W0
04422:  BRA     440C
04424:  MOV     854,W0
04426:  MOV     #0,W4
04428:  CALL    1688
0442C:  MOV     #19,W1
0442E:  MOV     W1,W0
04430:  CALL    B0A
04434:  INC     W1,W1
04436:  MOV     W1,[W15++]
04438:  BTSC.B  219.1
0443A:  BRA     4438
0443C:  MOV     W0,21A
0443E:  MOV     [--W15],W1
04440:  MOV     #23,W0
04442:  CPSGT   W1,W0
04444:  BRA     442E
04446:  MOV     W5,W0
04448:  MOV     #0,W4
0444A:  CALL    1688
0444E:  BTSC.B  219.1
04450:  BRA     444E
04452:  MOV     #A,W4
04454:  MOV     W4,21A
04456:  BTSC.B  219.1
04458:  BRA     4456
0445A:  MOV     #D,W4
0445C:  MOV     W4,21A
.................... } 
0445E:  MOV     [--W15],W5
04460:  RETURN  
.................... // Moves to position given via parallel port 
.................... void pp_move_pos(unsigned int input) 
.................... { 
04462:  CALL    42C6
04466:  MOV     W0,856
....................    unsigned int index=pp_get_BCD_byte();; 
....................    unsigned int position=data_get_pos(index); 
04468:  MOV.B   856,W0L
0446A:  MOV.B   W0L,896
0446C:  CALL    3546
04470:  MOV     W0,858
....................     
....................    fprintf(RS232,"Move Position -> index: %u position: %u\n\r", index, position); 
04472:  MOV     #0,W1
04474:  MOV     W1,W0
04476:  CALL    B40
0447A:  INC     W1,W1
0447C:  MOV     W1,[W15++]
0447E:  BTSC.B  219.1
04480:  BRA     447E
04482:  MOV     W0,21A
04484:  MOV     [--W15],W1
04486:  MOV     #17,W0
04488:  CPSGT   W1,W0
0448A:  BRA     4474
0448C:  MOV     856,W0
0448E:  MOV     #0,W4
04490:  CALL    1688
04494:  MOV     #1A,W1
04496:  MOV     W1,W0
04498:  CALL    B40
0449C:  INC     W1,W1
0449E:  MOV     W1,[W15++]
044A0:  BTSC.B  219.1
044A2:  BRA     44A0
044A4:  MOV     W0,21A
044A6:  MOV     [--W15],W1
044A8:  MOV     #24,W0
044AA:  CPSGT   W1,W0
044AC:  BRA     4496
044AE:  MOV     858,W0
044B0:  MOV     #0,W4
044B2:  CALL    1688
044B6:  BTSC.B  219.1
044B8:  BRA     44B6
044BA:  MOV     #A,W4
044BC:  MOV     W4,21A
044BE:  BTSC.B  219.1
044C0:  BRA     44BE
044C2:  MOV     #D,W4
044C4:  MOV     W4,21A
....................        
....................    move_pos(position); 
044C6:  PUSH    858
044C8:  POP     894
044CA:  CALL    2BEA
.................... } 
044CE:  RETURN  
.................... // Gets command via parallel port when system is idle 
.................... void pp_get_command() 
.................... { 
....................    output_low(PP_ACK); 
044D0:  BCLR.B  2D2.4
044D2:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
044D4:  BCLR.B  2D2.5
044D6:  BCLR.B  2D6.5
....................    unsigned int input=pp_get_byte(); 
044D8:  CALL    41A8
044DC:  MOV     W0,852
....................    delay_ms(pp_ack_delay); 
044DE:  MOV     848,W0
044E0:  CALL    1674
....................    output_high(PP_ACK); 
044E4:  BCLR.B  2D2.4
044E6:  BSET.B  2D6.4
....................  
....................    switch (input) 
....................    { 
044E8:  MOV     852,W0
044EA:  XOR     #FE,W0
044EC:  BRA     Z,4500
044EE:  XOR     #3,W0
044F0:  BRA     Z,4520
044F2:  XOR     #1,W0
044F4:  BRA     Z,4542
044F6:  XOR     #7,W0
044F8:  BRA     Z,456C
044FA:  XOR     #4,W0
044FC:  BRA     Z,4596
044FE:  BRA     45B8
....................       case 0x00FE:   fprintf(RS232,"Emergency Stop Command\n\r"); 
04500:  MOV     #0,W1
04502:  MOV     W1,W0
04504:  CALL    B78
04508:  INC     W1,W1
0450A:  MOV     W1,[W15++]
0450C:  BTSC.B  219.1
0450E:  BRA     450C
04510:  MOV     W0,21A
04512:  MOV     [--W15],W1
04514:  MOV     #17,W0
04516:  CPSGT   W1,W0
04518:  BRA     4502
....................                       
....................                      reg_pp_stop=1; 
0451A:  BSET.B  800.7
....................                      break; 
0451C:  GOTO    45C4
....................       case 0x00FD:   fprintf(RS232,"Homing Command\n\r"); 
04520:  MOV     #0,W1
04522:  MOV     W1,W0
04524:  CALL    B9E
04528:  INC     W1,W1
0452A:  MOV     W1,[W15++]
0452C:  BTSC.B  219.1
0452E:  BRA     452C
04530:  MOV     W0,21A
04532:  MOV     [--W15],W1
04534:  MOV     #F,W0
04536:  CPSGT   W1,W0
04538:  BRA     4522
....................        
....................                      move_home();    
0453A:  CALL    22E8
....................                      break; 
0453E:  GOTO    45C4
....................       case 0x00FC:   fprintf(RS232,"Laser Off Command\n\r"); 
04542:  MOV     #0,W1
04544:  MOV     W1,W0
04546:  CALL    BBC
0454A:  INC     W1,W1
0454C:  MOV     W1,[W15++]
0454E:  BTSC.B  219.1
04550:  BRA     454E
04552:  MOV     W0,21A
04554:  MOV     [--W15],W1
04556:  MOV     #12,W0
04558:  CPSGT   W1,W0
0455A:  BRA     4544
....................                          
....................                      output_low(LAS_1); 
0455C:  BCLR.B  2C6.0
0455E:  BCLR.B  2CA.0
....................                      output_low(LAS_2); 
04560:  BCLR.B  2C6.1
04562:  BCLR.B  2CA.1
....................                      output_low(LAS_3); 
04564:  BCLR.B  2D2.6
04566:  BCLR.B  2D6.6
....................                      break; 
04568:  GOTO    45C4
....................       case 0x00FB:   fprintf(RS232,"Laser On Command\n\r"); 
0456C:  MOV     #0,W1
0456E:  MOV     W1,W0
04570:  CALL    BDC
04574:  INC     W1,W1
04576:  MOV     W1,[W15++]
04578:  BTSC.B  219.1
0457A:  BRA     4578
0457C:  MOV     W0,21A
0457E:  MOV     [--W15],W1
04580:  MOV     #11,W0
04582:  CPSGT   W1,W0
04584:  BRA     456E
....................                       
....................                      output_high(LAS_1); 
04586:  BCLR.B  2C6.0
04588:  BSET.B  2CA.0
....................                      output_high(LAS_2); 
0458A:  BCLR.B  2C6.1
0458C:  BSET.B  2CA.1
....................                      output_high(LAS_3); 
0458E:  BCLR.B  2D2.6
04590:  BSET.B  2D6.6
....................                      break;  
04592:  GOTO    45C4
....................       case 0x00FF:   fprintf(RS232,"Set Position Command\n\r"); 
04596:  MOV     #0,W1
04598:  MOV     W1,W0
0459A:  CALL    BFC
0459E:  INC     W1,W1
045A0:  MOV     W1,[W15++]
045A2:  BTSC.B  219.1
045A4:  BRA     45A2
045A6:  MOV     W0,21A
045A8:  MOV     [--W15],W1
045AA:  MOV     #15,W0
045AC:  CPSGT   W1,W0
045AE:  BRA     4598
....................                       
....................                      pp_set_pos(); 
045B0:  CALL    435E
....................                      break; 
045B4:  GOTO    45C4
....................       default:       pp_move_pos(input);  
045B8:  PUSH    852
045BA:  POP     854
045BC:  CALL    4462
....................                      break; 
045C0:  GOTO    45C4
....................    } 
....................     
....................    delay_ms(pp_rdy_delay); 
045C4:  MOV     84A,W0
045C6:  CALL    1674
....................    output_high(PP_RDY); 
045CA:  BCLR.B  2D2.5
045CC:  BSET.B  2D6.5
.................... } 
045CE:  RETURN  
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
.................... { 
*
03648:  MOV     W5,[W15++]
0364A:  MOV     W6,[W15++]
....................    char input; 
....................     
....................    input=fgetc(RS232); 
0364C:  BTSS.B  218.0
0364E:  BRA     364C
03650:  MOV     21C,W0
03652:  MOV.B   W0L,852
....................    switch (input){ 
03654:  MOV.B   852,W0L
03656:  CLR.B   1
03658:  XOR     #63,W0
0365A:  BRA     Z,36AA
0365C:  XOR     #10,W0
0365E:  BRA     Z,389A
03660:  XOR     #1,W0
03662:  BRA     Z,38D4
03664:  XOR     #1A,W0
03666:  BRA     Z,390E
03668:  XOR     #D,W0
0366A:  BRA     Z,3948
0366C:  XOR     #13,W0
0366E:  BRA     Z,3982
03670:  XOR     #14,W0
03672:  BRA     Z,39BC
03674:  XOR     #16,W0
03676:  BRA     Z,39F6
03678:  XOR     #1D,W0
0367A:  BRA     Z,3A30
0367C:  XOR     #4,W0
0367E:  BRA     Z,3A38
03680:  XOR     #15,W0
03682:  BRA     Z,3A5A
03684:  XOR     #9,W0
03686:  BRA     Z,3AF0
03688:  XOR     #1E,W0
0368A:  BRA     Z,3C46
0368C:  XOR     #3,W0
0368E:  BRA     Z,3D3A
03690:  XOR     #8,W0
03692:  BRA     Z,3E28
03694:  XOR     #13,W0
03696:  BRA     Z,403E
03698:  XOR     #D,W0
0369A:  BRA     Z,407A
0369C:  XOR     #1C,W0
0369E:  BRA     Z,4112
036A0:  XOR     #1,W0
036A2:  BRA     Z,419A
036A4:  XOR     #1E,W0
036A6:  BRA     Z,419E
036A8:  BRA     41A2
....................       case 'c':   fprintf(RS232,"\n\rCOMMAND LIST\n\r"); 
036AA:  MOV     #0,W1
036AC:  MOV     W1,W0
036AE:  CALL    C20
036B2:  INC     W1,W1
036B4:  MOV     W1,[W15++]
036B6:  BTSC.B  219.1
036B8:  BRA     36B6
036BA:  MOV     W0,21A
036BC:  MOV     [--W15],W1
036BE:  MOV     #F,W0
036C0:  CPSGT   W1,W0
036C2:  BRA     36AC
....................                   fprintf(RS232,"\n\rSet Serial Number\t(s)"); 
036C4:  MOV     #0,W1
036C6:  MOV     W1,W0
036C8:  CALL    C3E
036CC:  INC     W1,W1
036CE:  MOV     W1,[W15++]
036D0:  BTSC.B  219.1
036D2:  BRA     36D0
036D4:  MOV     W0,21A
036D6:  MOV     [--W15],W1
036D8:  MOV     #16,W0
036DA:  CPSGT   W1,W0
036DC:  BRA     36C6
....................                   fprintf(RS232,"\n\rSet Move Range \t\t(r)"); 
036DE:  MOV     #0,W1
036E0:  MOV     W1,W0
036E2:  CALL    C62
036E6:  INC     W1,W1
036E8:  MOV     W1,[W15++]
036EA:  BTSC.B  219.1
036EC:  BRA     36EA
036EE:  MOV     W0,21A
036F0:  MOV     [--W15],W1
036F2:  MOV     #15,W0
036F4:  CPSGT   W1,W0
036F6:  BRA     36E0
....................                   fprintf(RS232,"\n\rSet Homing Distance \t(h)"); 
036F8:  MOV     #0,W1
036FA:  MOV     W1,W0
036FC:  CALL    C86
03700:  INC     W1,W1
03702:  MOV     W1,[W15++]
03704:  BTSC.B  219.1
03706:  BRA     3704
03708:  MOV     W0,21A
0370A:  MOV     [--W15],W1
0370C:  MOV     #19,W0
0370E:  CPSGT   W1,W0
03710:  BRA     36FA
....................                   fprintf(RS232,"\n\rSet End Distance \t(e)"); 
03712:  MOV     #0,W1
03714:  MOV     W1,W0
03716:  CALL    CAE
0371A:  INC     W1,W1
0371C:  MOV     W1,[W15++]
0371E:  BTSC.B  219.1
03720:  BRA     371E
03722:  MOV     W0,21A
03724:  MOV     [--W15],W1
03726:  MOV     #16,W0
03728:  CPSGT   W1,W0
0372A:  BRA     3714
....................                   fprintf(RS232,"\n\rSet Conversion Constant\t(v)"); 
0372C:  MOV     #0,W1
0372E:  MOV     W1,W0
03730:  CALL    CD2
03734:  INC     W1,W1
03736:  MOV     W1,[W15++]
03738:  BTSC.B  219.1
0373A:  BRA     3738
0373C:  MOV     W0,21A
0373E:  MOV     [--W15],W1
03740:  MOV     #1C,W0
03742:  CPSGT   W1,W0
03744:  BRA     372E
....................                   fprintf(RS232,"\n\rSet Backlash \t\t(b)"); 
03746:  MOV     #0,W1
03748:  MOV     W1,W0
0374A:  CALL    CFC
0374E:  INC     W1,W1
03750:  MOV     W1,[W15++]
03752:  BTSC.B  219.1
03754:  BRA     3752
03756:  MOV     W0,21A
03758:  MOV     [--W15],W1
0375A:  MOV     #13,W0
0375C:  CPSGT   W1,W0
0375E:  BRA     3748
....................                   fprintf(RS232,"\n\rSet Communication Type \t(t)"); 
03760:  MOV     #0,W1
03762:  MOV     W1,W0
03764:  CALL    D1E
03768:  INC     W1,W1
0376A:  MOV     W1,[W15++]
0376C:  BTSC.B  219.1
0376E:  BRA     376C
03770:  MOV     W0,21A
03772:  MOV     [--W15],W1
03774:  MOV     #1C,W0
03776:  CPSGT   W1,W0
03778:  BRA     3762
....................                   fprintf(RS232,"\n\rGet System Data \t(i)"); 
0377A:  MOV     #0,W1
0377C:  MOV     W1,W0
0377E:  CALL    D48
03782:  INC     W1,W1
03784:  MOV     W1,[W15++]
03786:  BTSC.B  219.1
03788:  BRA     3786
0378A:  MOV     W0,21A
0378C:  MOV     [--W15],W1
0378E:  MOV     #15,W0
03790:  CPSGT   W1,W0
03792:  BRA     377C
....................                   fprintf(RS232,"\n\rGet Position List \t(m)"); 
03794:  MOV     #0,W1
03796:  MOV     W1,W0
03798:  CALL    D6C
0379C:  INC     W1,W1
0379E:  MOV     W1,[W15++]
037A0:  BTSC.B  219.1
037A2:  BRA     37A0
037A4:  MOV     W0,21A
037A6:  MOV     [--W15],W1
037A8:  MOV     #17,W0
037AA:  CPSGT   W1,W0
037AC:  BRA     3796
....................                   fprintf(RS232,"\n\rMove To Position \t(x)"); 
037AE:  MOV     #0,W1
037B0:  MOV     W1,W0
037B2:  CALL    D92
037B6:  INC     W1,W1
037B8:  MOV     W1,[W15++]
037BA:  BTSC.B  219.1
037BC:  BRA     37BA
037BE:  MOV     W0,21A
037C0:  MOV     [--W15],W1
037C2:  MOV     #16,W0
037C4:  CPSGT   W1,W0
037C6:  BRA     37B0
....................                   fprintf(RS232,"\n\rSet Table Data \t\t(q)"); 
037C8:  MOV     #0,W1
037CA:  MOV     W1,W0
037CC:  CALL    DB6
037D0:  INC     W1,W1
037D2:  MOV     W1,[W15++]
037D4:  BTSC.B  219.1
037D6:  BRA     37D4
037D8:  MOV     W0,21A
037DA:  MOV     [--W15],W1
037DC:  MOV     #15,W0
037DE:  CPSGT   W1,W0
037E0:  BRA     37CA
....................                   fprintf(RS232,"\n\rTest Run (low res) \t(o)"); 
037E2:  MOV     #0,W1
037E4:  MOV     W1,W0
037E6:  CALL    DDA
037EA:  INC     W1,W1
037EC:  MOV     W1,[W15++]
037EE:  BTSC.B  219.1
037F0:  BRA     37EE
037F2:  MOV     W0,21A
037F4:  MOV     [--W15],W1
037F6:  MOV     #18,W0
037F8:  CPSGT   W1,W0
037FA:  BRA     37E4
....................                   fprintf(RS232,"\n\rTest Run (high res) \t(l)"); 
037FC:  MOV     #0,W1
037FE:  MOV     W1,W0
03800:  CALL    E00
03804:  INC     W1,W1
03806:  MOV     W1,[W15++]
03808:  BTSC.B  219.1
0380A:  BRA     3808
0380C:  MOV     W0,21A
0380E:  MOV     [--W15],W1
03810:  MOV     #19,W0
03812:  CPSGT   W1,W0
03814:  BRA     37FE
....................                   fprintf(RS232,"\n\rSet Debug State \t(d)"); 
03816:  MOV     #0,W1
03818:  MOV     W1,W0
0381A:  CALL    E28
0381E:  INC     W1,W1
03820:  MOV     W1,[W15++]
03822:  BTSC.B  219.1
03824:  BRA     3822
03826:  MOV     W0,21A
03828:  MOV     [--W15],W1
0382A:  MOV     #15,W0
0382C:  CPSGT   W1,W0
0382E:  BRA     3818
....................                   fprintf(RS232,"\n\rGet Encoder Count \t(w)"); 
03830:  MOV     #0,W1
03832:  MOV     W1,W0
03834:  CALL    E4C
03838:  INC     W1,W1
0383A:  MOV     W1,[W15++]
0383C:  BTSC.B  219.1
0383E:  BRA     383C
03840:  MOV     W0,21A
03842:  MOV     [--W15],W1
03844:  MOV     #17,W0
03846:  CPSGT   W1,W0
03848:  BRA     3832
....................                   fprintf(RS232,"\n\rStart Memory Test \t(z)"); 
0384A:  MOV     #0,W1
0384C:  MOV     W1,W0
0384E:  CALL    E72
03852:  INC     W1,W1
03854:  MOV     W1,[W15++]
03856:  BTSC.B  219.1
03858:  BRA     3856
0385A:  MOV     W0,21A
0385C:  MOV     [--W15],W1
0385E:  MOV     #17,W0
03860:  CPSGT   W1,W0
03862:  BRA     384C
....................                   fprintf(RS232,"\n\rClear Memory \t\t(f)"); 
03864:  MOV     #0,W1
03866:  MOV     W1,W0
03868:  CALL    E98
0386C:  INC     W1,W1
0386E:  MOV     W1,[W15++]
03870:  BTSC.B  219.1
03872:  BRA     3870
03874:  MOV     W0,21A
03876:  MOV     [--W15],W1
03878:  MOV     #13,W0
0387A:  CPSGT   W1,W0
0387C:  BRA     3866
....................                   fprintf(RS232,"\n\n\r"); 
0387E:  BTSC.B  219.1
03880:  BRA     387E
03882:  MOV     #A,W4
03884:  MOV     W4,21A
03886:  BTSC.B  219.1
03888:  BRA     3886
0388A:  MOV     #A,W4
0388C:  MOV     W4,21A
0388E:  BTSC.B  219.1
03890:  BRA     388E
03892:  MOV     #D,W4
03894:  MOV     W4,21A
....................                   break; 
03896:  GOTO    41A2
....................       case 's':   fprintf(RS232,"\n\rSet Serial Number (13 Characters): "); 
0389A:  MOV     #0,W1
0389C:  MOV     W1,W0
0389E:  CALL    EBA
038A2:  INC     W1,W1
038A4:  MOV     W1,[W15++]
038A6:  BTSC.B  219.1
038A8:  BRA     38A6
038AA:  MOV     W0,21A
038AC:  MOV     [--W15],W1
038AE:  MOV     #24,W0
038B0:  CPSGT   W1,W0
038B2:  BRA     389C
....................                   data_set_serial_no(); 
038B4:  CALL    2FA8
....................                   fprintf(RS232,"\n\n\r"); 
038B8:  BTSC.B  219.1
038BA:  BRA     38B8
038BC:  MOV     #A,W4
038BE:  MOV     W4,21A
038C0:  BTSC.B  219.1
038C2:  BRA     38C0
038C4:  MOV     #A,W4
038C6:  MOV     W4,21A
038C8:  BTSC.B  219.1
038CA:  BRA     38C8
038CC:  MOV     #D,W4
038CE:  MOV     W4,21A
....................                   break; 
038D0:  GOTO    41A2
....................       case 'r':   fprintf(RS232,"\n\rSet Move Range in mm (xxxx): "); 
038D4:  MOV     #0,W1
038D6:  MOV     W1,W0
038D8:  CALL    EEC
038DC:  INC     W1,W1
038DE:  MOV     W1,[W15++]
038E0:  BTSC.B  219.1
038E2:  BRA     38E0
038E4:  MOV     W0,21A
038E6:  MOV     [--W15],W1
038E8:  MOV     #1E,W0
038EA:  CPSGT   W1,W0
038EC:  BRA     38D6
....................                   data_set_move_range(); 
038EE:  CALL    300C
....................                   fprintf(RS232,"\n\n\r"); 
038F2:  BTSC.B  219.1
038F4:  BRA     38F2
038F6:  MOV     #A,W4
038F8:  MOV     W4,21A
038FA:  BTSC.B  219.1
038FC:  BRA     38FA
038FE:  MOV     #A,W4
03900:  MOV     W4,21A
03902:  BTSC.B  219.1
03904:  BRA     3902
03906:  MOV     #D,W4
03908:  MOV     W4,21A
....................                   break; 
0390A:  GOTO    41A2
....................       case 'h':   fprintf(RS232,"\n\rSet Homing Distance in counts (xxxx): "); 
0390E:  MOV     #0,W1
03910:  MOV     W1,W0
03912:  CALL    F18
03916:  INC     W1,W1
03918:  MOV     W1,[W15++]
0391A:  BTSC.B  219.1
0391C:  BRA     391A
0391E:  MOV     W0,21A
03920:  MOV     [--W15],W1
03922:  MOV     #27,W0
03924:  CPSGT   W1,W0
03926:  BRA     3910
....................                   data_set_home_pos(); 
03928:  CALL    30E4
....................                   fprintf(RS232,"\n\n\r"); 
0392C:  BTSC.B  219.1
0392E:  BRA     392C
03930:  MOV     #A,W4
03932:  MOV     W4,21A
03934:  BTSC.B  219.1
03936:  BRA     3934
03938:  MOV     #A,W4
0393A:  MOV     W4,21A
0393C:  BTSC.B  219.1
0393E:  BRA     393C
03940:  MOV     #D,W4
03942:  MOV     W4,21A
....................                   break; 
03944:  GOTO    41A2
....................       case 'e':   fprintf(RS232,"\n\rSet End Distance in counts (xxxxx): "); 
03948:  MOV     #0,W1
0394A:  MOV     W1,W0
0394C:  CALL    F4E
03950:  INC     W1,W1
03952:  MOV     W1,[W15++]
03954:  BTSC.B  219.1
03956:  BRA     3954
03958:  MOV     W0,21A
0395A:  MOV     [--W15],W1
0395C:  MOV     #25,W0
0395E:  CPSGT   W1,W0
03960:  BRA     394A
....................                   data_set_end_pos(); 
03962:  CALL    317A
....................                   fprintf(RS232,"\n\n\r"); 
03966:  BTSC.B  219.1
03968:  BRA     3966
0396A:  MOV     #A,W4
0396C:  MOV     W4,21A
0396E:  BTSC.B  219.1
03970:  BRA     396E
03972:  MOV     #A,W4
03974:  MOV     W4,21A
03976:  BTSC.B  219.1
03978:  BRA     3976
0397A:  MOV     #D,W4
0397C:  MOV     W4,21A
....................                   break; 
0397E:  GOTO    41A2
....................       case 'v':   fprintf(RS232,"\n\rSet Conversion Constant (xxxxx): "); 
03982:  MOV     #0,W1
03984:  MOV     W1,W0
03986:  CALL    F82
0398A:  INC     W1,W1
0398C:  MOV     W1,[W15++]
0398E:  BTSC.B  219.1
03990:  BRA     398E
03992:  MOV     W0,21A
03994:  MOV     [--W15],W1
03996:  MOV     #22,W0
03998:  CPSGT   W1,W0
0399A:  BRA     3984
....................                   data_set_conv_const(); 
0399C:  CALL    3224
....................                   fprintf(RS232,"\n\n\r"); 
039A0:  BTSC.B  219.1
039A2:  BRA     39A0
039A4:  MOV     #A,W4
039A6:  MOV     W4,21A
039A8:  BTSC.B  219.1
039AA:  BRA     39A8
039AC:  MOV     #A,W4
039AE:  MOV     W4,21A
039B0:  BTSC.B  219.1
039B2:  BRA     39B0
039B4:  MOV     #D,W4
039B6:  MOV     W4,21A
....................                   break; 
039B8:  GOTO    41A2
....................       case 'b':   fprintf(RS232,"\n\rSet Backlash (xx): "); 
039BC:  MOV     #0,W1
039BE:  MOV     W1,W0
039C0:  CALL    FB2
039C4:  INC     W1,W1
039C6:  MOV     W1,[W15++]
039C8:  BTSC.B  219.1
039CA:  BRA     39C8
039CC:  MOV     W0,21A
039CE:  MOV     [--W15],W1
039D0:  MOV     #14,W0
039D2:  CPSGT   W1,W0
039D4:  BRA     39BE
....................                   data_set_backlash(); 
039D6:  CALL    334E
....................                   fprintf(RS232,"\n\n\r"); 
039DA:  BTSC.B  219.1
039DC:  BRA     39DA
039DE:  MOV     #A,W4
039E0:  MOV     W4,21A
039E2:  BTSC.B  219.1
039E4:  BRA     39E2
039E6:  MOV     #A,W4
039E8:  MOV     W4,21A
039EA:  BTSC.B  219.1
039EC:  BRA     39EA
039EE:  MOV     #D,W4
039F0:  MOV     W4,21A
....................                   break; 
039F2:  GOTO    41A2
....................       case 't':   fprintf(RS232,"\n\rSet Communication Type (0: Parallel, 1: RS232"); 
039F6:  MOV     #0,W1
039F8:  MOV     W1,W0
039FA:  CALL    FD4
039FE:  INC     W1,W1
03A00:  MOV     W1,[W15++]
03A02:  BTSC.B  219.1
03A04:  BRA     3A02
03A06:  MOV     W0,21A
03A08:  MOV     [--W15],W1
03A0A:  MOV     #2E,W0
03A0C:  CPSGT   W1,W0
03A0E:  BRA     39F8
....................                   data_set_comm_type(); 
03A10:  CALL    33B2
....................                   fprintf(RS232,"\n\n\r"); 
03A14:  BTSC.B  219.1
03A16:  BRA     3A14
03A18:  MOV     #A,W4
03A1A:  MOV     W4,21A
03A1C:  BTSC.B  219.1
03A1E:  BRA     3A1C
03A20:  MOV     #A,W4
03A22:  MOV     W4,21A
03A24:  BTSC.B  219.1
03A26:  BRA     3A24
03A28:  MOV     #D,W4
03A2A:  MOV     W4,21A
....................                   break; 
03A2C:  GOTO    41A2
....................       case 'i':   data_get_sys_data(); 
03A30:  CALL    348A
....................                   break; 
03A34:  GOTO    41A2
....................       case 'm':   fprintf(RS232,"\n\rGet Position List(0<=X<=9): "); 
03A38:  MOV     #0,W1
03A3A:  MOV     W1,W0
03A3C:  CALL    1010
03A40:  INC     W1,W1
03A42:  MOV     W1,[W15++]
03A44:  BTSC.B  219.1
03A46:  BRA     3A44
03A48:  MOV     W0,21A
03A4A:  MOV     [--W15],W1
03A4C:  MOV     #1D,W0
03A4E:  CPSGT   W1,W0
03A50:  BRA     3A3A
....................                   data_get_pos_table(); 
03A52:  CALL    35C8
....................                   break; 
03A56:  GOTO    41A2
....................       case 'x':   fprintf(RS232,"\n\rMove To(0<=X<=9999): "); 
03A5A:  MOV     #0,W1
03A5C:  MOV     W1,W0
03A5E:  CALL    103C
03A62:  INC     W1,W1
03A64:  MOV     W1,[W15++]
03A66:  BTSC.B  219.1
03A68:  BRA     3A66
03A6A:  MOV     W0,21A
03A6C:  MOV     [--W15],W1
03A6E:  MOV     #16,W0
03A70:  CPSGT   W1,W0
03A72:  BRA     3A5C
....................                   unsigned int i=0; 
....................                   unsigned int input_step[4]; 
....................                   unsigned int step=0; 
03A74:  CLR     854
03A76:  CLR     85E
....................                   for(i=0;i<4;i++){ 
03A78:  CLR     854
03A7A:  MOV     854,W4
03A7C:  CP      W4,#4
03A7E:  BRA     C,3AB0
....................                      input_step[i]=(unsigned)(fgetc(RS232)-48); 
03A80:  MOV     854,W0
03A82:  SL      W0,#1,W0
03A84:  MOV     #856,W4
03A86:  ADD     W0,W4,W5
03A88:  BTSS.B  218.0
03A8A:  BRA     3A88
03A8C:  MOV     21C,W0
03A8E:  SUB.B   #30,W0L
03A90:  CLR.B   1
03A92:  MOV     W0,[W5]
....................                      fputc(input_step[i]+48,RS232); 
03A94:  MOV     854,W0
03A96:  SL      W0,#1,W0
03A98:  MOV     #856,W4
03A9A:  ADD     W0,W4,W0
03A9C:  MOV     [W0],W5
03A9E:  ADD     #30,W5
03AA0:  MOV.B   W5L,W0L
03AA2:  BTSC.B  219.1
03AA4:  BRA     3AA2
03AA6:  MOV.B   W0L,21A
03AA8:  CLR.B   21B
....................                   } 
03AAA:  INC     0854
03AAC:  GOTO    3A7A
....................                   fprintf(RS232,"\n\n\r"); 
03AB0:  BTSC.B  219.1
03AB2:  BRA     3AB0
03AB4:  MOV     #A,W4
03AB6:  MOV     W4,21A
03AB8:  BTSC.B  219.1
03ABA:  BRA     3AB8
03ABC:  MOV     #A,W4
03ABE:  MOV     W4,21A
03AC0:  BTSC.B  219.1
03AC2:  BRA     3AC0
03AC4:  MOV     #D,W4
03AC6:  MOV     W4,21A
....................                    
....................                   step=1000*input_step[0]+100*input_step[1]+10*input_step[2]+1*input_step[3]; 
03AC8:  MOV     #3E8,W4
03ACA:  MOV     856,W3
03ACC:  MUL.UU  W4,W3,W0
03ACE:  MOV     W0,W5
03AD0:  MOV     #64,W4
03AD2:  MOV     858,W3
03AD4:  MUL.UU  W4,W3,W0
03AD6:  ADD     W0,W5,W5
03AD8:  MOV     85A,W4
03ADA:  MUL.UU  W4,#A,W0
03ADC:  ADD     W0,W5,W5
03ADE:  MOV     W5,W0
03AE0:  ADD     85C,W0
03AE2:  MOV     W0,85E
....................                    
....................                   move_pos(step); 
03AE4:  PUSH    85E
03AE6:  POP     894
03AE8:  CALL    2BEA
....................                   break; 
03AEC:  GOTO    41A2
....................       case 'q':   fprintf(RS232,"\n\rEnter Table Index (xx): "); 
03AF0:  MOV     #0,W1
03AF2:  MOV     W1,W0
03AF4:  CALL    1060
03AF8:  INC     W1,W1
03AFA:  MOV     W1,[W15++]
03AFC:  BTSC.B  219.1
03AFE:  BRA     3AFC
03B00:  MOV     W0,21A
03B02:  MOV     [--W15],W1
03B04:  MOV     #19,W0
03B06:  CPSGT   W1,W0
03B08:  BRA     3AF2
....................                   unsigned int k=0; 
....................                   unsigned int input_index[2]; 
....................                   unsigned int index=0; 
03B0A:  CLR     860
03B0C:  CLR     866
....................                   for(k=0;k<2;k++){ 
03B0E:  CLR     860
03B10:  MOV     860,W4
03B12:  CP      W4,#2
03B14:  BRA     C,3B46
....................                      input_index[k]=(unsigned)(fgetc(RS232)-48); 
03B16:  MOV     860,W0
03B18:  SL      W0,#1,W0
03B1A:  MOV     #862,W4
03B1C:  ADD     W0,W4,W5
03B1E:  BTSS.B  218.0
03B20:  BRA     3B1E
03B22:  MOV     21C,W0
03B24:  SUB.B   #30,W0L
03B26:  CLR.B   1
03B28:  MOV     W0,[W5]
....................                      fputc(input_index[k]+48,RS232); 
03B2A:  MOV     860,W0
03B2C:  SL      W0,#1,W0
03B2E:  MOV     #862,W4
03B30:  ADD     W0,W4,W0
03B32:  MOV     [W0],W5
03B34:  ADD     #30,W5
03B36:  MOV.B   W5L,W0L
03B38:  BTSC.B  219.1
03B3A:  BRA     3B38
03B3C:  MOV.B   W0L,21A
03B3E:  CLR.B   21B
....................                   } 
03B40:  INC     0860
03B42:  GOTO    3B10
....................                   fprintf(RS232,"\n\n\r"); 
03B46:  BTSC.B  219.1
03B48:  BRA     3B46
03B4A:  MOV     #A,W4
03B4C:  MOV     W4,21A
03B4E:  BTSC.B  219.1
03B50:  BRA     3B4E
03B52:  MOV     #A,W4
03B54:  MOV     W4,21A
03B56:  BTSC.B  219.1
03B58:  BRA     3B56
03B5A:  MOV     #D,W4
03B5C:  MOV     W4,21A
....................                    
....................                   index=10*input_index[0]+1*input_index[1]; 
03B5E:  MOV     862,W4
03B60:  MUL.UU  W4,#A,W0
03B62:  MOV     W0,W5
03B64:  MOV     W5,W0
03B66:  ADD     864,W0
03B68:  MOV     W0,866
....................                    
....................                   fprintf(RS232,"\n\rIndex: %u", index); 
03B6A:  MOV     #0,W1
03B6C:  MOV     W1,W0
03B6E:  CALL    1088
03B72:  INC     W1,W1
03B74:  MOV     W1,[W15++]
03B76:  BTSC.B  219.1
03B78:  BRA     3B76
03B7A:  MOV     W0,21A
03B7C:  MOV     [--W15],W1
03B7E:  MOV     #8,W0
03B80:  CPSGT   W1,W0
03B82:  BRA     3B6C
03B84:  MOV     866,W0
03B86:  MOV     #0,W4
03B88:  CALL    1688
....................                    
....................                   fprintf(RS232,"\n\rEnter Position (xxxx): "); 
03B8C:  MOV     #0,W1
03B8E:  MOV     W1,W0
03B90:  CALL    10A0
03B94:  INC     W1,W1
03B96:  MOV     W1,[W15++]
03B98:  BTSC.B  219.1
03B9A:  BRA     3B98
03B9C:  MOV     W0,21A
03B9E:  MOV     [--W15],W1
03BA0:  MOV     #18,W0
03BA2:  CPSGT   W1,W0
03BA4:  BRA     3B8E
....................                   unsigned int input_pos[2]; 
....................                   unsigned int posi=0; 
03BA6:  CLR     86C
....................                   for(k=0;k<4;k++){ 
03BA8:  CLR     860
03BAA:  MOV     860,W4
03BAC:  CP      W4,#4
03BAE:  BRA     C,3BE0
....................                      input_pos[k]=(unsigned)(fgetc(RS232)-48); 
03BB0:  MOV     860,W0
03BB2:  SL      W0,#1,W0
03BB4:  MOV     #868,W4
03BB6:  ADD     W0,W4,W5
03BB8:  BTSS.B  218.0
03BBA:  BRA     3BB8
03BBC:  MOV     21C,W0
03BBE:  SUB.B   #30,W0L
03BC0:  CLR.B   1
03BC2:  MOV     W0,[W5]
....................                      fputc(input_pos[k]+48,RS232); 
03BC4:  MOV     860,W0
03BC6:  SL      W0,#1,W0
03BC8:  MOV     #868,W4
03BCA:  ADD     W0,W4,W0
03BCC:  MOV     [W0],W5
03BCE:  ADD     #30,W5
03BD0:  MOV.B   W5L,W0L
03BD2:  BTSC.B  219.1
03BD4:  BRA     3BD2
03BD6:  MOV.B   W0L,21A
03BD8:  CLR.B   21B
....................                   } 
03BDA:  INC     0860
03BDC:  GOTO    3BAA
....................                   fprintf(RS232,"\n\n\r"); 
03BE0:  BTSC.B  219.1
03BE2:  BRA     3BE0
03BE4:  MOV     #A,W4
03BE6:  MOV     W4,21A
03BE8:  BTSC.B  219.1
03BEA:  BRA     3BE8
03BEC:  MOV     #A,W4
03BEE:  MOV     W4,21A
03BF0:  BTSC.B  219.1
03BF2:  BRA     3BF0
03BF4:  MOV     #D,W4
03BF6:  MOV     W4,21A
....................                    
....................                   posi=1000*input_pos[0]+100*input_pos[1]+10*input_pos[2]+1*input_pos[3]; 
03BF8:  MOV     #3E8,W4
03BFA:  MOV     868,W3
03BFC:  MUL.UU  W4,W3,W0
03BFE:  MOV     W0,W5
03C00:  MOV     #64,W4
03C02:  MOV     86A,W3
03C04:  MUL.UU  W4,W3,W0
03C06:  ADD     W0,W5,W5
03C08:  MOV     86C,W4
03C0A:  MUL.UU  W4,#A,W0
03C0C:  ADD     W0,W5,W5
03C0E:  MOV     W5,W0
03C10:  ADD     86E,W0
03C12:  MOV     W0,86C
....................                    
....................                   fprintf(RS232,"\n\rPosition: %u", posi); 
03C14:  MOV     #0,W1
03C16:  MOV     W1,W0
03C18:  CALL    10C6
03C1C:  INC     W1,W1
03C1E:  MOV     W1,[W15++]
03C20:  BTSC.B  219.1
03C22:  BRA     3C20
03C24:  MOV     W0,21A
03C26:  MOV     [--W15],W1
03C28:  MOV     #B,W0
03C2A:  CPSGT   W1,W0
03C2C:  BRA     3C16
03C2E:  MOV     86C,W0
03C30:  MOV     #0,W4
03C32:  CALL    1688
....................                    
....................                   data_set_pos(index, posi); 
03C36:  MOV.B   866,W0L
03C38:  MOV.B   W0L,892
03C3A:  PUSH    86C
03C3C:  POP     894
03C3E:  CALL    362C
....................                   break; 
03C42:  GOTO    41A2
....................       case 'o':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
03C46:  MOV     #0,W1
03C48:  MOV     W1,W0
03C4A:  CALL    10E2
03C4E:  INC     W1,W1
03C50:  MOV     W1,[W15++]
03C52:  BTSC.B  219.1
03C54:  BRA     3C52
03C56:  MOV     W0,21A
03C58:  MOV     [--W15],W1
03C5A:  MOV     #F,W0
03C5C:  CPSGT   W1,W0
03C5E:  BRA     3C48
....................                   unsigned int r=0; 
....................                   unsigned int input_speed[4]; 
....................                   unsigned int delay=0; 
03C60:  CLR     86E
03C62:  CLR     878
....................                   for(r=0;r<4;r++){ 
03C64:  CLR     86E
03C66:  MOV     86E,W4
03C68:  CP      W4,#4
03C6A:  BRA     C,3C9C
....................                      input_speed[r]=(unsigned)(fgetc(RS232)-48); 
03C6C:  MOV     86E,W0
03C6E:  SL      W0,#1,W0
03C70:  MOV     #870,W4
03C72:  ADD     W0,W4,W5
03C74:  BTSS.B  218.0
03C76:  BRA     3C74
03C78:  MOV     21C,W0
03C7A:  SUB.B   #30,W0L
03C7C:  CLR.B   1
03C7E:  MOV     W0,[W5]
....................                      fputc(input_speed[r]+48,RS232); 
03C80:  MOV     86E,W0
03C82:  SL      W0,#1,W0
03C84:  MOV     #870,W4
03C86:  ADD     W0,W4,W0
03C88:  MOV     [W0],W5
03C8A:  ADD     #30,W5
03C8C:  MOV.B   W5L,W0L
03C8E:  BTSC.B  219.1
03C90:  BRA     3C8E
03C92:  MOV.B   W0L,21A
03C94:  CLR.B   21B
....................                   } 
03C96:  INC     086E
03C98:  GOTO    3C66
....................                   fprintf(RS232,"\n\r"); 
03C9C:  BTSC.B  219.1
03C9E:  BRA     3C9C
03CA0:  MOV     #A,W4
03CA2:  MOV     W4,21A
03CA4:  BTSC.B  219.1
03CA6:  BRA     3CA4
03CA8:  MOV     #D,W4
03CAA:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
03CAC:  MOV     #3E8,W4
03CAE:  MOV     870,W3
03CB0:  MUL.UU  W4,W3,W0
03CB2:  MOV     W0,W5
03CB4:  MOV     #64,W4
03CB6:  MOV     872,W3
03CB8:  MUL.UU  W4,W3,W0
03CBA:  ADD     W0,W5,W5
03CBC:  MOV     874,W4
03CBE:  MUL.UU  W4,#A,W0
03CC0:  ADD     W0,W5,W5
03CC2:  MOV     W5,W0
03CC4:  ADD     876,W0
03CC6:  MOV     W0,878
....................        
....................                   unsigned int m; 
....................                   unsigned int pos_cal=md_min_distance; 
....................                   unsigned int num=(md_move_range-md_min_distance)/40+1; 
03CC8:  PUSH    818
03CCA:  POP     87C
03CCC:  MOV     80E,W4
03CCE:  MOV     818,W3
03CD0:  SUB     W4,W3,W5
03CD2:  MOV     W5,W4
03CD4:  MOV     #28,W3
03CD6:  REPEAT  #11
03CD8:  DIV.U   W4,W3
03CDA:  MOV     W0,W5
03CDC:  ADD     W5,#1,W5
03CDE:  MOV     W5,87E
....................                    
....................                   for(m=0; m<num; m++) 
03CE0:  CLR     87A
03CE2:  MOV     87A,W0
03CE4:  MOV     87E,W4
03CE6:  CP      W4,W0
03CE8:  BRA     LEU,3D06
....................                   { 
....................                      move_pos(pos_cal+m*40); 
03CEA:  MOV     87A,W4
03CEC:  MOV     #28,W3
03CEE:  MUL.UU  W4,W3,W0
03CF0:  MOV     87C,W4
03CF2:  ADD     W0,W4,W5
03CF4:  MOV     W5,894
03CF6:  CALL    2BEA
....................                      delay_ms(delay); 
03CFA:  MOV     878,W0
03CFC:  CALL    1674
....................                   } 
03D00:  INC     087A
03D02:  GOTO    3CE2
....................                    
....................                   pos_cal=pos_cal+(num-1)*40; 
03D06:  MOV     87E,W4
03D08:  SUB     W4,#1,W5
03D0A:  MOV     #28,W4
03D0C:  MUL.UU  W5,W4,W0
03D0E:  ADD     87C
....................                    
....................                   for(m=0; m<num; m++) 
03D10:  CLR     87A
03D12:  MOV     87A,W0
03D14:  MOV     87E,W4
03D16:  CP      W4,W0
03D18:  BRA     LEU,3D36
....................                   { 
....................                      move_pos(pos_cal-m*40); 
03D1A:  MOV     87A,W4
03D1C:  MOV     #28,W3
03D1E:  MUL.UU  W4,W3,W0
03D20:  MOV     87C,W4
03D22:  SUB     W4,W0,W5
03D24:  MOV     W5,894
03D26:  CALL    2BEA
....................                      delay_ms(delay); 
03D2A:  MOV     878,W0
03D2C:  CALL    1674
....................                   } 
03D30:  INC     087A
03D32:  GOTO    3D12
....................                   break; 
03D36:  GOTO    41A2
....................       case 'l':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
03D3A:  MOV     #0,W1
03D3C:  MOV     W1,W0
03D3E:  CALL    10E2
03D42:  INC     W1,W1
03D44:  MOV     W1,[W15++]
03D46:  BTSC.B  219.1
03D48:  BRA     3D46
03D4A:  MOV     W0,21A
03D4C:  MOV     [--W15],W1
03D4E:  MOV     #F,W0
03D50:  CPSGT   W1,W0
03D52:  BRA     3D3C
....................                   unsigned int p=0; 
03D54:  CLR     880
....................                   for(p=0;p<4;p++){ 
03D56:  CLR     880
03D58:  MOV     880,W4
03D5A:  CP      W4,#4
03D5C:  BRA     C,3D8E
....................                      input_speed[p]=(unsigned)(fgetc(RS232)-48); 
03D5E:  MOV     880,W0
03D60:  SL      W0,#1,W0
03D62:  MOV     #870,W4
03D64:  ADD     W0,W4,W5
03D66:  BTSS.B  218.0
03D68:  BRA     3D66
03D6A:  MOV     21C,W0
03D6C:  SUB.B   #30,W0L
03D6E:  CLR.B   1
03D70:  MOV     W0,[W5]
....................                      fputc(input_speed[p]+48,RS232); 
03D72:  MOV     880,W0
03D74:  SL      W0,#1,W0
03D76:  MOV     #870,W4
03D78:  ADD     W0,W4,W0
03D7A:  MOV     [W0],W5
03D7C:  ADD     #30,W5
03D7E:  MOV.B   W5L,W0L
03D80:  BTSC.B  219.1
03D82:  BRA     3D80
03D84:  MOV.B   W0L,21A
03D86:  CLR.B   21B
....................                   } 
03D88:  INC     0880
03D8A:  GOTO    3D58
....................                   fprintf(RS232,"\n\r"); 
03D8E:  BTSC.B  219.1
03D90:  BRA     3D8E
03D92:  MOV     #A,W4
03D94:  MOV     W4,21A
03D96:  BTSC.B  219.1
03D98:  BRA     3D96
03D9A:  MOV     #D,W4
03D9C:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
03D9E:  MOV     #3E8,W4
03DA0:  MOV     870,W3
03DA2:  MUL.UU  W4,W3,W0
03DA4:  MOV     W0,W5
03DA6:  MOV     #64,W4
03DA8:  MOV     872,W3
03DAA:  MUL.UU  W4,W3,W0
03DAC:  ADD     W0,W5,W5
03DAE:  MOV     874,W4
03DB0:  MUL.UU  W4,#A,W0
03DB2:  ADD     W0,W5,W5
03DB4:  MOV     W5,W0
03DB6:  ADD     876,W0
03DB8:  MOV     W0,878
....................        
....................                   unsigned int l; 
....................                   unsigned int pos_cal_2=md_min_distance; 
....................                   unsigned int num_2=(md_move_range-md_min_distance)/10+1; 
03DBA:  PUSH    818
03DBC:  POP     884
03DBE:  MOV     80E,W4
03DC0:  MOV     818,W3
03DC2:  SUB     W4,W3,W5
03DC4:  MOV     W5,W4
03DC6:  MOV     #A,W3
03DC8:  REPEAT  #11
03DCA:  DIV.U   W4,W3
03DCC:  MOV     W0,W5
03DCE:  ADD     W5,#1,W5
03DD0:  MOV     W5,886
....................                    
....................                   for(l=0; l<num_2; l++) 
03DD2:  CLR     882
03DD4:  MOV     882,W0
03DD6:  MOV     886,W4
03DD8:  CP      W4,W0
03DDA:  BRA     LEU,3DF6
....................                   { 
....................                      move_pos(pos_cal_2+l*10); 
03DDC:  MOV     882,W4
03DDE:  MUL.UU  W4,#A,W0
03DE0:  MOV     884,W4
03DE2:  ADD     W0,W4,W5
03DE4:  MOV     W5,894
03DE6:  CALL    2BEA
....................                      delay_ms(delay); 
03DEA:  MOV     878,W0
03DEC:  CALL    1674
....................                   } 
03DF0:  INC     0882
03DF2:  GOTO    3DD4
....................                    
....................                   pos_cal_2=pos_cal_2+(num_2-1)*10; 
03DF6:  MOV     886,W4
03DF8:  SUB     W4,#1,W5
03DFA:  MOV     W5,W4
03DFC:  MUL.UU  W4,#A,W0
03DFE:  ADD     884
....................                    
....................                   for(l=0; l<num_2; l++) 
03E00:  CLR     882
03E02:  MOV     882,W0
03E04:  MOV     886,W4
03E06:  CP      W4,W0
03E08:  BRA     LEU,3E24
....................                   { 
....................                      move_pos(pos_cal_2-l*10); 
03E0A:  MOV     882,W4
03E0C:  MUL.UU  W4,#A,W0
03E0E:  MOV     884,W4
03E10:  SUB     W4,W0,W5
03E12:  MOV     W5,894
03E14:  CALL    2BEA
....................                      delay_ms(delay); 
03E18:  MOV     878,W0
03E1A:  CALL    1674
....................                   } 
03E1E:  INC     0882
03E20:  GOTO    3E02
....................                   break; 
03E24:  GOTO    41A2
....................       case 'd':   fprintf(RS232,"\n\rSet debug state\n\r"); 
03E28:  MOV     #0,W1
03E2A:  MOV     W1,W0
03E2C:  CALL    1100
03E30:  INC     W1,W1
03E32:  MOV     W1,[W15++]
03E34:  BTSC.B  219.1
03E36:  BRA     3E34
03E38:  MOV     W0,21A
03E3A:  MOV     [--W15],W1
03E3C:  MOV     #12,W0
03E3E:  CPSGT   W1,W0
03E40:  BRA     3E2A
....................                   fprintf(RS232,"Digital potentiometer (a)(0 or 1): \n\r"); 
03E42:  MOV     #0,W1
03E44:  MOV     W1,W0
03E46:  CALL    1120
03E4A:  INC     W1,W1
03E4C:  MOV     W1,[W15++]
03E4E:  BTSC.B  219.1
03E50:  BRA     3E4E
03E52:  MOV     W0,21A
03E54:  MOV     [--W15],W1
03E56:  MOV     #24,W0
03E58:  CPSGT   W1,W0
03E5A:  BRA     3E44
....................                   fprintf(RS232,"Parallel port         (b)(0 or 1): \n\r"); 
03E5C:  MOV     #0,W1
03E5E:  MOV     W1,W0
03E60:  CALL    1152
03E64:  INC     W1,W1
03E66:  MOV     W1,[W15++]
03E68:  BTSC.B  219.1
03E6A:  BRA     3E68
03E6C:  MOV     W0,21A
03E6E:  MOV     [--W15],W1
03E70:  MOV     #24,W0
03E72:  CPSGT   W1,W0
03E74:  BRA     3E5E
....................                   fprintf(RS232,"FRAM                  (c)(0 or 1): \n\r"); 
03E76:  MOV     #0,W1
03E78:  MOV     W1,W0
03E7A:  CALL    1184
03E7E:  INC     W1,W1
03E80:  MOV     W1,[W15++]
03E82:  BTSC.B  219.1
03E84:  BRA     3E82
03E86:  MOV     W0,21A
03E88:  MOV     [--W15],W1
03E8A:  MOV     #24,W0
03E8C:  CPSGT   W1,W0
03E8E:  BRA     3E78
....................                   fprintf(RS232,"Motor driver          (d)(0 or 1): \n\r"); 
03E90:  MOV     #0,W1
03E92:  MOV     W1,W0
03E94:  CALL    11B6
03E98:  INC     W1,W1
03E9A:  MOV     W1,[W15++]
03E9C:  BTSC.B  219.1
03E9E:  BRA     3E9C
03EA0:  MOV     W0,21A
03EA2:  MOV     [--W15],W1
03EA4:  MOV     #24,W0
03EA6:  CPSGT   W1,W0
03EA8:  BRA     3E92
....................                   fprintf(RS232,"Encoder               (e)(0 or 1): \n\r"); 
03EAA:  MOV     #0,W1
03EAC:  MOV     W1,W0
03EAE:  CALL    11E8
03EB2:  INC     W1,W1
03EB4:  MOV     W1,[W15++]
03EB6:  BTSC.B  219.1
03EB8:  BRA     3EB6
03EBA:  MOV     W0,21A
03EBC:  MOV     [--W15],W1
03EBE:  MOV     #24,W0
03EC0:  CPSGT   W1,W0
03EC2:  BRA     3EAC
....................                   fprintf(RS232,"PWM Module            (f)(0 or 1): \n\r"); 
03EC4:  MOV     #0,W1
03EC6:  MOV     W1,W0
03EC8:  CALL    121A
03ECC:  INC     W1,W1
03ECE:  MOV     W1,[W15++]
03ED0:  BTSC.B  219.1
03ED2:  BRA     3ED0
03ED4:  MOV     W0,21A
03ED6:  MOV     [--W15],W1
03ED8:  MOV     #24,W0
03EDA:  CPSGT   W1,W0
03EDC:  BRA     3EC6
....................                   fprintf(RS232,"All Modes             (g)(0 or 1): \n\r"); 
03EDE:  MOV     #0,W1
03EE0:  MOV     W1,W0
03EE2:  CALL    124C
03EE6:  INC     W1,W1
03EE8:  MOV     W1,[W15++]
03EEA:  BTSC.B  219.1
03EEC:  BRA     3EEA
03EEE:  MOV     W0,21A
03EF0:  MOV     [--W15],W1
03EF2:  MOV     #24,W0
03EF4:  CPSGT   W1,W0
03EF6:  BRA     3EE0
....................                   fprintf(RS232,"Selection (xx): "); 
03EF8:  MOV     #0,W1
03EFA:  MOV     W1,W0
03EFC:  CALL    127E
03F00:  INC     W1,W1
03F02:  MOV     W1,[W15++]
03F04:  BTSC.B  219.1
03F06:  BRA     3F04
03F08:  MOV     W0,21A
03F0A:  MOV     [--W15],W1
03F0C:  MOV     #F,W0
03F0E:  CPSGT   W1,W0
03F10:  BRA     3EFA
....................                    
....................                   int1 value=0; 
....................                   unsigned int f=0; 
....................                   char input_ds[2]; 
03F12:  BCLR.B  853.0
03F14:  CLR     888
....................                   for(f=0;f<2;f++){ 
03F16:  CLR     888
03F18:  MOV     888,W4
03F1A:  CP      W4,#2
03F1C:  BRA     C,3F44
....................                      input_ds[f]=fgetc(RS232); 
03F1E:  MOV     #88A,W4
03F20:  MOV     888,W3
03F22:  ADD     W3,W4,W5
03F24:  BTSS.B  218.0
03F26:  BRA     3F24
03F28:  MOV     21C,W0
03F2A:  MOV.B   W0L,[W5]
....................                      fputc(input_ds[f],RS232); 
03F2C:  MOV     #88A,W4
03F2E:  MOV     888,W3
03F30:  ADD     W3,W4,W0
03F32:  MOV.B   [W0],W5L
03F34:  MOV.B   W5L,W0L
03F36:  BTSC.B  219.1
03F38:  BRA     3F36
03F3A:  MOV.B   W0L,21A
03F3C:  CLR.B   21B
....................                   } 
03F3E:  INC     0888
03F40:  GOTO    3F18
....................                   fprintf(RS232,"\n\n\r"); 
03F44:  BTSC.B  219.1
03F46:  BRA     3F44
03F48:  MOV     #A,W4
03F4A:  MOV     W4,21A
03F4C:  BTSC.B  219.1
03F4E:  BRA     3F4C
03F50:  MOV     #A,W4
03F52:  MOV     W4,21A
03F54:  BTSC.B  219.1
03F56:  BRA     3F54
03F58:  MOV     #D,W4
03F5A:  MOV     W4,21A
....................                    
....................                   if(input_ds[1]=='0') 
03F5C:  MOV     88A,W4
03F5E:  LSR     W4,#8,W4
03F60:  XOR.B   #30,W4L
03F62:  BRA     NZ,3F6A
....................                      value=0; 
03F64:  BCLR.B  853.0
....................                   else if(input_ds[1]=='1') 
03F66:  GOTO    3F96
03F6A:  MOV     88A,W4
03F6C:  LSR     W4,#8,W4
03F6E:  XOR.B   #31,W4L
03F70:  BRA     NZ,3F78
....................                      value=1; 
03F72:  BSET.B  853.0
....................                   else 
03F74:  GOTO    3F96
....................                   { 
....................                      fprintf(RS232,"Invalid Entry\n\r"); 
03F78:  MOV     #0,W1
03F7A:  MOV     W1,W0
03F7C:  CALL    129C
03F80:  INC     W1,W1
03F82:  MOV     W1,[W15++]
03F84:  BTSC.B  219.1
03F86:  BRA     3F84
03F88:  MOV     W0,21A
03F8A:  MOV     [--W15],W1
03F8C:  MOV     #E,W0
03F8E:  CPSGT   W1,W0
03F90:  BRA     3F7A
....................                      break; 
03F92:  GOTO    41A2
....................                   } 
....................  
....................                   switch (input_ds[0]){ 
03F96:  MOV.B   88A,W0L
03F98:  CLR.B   1
03F9A:  XOR     #61,W0
03F9C:  BRA     Z,3FB8
03F9E:  XOR     #3,W0
03FA0:  BRA     Z,3FC2
03FA2:  XOR     #1,W0
03FA4:  BRA     Z,3FCC
03FA6:  XOR     #7,W0
03FA8:  BRA     Z,3FD6
03FAA:  XOR     #1,W0
03FAC:  BRA     Z,3FE0
03FAE:  XOR     #3,W0
03FB0:  BRA     Z,3FEA
03FB2:  XOR     #1,W0
03FB4:  BRA     Z,3FF4
03FB6:  BRA     401C
....................                      case 'a':   debug_mode_dp = value; 
03FB8:  BCLR.B  800.0
03FBA:  BTSC.B  853.0
03FBC:  BSET.B  800.0
....................                                  break; 
03FBE:  GOTO    403A
....................                      case 'b':   debug_mode_pp = value; 
03FC2:  BCLR.B  800.1
03FC4:  BTSC.B  853.0
03FC6:  BSET.B  800.1
....................                                  break; 
03FC8:  GOTO    403A
....................                      case 'c':   debug_mode_fr = value; 
03FCC:  BCLR.B  800.2
03FCE:  BTSC.B  853.0
03FD0:  BSET.B  800.2
....................                                  break; 
03FD2:  GOTO    403A
....................                      case 'd':   debug_mode_md = value; 
03FD6:  BCLR.B  800.3
03FD8:  BTSC.B  853.0
03FDA:  BSET.B  800.3
....................                                  break; 
03FDC:  GOTO    403A
....................                      case 'e':   debug_mode_qei = value; 
03FE0:  BCLR.B  800.5
03FE2:  BTSC.B  853.0
03FE4:  BSET.B  800.5
....................                                  break; 
03FE6:  GOTO    403A
....................                      case 'f':   debug_mode_pwm = value; 
03FEA:  BCLR.B  800.4
03FEC:  BTSC.B  853.0
03FEE:  BSET.B  800.4
....................                                  break;           
03FF0:  GOTO    403A
....................                      case 'g':   debug_mode_dp = value; 
03FF4:  BCLR.B  800.0
03FF6:  BTSC.B  853.0
03FF8:  BSET.B  800.0
....................                                  debug_mode_pp = value; 
03FFA:  BCLR.B  800.1
03FFC:  BTSC.B  853.0
03FFE:  BSET.B  800.1
....................                                  debug_mode_fr = value; 
04000:  BCLR.B  800.2
04002:  BTSC.B  853.0
04004:  BSET.B  800.2
....................                                  debug_mode_md = value; 
04006:  BCLR.B  800.3
04008:  BTSC.B  853.0
0400A:  BSET.B  800.3
....................                                  debug_mode_qei = value; 
0400C:  BCLR.B  800.5
0400E:  BTSC.B  853.0
04010:  BSET.B  800.5
....................                                  debug_mode_pwm = value; 
04012:  BCLR.B  800.4
04014:  BTSC.B  853.0
04016:  BSET.B  800.4
....................                                  break; 
04018:  GOTO    403A
....................                      default:    fprintf(RS232,"Invalid Entry\n\r"); 
0401C:  MOV     #0,W1
0401E:  MOV     W1,W0
04020:  CALL    129C
04024:  INC     W1,W1
04026:  MOV     W1,[W15++]
04028:  BTSC.B  219.1
0402A:  BRA     4028
0402C:  MOV     W0,21A
0402E:  MOV     [--W15],W1
04030:  MOV     #E,W0
04032:  CPSGT   W1,W0
04034:  BRA     401E
....................                                  break; 
04036:  GOTO    403A
....................                   } 
....................                   break; 
0403A:  GOTO    41A2
....................       case 'w':   fprintf(RS232,"\n\rEncoder count %4u\n\r",qei_get_count()); 
0403E:  CALL    20A0
04042:  MOV     W0,W5
04044:  MOV     #0,W1
04046:  MOV     W1,W0
04048:  CALL    12B8
0404C:  INC     W1,W1
0404E:  MOV     W1,[W15++]
04050:  BTSC.B  219.1
04052:  BRA     4050
04054:  MOV     W0,21A
04056:  MOV     [--W15],W1
04058:  MOV     #F,W0
0405A:  CPSGT   W1,W0
0405C:  BRA     4046
0405E:  MOV     W5,W0
04060:  MOV     #4,W4
04062:  CALL    1688
04066:  BTSC.B  219.1
04068:  BRA     4066
0406A:  MOV     #A,W4
0406C:  MOV     W4,21A
0406E:  BTSC.B  219.1
04070:  BRA     406E
04072:  MOV     #D,W4
04074:  MOV     W4,21A
....................                   break; 
04076:  GOTO    41A2
....................       case 'z':   fprintf(RS232,"\n\rStart Memory Test (Yes -> 1, No -> 0): "); 
0407A:  MOV     #0,W1
0407C:  MOV     W1,W0
0407E:  CALL    12DA
04082:  INC     W1,W1
04084:  MOV     W1,[W15++]
04086:  BTSC.B  219.1
04088:  BRA     4086
0408A:  MOV     W0,21A
0408C:  MOV     [--W15],W1
0408E:  MOV     #28,W0
04090:  CPSGT   W1,W0
04092:  BRA     407C
....................                   unsigned int input_mem_test=(unsigned)(fgetc(RS232)-48); 
04094:  BTSS.B  218.0
04096:  BRA     4094
04098:  MOV     21C,W0
0409A:  MOV     #30,W4
0409C:  SUB.B   W0L,W4L,W0L
0409E:  MOV.B   W0L,88C
040A0:  CLR.B   88D
....................                   fputc(input_mem_test+48,RS232); 
040A2:  MOV     #30,W4
040A4:  MOV     88C,W3
040A6:  ADD     W3,W4,W5
040A8:  MOV.B   W5L,W0L
040AA:  BTSC.B  219.1
040AC:  BRA     40AA
040AE:  MOV.B   W0L,21A
040B0:  CLR.B   21B
....................                   
....................                   unsigned int8 mem=0; 
040B2:  CLR.B   88E
....................                    
....................                   if(input_mem_test == 1) 
040B4:  MOV     88C,W4
040B6:  CP      W4,#1
040B8:  BRA     NZ,410E
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
040BA:  CLR.B   88E
040BC:  MOV     88E,W4
040BE:  MOV     #64,W3
040C0:  CP.B    W3L,W4L
040C2:  BRA     LEU,40E2
....................                         data_set_pos(mem, mem+1); 
040C4:  MOV     88E,W4
040C6:  ADD.B   W4L,#1,W4L
040C8:  MOV.B   W4L,W0L
040CA:  MOV.B   W0L,A
040CC:  MOV.B   88E,W0L
040CE:  MOV.B   W0L,892
040D0:  PUSH    894
040D2:  MOV.B   W5L,[W15-#2]
040D4:  POP     894
040D6:  CLR.B   895
040D8:  CALL    362C
040DC:  INC.B   088E
040DE:  GOTO    40BC
....................                          
....................                      fprintf(RS232,"\n\r"); 
040E2:  BTSC.B  219.1
040E4:  BRA     40E2
040E6:  MOV     #A,W4
040E8:  MOV     W4,21A
040EA:  BTSC.B  219.1
040EC:  BRA     40EA
040EE:  MOV     #D,W4
040F0:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
040F2:  BSET.B  800.2
....................                      for(mem=0; mem<100; mem++) 
040F4:  CLR.B   88E
040F6:  MOV     88E,W4
040F8:  MOV     #64,W3
040FA:  CP.B    W3L,W4L
040FC:  BRA     LEU,410C
....................                         data_get_pos(mem); 
040FE:  MOV.B   88E,W0L
04100:  MOV.B   W0L,896
04102:  CALL    3546
04106:  INC.B   088E
04108:  GOTO    40F6
....................                      debug_mode_fr=0; 
0410C:  BCLR.B  800.2
....................                   } 
....................                   break; 
0410E:  GOTO    41A2
....................       case 'f':   fprintf(RS232,"\n\rClear Memory (Yes -> 1, No -> 0): "); 
04112:  MOV     #0,W1
04114:  MOV     W1,W0
04116:  CALL    1312
0411A:  INC     W1,W1
0411C:  MOV     W1,[W15++]
0411E:  BTSC.B  219.1
04120:  BRA     411E
04122:  MOV     W0,21A
04124:  MOV     [--W15],W1
04126:  MOV     #23,W0
04128:  CPSGT   W1,W0
0412A:  BRA     4114
....................                   input_mem_test=(unsigned)(fgetc(RS232)-48); 
0412C:  BTSS.B  218.0
0412E:  BRA     412C
04130:  MOV     21C,W0
04132:  MOV     #30,W4
04134:  SUB.B   W0L,W4L,W0L
04136:  MOV.B   W0L,88C
04138:  CLR.B   88D
....................                   fputc(input_mem_test+48,RS232); 
0413A:  MOV     #30,W4
0413C:  MOV     88C,W3
0413E:  ADD     W3,W4,W5
04140:  MOV.B   W5L,W0L
04142:  BTSC.B  219.1
04144:  BRA     4142
04146:  MOV.B   W0L,21A
04148:  CLR.B   21B
....................                    
....................                   if(input_mem_test == 1) 
0414A:  MOV     88C,W4
0414C:  CP      W4,#1
0414E:  BRA     NZ,4196
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
04150:  CLR.B   88E
04152:  MOV     88E,W4
04154:  MOV     #64,W3
04156:  CP.B    W3L,W4L
04158:  BRA     LEU,416A
....................                         data_set_pos(mem, 0); 
0415A:  MOV.B   88E,W0L
0415C:  MOV.B   W0L,892
0415E:  CLR     894
04160:  CALL    362C
04164:  INC.B   088E
04166:  GOTO    4152
....................                          
....................                      fprintf(RS232,"\n\r"); 
0416A:  BTSC.B  219.1
0416C:  BRA     416A
0416E:  MOV     #A,W4
04170:  MOV     W4,21A
04172:  BTSC.B  219.1
04174:  BRA     4172
04176:  MOV     #D,W4
04178:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
0417A:  BSET.B  800.2
....................                      for(mem=0; mem<100; mem++) 
0417C:  CLR.B   88E
0417E:  MOV     88E,W4
04180:  MOV     #64,W3
04182:  CP.B    W3L,W4L
04184:  BRA     LEU,4194
....................                         data_get_pos(mem); 
04186:  MOV.B   88E,W0L
04188:  MOV.B   W0L,896
0418A:  CALL    3546
0418E:  INC.B   088E
04190:  GOTO    417E
....................                      debug_mode_fr=0; 
04194:  BCLR.B  800.2
....................                   } 
....................                   break; 
04196:  GOTO    41A2
....................       case 'g':    
....................                   break; 
0419A:  GOTO    41A2
....................       case 'y':    
....................                   break; 
0419E:  GOTO    41A2
....................    } 
....................     
....................    return; 
.................... } 
041A2:  MOV     [--W15],W6
041A4:  MOV     [--W15],W5
041A6:  RETURN  
....................  
....................  
.................... #int_default 
.................... void default_isr()  
.................... { 
*
01570:  PUSH    42
01572:  PUSH    36
01574:  MOV     W0,[W15++]
01576:  MOV     #2,W0
01578:  REPEAT  #C
0157A:  MOV     [W0++],[W15++]
....................    printf("Unexplained interrupt\r\n"); 
0157C:  MOV     #0,W1
0157E:  MOV     W1,W0
01580:  CALL    1344
01584:  INC     W1,W1
01586:  MOV     W1,[W15++]
01588:  BTSC.B  219.1
0158A:  BRA     1588
0158C:  MOV     W0,21A
0158E:  MOV     [--W15],W1
01590:  MOV     #16,W0
01592:  CPSGT   W1,W0
01594:  BRA     157E
.................... } 
....................  
....................  
01596:  MOV     #1A,W0
01598:  REPEAT  #C
0159A:  MOV     [--W15],[W0--]
0159C:  MOV     [--W15],W0
0159E:  POP     36
015A0:  POP     42
015A2:  RETFIE  
.................... #INT_ADDRERR 
.................... void isr_addrerr() 
.................... { 
015A4:  PUSH    42
015A6:  PUSH    36
015A8:  MOV     W0,[W15++]
015AA:  MOV     #2,W0
015AC:  REPEAT  #C
015AE:  MOV     [W0++],[W15++]
....................    fprintf(RS232,"address error"); 
015B0:  MOV     #0,W1
015B2:  MOV     W1,W0
015B4:  CALL    1368
015B8:  INC     W1,W1
015BA:  MOV     W1,[W15++]
015BC:  BTSC.B  219.1
015BE:  BRA     15BC
015C0:  MOV     W0,21A
015C2:  MOV     [--W15],W1
015C4:  MOV     #C,W0
015C6:  CPSGT   W1,W0
015C8:  BRA     15B2
....................    fprintf(RS232,"\n\r"); 
015CA:  BTSC.B  219.1
015CC:  BRA     15CA
015CE:  MOV     #A,W4
015D0:  MOV     W4,21A
015D2:  BTSC.B  219.1
015D4:  BRA     15D2
015D6:  MOV     #D,W4
015D8:  MOV     W4,21A
....................    clear_interrupt(INT_ADDRERR); 
015DA:  BCLR.B  80.3
.................... } 
....................  
015DC:  BCLR.B  80.3
015DE:  MOV     #1A,W0
015E0:  REPEAT  #C
015E2:  MOV     [--W15],[W0--]
015E4:  MOV     [--W15],W0
015E6:  POP     36
015E8:  POP     42
015EA:  RETFIE  
.................... #INT_OSCFAIL 
.................... void isr_oscfail() 
.................... { 
015EC:  PUSH    42
015EE:  PUSH    36
015F0:  MOV     W0,[W15++]
015F2:  MOV     #2,W0
015F4:  REPEAT  #C
015F6:  MOV     [W0++],[W15++]
....................    fprintf(RS232,"oscfail"); 
015F8:  MOV     #0,W1
015FA:  MOV     W1,W0
015FC:  CALL    1382
01600:  INC     W1,W1
01602:  MOV     W1,[W15++]
01604:  BTSC.B  219.1
01606:  BRA     1604
01608:  MOV     W0,21A
0160A:  MOV     [--W15],W1
0160C:  MOV     #6,W0
0160E:  CPSGT   W1,W0
01610:  BRA     15FA
....................    fprintf(RS232,"\n\r"); 
01612:  BTSC.B  219.1
01614:  BRA     1612
01616:  MOV     #A,W4
01618:  MOV     W4,21A
0161A:  BTSC.B  219.1
0161C:  BRA     161A
0161E:  MOV     #D,W4
01620:  MOV     W4,21A
....................    clear_interrupt(INT_OSCFAIL); 
01622:  BCLR.B  80.1
.................... } 
....................  
.................... // Parallel port strobe signal interrupt 
01624:  BCLR.B  80.1
01626:  MOV     #1A,W0
01628:  REPEAT  #C
0162A:  MOV     [--W15],[W0--]
0162C:  MOV     [--W15],W0
0162E:  POP     36
01630:  POP     42
01632:  RETFIE  
.................... #INT_EXT3 
.................... void isr_pp_strobe() 
.................... { 
01634:  PUSH    42
01636:  PUSH    36
01638:  MOV     W0,[W15++]
0163A:  MOV     #2,W0
0163C:  REPEAT  #C
0163E:  MOV     [W0++],[W15++]
....................    if(reg_comm_type == 0) 
01640:  BTSC.B  800.6
01642:  BRA     1646
....................       reg_pp_strobe = 1; 
01644:  BSET.B  84C.0
.................... } 
.................... // RS232 receive byte interrupt 
01646:  BCLR.B  88.4
01648:  MOV     #1A,W0
0164A:  REPEAT  #C
0164C:  MOV     [--W15],[W0--]
0164E:  MOV     [--W15],W0
01650:  POP     36
01652:  POP     42
01654:  RETFIE  
.................... #INT_RDA2 
.................... void isr_rs232_message() 
.................... { 
01656:  PUSH    42
01658:  PUSH    36
0165A:  MOV     W0,[W15++]
0165C:  MOV     #2,W0
0165E:  REPEAT  #C
01660:  MOV     [W0++],[W15++]
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1;   
01662:  BSET.B  84C.3
.................... }  
.................... // Clears RS232 interrupt flags 
01664:  BCLR.B  87.0
01666:  MOV     #1A,W0
01668:  REPEAT  #C
0166A:  MOV     [--W15],[W0--]
0166C:  MOV     [--W15],W0
0166E:  POP     36
01670:  POP     42
01672:  RETFIE  
.................... void rs232_clear() 
.................... { 
....................    UART_IFS0_U1RXIF = 0; 
....................    UART_IFS0_U1TXIF = 0; 
....................    reg_rs232_message = 0; 
.................... } 
....................  
.................... // Main method 
.................... void main() 
.................... { 
*
045D0:  BSET.B  81.7
045D2:  MOV     #8000,W4
045D4:  MOV     W4,20C
045D6:  MOV     #400,W4
045D8:  MOV     W4,20E
045DA:  MOV     #30,W4
045DC:  MOV     W4,214
045DE:  MOV     #8000,W4
045E0:  MOV     W4,216
045E2:  MOV     #400,W4
045E4:  MOV     W4,218
045E6:  MOV     #30,W4
045E8:  MOV     W4,21E
045EA:  BCLR.B  800.0
045EC:  BCLR.B  800.1
045EE:  BCLR.B  800.2
045F0:  BCLR.B  800.3
045F2:  BCLR.B  800.4
045F4:  BCLR.B  800.5
045F6:  MOV     #20,W4
045F8:  MOV     W4,802
045FA:  MOV     #3FF,W4
045FC:  MOV     W4,804
045FE:  MOV     #323,W4
04600:  MOV     W4,806
04602:  MOV     #46,W4
04604:  MOV     W4,808
04606:  MOV     #1C,W4
04608:  MOV     W4,80A
0460A:  CLR     80C
0460C:  MOV     #190,W4
0460E:  MOV     W4,80E
04610:  MOV     #2D,W4
04612:  MOV     W4,810
04614:  MOV     #3E8,W4
04616:  MOV     W4,812
04618:  MOV     #32,W4
0461A:  MOV     W4,814
0461C:  MOV     #64,W4
0461E:  MOV     W4,816
04620:  MOV     #46,W4
04622:  MOV     W4,818
04624:  CLR     81A
04626:  MOV     #BB8,W4
04628:  MOV     W4,81C
0462A:  MOV     #BB8,W4
0462C:  MOV     W4,81E
0462E:  MOV     #64,W4
04630:  MOV     W4,820
04632:  CLR.B   801
04634:  CLR     822
04636:  CLR     824
04638:  CLR     826
0463A:  CLR     828
0463C:  CLR     82A
0463E:  CLR     82C
04640:  CLR     82E
04642:  CLR     830
04644:  CLR     832
04646:  MOV     #D,W4
04648:  MOV     W4,834
0464A:  MOV     #F,W4
0464C:  MOV     W4,836
0464E:  MOV     #11,W4
04650:  MOV     W4,838
04652:  MOV     #13,W4
04654:  MOV     W4,83A
04656:  MOV     #15,W4
04658:  MOV     W4,83C
0465A:  MOV     #17,W4
0465C:  MOV     W4,83E
0465E:  MOV     #18,W4
04660:  MOV     W4,840
04662:  MOV     #1A,W4
04664:  MOV     W4,842
04666:  MOV     #A,W4
04668:  MOV     W4,844
0466A:  MOV     #1,W4
0466C:  MOV     W4,846
0466E:  MOV     #64,W4
04670:  MOV     W4,848
04672:  MOV     #64,W4
04674:  MOV     W4,84A
04676:  BCLR.B  800.6
04678:  BCLR.B  800.7
0467A:  BCLR.B  84C.0
0467C:  BCLR.B  84C.1
0467E:  BCLR.B  84C.2
04680:  BCLR.B  84C.3
04682:  BCLR.B  84C.4
04684:  MOV     #58,W4
04686:  MOV     W4,84E
04688:  SETM    2A8
0468A:  MOV     #2780,W15
0468C:  MOV     #27FF,W0
0468E:  MOV     W0,20
04690:  NOP     
....................    // Set I/O states of the ports 
....................    //           FEDCBA9876543210 
....................    set_tris_b(0b1111111011111100); 
04692:  MOV     #FEFC,W4
04694:  MOV     W4,2C6
....................    set_tris_c(0b1111111111111111); 
04696:  SETM    2CC
....................    set_tris_d(0b1111111100001111); 
04698:  MOV     #FF0F,W4
0469A:  MOV     W4,2D2
....................    set_tris_e(0b1111111110000000); 
0469C:  MOV     #FF80,W4
0469E:  MOV     W4,2D8
....................    set_tris_f(0b1111111111111100); 
046A0:  MOV     #FFFC,W4
046A2:  MOV     W4,2DE
....................    set_tris_g(0b1111111100111111); 
046A4:  MOV     #FF3F,W4
046A6:  MOV     W4,2E4
....................     
....................    // Set parallel port pins 
....................    output_low(PP_ACK); 
046A8:  BCLR.B  2D2.4
046AA:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
046AC:  BCLR.B  2D2.5
046AE:  BCLR.B  2D6.5
....................     
....................    // Turn on debug led 
....................    output_high(LED); 
046B0:  BCLR.B  2C7.0
046B2:  BSET.B  2CB.0
....................     
....................    //Turn on lasers 
....................    output_high(LAS_1); 
046B4:  BCLR.B  2C6.0
046B6:  BSET.B  2CA.0
....................    output_high(LAS_2); 
046B8:  BCLR.B  2C6.1
046BA:  BSET.B  2CA.1
....................    output_high(LAS_3); 
046BC:  BCLR.B  2D2.6
046BE:  BSET.B  2D6.6
....................  
....................    // Set A/D converter to read motor torque control voltage 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
046C0:  MOV     #80,W4
046C2:  MOV     W4,2A4
046C4:  MOV     #80E0,W4
046C6:  MOV     W4,2A0
....................    setup_adc_ports(sAN2); 
046C8:  MOV     #FFFB,W4
046CA:  MOV     W4,2A8
046CC:  CLR     2A2
....................    set_adc_channel(2); 
046CE:  MOV     #2,W4
046D0:  MOV     W4,2A6
....................     
....................    delay_ms(500); 
046D2:  MOV     #1F4,W0
046D4:  CALL    1674
....................     
....................    fprintf(RS232,"\n\r"); 
046D8:  BTSC.B  219.1
046DA:  BRA     46D8
046DC:  MOV     #A,W4
046DE:  MOV     W4,21A
046E0:  BTSC.B  219.1
046E2:  BRA     46E0
046E4:  MOV     #D,W4
046E6:  MOV     W4,21A
....................    fprintf(RS232,"______________________________________________________________\n\r"); 
046E8:  MOV.B   #3E,W5L
046EA:  MOV     #5F,W0
046EC:  BTSC.B  219.1
046EE:  BRA     46EC
046F0:  MOV.B   W0L,21A
046F2:  CLR.B   21B
046F4:  DEC.B   000A
046F6:  BTSS.B  42.1
046F8:  BRA     46EA
046FA:  BTSC.B  219.1
046FC:  BRA     46FA
046FE:  MOV     #A,W4
04700:  MOV     W4,21A
04702:  BTSC.B  219.1
04704:  BRA     4702
04706:  MOV     #D,W4
04708:  MOV     W4,21A
....................    fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING SYSTEM\n\n\r"); 
0470A:  MOV     #0,W1
0470C:  MOV     W1,W0
0470E:  CALL    1396
04712:  INC     W1,W1
04714:  MOV     W1,[W15++]
04716:  BTSC.B  219.1
04718:  BRA     4716
0471A:  MOV     W0,21A
0471C:  MOV     [--W15],W1
0471E:  MOV     #25,W0
04720:  CPSGT   W1,W0
04722:  BRA     470C
....................    fprintf(RS232,"Press 'c' for command list\n\n\r"); 
04724:  MOV     #0,W1
04726:  MOV     W1,W0
04728:  CALL    13CA
0472C:  INC     W1,W1
0472E:  MOV     W1,[W15++]
04730:  BTSC.B  219.1
04732:  BRA     4730
04734:  MOV     W0,21A
04736:  MOV     [--W15],W1
04738:  MOV     #1C,W0
0473A:  CPSGT   W1,W0
0473C:  BRA     4726
....................    fprintf(RS232,"RCON REGISTER VALUE(10'luk Tabanda):  "); 
0473E:  MOV     #0,W1
04740:  MOV     W1,W0
04742:  CALL    13F4
04746:  INC     W1,W1
04748:  MOV     W1,[W15++]
0474A:  BTSC.B  219.1
0474C:  BRA     474A
0474E:  MOV     W0,21A
04750:  MOV     [--W15],W1
04752:  MOV     #25,W0
04754:  CPSGT   W1,W0
04756:  BRA     4740
....................    fprintf(RS232,"%u",RCON); 
04758:  MOV     740,W0
0475A:  MOV     #0,W4
0475C:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
04760:  BTSC.B  219.1
04762:  BRA     4760
04764:  MOV     #A,W4
04766:  MOV     W4,21A
04768:  BTSC.B  219.1
0476A:  BRA     4768
0476C:  MOV     #D,W4
0476E:  MOV     W4,21A
....................    fprintf(RS232,"RCON REGISTER BITLERI:"); 
04770:  MOV     #0,W1
04772:  MOV     W1,W0
04774:  CALL    1428
04778:  INC     W1,W1
0477A:  MOV     W1,[W15++]
0477C:  BTSC.B  219.1
0477E:  BRA     477C
04780:  MOV     W0,21A
04782:  MOV     [--W15],W1
04784:  MOV     #15,W0
04786:  CPSGT   W1,W0
04788:  BRA     4772
....................    fprintf(RS232,"\n\r"); 
0478A:  BTSC.B  219.1
0478C:  BRA     478A
0478E:  MOV     #A,W4
04790:  MOV     W4,21A
04792:  BTSC.B  219.1
04794:  BRA     4792
04796:  MOV     #D,W4
04798:  MOV     W4,21A
....................     
....................    fprintf(RS232,"POR:    "); 
0479A:  MOV     #0,W1
0479C:  MOV     W1,W0
0479E:  CALL    144C
047A2:  INC     W1,W1
047A4:  MOV     W1,[W15++]
047A6:  BTSC.B  219.1
047A8:  BRA     47A6
047AA:  MOV     W0,21A
047AC:  MOV     [--W15],W1
047AE:  MOV     #7,W0
047B0:  CPSGT   W1,W0
047B2:  BRA     479C
....................    fprintf(RS232,"%u",RCON_POR); 
047B4:  CLR.B   W0
047B6:  BTSC.B  740.0
047B8:  INC     W0,W0
047BA:  MOV.B   W0L,W5L
047BC:  MOV.B   W5L,W0L
047BE:  CLR.B   1
047C0:  MOV     #0,W4
047C2:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
047C6:  BTSC.B  219.1
047C8:  BRA     47C6
047CA:  MOV     #A,W4
047CC:  MOV     W4,21A
047CE:  BTSC.B  219.1
047D0:  BRA     47CE
047D2:  MOV     #D,W4
047D4:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BOR:    "); 
047D6:  MOV     #0,W1
047D8:  MOV     W1,W0
047DA:  CALL    1462
047DE:  INC     W1,W1
047E0:  MOV     W1,[W15++]
047E2:  BTSC.B  219.1
047E4:  BRA     47E2
047E6:  MOV     W0,21A
047E8:  MOV     [--W15],W1
047EA:  MOV     #7,W0
047EC:  CPSGT   W1,W0
047EE:  BRA     47D8
....................    fprintf(RS232,"%u",RCON_BOR); 
047F0:  CLR.B   W0
047F2:  BTSC.B  740.1
047F4:  INC     W0,W0
047F6:  MOV.B   W0L,W5L
047F8:  MOV.B   W5L,W0L
047FA:  CLR.B   1
047FC:  MOV     #0,W4
047FE:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
04802:  BTSC.B  219.1
04804:  BRA     4802
04806:  MOV     #A,W4
04808:  MOV     W4,21A
0480A:  BTSC.B  219.1
0480C:  BRA     480A
0480E:  MOV     #D,W4
04810:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IDLE:   "); 
04812:  MOV     #0,W1
04814:  MOV     W1,W0
04816:  CALL    1478
0481A:  INC     W1,W1
0481C:  MOV     W1,[W15++]
0481E:  BTSC.B  219.1
04820:  BRA     481E
04822:  MOV     W0,21A
04824:  MOV     [--W15],W1
04826:  MOV     #7,W0
04828:  CPSGT   W1,W0
0482A:  BRA     4814
....................    fprintf(RS232,"%u",RCON_IDLE); 
0482C:  CLR.B   W0
0482E:  BTSC.B  740.2
04830:  INC     W0,W0
04832:  MOV.B   W0L,W5L
04834:  MOV.B   W5L,W0L
04836:  CLR.B   1
04838:  MOV     #0,W4
0483A:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
0483E:  BTSC.B  219.1
04840:  BRA     483E
04842:  MOV     #A,W4
04844:  MOV     W4,21A
04846:  BTSC.B  219.1
04848:  BRA     4846
0484A:  MOV     #D,W4
0484C:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SLEEP:  "); 
0484E:  MOV     #0,W1
04850:  MOV     W1,W0
04852:  CALL    148E
04856:  INC     W1,W1
04858:  MOV     W1,[W15++]
0485A:  BTSC.B  219.1
0485C:  BRA     485A
0485E:  MOV     W0,21A
04860:  MOV     [--W15],W1
04862:  MOV     #7,W0
04864:  CPSGT   W1,W0
04866:  BRA     4850
....................    fprintf(RS232,"%u",RCON_SLEEP); 
04868:  CLR.B   W0
0486A:  BTSC.B  740.3
0486C:  INC     W0,W0
0486E:  MOV.B   W0L,W5L
04870:  MOV.B   W5L,W0L
04872:  CLR.B   1
04874:  MOV     #0,W4
04876:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
0487A:  BTSC.B  219.1
0487C:  BRA     487A
0487E:  MOV     #A,W4
04880:  MOV     W4,21A
04882:  BTSC.B  219.1
04884:  BRA     4882
04886:  MOV     #D,W4
04888:  MOV     W4,21A
....................     
....................    fprintf(RS232,"WDTO:   "); 
0488A:  MOV     #0,W1
0488C:  MOV     W1,W0
0488E:  CALL    14A4
04892:  INC     W1,W1
04894:  MOV     W1,[W15++]
04896:  BTSC.B  219.1
04898:  BRA     4896
0489A:  MOV     W0,21A
0489C:  MOV     [--W15],W1
0489E:  MOV     #7,W0
048A0:  CPSGT   W1,W0
048A2:  BRA     488C
....................    fprintf(RS232,"%u",RCON_WDTO); 
048A4:  CLR.B   W0
048A6:  BTSC.B  740.4
048A8:  INC     W0,W0
048AA:  MOV.B   W0L,W5L
048AC:  MOV.B   W5L,W0L
048AE:  CLR.B   1
048B0:  MOV     #0,W4
048B2:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
048B6:  BTSC.B  219.1
048B8:  BRA     48B6
048BA:  MOV     #A,W4
048BC:  MOV     W4,21A
048BE:  BTSC.B  219.1
048C0:  BRA     48BE
048C2:  MOV     #D,W4
048C4:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWDTEN: "); 
048C6:  MOV     #0,W1
048C8:  MOV     W1,W0
048CA:  CALL    14BA
048CE:  INC     W1,W1
048D0:  MOV     W1,[W15++]
048D2:  BTSC.B  219.1
048D4:  BRA     48D2
048D6:  MOV     W0,21A
048D8:  MOV     [--W15],W1
048DA:  MOV     #7,W0
048DC:  CPSGT   W1,W0
048DE:  BRA     48C8
....................    fprintf(RS232,"%u",RCON_SWDTEN); 
048E0:  CLR.B   W0
048E2:  BTSC.B  740.5
048E4:  INC     W0,W0
048E6:  MOV.B   W0L,W5L
048E8:  MOV.B   W5L,W0L
048EA:  CLR.B   1
048EC:  MOV     #0,W4
048EE:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
048F2:  BTSC.B  219.1
048F4:  BRA     48F2
048F6:  MOV     #A,W4
048F8:  MOV     W4,21A
048FA:  BTSC.B  219.1
048FC:  BRA     48FA
048FE:  MOV     #D,W4
04900:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWR:    "); 
04902:  MOV     #0,W1
04904:  MOV     W1,W0
04906:  CALL    14D0
0490A:  INC     W1,W1
0490C:  MOV     W1,[W15++]
0490E:  BTSC.B  219.1
04910:  BRA     490E
04912:  MOV     W0,21A
04914:  MOV     [--W15],W1
04916:  MOV     #7,W0
04918:  CPSGT   W1,W0
0491A:  BRA     4904
....................    fprintf(RS232,"%u",RCON_SWR); 
0491C:  CLR.B   W0
0491E:  BTSC.B  740.6
04920:  INC     W0,W0
04922:  MOV.B   W0L,W5L
04924:  MOV.B   W5L,W0L
04926:  CLR.B   1
04928:  MOV     #0,W4
0492A:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
0492E:  BTSC.B  219.1
04930:  BRA     492E
04932:  MOV     #A,W4
04934:  MOV     W4,21A
04936:  BTSC.B  219.1
04938:  BRA     4936
0493A:  MOV     #D,W4
0493C:  MOV     W4,21A
....................     
....................    fprintf(RS232,"EXTR:   "); 
0493E:  MOV     #0,W1
04940:  MOV     W1,W0
04942:  CALL    14E6
04946:  INC     W1,W1
04948:  MOV     W1,[W15++]
0494A:  BTSC.B  219.1
0494C:  BRA     494A
0494E:  MOV     W0,21A
04950:  MOV     [--W15],W1
04952:  MOV     #7,W0
04954:  CPSGT   W1,W0
04956:  BRA     4940
....................    fprintf(RS232,"%u",RCON_EXTR); 
04958:  CLR.B   W0
0495A:  BTSC.B  740.7
0495C:  INC     W0,W0
0495E:  MOV.B   W0L,W5L
04960:  MOV.B   W5L,W0L
04962:  CLR.B   1
04964:  MOV     #0,W4
04966:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
0496A:  BTSC.B  219.1
0496C:  BRA     496A
0496E:  MOV     #A,W4
04970:  MOV     W4,21A
04972:  BTSC.B  219.1
04974:  BRA     4972
04976:  MOV     #D,W4
04978:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BGST:   "); 
0497A:  MOV     #0,W1
0497C:  MOV     W1,W0
0497E:  CALL    14FC
04982:  INC     W1,W1
04984:  MOV     W1,[W15++]
04986:  BTSC.B  219.1
04988:  BRA     4986
0498A:  MOV     W0,21A
0498C:  MOV     [--W15],W1
0498E:  MOV     #7,W0
04990:  CPSGT   W1,W0
04992:  BRA     497C
....................    fprintf(RS232,"%u",RCON_BGST); 
04994:  CLR.B   W0
04996:  BTSC.B  741.5
04998:  INC     W0,W0
0499A:  MOV.B   W0L,W5L
0499C:  MOV.B   W5L,W0L
0499E:  CLR.B   1
049A0:  MOV     #0,W4
049A2:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
049A6:  BTSC.B  219.1
049A8:  BRA     49A6
049AA:  MOV     #A,W4
049AC:  MOV     W4,21A
049AE:  BTSC.B  219.1
049B0:  BRA     49AE
049B2:  MOV     #D,W4
049B4:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IOPUWR: "); 
049B6:  MOV     #0,W1
049B8:  MOV     W1,W0
049BA:  CALL    1512
049BE:  INC     W1,W1
049C0:  MOV     W1,[W15++]
049C2:  BTSC.B  219.1
049C4:  BRA     49C2
049C6:  MOV     W0,21A
049C8:  MOV     [--W15],W1
049CA:  MOV     #7,W0
049CC:  CPSGT   W1,W0
049CE:  BRA     49B8
....................    fprintf(RS232,"%u",RCON_IOPUWR); 
049D0:  CLR.B   W0
049D2:  BTSC.B  741.6
049D4:  INC     W0,W0
049D6:  MOV.B   W0L,W5L
049D8:  MOV.B   W5L,W0L
049DA:  CLR.B   1
049DC:  MOV     #0,W4
049DE:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
049E2:  BTSC.B  219.1
049E4:  BRA     49E2
049E6:  MOV     #A,W4
049E8:  MOV     W4,21A
049EA:  BTSC.B  219.1
049EC:  BRA     49EA
049EE:  MOV     #D,W4
049F0:  MOV     W4,21A
....................     
....................    fprintf(RS232,"TRAPR:  "); 
049F2:  MOV     #0,W1
049F4:  MOV     W1,W0
049F6:  CALL    1528
049FA:  INC     W1,W1
049FC:  MOV     W1,[W15++]
049FE:  BTSC.B  219.1
04A00:  BRA     49FE
04A02:  MOV     W0,21A
04A04:  MOV     [--W15],W1
04A06:  MOV     #7,W0
04A08:  CPSGT   W1,W0
04A0A:  BRA     49F4
....................    fprintf(RS232,"%u",RCON_TRAPR); 
04A0C:  CLR.B   W0
04A0E:  BTSC.B  741.7
04A10:  INC     W0,W0
04A12:  MOV.B   W0L,W5L
04A14:  MOV.B   W5L,W0L
04A16:  CLR.B   1
04A18:  MOV     #0,W4
04A1A:  CALL    1688
....................    fprintf(RS232,"\n\r"); 
04A1E:  BTSC.B  219.1
04A20:  BRA     4A1E
04A22:  MOV     #A,W4
04A24:  MOV     W4,21A
04A26:  BTSC.B  219.1
04A28:  BRA     4A26
04A2A:  MOV     #D,W4
04A2C:  MOV     W4,21A
....................     
....................    fprintf(RS232,"Register Ekrana Yazdirilip Sifirlandi"); 
04A2E:  MOV     #0,W1
04A30:  MOV     W1,W0
04A32:  CALL    153E
04A36:  INC     W1,W1
04A38:  MOV     W1,[W15++]
04A3A:  BTSC.B  219.1
04A3C:  BRA     4A3A
04A3E:  MOV     W0,21A
04A40:  MOV     [--W15],W1
04A42:  MOV     #24,W0
04A44:  CPSGT   W1,W0
04A46:  BRA     4A30
....................    fprintf(RS232,"\n\r"); 
04A48:  BTSC.B  219.1
04A4A:  BRA     4A48
04A4C:  MOV     #A,W4
04A4E:  MOV     W4,21A
04A50:  BTSC.B  219.1
04A52:  BRA     4A50
04A54:  MOV     #D,W4
04A56:  MOV     W4,21A
....................    RCON = 0x0000; 
04A58:  CLR     740
....................     
....................    // Initialize components 
....................    qei_init();                            // Initialize quadrature encoder  
04A5A:  CALL    173E
....................    pwm_init();                            // Initialize PWM module 
04A5E:  CALL    17A4
....................    dp_init();                             // Initialize digital potentiometer 
04A62:  CALL    17E4
....................    md_init();                             // Initialize motor driver 
04A66:  CALL    1D0C
....................    fr_init();                             // Initialize FRAM 
04A6A:  CALL    1D36
....................    move_init();                           // Initializes the system for movement 
04A6E:  CALL    2E94
....................     
....................    // Enable RS232 receive byte interrupt 
....................    enable_interrupts(INT_RDA2); 
04A72:  BSET.B  8F.0
....................    // Enable parallel port strobe signal interrupt 
....................    ext_int_edge(3, H_TO_L); 
04A74:  BSET.B  82.3
....................    enable_interrupts(INT_EXT3); 
04A76:  BSET.B  90.4
....................     
....................    reg_comm_type = data_get_comm_type();  // Set communication type 
04A78:  CALL    2F2C
04A7C:  BCLR.B  800.6
04A7E:  BTSC.B  0.0
04A80:  BSET.B  800.6
....................     
....................    switch (reg_comm_type) 
....................    { 
04A82:  CLR.B   W0
04A84:  BTSC.B  800.6
04A86:  INC     W0,W0
04A88:  CLR.B   1
04A8A:  XOR     #0,W0
04A8C:  BRA     Z,4A94
04A8E:  XOR     #1,W0
04A90:  BRA     Z,4AA0
04A92:  BRA     4AAC
....................       case 0   :  output_high(PP_ACK); 
04A94:  BCLR.B  2D2.4
04A96:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04A98:  BCLR.B  2D2.5
04A9A:  BSET.B  2D6.5
....................                   break; 
04A9C:  GOTO    4AC2
....................       case 1   :  output_low(PP_ACK); 
04AA0:  BCLR.B  2D2.4
04AA2:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
04AA4:  BCLR.B  2D2.5
04AA6:  BCLR.B  2D6.5
....................                   break; 
04AA8:  GOTO    4AC2
....................       default:    output_high(PP_ACK); 
04AAC:  BCLR.B  2D2.4
04AAE:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04AB0:  BCLR.B  2D2.5
04AB2:  BSET.B  2D6.5
....................                   fr_write_byte(fr_comm_type, 0); 
04AB4:  CLR.B   8AE
04AB6:  PUSH    83E
04AB8:  POP     8AC
04ABA:  CALL    237A
....................                   break; 
04ABE:  GOTO    4AC2
....................    } 
....................     
....................       while(true) 
....................    { 
....................       if(reg_rs232_message) 
04AC2:  BTSS.B  84C.3
04AC4:  BRA     4AD0
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04AC6:  BCLR.B  8F.0
....................  
....................          rs232_message(); 
04AC8:  CALL    3648
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
....................          enable_interrupts(INT_RDA2); 
04ACC:  BSET.B  8F.0
....................          reg_rs232_message = 0; 
04ACE:  BCLR.B  84C.3
....................       } 
....................       if(reg_pp_strobe) 
04AD0:  BTSS.B  84C.0
04AD2:  BRA     4B58
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04AD4:  BCLR.B  8F.0
....................           
....................          reg_pp_strobe=0; 
04AD6:  BCLR.B  84C.0
....................           
....................          if(debug_mode_pp) 
04AD8:  BTSS.B  800.1
04ADA:  BRA     4AF6
....................             fprintf(RS232,"Strobe received\n\r"); 
04ADC:  MOV     #0,W1
04ADE:  MOV     W1,W0
04AE0:  CALL    AA6
04AE4:  INC     W1,W1
04AE6:  MOV     W1,[W15++]
04AE8:  BTSC.B  219.1
04AEA:  BRA     4AE8
04AEC:  MOV     W0,21A
04AEE:  MOV     [--W15],W1
04AF0:  MOV     #10,W0
04AF2:  CPSGT   W1,W0
04AF4:  BRA     4ADE
....................  
....................          unsigned int i; 
....................          for(i=0; i<pp_str_check; i++) 
04AF6:  CLR     850
04AF8:  MOV     850,W0
04AFA:  MOV     844,W4
04AFC:  CP      W4,W0
04AFE:  BRA     LEU,4B32
....................          { 
....................             delay_ms(pp_str_delay); 
04B00:  MOV     846,W0
04B02:  CALL    1674
....................             if(input(PP_STR)==1) 
04B06:  BSET.B  2D3.2
04B08:  BTSS.B  2D5.2
04B0A:  BRA     4B2C
....................             { 
....................                if(debug_mode_pp) 
04B0C:  BTSS.B  800.1
04B0E:  BRA     4B2A
....................                   fprintf(RS232,"Strobe signal rejected\n\r"); 
04B10:  MOV     #0,W1
04B12:  MOV     W1,W0
04B14:  CALL    AC4
04B18:  INC     W1,W1
04B1A:  MOV     W1,[W15++]
04B1C:  BTSC.B  219.1
04B1E:  BRA     4B1C
04B20:  MOV     W0,21A
04B22:  MOV     [--W15],W1
04B24:  MOV     #17,W0
04B26:  CPSGT   W1,W0
04B28:  BRA     4B12
....................                return; 
04B2A:  BRA     4B5C
....................             } 
....................          } 
04B2C:  INC     0850
04B2E:  GOTO    4AF8
....................           
....................          if(debug_mode_pp) 
04B32:  BTSS.B  800.1
04B34:  BRA     4B50
....................             fprintf(RS232,"Strobe confirmed\n\r"); 
04B36:  MOV     #0,W1
04B38:  MOV     W1,W0
04B3A:  CALL    AEA
04B3E:  INC     W1,W1
04B40:  MOV     W1,[W15++]
04B42:  BTSC.B  219.1
04B44:  BRA     4B42
04B46:  MOV     W0,21A
04B48:  MOV     [--W15],W1
04B4A:  MOV     #11,W0
04B4C:  CPSGT   W1,W0
04B4E:  BRA     4B38
....................  
....................          pp_get_command(); 
04B50:  CALL    44D0
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
....................          enable_interrupts(INT_RDA2); 
04B54:  BSET.B  8F.0
....................          reg_rs232_message = 0; 
04B56:  BCLR.B  84C.3
....................       } 
....................    } 
04B58:  GOTO    4AC2
.................... } 
04B5C:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C713   NOCKSFSM HS2_PLL16 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 87B3   PUT64 BROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F   WRTB NOBSS NOEBS NORBS
          H: 0000  
   Word  5L: 330F   NOWRTSS NOSSS NORSS NOESS
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  

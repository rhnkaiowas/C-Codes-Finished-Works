CCS PCM C Compiler, Version 5.008, 5967               18-Eyl-14 11:34

               Filename:   E:\File Server\Modesis\Proje Dosyalarý\DLM - Düzlemsel Konumlama Sistemi\Software\kalibrasyon_paralel_0.150\256x\Motor Ayarlarý\X Motoru.lst

               ROM used:   1546 words (75%)
                           Largest free fragment is 501
               RAM used:   28 (8%) at main() level
                           56 (17%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   5B4
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  CLRF   05
0010:  MOVLW  91
0011:  MOVWF  04
0012:  BTFSS  00.5
0013:  GOTO   016
0014:  BTFSC  11.5
0015:  GOTO   116
0016:  MOVF   20,W
0017:  MOVWF  77
0018:  MOVF   21,W
0019:  MOVWF  78
001A:  MOVF   22,W
001B:  MOVWF  79
001C:  MOVF   23,W
001D:  MOVWF  7A
001E:  RETFIE
.................... #INCLUDE <16f1826.h>  
.................... //////// Standard Header file for the PIC16F1826 device //////////////// 
.................... #device PIC16F1826 
001F:  DATA 43,2A
0020:  DATA 52,26
0021:  DATA 20,29
0022:  DATA E5,33
0023:  DATA E9,39
0024:  DATA F4,32
0025:  DATA F2,04
0026:  DATA 3A,10
0027:  DATA 00,00
0028:  DATA 43,2A
0029:  DATA 52,26
002A:  DATA 20,29
002B:  DATA E5,33
002C:  DATA E9,39
002D:  DATA F4,32
002E:  DATA F2,04
002F:  DATA 3A,10
0030:  DATA 00,00
0031:  DATA 43,2A
0032:  DATA 52,26
0033:  DATA 20,29
0034:  DATA E5,33
0035:  DATA E9,39
0036:  DATA F4,32
0037:  DATA F2,04
0038:  DATA 3A,10
0039:  DATA 00,00
003A:  DATA 43,2A
003B:  DATA 52,26
003C:  DATA 20,29
003D:  DATA E5,33
003E:  DATA E9,39
003F:  DATA F4,32
0040:  DATA F2,04
0041:  DATA 3A,10
0042:  DATA 00,00
0043:  DATA 43,2A
0044:  DATA 52,26
0045:  DATA 20,29
0046:  DATA E5,33
0047:  DATA E9,39
0048:  DATA F4,32
0049:  DATA F2,04
004A:  DATA 3A,10
004B:  DATA 00,00
004C:  DATA 43,2A
004D:  DATA 52,26
004E:  DATA 20,29
004F:  DATA E5,33
0050:  DATA E9,39
0051:  DATA F4,32
0052:  DATA F2,04
0053:  DATA 3A,10
0054:  DATA 00,00
0055:  DATA 43,2A
0056:  DATA 52,26
0057:  DATA 20,29
0058:  DATA E5,33
0059:  DATA E9,39
005A:  DATA F4,32
005B:  DATA F2,04
005C:  DATA 3A,10
005D:  DATA 00,00
005E:  DATA 43,2A
005F:  DATA 52,26
0060:  DATA 20,29
0061:  DATA E5,33
0062:  DATA E9,39
0063:  DATA F4,32
0064:  DATA F2,04
0065:  DATA 3A,10
0066:  DATA 00,00
0067:  DATA D4,27
0068:  DATA D2,28
0069:  DATA D5,22
006A:  DATA 20,29
006B:  DATA E5,33
006C:  DATA E9,39
006D:  DATA F4,32
006E:  DATA F2,04
006F:  DATA 3A,10
0070:  DATA 00,00
0071:  DATA D4,27
0072:  DATA D2,28
0073:  DATA D5,22
0074:  DATA 20,29
0075:  DATA E5,33
0076:  DATA E9,39
0077:  DATA F4,32
0078:  DATA F2,04
0079:  DATA 3A,10
007A:  DATA 00,00
007B:  DATA D4,27
007C:  DATA D2,28
007D:  DATA D5,22
007E:  DATA 20,29
007F:  DATA E5,33
0080:  DATA E9,39
0081:  DATA F4,32
0082:  DATA F2,04
0083:  DATA 3A,10
0084:  DATA 00,00
0085:  DATA D4,27
0086:  DATA 46,23
0087:  DATA 20,29
0088:  DATA E5,33
0089:  DATA E9,39
008A:  DATA F4,32
008B:  DATA F2,04
008C:  DATA 3A,10
008D:  DATA 00,00
008E:  DATA D4,27
008F:  DATA 46,23
0090:  DATA 20,29
0091:  DATA E5,33
0092:  DATA E9,39
0093:  DATA F4,32
0094:  DATA F2,04
0095:  DATA 3A,10
0096:  DATA 00,00
0097:  DATA D4,27
0098:  DATA 46,23
0099:  DATA 20,29
009A:  DATA E5,33
009B:  DATA E9,39
009C:  DATA F4,32
009D:  DATA F2,04
009E:  DATA 3A,10
009F:  DATA 00,00
00A0:  DATA 42,26
00A1:  DATA 41,27
00A2:  DATA 4B,10
00A3:  DATA D2,32
00A4:  DATA E7,34
00A5:  DATA 73,3A
00A6:  DATA 65,39
00A7:  DATA 09,1D
00A8:  DATA 20,00
00A9:  DATA 42,26
00AA:  DATA 41,27
00AB:  DATA 4B,10
00AC:  DATA D2,32
00AD:  DATA E7,34
00AE:  DATA 73,3A
00AF:  DATA 65,39
00B0:  DATA 09,1D
00B1:  DATA 20,00
00B2:  DATA 42,26
00B3:  DATA 41,27
00B4:  DATA 4B,10
00B5:  DATA D2,32
00B6:  DATA E7,34
00B7:  DATA 73,3A
00B8:  DATA 65,39
00B9:  DATA 09,1D
00BA:  DATA 20,00
00BB:  DATA C4,22
00BC:  DATA C3,20
00BD:  DATA 59,10
00BE:  DATA D2,32
00BF:  DATA E7,34
00C0:  DATA 73,3A
00C1:  DATA 65,39
00C2:  DATA 09,1D
00C3:  DATA 20,00
00C4:  DATA C4,22
00C5:  DATA C3,20
00C6:  DATA 59,10
00C7:  DATA D2,32
00C8:  DATA E7,34
00C9:  DATA 73,3A
00CA:  DATA 65,39
00CB:  DATA 09,1D
00CC:  DATA 20,00
00CD:  DATA C4,22
00CE:  DATA C3,20
00CF:  DATA 59,10
00D0:  DATA D2,32
00D1:  DATA E7,34
00D2:  DATA 73,3A
00D3:  DATA 65,39
00D4:  DATA 09,1D
00D5:  DATA 20,00
00D6:  DATA 53,2A
00D7:  DATA 41,26
00D8:  DATA 4C,10
00D9:  DATA D2,32
00DA:  DATA E7,34
00DB:  DATA 73,3A
00DC:  DATA 65,39
00DD:  DATA 09,1D
00DE:  DATA 20,00
00DF:  DATA 53,2A
00E0:  DATA 41,26
00E1:  DATA 4C,10
00E2:  DATA D2,32
00E3:  DATA E7,34
00E4:  DATA 73,3A
00E5:  DATA 65,39
00E6:  DATA 09,1D
00E7:  DATA 20,00
00E8:  DATA 53,2A
00E9:  DATA 41,26
00EA:  DATA 4C,10
00EB:  DATA D2,32
00EC:  DATA E7,34
00ED:  DATA 73,3A
00EE:  DATA 65,39
00EF:  DATA 09,1D
00F0:  DATA 20,00
00F1:  DATA 53,2A
00F2:  DATA 41,26
00F3:  DATA 4C,10
00F4:  DATA D2,32
00F5:  DATA E7,34
00F6:  DATA 73,3A
00F7:  DATA 65,39
00F8:  DATA 09,1D
00F9:  DATA 20,00
00FA:  DATA 44,29
00FB:  DATA 49,2B
00FC:  DATA 45,10
00FD:  DATA D2,32
00FE:  DATA E7,34
00FF:  DATA 73,3A
0100:  DATA 65,39
0101:  DATA 09,1D
0102:  DATA 20,00
0103:  DATA 53,2A
0104:  DATA 41,2A
0105:  DATA D5,29
0106:  DATA 20,29
0107:  DATA E5,33
0108:  DATA E9,39
0109:  DATA F4,32
010A:  DATA F2,04
010B:  DATA 3A,10
010C:  DATA 00,00
010D:  DATA 44,39
010E:  DATA 69,3B
010F:  DATA 65,39
0110:  DATA 20,22
0111:  DATA 65,31
0112:  DATA F5,33
0113:  DATA 3A,10
0114:  DATA A5,3A
0115:  DATA 00,00
*
0159:  MOVF   0B,W
015A:  MOVWF  3E
015B:  BCF    0B.7
015C:  MOVLB  03
015D:  BSF    15.7
015E:  BSF    15.0
015F:  NOP
0160:  NOP
0161:  MOVF   13,W
0162:  ANDLW  7F
0163:  BTFSC  03.2
0164:  GOTO   1A0
0165:  MOVLB  00
0166:  MOVWF  3F
0167:  MOVLB  03
0168:  MOVF   11,W
0169:  MOVLB  00
016A:  MOVWF  40
016B:  MOVLB  03
016C:  MOVF   12,W
016D:  MOVLB  00
016E:  MOVWF  41
016F:  MOVF   3F,W
0170:  BTFSS  11.4
0171:  GOTO   170
0172:  MOVLB  03
0173:  MOVWF  1A
0174:  MOVLB  00
0175:  MOVF   40,W
0176:  MOVLB  03
0177:  MOVWF  11
0178:  MOVLB  00
0179:  MOVF   41,W
017A:  MOVLB  03
017B:  MOVWF  12
017C:  BSF    15.7
017D:  BSF    15.0
017E:  NOP
017F:  NOP
0180:  RLF    13,W
0181:  RLF    14,W
0182:  ANDLW  7F
0183:  BTFSC  03.2
0184:  GOTO   1A0
0185:  MOVLB  00
0186:  MOVWF  3F
0187:  MOVLB  03
0188:  MOVF   11,W
0189:  MOVLB  00
018A:  MOVWF  40
018B:  MOVLB  03
018C:  MOVF   12,W
018D:  MOVLB  00
018E:  MOVWF  41
018F:  MOVF   3F,W
0190:  BTFSS  11.4
0191:  GOTO   190
0192:  MOVLB  03
0193:  MOVWF  1A
0194:  MOVLB  00
0195:  MOVF   40,W
0196:  MOVLB  03
0197:  MOVWF  11
0198:  MOVLB  00
0199:  MOVF   41,W
019A:  MOVLB  03
019B:  MOVWF  12
019C:  INCF   11,F
019D:  BTFSC  03.2
019E:  INCF   12,F
019F:  GOTO   15D
01A0:  MOVLB  00
01A1:  BTFSC  3E.7
01A2:  BSF    0B.7
01A3:  RETURN
*
020F:  MOVF   05,W
0210:  MOVWF  48
0211:  MOVF   04,W
0212:  MOVWF  47
0213:  SWAPF  41,W
0214:  IORLW  F0
0215:  MOVWF  43
0216:  ADDWF  43,F
0217:  ADDLW  E2
0218:  MOVWF  44
0219:  ADDLW  32
021A:  MOVWF  46
021B:  MOVF   41,W
021C:  ANDLW  0F
021D:  ADDWF  44,F
021E:  ADDWF  44,F
021F:  ADDWF  46,F
0220:  ADDLW  E9
0221:  MOVWF  45
0222:  ADDWF  45,F
0223:  ADDWF  45,F
0224:  SWAPF  40,W
0225:  ANDLW  0F
0226:  ADDWF  45,F
0227:  ADDWF  46,F
0228:  RLF    45,F
0229:  RLF    46,F
022A:  COMF   46,F
022B:  RLF    46,F
022C:  MOVF   40,W
022D:  ANDLW  0F
022E:  ADDWF  46,F
022F:  RLF    43,F
0230:  MOVLW  07
0231:  MOVWF  42
0232:  MOVLW  0A
0233:  ADDWF  46,F
0234:  DECF   45,F
0235:  BTFSS  03.0
0236:  GOTO   233
0237:  ADDWF  45,F
0238:  DECF   44,F
0239:  BTFSS  03.0
023A:  GOTO   237
023B:  ADDWF  44,F
023C:  DECF   43,F
023D:  BTFSS  03.0
023E:  GOTO   23B
023F:  ADDWF  43,F
0240:  DECF   42,F
0241:  BTFSS  03.0
0242:  GOTO   23F
0243:  CLRF   05
0244:  MOVLW  42
0245:  MOVWF  04
0246:  MOVLW  07
0247:  ANDWF  47,W
0248:  BCF    47.6
0249:  ADDWF  04,F
024A:  MOVLW  46
024B:  SUBWF  04,W
024C:  BTFSC  03.2
024D:  BSF    47.6
024E:  MOVF   00,W
024F:  MOVWF  77
0250:  BTFSS  03.2
0251:  GOTO   25A
0252:  BTFSC  47.6
0253:  GOTO   25A
0254:  BTFSC  47.4
0255:  GOTO   264
0256:  BTFSC  47.3
0257:  GOTO   25A
0258:  MOVLW  20
0259:  GOTO   25D
025A:  BSF    47.3
025B:  BCF    47.4
025C:  MOVLW  30
025D:  ADDWF  77,F
025E:  MOVF   77,W
025F:  BTFSS  11.4
0260:  GOTO   25F
0261:  MOVLB  03
0262:  MOVWF  1A
0263:  MOVLB  00
0264:  ADDFSR 01,FSR0
0265:  BTFSS  47.6
0266:  GOTO   24A
....................  
.................... #list 
....................  
....................  
.................... #FUSES INTRC_IO      // Internal RC clock (OSC1 and OSC2 pins are normal I/O) 
.................... #FUSES NOWDT         // Watch Dog Timer disabled 
.................... #FUSES PUT           // Power Up Timer enabled 
.................... #FUSES NOMCLR        // Master Clear pin is used for I/O 
.................... #FUSES PROTECT       // Code protected from reads 
.................... #FUSES CPD           // Data EEPROM code protected 
.................... #FUSES BROWNOUT      // Brownout Reset enabled 
.................... #FUSES BORV25        // Brownout Reset at 2.5V 
.................... #FUSES NOCLKOUT      // Disable clock output on OSC2 
.................... #FUSES NOIESO        // Internal External Switch Over Mode disabled 
.................... #FUSES NOFCMEN       // Fail-safe clock monitor disabled 
.................... #FUSES WRT           // Program memory write protected                                               
.................... #FUSES NOLVP         // Low Voltage Programming disabled 
....................  
.................... #USE   DELAY(internal = 32MHz) 
*
011F:  MOVLW  20
0120:  MOVWF  05
0121:  MOVWF  04
0122:  MOVF   00,W
0123:  BTFSC  03.2
0124:  GOTO   132
0125:  MOVLW  0A
0126:  MOVWF  78
0127:  CLRF   77
0128:  DECFSZ 77,F
0129:  GOTO   128
012A:  DECFSZ 78,F
012B:  GOTO   127
012C:  MOVLW  5F
012D:  MOVWF  77
012E:  DECFSZ 77,F
012F:  GOTO   12E
0130:  DECFSZ 00,F
0131:  GOTO   125
0132:  RETURN
*
05A1:  MOVLW  02
05A2:  SUBWF  38,F
05A3:  BTFSS  03.0
05A4:  GOTO   5B2
05A5:  MOVLW  20
05A6:  MOVWF  05
05A7:  MOVLW  18
05A8:  MOVWF  04
05A9:  MOVF   00,W
05AA:  BTFSC  03.2
05AB:  GOTO   5B2
05AC:  GOTO   5B0
05AD:  GOTO   5AE
05AE:  GOTO   5AF
05AF:  NOP
05B0:  DECFSZ 00,F
05B1:  GOTO   5AD
05B2:  MOVLP  00
05B3:  GOTO   608 (RETURN)
.................... #USE   RS232(stream=RS232, baud=38400, xmit=PIN_B5, rcv=PIN_B2, parity=N, bits=8, stop=1) 
....................  
.................... #DEFINE DRV_STEP           PIN_A0                  // Step output pin to driver (Rising edge causes the indexer to move one step) 
.................... #DEFINE DRV_RESET          PIN_A1                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.) 
.................... #DEFINE DRV_DIR            PIN_A4                  // Direction output pin to driver (Logic level, sets the direction of stepping) 
.................... #DEFINE SPI_SDO            PIN_A6                  // SPI data output pin 
.................... #DEFINE SPI_CS             PIN_A7                  // SPI chip select pin 
.................... #DEFINE SPI_SDI            PIN_B1                  // SPI data input pin 
.................... #DEFINE SPI_SCK            PIN_B4                  // SPI clock output pin 
.................... #DEFINE DRV_STALL          PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut) 
.................... #DEFINE DRV_FAULT          PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut) 
....................  
.................... #DEFINE LIMIT_SWITCH       PIN_A2                  // Fault output pin to user 
.................... #DEFINE USER_DIR           PIN_A3                  // Direction input pin from user 
.................... #DEFINE USER_STEP          PIN_B0                  // Step input pin from user 
.................... #DEFINE HOME_SWITCH        PIN_B3                  // Enable input pin from user 
....................  
.................... // Interrupt On Change Registers 
.................... #WORD IOC_INTCON     =0x00B 
.................... #WORD IOC_IOCBP      =0x394 
.................... #WORD IOC_IOCBN      =0x395 
.................... #WORD IOC_IOCBF      =0x396 
.................... #WORD ANSELB         =0x18d 
....................  
.................... //Bits of IOC_INTCON register 
.................... #BIT IOC_GIE           = IOC_INTCON.7        //General interrupt enable bit 
.................... #BIT IOC_PEIE          = IOC_INTCON.6        //Peripheral interrupt enable bit 
.................... #BIT IOC_IOCIE         = IOC_INTCON.3        //Interrupt on change enable bit 
....................  
.................... //Bits of IOC_IOCBP register 
.................... #BIT IOC_PINB0_RISING            = IOC_IOCBP.0        //Pin B3 interrupt on change enable bit(Rising Edge) 
.................... #BIT IOC_PINB3_RISING            = IOC_IOCBP.3        //Pin B3 interrupt on change enable bit(Rising Edge) 
....................  
.................... //Bits of IOC_IOCBN register 
.................... #BIT IOC_PINB0_FALLING           = IOC_IOCBN.0        //Pin B3 interrupt on change enable bit(Falling Edge) 
.................... #BIT IOC_PINB3_FALLING           = IOC_IOCBN.3        //Pin B3 interrupt on change enable bit(Rising Edge) 
.................... /* 
.................... //Bits of IOC_IOCBF register 
.................... #BIT IOC_PINB3_FLAG              = IOC_IOCBF.3        //Pin B3 interrupt on change interrupt flag bit(Both Rising and Falling Edges) 
.................... #BIT IOC_PINB3_FLAG              = IOC_IOCBP.3        //Pin B3 interrupt on change enable bit(Rising Edge) 
....................  
.................... //Bits of ANSELB register 
.................... #BIT ANSELB_PINB3                = ANSELB.3           //Selection of Pin B3 as a Digial I/O (0) or an Analog input (1) selection bit 
.................... */ 
.................... // SPI Registers 
.................... #WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register 
.................... #WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register 
.................... #WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register 
.................... #WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register 
.................... // Pin function control registers 
.................... #WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0 
.................... #WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1 
....................  
.................... // Bits of SSP1CON1 register 
.................... #BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit 
.................... #BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit 
.................... #BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit 
.................... #BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits 
.................... #BIT SPI_MODE_2         = SPI_SSP1CON1.2    
.................... #BIT SPI_MODE_1         = SPI_SSP1CON1.1    
.................... #BIT SPI_MODE_0         = SPI_SSP1CON1.0   
....................  
.................... // Bits of SPI_SSP1STAT register 
.................... #BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit 
.................... #BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit 
.................... #BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit 
....................  
.................... // Bits of SPI_PIR1 register 
.................... #BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit 
....................  
.................... // Bits of PIN_APFCON0 register 
.................... //#BIT PIN_RX_SELECT      = PIN_APFCON0.7      // RX pin selection bit 
.................... #BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit  
.................... #BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit  
....................  
.................... // Bits of PIN_APFCON1 register 
.................... //#BIT PIN_TX_SELECT      = PIN_APFCON1.0      // TX pin selection bit 
....................  
.................... // CTRL register of the driver 
.................... unsigned int16 reg_ctrl = 0; 
.................... // TORQUE register of the driver 
.................... unsigned int16 reg_torque = 0; 
.................... // OFF register of the driver 
.................... unsigned int16 reg_off = 0; 
.................... // BLANK register of the driver 
.................... unsigned int16 reg_blank = 0; 
.................... // DECAY register of the driver 
.................... unsigned int16 reg_decay = 0; 
.................... // STALL register of the driver 
.................... unsigned int16 reg_stall = 0; 
.................... // DRIVE register of the driver 
.................... unsigned int16 reg_drive = 0; 
.................... // STATUS register of the driver 
.................... unsigned int16 reg_status = 0; 
.................... // Driver debug mode 
.................... int1 drv_debug = 1; 
....................  
.................... char reg_rs232_message = 0; 
....................  
.................... unsigned int delay = 30; 
....................  
.................... // Sets alternative pin functions 
.................... void set_pins() 
.................... { 
....................    // Set RB2 as RX pin 
....................    //PIN_RX_SELECT = 1; 
....................    // Set RA6 as SDO pin 
....................    PIN_SDO_SELECT = 1; 
*
0133:  MOVLB  02
0134:  BSF    1D.6
....................    // Set RA5 as SS pin 
....................    PIN_SS_SELECT = 1; 
0135:  BSF    1D.5
0136:  MOVLP  00
0137:  MOVLB  00
0138:  GOTO   5E8 (RETURN)
....................    // Set RB5 as TX pin 
.................... } 
.................... // Sets SPI parameters 
.................... void set_SPI() 
.................... { 
....................    // Disable SPI to set registers 
....................    SPI_ENABLE = 0; 
0139:  MOVLB  04
013A:  BCF    15.5
....................    // Set idle state of the clock to low  
....................    SPI_CLOCK_POLARITY = 0; 
013B:  BCF    15.4
....................    // Set SPI mode to SPI  
....................    SPI_MODE_3 = 0;  
013C:  BCF    15.3
....................    SPI_MODE_2 = 0; 
013D:  BCF    15.2
....................    SPI_MODE_1 = 1; 
013E:  BSF    15.1
....................    SPI_MODE_0 = 0; 
013F:  BCF    15.0
....................    // Input data sampled at the middle of data output time 
....................    SPI_INPUT_SAMPLE = 0; 
0140:  BCF    14.7
....................    // Transmit occurs on transition from active to idle clock state 
....................    SPI_CLOCK_EDGE = 1; 
0141:  BSF    14.6
....................  
....................    // Enable SPI 
....................    SPI_ENABLE = 1; 
0142:  BSF    15.5
0143:  MOVLP  00
0144:  MOVLB  00
0145:  GOTO   5E9 (RETURN)
.................... } 
.................... // Sets variables to default values  
.................... void set_variables() 
.................... { 
....................    output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction  
0146:  MOVLB  01
0147:  BCF    0C.7
0148:  MOVLB  02
0149:  BCF    0C.7
....................    output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver  
014A:  MOVLB  01
014B:  BCF    0C.1
014C:  MOVLB  02
014D:  BCF    0C.1
....................    output_low(DRV_DIR);    // Set default direction 
014E:  MOVLB  01
014F:  BCF    0C.4
0150:  MOVLB  02
0151:  BCF    0C.4
....................    output_low(DRV_STEP);   // Keep step output low until a step command is received from the user 
0152:  MOVLB  01
0153:  BCF    0C.0
0154:  MOVLB  02
0155:  BCF    0C.0
0156:  MOVLP  00
0157:  MOVLB  00
0158:  GOTO   5EA (RETURN)
.................... } 
....................  
.................... // Writes the given register byte to the driver 
.................... void write_register_byte(unsigned int8 reg_byte) 
.................... { 
....................    // write the byte to spi buffer 
....................    SPI_SSP1BUF = reg_byte; 
*
01FC:  MOVLB  04
01FD:  CLRF   12
01FE:  MOVLB  00
01FF:  MOVF   41,W
0200:  MOVLB  04
0201:  MOVWF  11
....................    // Wait until the end of the write operation 
....................    while (!SPI_FLAG); 
0202:  MOVLB  00
0203:  BTFSS  11.3
0204:  GOTO   203
....................    // Clear the write-completed-flag of the spi module 
....................    SPI_FLAG = 0; 
0205:  BCF    11.3
0206:  RETURN
.................... } 
.................... // Writes the given register to the driver 
.................... void write_register(unsigned int16 reg) 
.................... { 
....................    if(drv_debug) 
0207:  BTFSS  34.0
0208:  GOTO   273
....................       fprintf(RS232,"%Lu\n\r", reg); 
0209:  MOVLW  10
020A:  MOVWF  04
020B:  MOVF   3F,W
020C:  MOVWF  41
020D:  MOVF   3E,W
020E:  MOVWF  40
*
0267:  MOVLW  0A
0268:  BTFSS  11.4
0269:  GOTO   268
026A:  MOVLB  03
026B:  MOVWF  1A
026C:  MOVLW  0D
026D:  MOVLB  00
026E:  BTFSS  11.4
026F:  GOTO   26E
0270:  MOVLB  03
0271:  MOVWF  1A
0272:  MOVLB  00
....................     
....................    // start spi write operation by setting the chip select port to high 
....................    output_high(SPI_CS); 
0273:  MOVLB  01
0274:  BCF    0C.7
0275:  MOVLB  02
0276:  BSF    0C.7
....................    // Get and write the MSB of the register 
....................    write_register_byte(make8(reg, 1)); 
0277:  MOVLB  00
0278:  MOVF   3F,W
0279:  MOVWF  40
027A:  MOVWF  41
027B:  CALL   1FC
....................    // Get and write the MSB of the register 
....................    write_register_byte(make8(reg, 0)); 
027C:  MOVF   3E,W
027D:  MOVWF  40
027E:  MOVWF  41
027F:  CALL   1FC
....................    // stop spi write operation by setting the chip select port to low 
....................    output_low(SPI_CS); 
0280:  MOVLB  01
0281:  BCF    0C.7
0282:  MOVLB  02
0283:  BCF    0C.7
....................    delay_ms(10); 
0284:  MOVLW  0A
0285:  MOVLB  00
0286:  MOVWF  40
0287:  CALL   11F
0288:  RETURN
.................... } 
.................... // Sets the given number of bits of the register from starting address to the given value 
.................... unsigned int16 set_register_bits(unsigned int16 reg, unsigned int8 bit_address, unsigned int8 bit_size, unsigned int16 value) 
.................... { 
....................    // bit address must be smaller then register size (16 bit) 
....................    if(bit_address > 15) return 0; 
*
01A4:  MOVF   40,W
01A5:  SUBLW  0F
01A6:  BTFSC  03.0
01A7:  GOTO   1AC
01A8:  MOVLW  00
01A9:  MOVWF  78
01AA:  MOVWF  79
01AB:  GOTO   1FB
....................    // bit size can't be larger then the number of bits between the given address and the last bit of the register 
....................    if(bit_size > (16 - bit_address)) return 0; 
01AC:  MOVF   40,W
01AD:  SUBLW  10
01AE:  SUBWF  41,W
01AF:  BTFSC  03.2
01B0:  GOTO   1B7
01B1:  BTFSS  03.0
01B2:  GOTO   1B7
01B3:  MOVLW  00
01B4:  MOVWF  78
01B5:  MOVWF  79
01B6:  GOTO   1FB
....................     
....................    //fprintf(RS232,"reg: %Lu adr: %u size: %u val: %lu\n\r", reg, bit_address, bit_size, value); 
....................     
....................    // Get the bits of the "value" and set it to the corresponding bit in the given address 
....................    for(int i=0; i<bit_size; i++) 
01B7:  CLRF   44
01B8:  MOVF   41,W
01B9:  SUBWF  44,W
01BA:  BTFSC  03.0
01BB:  GOTO   1F7
....................    { 
....................       if(bit_test(value, i) == 1) 
01BC:  MOVF   43,W
01BD:  MOVWF  7A
01BE:  MOVF   42,W
01BF:  MOVWF  79
01C0:  MOVF   44,W
01C1:  MOVWF  77
01C2:  BTFSC  03.2
01C3:  GOTO   1C8
01C4:  LSRF   7A,F
01C5:  RRF    79,F
01C6:  DECFSZ 77,F
01C7:  GOTO   1C4
01C8:  MOVF   79,W
01C9:  BTFSS  79.0
01CA:  GOTO   1DE
....................          bit_set(reg, bit_address + i); 
01CB:  MOVF   44,W
01CC:  ADDWF  40,W
01CD:  MOVWF  45
01CE:  CLRF   7A
01CF:  MOVLW  01
01D0:  MOVWF  79
01D1:  MOVF   45,W
01D2:  MOVWF  77
01D3:  BTFSC  03.2
01D4:  GOTO   1D9
01D5:  LSLF   79,F
01D6:  RLF    7A,F
01D7:  DECFSZ 77,F
01D8:  GOTO   1D5
01D9:  MOVF   79,W
01DA:  IORWF  3E,F
01DB:  MOVF   7A,W
01DC:  IORWF  3F,F
01DD:  GOTO   1F5
....................       else 
....................          bit_clear(reg, bit_address + i); 
01DE:  MOVF   44,W
01DF:  ADDWF  40,W
01E0:  MOVWF  45
01E1:  CLRF   7A
01E2:  MOVLW  01
01E3:  MOVWF  79
01E4:  MOVF   45,W
01E5:  MOVWF  77
01E6:  BTFSC  03.2
01E7:  GOTO   1EC
01E8:  LSLF   79,F
01E9:  RLF    7A,F
01EA:  DECFSZ 77,F
01EB:  GOTO   1E8
01EC:  MOVF   79,W
01ED:  XORLW  FF
01EE:  MOVWF  77
01EF:  MOVLW  FF
01F0:  XORWF  7A,F
01F1:  MOVF   77,W
01F2:  ANDWF  3E,F
01F3:  MOVF   7A,W
01F4:  ANDWF  3F,F
01F5:  INCF   44,F
01F6:  GOTO   1B8
....................    } 
....................     
....................    //fprintf(RS232,"reg: %Lu\n\r", reg); 
....................     
....................    return reg; 
01F7:  MOVF   3E,W
01F8:  MOVWF  78
01F9:  MOVF   3F,W
01FA:  MOVWF  79
01FB:  RETURN
.................... } 
.................... /* 
.................... // Driver common register variables 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 000: CTRL register 
.................... //                                                             001: TORQUE register 
.................... //                                                             010: OFF register 
.................... //                                                             011: BLANK register 
.................... //                                                             100: DECAY register 
.................... //                                                             101: STALL register 
.................... //                                                             110: DRIVE register 
.................... //                                                             111: STATUS register 
.................... */ 
.................... enum reg_type           {type_ctrl = 0, type_torque = 1, type_off = 2, type_blank = 3, type_decay = 4, type_stall = 5, type_drive = 6, type_status = 7}; 
.................... enum op_type            {op_write = 0, op_read = 1}; 
.................... enum reg_common_mask    {reg_type_addr = 12, op_type_addr = 15}; 
.................... enum reg_common_size    {reg_type_size = 3, op_type_size = 1}; 
.................... /* 
.................... // CTRL register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 000: CTRL reg 
.................... // DTIME (dead time btw MOSFET switching)    (R/W) (bit 11-10) 00: 400 ns,  
.................... //                                                             01: 450 ns,  
.................... //                                                             10: 650 ns,  
.................... //                                                             11: 850 ns 
.................... // ISGain (current amplifier gain)           (R/W) (bit 9-8)   00: Gain of 5,  
.................... //                                                             01: Gain of 10,  
.................... //                                                             10: Gain of 20,  
.................... //                                                             11: Gain of 40 
.................... // EXSTALL (source of stall detection)       (R/W) (bit 7)     0: Internal 
.................... //                                                             1: External 
.................... // MODE (microstepping mode)                 (R/W) (bit 6-3)   0000: Full-step, 71% current 
.................... //                                                             0001: Half step 
.................... //                                                             0010: 1/4 step 
.................... //                                                             0011: 1/8 step 
.................... //                                                             0100: 1/16 step 
.................... //                                                             0101: 1/32 step 
.................... //                                                             0110: 1/64 step 
.................... //                                                             0111: 1/128 step 
.................... //                                                             1000: 1/256 step 
.................... // RSTEP (single step output)                (W)   (bit 2)     0: No action 
.................... //                                                             1: Indexer will advance one step; automatically cleared after write 
.................... // direction                                 (R/W) (bit 1)     0: Direction set by DIR pin 
.................... //                                                             1: Direction set by inverse of DIR pin 
.................... // motor state                               (R/W) (bit 0)     0: Disable motor 
.................... //                                                             1: Enable motor 
.................... */ 
.................... enum dead_time          {dtime_400ns = 0, dtime_450ns = 1, dtime_650ns = 2, dtime_850ns = 3}; 
.................... enum curent_amp_gain    {gain_5 = 0, gain_10 = 1, gain_20 = 2, gain_40 = 3}; 
.................... enum src_stall_detect   {stall_int = 0, stall_ext = 1}; 
.................... enum microstepping      {full_step = 0, half_step = 1, _4x = 2, _8x = 3, _16x = 4, _32x = 5, _64x = 6, _128x = 7, _256x = 8}; 
.................... enum single_step_out    {no_action = 0, one_step = 1}; 
.................... enum dir_control        {dir_pin = 0, inv_dir_pin = 1}; 
.................... enum motor_state        {motor_disable = 0, motor_enable = 1}; 
.................... enum reg_ctrl_mask      {motor_state_addr = 0, dir_control_addr = 1, single_step_out_addr = 2, microstepping_addr = 3, src_stall_detect_addr = 7, curent_amp_gain_addr = 8, dead_time_addr = 10}; 
.................... enum reg_ctrl_size      {motor_state_size = 1, dir_control_size = 1, single_step_out_size = 1, microstepping_size = 4, src_stall_detect_size = 1, curent_amp_gain_size = 2, dead_time_size = 2}; 
.................... // Sets CTRL register 
.................... void set_ctrl_reg(dead_time dtime, curent_amp_gain gain, src_stall_detect stall, microstepping mode, single_step_out rstep, dir_control dir, motor_state state) 
.................... { 
....................    if(drv_debug) 
*
0294:  BTFSS  34.0
0295:  GOTO   29D
....................       fprintf(RS232,"CTRL Register\t: "); 
0296:  MOVLW  1F
0297:  MOVLB  03
0298:  MOVWF  11
0299:  MOVLW  00
029A:  MOVWF  12
029B:  MOVLB  00
029C:  CALL   159
....................     
....................    // clear the register 
....................    reg_ctrl = 0b0000000000000000; 
029D:  CLRF   25
029E:  CLRF   24
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
029F:  MOVF   25,W
02A0:  MOVWF  3F
02A1:  MOVF   24,W
02A2:  MOVWF  3E
02A3:  MOVLW  0F
02A4:  MOVWF  40
02A5:  MOVLW  01
02A6:  MOVWF  41
02A7:  CLRF   43
02A8:  CLRF   42
02A9:  CALL   1A4
02AA:  MOVF   79,W
02AB:  MOVWF  25
02AC:  MOVF   78,W
02AD:  MOVWF  24
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
02AE:  MOVF   25,W
02AF:  MOVWF  3F
02B0:  MOVF   24,W
02B1:  MOVWF  3E
02B2:  MOVLW  0C
02B3:  MOVWF  40
02B4:  MOVLW  03
02B5:  MOVWF  41
02B6:  CLRF   43
02B7:  CLRF   42
02B8:  CALL   1A4
02B9:  MOVF   79,W
02BA:  MOVWF  25
02BB:  MOVF   78,W
02BC:  MOVWF  24
....................    // set dead time between MOSFET switching 
....................    reg_ctrl = set_register_bits(reg_ctrl, dead_time_addr, dead_time_size, dtime);  
02BD:  MOVF   25,W
02BE:  MOVWF  3F
02BF:  MOVF   24,W
02C0:  MOVWF  3E
02C1:  MOVLW  0A
02C2:  MOVWF  40
02C3:  MOVLW  02
02C4:  MOVWF  41
02C5:  CLRF   43
02C6:  MOVF   37,W
02C7:  MOVWF  42
02C8:  CALL   1A4
02C9:  MOVF   79,W
02CA:  MOVWF  25
02CB:  MOVF   78,W
02CC:  MOVWF  24
....................    // set current amplifier gain 
....................    reg_ctrl = set_register_bits(reg_ctrl, curent_amp_gain_addr, curent_amp_gain_size, gain); 
02CD:  MOVF   25,W
02CE:  MOVWF  3F
02CF:  MOVF   24,W
02D0:  MOVWF  3E
02D1:  MOVLW  08
02D2:  MOVWF  40
02D3:  MOVLW  02
02D4:  MOVWF  41
02D5:  CLRF   43
02D6:  MOVF   38,W
02D7:  MOVWF  42
02D8:  CALL   1A4
02D9:  MOVF   79,W
02DA:  MOVWF  25
02DB:  MOVF   78,W
02DC:  MOVWF  24
....................    // set source of stall detection 
....................    reg_ctrl = set_register_bits(reg_ctrl, src_stall_detect_addr, src_stall_detect_size, stall); 
02DD:  MOVF   25,W
02DE:  MOVWF  3F
02DF:  MOVF   24,W
02E0:  MOVWF  3E
02E1:  MOVLW  07
02E2:  MOVWF  40
02E3:  MOVLW  01
02E4:  MOVWF  41
02E5:  CLRF   43
02E6:  MOVF   39,W
02E7:  MOVWF  42
02E8:  CALL   1A4
02E9:  MOVF   79,W
02EA:  MOVWF  25
02EB:  MOVF   78,W
02EC:  MOVWF  24
....................    // set microstepping mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, microstepping_addr, microstepping_size, mode); 
02ED:  MOVF   25,W
02EE:  MOVWF  3F
02EF:  MOVF   24,W
02F0:  MOVWF  3E
02F1:  MOVLW  03
02F2:  MOVWF  40
02F3:  MOVLW  04
02F4:  MOVWF  41
02F5:  CLRF   43
02F6:  MOVF   3A,W
02F7:  MOVWF  42
02F8:  CALL   1A4
02F9:  MOVF   79,W
02FA:  MOVWF  25
02FB:  MOVF   78,W
02FC:  MOVWF  24
....................    // set single step output mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, single_step_out_addr, single_step_out_size, rstep); 
02FD:  MOVF   25,W
02FE:  MOVWF  3F
02FF:  MOVF   24,W
0300:  MOVWF  3E
0301:  MOVLW  02
0302:  MOVWF  40
0303:  MOVLW  01
0304:  MOVWF  41
0305:  CLRF   43
0306:  MOVF   3B,W
0307:  MOVWF  42
0308:  CALL   1A4
0309:  MOVF   79,W
030A:  MOVWF  25
030B:  MOVF   78,W
030C:  MOVWF  24
....................    // set direction 
....................    reg_ctrl = set_register_bits(reg_ctrl, dir_control_addr, dir_control_size, dir); 
030D:  MOVF   25,W
030E:  MOVWF  3F
030F:  MOVF   24,W
0310:  MOVWF  3E
0311:  MOVLW  01
0312:  MOVWF  40
0313:  MOVWF  41
0314:  CLRF   43
0315:  MOVF   3C,W
0316:  MOVWF  42
0317:  CALL   1A4
0318:  MOVF   79,W
0319:  MOVWF  25
031A:  MOVF   78,W
031B:  MOVWF  24
....................    // set motor state 
....................    reg_ctrl = set_register_bits(reg_ctrl, motor_state_addr, motor_state_size, state); 
031C:  MOVF   25,W
031D:  MOVWF  3F
031E:  MOVF   24,W
031F:  MOVWF  3E
0320:  CLRF   40
0321:  MOVLW  01
0322:  MOVWF  41
0323:  CLRF   43
0324:  MOVF   3D,W
0325:  MOVWF  42
0326:  CALL   1A4
0327:  MOVF   79,W
0328:  MOVWF  25
0329:  MOVF   78,W
032A:  MOVWF  24
....................  
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
032B:  MOVF   25,W
032C:  MOVWF  3F
032D:  MOVF   24,W
032E:  MOVWF  3E
032F:  CALL   207
.................... } 
.................... // Sets CTRL register 
.................... void set_dead_time(dead_time dtime) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set dead time between MOSFET switching 
....................    reg_ctrl = set_register_bits(reg_ctrl, dead_time_addr, dead_time_size, dtime);  
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_amp_gain(curent_amp_gain gain) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set current amplifier gain 
....................    reg_ctrl = set_register_bits(reg_ctrl, curent_amp_gain_addr, curent_amp_gain_size, gain); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_stall_detection(src_stall_detect stall) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set source of stall detection 
....................    reg_ctrl = set_register_bits(reg_ctrl, src_stall_detect_addr, src_stall_detect_size, stall); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_microstepping_mode(microstepping mode) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set microstepping mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, microstepping_addr, microstepping_size, mode); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_rstep(single_step_out rstep) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................          
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set single step output mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, single_step_out_addr, single_step_out_size, rstep); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_dir_mode(dir_control dir) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set direction mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, dir_control_addr, dir_control_size, dir); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_motor_state(motor_state state) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set motor state 
....................    reg_ctrl = set_register_bits(reg_ctrl, motor_state_addr, motor_state_size, state); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... /* 
.................... // TORQUE register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 001: Torque reg 
.................... // Reserved                                        (bit 11) 
.................... // SMPLTH (Back EMF sample threshold)        (R/W) (bit 10-8)  000: 50 us,  
.................... //                                                             001: 100 us,  
.................... //                                                             010: 200 us,  
.................... //                                                             011: 300 us, 
.................... //                                                             100: 400 us, 
.................... //                                                             101: 600 us, 
.................... //                                                             110: 800 us,  
.................... //                                                             111: 1000 us, 
.................... // Torque (Output current for H-bridges)     (R/W) (bit 7-0)   0xFFh 
.................... */ 
.................... enum emf_samp_thr       {emf_50us = 0, emf_100us = 1, emf_200us = 2, emf_300us = 3, emf_400us = 4, emf_600us = 5, emf_800us = 6, emf_1000us = 7}; 
.................... enum reg_torque_mask    {torque_addr = 0, emf_samp_thr_addr = 8}; 
.................... enum reg_torque_size    {torque_size = 8, emf_samp_thr_size = 3}; 
.................... // Sets TORQUE register 
.................... void set_torque_reg(emf_samp_thr emf, unsigned int8 torque) 
.................... { 
....................    if(drv_debug) 
*
0333:  BTFSS  34.0
0334:  GOTO   33C
....................       fprintf(RS232,"TORQUE Register\t: "); 
0335:  MOVLW  67
0336:  MOVLB  03
0337:  MOVWF  11
0338:  MOVLW  00
0339:  MOVWF  12
033A:  MOVLB  00
033B:  CALL   159
....................        
....................    // clear the register 
....................    reg_torque = 0b0000000000000000; 
033C:  CLRF   27
033D:  CLRF   26
....................    // set write operation 
....................    reg_torque = set_register_bits(reg_torque, op_type_addr, op_type_size, op_write);  
033E:  MOVF   27,W
033F:  MOVWF  3F
0340:  MOVF   26,W
0341:  MOVWF  3E
0342:  MOVLW  0F
0343:  MOVWF  40
0344:  MOVLW  01
0345:  MOVWF  41
0346:  CLRF   43
0347:  CLRF   42
0348:  CALL   1A4
0349:  MOVF   79,W
034A:  MOVWF  27
034B:  MOVF   78,W
034C:  MOVWF  26
....................    // set register address 
....................    reg_torque = set_register_bits(reg_torque, reg_type_addr, reg_type_size, type_torque); 
034D:  MOVF   27,W
034E:  MOVWF  3F
034F:  MOVF   26,W
0350:  MOVWF  3E
0351:  MOVLW  0C
0352:  MOVWF  40
0353:  MOVLW  03
0354:  MOVWF  41
0355:  CLRF   43
0356:  MOVLW  01
0357:  MOVWF  42
0358:  CALL   1A4
0359:  MOVF   79,W
035A:  MOVWF  27
035B:  MOVF   78,W
035C:  MOVWF  26
....................    // set back EMF sample threshold 
....................    reg_torque = set_register_bits(reg_torque, emf_samp_thr_addr, emf_samp_thr_size, emf); 
035D:  MOVF   27,W
035E:  MOVWF  3F
035F:  MOVF   26,W
0360:  MOVWF  3E
0361:  MOVLW  08
0362:  MOVWF  40
0363:  MOVLW  03
0364:  MOVWF  41
0365:  CLRF   43
0366:  MOVF   37,W
0367:  MOVWF  42
0368:  CALL   1A4
0369:  MOVF   79,W
036A:  MOVWF  27
036B:  MOVF   78,W
036C:  MOVWF  26
....................    // set output current for H-bridges 
....................    reg_torque = set_register_bits(reg_torque, torque_addr, torque_size, torque); 
036D:  MOVF   27,W
036E:  MOVWF  3F
036F:  MOVF   26,W
0370:  MOVWF  3E
0371:  CLRF   40
0372:  MOVLW  08
0373:  MOVWF  41
0374:  CLRF   43
0375:  MOVF   38,W
0376:  MOVWF  42
0377:  CALL   1A4
0378:  MOVF   79,W
0379:  MOVWF  27
037A:  MOVF   78,W
037B:  MOVWF  26
....................     
....................    // write register to SPI 
....................    write_register(reg_torque); 
037C:  MOVF   27,W
037D:  MOVWF  3F
037E:  MOVF   26,W
037F:  MOVWF  3E
0380:  CALL   207
.................... } 
.................... // Sets back EMF sample threshold 
.................... void set_emf_samp_thr(emf_samp_thr emf) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"TORQUE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_torque = set_register_bits(reg_torque, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_torque = set_register_bits(reg_torque, reg_type_addr, reg_type_size, type_torque); 
....................    // set back EMF sample threshold 
....................    reg_torque = set_register_bits(reg_torque, emf_samp_thr_addr, emf_samp_thr_size, emf); 
....................    // write register to SPI 
....................    write_register(reg_torque); 
.................... } 
.................... // Sets full-scale output current for both H-bridges 
.................... void set_torque(unsigned int8 torque) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"TORQUE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_torque = set_register_bits(reg_torque, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_torque = set_register_bits(reg_torque, reg_type_addr, reg_type_size, type_torque); 
....................    // set output current for H-bridges 
....................    reg_torque = set_register_bits(reg_torque, torque_addr, torque_size, torque); 
....................    // write register to SPI 
....................    write_register(reg_torque); 
.................... } 
.................... /* 
.................... // OFF register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 010: OFF reg 
.................... // Reserved                                        (bit 11-9) 
.................... // PWMMODE (indexer mode)                    (R/W) (bit 8)     0: Use internal indexer,  
.................... //                                                             1: Bypass indexer, use xINx inputs to control outputs  
.................... // TOFF (Sets fixed off time, 500ns steps)   (R/W) (bit 7-0)   0x00h: 500 ns 
.................... //                                                             0xFFh: 128 us 
.................... */ 
.................... enum pwm_mode           {int_indexer = 0, ext_indexer = 1}; 
.................... enum reg_off_mask       {toff_addr = 0, pwm_mode_addr = 8}; 
.................... enum reg_off_size       {toff_size = 8, pwm_mode_size = 1}; 
.................... // Sets OFF register 
.................... void set_off_reg(pwm_mode indexer, unsigned int8 toff) 
.................... { 
....................    if(drv_debug) 
*
0384:  BTFSS  34.0
0385:  GOTO   38D
....................       fprintf(RS232,"TOFF Register\t: "); 
0386:  MOVLW  85
0387:  MOVLB  03
0388:  MOVWF  11
0389:  MOVLW  00
038A:  MOVWF  12
038B:  MOVLB  00
038C:  CALL   159
....................        
....................    // clear the register 
....................    reg_off = 0b0000000000000000; 
038D:  CLRF   29
038E:  CLRF   28
....................    // set write operation 
....................    reg_off = set_register_bits(reg_off, op_type_addr, op_type_size, op_write);  
038F:  MOVF   29,W
0390:  MOVWF  3F
0391:  MOVF   28,W
0392:  MOVWF  3E
0393:  MOVLW  0F
0394:  MOVWF  40
0395:  MOVLW  01
0396:  MOVWF  41
0397:  CLRF   43
0398:  CLRF   42
0399:  CALL   1A4
039A:  MOVF   79,W
039B:  MOVWF  29
039C:  MOVF   78,W
039D:  MOVWF  28
....................    // set register address 
....................    reg_off = set_register_bits(reg_off, reg_type_addr, reg_type_size, type_off); 
039E:  MOVF   29,W
039F:  MOVWF  3F
03A0:  MOVF   28,W
03A1:  MOVWF  3E
03A2:  MOVLW  0C
03A3:  MOVWF  40
03A4:  MOVLW  03
03A5:  MOVWF  41
03A6:  CLRF   43
03A7:  MOVLW  02
03A8:  MOVWF  42
03A9:  CALL   1A4
03AA:  MOVF   79,W
03AB:  MOVWF  29
03AC:  MOVF   78,W
03AD:  MOVWF  28
....................    // set pwm indexer mode 
....................    reg_off = set_register_bits(reg_off, pwm_mode_addr, pwm_mode_size, indexer); 
03AE:  MOVF   29,W
03AF:  MOVWF  3F
03B0:  MOVF   28,W
03B1:  MOVWF  3E
03B2:  MOVLW  08
03B3:  MOVWF  40
03B4:  MOVLW  01
03B5:  MOVWF  41
03B6:  CLRF   43
03B7:  MOVF   37,W
03B8:  MOVWF  42
03B9:  CALL   1A4
03BA:  MOVF   79,W
03BB:  MOVWF  29
03BC:  MOVF   78,W
03BD:  MOVWF  28
....................    // set fixed off time 
....................    reg_off = set_register_bits(reg_off, toff_addr, toff_size, toff); 
03BE:  MOVF   29,W
03BF:  MOVWF  3F
03C0:  MOVF   28,W
03C1:  MOVWF  3E
03C2:  CLRF   40
03C3:  MOVLW  08
03C4:  MOVWF  41
03C5:  CLRF   43
03C6:  MOVF   38,W
03C7:  MOVWF  42
03C8:  CALL   1A4
03C9:  MOVF   79,W
03CA:  MOVWF  29
03CB:  MOVF   78,W
03CC:  MOVWF  28
....................  
....................    // write register to SPI 
....................    write_register(reg_off); 
03CD:  MOVF   29,W
03CE:  MOVWF  3F
03CF:  MOVF   28,W
03D0:  MOVWF  3E
03D1:  CALL   207
.................... } 
.................... // Sets pwm indexer mode 
.................... void set_pwm_mode(pwm_mode indexer) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"TOFF Register\t: "); 
....................        
....................    // set write operation 
....................    reg_off = set_register_bits(reg_off, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_off = set_register_bits(reg_off, reg_type_addr, reg_type_size, type_off); 
....................    // set pwm indexer mode 
....................    reg_off = set_register_bits(reg_off, pwm_mode_addr, pwm_mode_size, indexer); 
....................    // write register to SPI 
....................    write_register(reg_off); 
.................... } 
.................... // Sets fixed off time 
.................... void set_off_time(unsigned int8 toff) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"TOFF Register\t: "); 
....................        
....................    // set write operation 
....................    reg_off = set_register_bits(reg_off, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_off = set_register_bits(reg_off, reg_type_addr, reg_type_size, type_off); 
....................    // set fixed off time 
....................    reg_off = set_register_bits(reg_off, toff_addr, toff_size, toff); 
....................    // write register to SPI 
....................    write_register(reg_off); 
.................... } 
.................... /* 
.................... // BLANK register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 011: BLANK reg 
.................... // Reserved                                        (bit 11-9) 
.................... // ABT (adaptive blanking time state)        (R/W) (bit 8)     0: Disable adaptive blanking time,  
.................... //                                                             1: Enable adaptive blanking time 
.................... // TBLANK (Sets blanking time, 20ns steps)   (R/W) (bit 7-0)   0x00h: 1.00 us 
.................... //                                                             ... 
.................... //                                                             0x32h: 1.00 us 
.................... //                                                             0x33h: 1.02 us 
.................... //                                                             ... 
.................... //                                                             0xFEh: 5.10 us 
.................... //                                                             0xFFh: 5.12 us 
.................... */ 
.................... enum adap_blank_state   {disable_abt = 0, enable_abt = 1}; 
.................... enum reg_blank_mask     {tblank_addr = 0, adap_blank_time_addr = 8}; 
.................... enum reg_blank_size     {tblank_size = 8, adap_blank_time_size = 1}; 
.................... // Sets BLANK register 
.................... void set_blank_reg(adap_blank_state abt, unsigned int8 tblank) 
.................... { 
....................    if(drv_debug) 
*
03D6:  BTFSS  34.0
03D7:  GOTO   3DF
....................       fprintf(RS232,"BLANK Register\t: "); 
03D8:  MOVLW  A0
03D9:  MOVLB  03
03DA:  MOVWF  11
03DB:  MOVLW  00
03DC:  MOVWF  12
03DD:  MOVLB  00
03DE:  CALL   159
....................        
....................    // clear the register 
....................    reg_blank = 0b0000000000000000; 
03DF:  CLRF   2B
03E0:  CLRF   2A
....................    // set write operation 
....................    reg_blank = set_register_bits(reg_blank, op_type_addr, op_type_size, op_write);  
03E1:  MOVF   2B,W
03E2:  MOVWF  3F
03E3:  MOVF   2A,W
03E4:  MOVWF  3E
03E5:  MOVLW  0F
03E6:  MOVWF  40
03E7:  MOVLW  01
03E8:  MOVWF  41
03E9:  CLRF   43
03EA:  CLRF   42
03EB:  CALL   1A4
03EC:  MOVF   79,W
03ED:  MOVWF  2B
03EE:  MOVF   78,W
03EF:  MOVWF  2A
....................    // set register address 
....................    reg_blank = set_register_bits(reg_blank, reg_type_addr, reg_type_size, type_blank); 
03F0:  MOVF   2B,W
03F1:  MOVWF  3F
03F2:  MOVF   2A,W
03F3:  MOVWF  3E
03F4:  MOVLW  0C
03F5:  MOVWF  40
03F6:  MOVLW  03
03F7:  MOVWF  41
03F8:  CLRF   43
03F9:  MOVWF  42
03FA:  CALL   1A4
03FB:  MOVF   79,W
03FC:  MOVWF  2B
03FD:  MOVF   78,W
03FE:  MOVWF  2A
....................    // set adaptive blanking time state 
....................    reg_blank = set_register_bits(reg_blank, adap_blank_time_addr, adap_blank_time_size, abt); 
03FF:  MOVF   2B,W
0400:  MOVWF  3F
0401:  MOVF   2A,W
0402:  MOVWF  3E
0403:  MOVLW  08
0404:  MOVWF  40
0405:  MOVLW  01
0406:  MOVWF  41
0407:  CLRF   43
0408:  MOVF   37,W
0409:  MOVWF  42
040A:  CALL   1A4
040B:  MOVF   79,W
040C:  MOVWF  2B
040D:  MOVF   78,W
040E:  MOVWF  2A
....................    // set blanking time 
....................    reg_blank = set_register_bits(reg_blank, tblank_addr, tblank_size, tblank); 
040F:  MOVF   2B,W
0410:  MOVWF  3F
0411:  MOVF   2A,W
0412:  MOVWF  3E
0413:  CLRF   40
0414:  MOVLW  08
0415:  MOVWF  41
0416:  CLRF   43
0417:  MOVF   38,W
0418:  MOVWF  42
0419:  CALL   1A4
041A:  MOVF   79,W
041B:  MOVWF  2B
041C:  MOVF   78,W
041D:  MOVWF  2A
....................     
....................    // write register to SPI 
....................    write_register(reg_blank); 
041E:  MOVF   2B,W
041F:  MOVWF  3F
0420:  MOVF   2A,W
0421:  MOVWF  3E
0422:  CALL   207
.................... } 
.................... // Sets adaptive blank time state 
.................... void set_adap_blank_state(adap_blank_state abt) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"BLANK Register\t: "); 
....................        
....................    // set write operation 
....................    reg_blank = set_register_bits(reg_blank, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_blank = set_register_bits(reg_blank, reg_type_addr, reg_type_size, type_blank); 
....................    // set adaptive blanking time state 
....................    reg_blank = set_register_bits(reg_blank, adap_blank_time_addr, adap_blank_time_size, abt); 
....................    // write register to SPI 
....................    write_register(reg_blank); 
.................... } 
.................... // Sets blanking time 
.................... void set_blank_time(unsigned int8 tblank) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"BLANK Register\t: "); 
....................        
....................    // set write operation 
....................    reg_blank = set_register_bits(reg_blank, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_blank = set_register_bits(reg_blank, reg_type_addr, reg_type_size, type_blank); 
....................    // set blanking time 
....................    reg_blank = set_register_bits(reg_blank, tblank_addr, tblank_size, tblank); 
....................    // write register to SPI 
....................    write_register(reg_blank); 
.................... } 
.................... /* 
.................... // DECAY register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 100: DECAY reg 
.................... // Reserved                                        (bit 11) 
.................... // DECMODE (decay modes)                     (R/W) (bit 10-8)  000: Force slow decay at all times 
.................... //                                                             001: Slow decay for increasing current, mixed decay for decreasing current (indexer mode only) 
.................... //                                                             010: Force fast decay at all times 
.................... //                                                             011: Use mixed decay at all times 
.................... //                                                             100: Slow decay for increasing current, auto mixed decay for decreasing current (indexer mode only) 
.................... //                                                             101: Use auto mixed decay at all times 
.................... //                                                             110-111: Reserved 
.................... // TDECAY (Sets transition time, 500ns steps)(R/W) (bit 7-0)   0x00h: 500 ns 
.................... //                                                             0xFFh: 128 us 
.................... */ 
.................... enum decay_mode         {force_slow_decay = 0, slow_mixed_decay = 1, force_fast_decay = 2, mixed_decay = 3, slow_auto_mixed_decay = 4, auto_mixed_decay = 5}; 
.................... enum reg_decay_mask     {tdecay_addr = 0, decay_mode_addr = 8}; 
.................... enum reg_decay_size     {tdecay_size = 8, decay_mode_size = 3}; 
.................... // Sets DECAY register 
.................... void set_decay_reg(decay_mode dmode, unsigned int8 tdecay) 
.................... { 
....................    if(drv_debug) 
*
0427:  BTFSS  34.0
0428:  GOTO   430
....................       fprintf(RS232,"DECAY Register\t: "); 
0429:  MOVLW  BB
042A:  MOVLB  03
042B:  MOVWF  11
042C:  MOVLW  00
042D:  MOVWF  12
042E:  MOVLB  00
042F:  CALL   159
....................        
....................    // clear the register 
....................    reg_decay = 0b0000000000000000; 
0430:  CLRF   2D
0431:  CLRF   2C
....................    // set write operation 
....................    reg_decay = set_register_bits(reg_decay, op_type_addr, op_type_size, op_write);  
0432:  MOVF   2D,W
0433:  MOVWF  3F
0434:  MOVF   2C,W
0435:  MOVWF  3E
0436:  MOVLW  0F
0437:  MOVWF  40
0438:  MOVLW  01
0439:  MOVWF  41
043A:  CLRF   43
043B:  CLRF   42
043C:  CALL   1A4
043D:  MOVF   79,W
043E:  MOVWF  2D
043F:  MOVF   78,W
0440:  MOVWF  2C
....................    // set register address 
....................    reg_decay = set_register_bits(reg_decay, reg_type_addr, reg_type_size, type_decay); 
0441:  MOVF   2D,W
0442:  MOVWF  3F
0443:  MOVF   2C,W
0444:  MOVWF  3E
0445:  MOVLW  0C
0446:  MOVWF  40
0447:  MOVLW  03
0448:  MOVWF  41
0449:  CLRF   43
044A:  MOVLW  04
044B:  MOVWF  42
044C:  CALL   1A4
044D:  MOVF   79,W
044E:  MOVWF  2D
044F:  MOVF   78,W
0450:  MOVWF  2C
....................    // set decay mode 
....................    reg_decay = set_register_bits(reg_decay, decay_mode_addr, decay_mode_size, dmode); 
0451:  MOVF   2D,W
0452:  MOVWF  3F
0453:  MOVF   2C,W
0454:  MOVWF  3E
0455:  MOVLW  08
0456:  MOVWF  40
0457:  MOVLW  03
0458:  MOVWF  41
0459:  CLRF   43
045A:  MOVF   37,W
045B:  MOVWF  42
045C:  CALL   1A4
045D:  MOVF   79,W
045E:  MOVWF  2D
045F:  MOVF   78,W
0460:  MOVWF  2C
....................    // set decay time 
....................    reg_decay = set_register_bits(reg_decay, tdecay_addr, tdecay_size, tdecay); 
0461:  MOVF   2D,W
0462:  MOVWF  3F
0463:  MOVF   2C,W
0464:  MOVWF  3E
0465:  CLRF   40
0466:  MOVLW  08
0467:  MOVWF  41
0468:  CLRF   43
0469:  MOVF   38,W
046A:  MOVWF  42
046B:  CALL   1A4
046C:  MOVF   79,W
046D:  MOVWF  2D
046E:  MOVF   78,W
046F:  MOVWF  2C
....................  
....................    // write register to SPI 
....................    write_register(reg_decay); 
0470:  MOVF   2D,W
0471:  MOVWF  3F
0472:  MOVF   2C,W
0473:  MOVWF  3E
0474:  CALL   207
.................... } 
.................... // Sets decay (transition) mode 
.................... void set_decay_mode(decay_mode dmode) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DECAY Register\t: "); 
....................        
....................    // set write operation 
....................    reg_decay = set_register_bits(reg_decay, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_decay = set_register_bits(reg_decay, reg_type_addr, reg_type_size, type_decay); 
....................    // set decay mode 
....................    reg_decay = set_register_bits(reg_decay, decay_mode_addr, decay_mode_size, dmode); 
....................    // write register to SPI 
....................    write_register(reg_decay); 
.................... } 
.................... // Sets decay (transition) time 
.................... void set_decay_time(unsigned int8 tdecay) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DECAY Register\t: "); 
....................        
....................    // set write operation 
....................    reg_decay = set_register_bits(reg_decay, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_decay = set_register_bits(reg_decay, reg_type_addr, reg_type_size, type_decay); 
....................    // set decay time 
....................    reg_decay = set_register_bits(reg_decay, tdecay_addr, tdecay_size, tdecay); 
....................    // write register to SPI 
....................    write_register(reg_decay); 
.................... } 
.................... /* 
.................... // STALL register bits 
.................... // data operation type                             (bit 15)    0: write, 
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 101: STALL reg 
.................... // VDIV (Back EMF divider)                   (R/W) (bit 11-10) 00: Back EMF is divided by 32 
.................... //                                                             01: Back EMF is divided by 16 
.................... //                                                             10: Back EMF is divided by 8 
.................... //                                                             11: Back EMF is divided by 4 
.................... // SDCNT (Back EMF sample step mode)         (R/W) (bit 9-8)   00: STALLn asserted on first step with back EMF below SDTHR 
.................... //                                                             01: STALLn asserted after 2 steps 
.................... //                                                             10: STALLn asserted after 4 steps 
.................... //                                                             11: STALLn asserted after 8 steps 
.................... // SDTHR (Sets stall detect threshold)       (R/W) (bit 7-0)   0x00h: 0 
.................... //                                                             0xFFh: 255 
.................... */ 
.................... enum emf_vol_div        {divide_by_32 = 0, divide_by_16 = 1, divide_by_8 = 2, divide_by_4 = 3}; 
.................... enum emf_samp_mode      {after_1_step = 0, after_2_steps = 1, after_4_steps = 2, after_8_steps = 3}; 
.................... enum reg_stall_mask     {stall_thr_addr = 0, emf_samp_mode_addr = 8, emf_vol_div_addr = 10}; 
.................... enum reg_stall_size     {stall_thr_size = 8, emf_samp_mode_size = 2, emf_vol_div_size = 2};   
.................... // Sets STALL register 
.................... void set_stall_reg(emf_vol_div divider, emf_samp_mode smode, unsigned int8 stall_thr) 
.................... { 
....................    if(drv_debug) 
*
047B:  BTFSS  34.0
047C:  GOTO   484
....................       fprintf(RS232,"STALL Register\t: "); 
047D:  MOVLW  D6
047E:  MOVLB  03
047F:  MOVWF  11
0480:  MOVLW  00
0481:  MOVWF  12
0482:  MOVLB  00
0483:  CALL   159
....................        
....................    // clear the register 
....................    reg_stall = 0b0000000000000000; 
0484:  CLRF   2F
0485:  CLRF   2E
....................    // set write operation 
....................    reg_stall = set_register_bits(reg_stall, op_type_addr, op_type_size, op_write);  
0486:  MOVF   2F,W
0487:  MOVWF  3F
0488:  MOVF   2E,W
0489:  MOVWF  3E
048A:  MOVLW  0F
048B:  MOVWF  40
048C:  MOVLW  01
048D:  MOVWF  41
048E:  CLRF   43
048F:  CLRF   42
0490:  CALL   1A4
0491:  MOVF   79,W
0492:  MOVWF  2F
0493:  MOVF   78,W
0494:  MOVWF  2E
....................    // set register address 
....................    reg_stall = set_register_bits(reg_stall, reg_type_addr, reg_type_size, type_stall); 
0495:  MOVF   2F,W
0496:  MOVWF  3F
0497:  MOVF   2E,W
0498:  MOVWF  3E
0499:  MOVLW  0C
049A:  MOVWF  40
049B:  MOVLW  03
049C:  MOVWF  41
049D:  CLRF   43
049E:  MOVLW  05
049F:  MOVWF  42
04A0:  CALL   1A4
04A1:  MOVF   79,W
04A2:  MOVWF  2F
04A3:  MOVF   78,W
04A4:  MOVWF  2E
....................    // set back EMF voltage divider 
....................    reg_stall = set_register_bits(reg_stall, emf_vol_div_addr, emf_vol_div_size, divider); 
04A5:  MOVF   2F,W
04A6:  MOVWF  3F
04A7:  MOVF   2E,W
04A8:  MOVWF  3E
04A9:  MOVLW  0A
04AA:  MOVWF  40
04AB:  MOVLW  02
04AC:  MOVWF  41
04AD:  CLRF   43
04AE:  MOVF   37,W
04AF:  MOVWF  42
04B0:  CALL   1A4
04B1:  MOVF   79,W
04B2:  MOVWF  2F
04B3:  MOVF   78,W
04B4:  MOVWF  2E
....................    // set back EMF sample step mode 
....................    reg_stall = set_register_bits(reg_stall, emf_samp_mode_addr, emf_samp_mode_size, smode); 
04B5:  MOVF   2F,W
04B6:  MOVWF  3F
04B7:  MOVF   2E,W
04B8:  MOVWF  3E
04B9:  MOVLW  08
04BA:  MOVWF  40
04BB:  MOVLW  02
04BC:  MOVWF  41
04BD:  CLRF   43
04BE:  MOVF   38,W
04BF:  MOVWF  42
04C0:  CALL   1A4
04C1:  MOVF   79,W
04C2:  MOVWF  2F
04C3:  MOVF   78,W
04C4:  MOVWF  2E
....................    // set stall detect threshold 
....................    reg_stall = set_register_bits(reg_stall, stall_thr_addr, stall_thr_size, stall_thr); 
04C5:  MOVF   2F,W
04C6:  MOVWF  3F
04C7:  MOVF   2E,W
04C8:  MOVWF  3E
04C9:  CLRF   40
04CA:  MOVLW  08
04CB:  MOVWF  41
04CC:  CLRF   43
04CD:  MOVF   39,W
04CE:  MOVWF  42
04CF:  CALL   1A4
04D0:  MOVF   79,W
04D1:  MOVWF  2F
04D2:  MOVF   78,W
04D3:  MOVWF  2E
....................     
....................    // write register to SPI 
....................    write_register(reg_stall); 
04D4:  MOVF   2F,W
04D5:  MOVWF  3F
04D6:  MOVF   2E,W
04D7:  MOVWF  3E
04D8:  CALL   207
.................... } 
.................... // Sets back EMF voltage divider 
.................... void set_emf_vol_div(emf_vol_div divider) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STALL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_stall = set_register_bits(reg_stall, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_stall = set_register_bits(reg_stall, reg_type_addr, reg_type_size, type_stall); 
....................    // set back EMF voltage divider 
....................    reg_stall = set_register_bits(reg_stall, emf_vol_div_addr, emf_vol_div_size, divider); 
....................    // write register to SPI 
....................    write_register(reg_stall); 
.................... } 
.................... // Sets back EMF sample step mode 
.................... void set_emf_samp_mode(emf_samp_mode smode) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STALL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_stall = set_register_bits(reg_stall, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_stall = set_register_bits(reg_stall, reg_type_addr, reg_type_size, type_stall); 
....................    // set back EMF sample step mode 
....................    reg_stall = set_register_bits(reg_stall, emf_samp_mode_addr, emf_samp_mode_size, smode); 
....................    // write register to SPI 
....................    write_register(reg_stall); 
.................... } 
.................... // Sets stall detect threshold 
.................... void set_stall_thr(unsigned int8 stall_thr) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STALL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_stall = set_register_bits(reg_stall, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_stall = set_register_bits(reg_stall, reg_type_addr, reg_type_size, type_stall); 
....................    // set stall detect threshold 
....................    reg_stall = set_register_bits(reg_stall, stall_thr_addr, stall_thr_size, stall_thr); 
....................    // write register to SPI 
....................    write_register(reg_stall); 
.................... } 
.................... /* 
.................... // DRIVE register bits 
.................... // data operation type                       (R/W) (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                          (R/W) (bit 14-12) 110: STALL reg 
.................... // IDRIVEP (High-side gate peak current)     (R/W) (bit 11-10) 00: 50 mA peak (source) 
.................... //                                                             01: 100 mA peak (source) 
.................... //                                                             10: 150 mA peak (source) 
.................... //                                                             11: 200 mA peak (source) 
.................... // IDRIVEN (Low-side gate peak current)      (R/W) (bit 9-8)   00: 100 mA peak (sink) 
.................... //                                                             01: 200 mA peak (sink) 
.................... //                                                             10: 300 mA peak (sink) 
.................... //                                                             11: 400 mA peak (sink) 
.................... // TDRIVEP (High-side gate drive time)       (R/W) (bit 7-6)   00: 250 ns 
.................... //                                                             01: 500 ns 
.................... //                                                             10: 1 us 
.................... //                                                             11: 2 us 
.................... // TDRIVEN (Low-side gate drive time)        (R/W) (bit 5-4)   00: 250 ns 
.................... //                                                             01: 500 ns 
.................... //                                                             10: 1 us 
.................... //                                                             11: 2 us 
.................... // OCPDEG (OCP deglitch time)                (R/W) (bit 3-2)   00: 1 us 
.................... //                                                             01: 2 us 
.................... //                                                             10: 4 us 
.................... //                                                             11: 8 us 
.................... // OCPTH (OCP threshold)                     (R/W) (bit 1-0)   00: 250 mV 
.................... //                                                             01: 500 mV 
.................... //                                                             10: 750 mV 
.................... //                                                             11: 1000 mV 
.................... */ 
.................... enum hs_peak_cur        {hs_50mA = 0, hs_100mA = 1, hs_150mA = 2, hs_200mA = 3}; 
.................... enum ls_peak_cur        {ls_100mA = 0, ls_200mA = 1, ls_300mA = 2, ls_400mA = 3}; 
.................... enum hs_drive_time      {hs_250ns = 0, hs_500ns = 1, hs_1us = 2, hs_2us = 3}; 
.................... enum ls_drive_time      {ls_250ns = 0, ls_500ns = 1, ls_1us = 2, ls_2us = 3}; 
.................... enum ocp_deg_time       {ocp_1us = 0, ocp_2us = 1, ocp_4us = 2, ocp_8us = 3}; 
.................... enum ocp_thr            {ocp_250mV = 0, ocp_500mV = 1, ocp_750mV = 2, ocp_1000mV = 3}; 
.................... enum reg_drive_mask     {ocp_thr_addr = 0, ocp_deg_time_addr = 2, ls_drive_time_addr = 4, hs_drive_time_addr = 6, ls_peak_cur_addr = 8, hs_peak_cur_addr = 10}; 
.................... enum reg_drive_size     {ocp_thr_size = 2, ocp_deg_time_size = 2, ls_drive_time_size = 2, hs_drive_time_size = 2, ls_peak_cur_size = 2, hs_peak_cur_size = 2};  
.................... // Sets DRIVE register 
.................... void set_drive_reg(hs_peak_cur idrivep, ls_peak_cur idriven, hs_drive_time tdrivep, ls_drive_time tdriven, ocp_deg_time ocpdeg, ocp_thr ocpth) 
.................... { 
....................    if(drv_debug) 
*
04E0:  BTFSS  34.0
04E1:  GOTO   4E9
....................       fprintf(RS232,"DRIVE Register\t: "); 
04E2:  MOVLW  FA
04E3:  MOVLB  03
04E4:  MOVWF  11
04E5:  MOVLW  00
04E6:  MOVWF  12
04E7:  MOVLB  00
04E8:  CALL   159
....................        
....................    // clear the register 
....................    reg_drive = 0b0000000000000000; 
04E9:  CLRF   31
04EA:  CLRF   30
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
04EB:  MOVF   31,W
04EC:  MOVWF  3F
04ED:  MOVF   30,W
04EE:  MOVWF  3E
04EF:  MOVLW  0F
04F0:  MOVWF  40
04F1:  MOVLW  01
04F2:  MOVWF  41
04F3:  CLRF   43
04F4:  CLRF   42
04F5:  CALL   1A4
04F6:  MOVF   79,W
04F7:  MOVWF  31
04F8:  MOVF   78,W
04F9:  MOVWF  30
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
04FA:  MOVF   31,W
04FB:  MOVWF  3F
04FC:  MOVF   30,W
04FD:  MOVWF  3E
04FE:  MOVLW  0C
04FF:  MOVWF  40
0500:  MOVLW  03
0501:  MOVWF  41
0502:  CLRF   43
0503:  MOVLW  06
0504:  MOVWF  42
0505:  CALL   1A4
0506:  MOVF   79,W
0507:  MOVWF  31
0508:  MOVF   78,W
0509:  MOVWF  30
....................    // set high-side gate peak current 
....................    reg_drive = set_register_bits(reg_drive, hs_peak_cur_addr, hs_peak_cur_size, idrivep); 
050A:  MOVF   31,W
050B:  MOVWF  3F
050C:  MOVF   30,W
050D:  MOVWF  3E
050E:  MOVLW  0A
050F:  MOVWF  40
0510:  MOVLW  02
0511:  MOVWF  41
0512:  CLRF   43
0513:  MOVF   37,W
0514:  MOVWF  42
0515:  CALL   1A4
0516:  MOVF   79,W
0517:  MOVWF  31
0518:  MOVF   78,W
0519:  MOVWF  30
....................    // set low-side gate peak current 
....................    reg_drive = set_register_bits(reg_drive, ls_peak_cur_addr, ls_peak_cur_size, idriven); 
051A:  MOVF   31,W
051B:  MOVWF  3F
051C:  MOVF   30,W
051D:  MOVWF  3E
051E:  MOVLW  08
051F:  MOVWF  40
0520:  MOVLW  02
0521:  MOVWF  41
0522:  CLRF   43
0523:  MOVF   38,W
0524:  MOVWF  42
0525:  CALL   1A4
0526:  MOVF   79,W
0527:  MOVWF  31
0528:  MOVF   78,W
0529:  MOVWF  30
....................    // set high-side gate drive time 
....................    reg_drive = set_register_bits(reg_drive, hs_drive_time_addr, hs_drive_time_size, tdrivep); 
052A:  MOVF   31,W
052B:  MOVWF  3F
052C:  MOVF   30,W
052D:  MOVWF  3E
052E:  MOVLW  06
052F:  MOVWF  40
0530:  MOVLW  02
0531:  MOVWF  41
0532:  CLRF   43
0533:  MOVF   39,W
0534:  MOVWF  42
0535:  CALL   1A4
0536:  MOVF   79,W
0537:  MOVWF  31
0538:  MOVF   78,W
0539:  MOVWF  30
....................    // set low-side gate drive time 
....................    reg_drive = set_register_bits(reg_drive, ls_drive_time_addr, ls_drive_time_size, tdriven); 
053A:  MOVF   31,W
053B:  MOVWF  3F
053C:  MOVF   30,W
053D:  MOVWF  3E
053E:  MOVLW  04
053F:  MOVWF  40
0540:  MOVLW  02
0541:  MOVWF  41
0542:  CLRF   43
0543:  MOVF   3A,W
0544:  MOVWF  42
0545:  CALL   1A4
0546:  MOVF   79,W
0547:  MOVWF  31
0548:  MOVF   78,W
0549:  MOVWF  30
....................    // set OCP deglitch time 
....................    reg_drive = set_register_bits(reg_drive, ocp_deg_time_addr, ocp_deg_time_size, ocpdeg); 
054A:  MOVF   31,W
054B:  MOVWF  3F
054C:  MOVF   30,W
054D:  MOVWF  3E
054E:  MOVLW  02
054F:  MOVWF  40
0550:  MOVWF  41
0551:  CLRF   43
0552:  MOVF   3B,W
0553:  MOVWF  42
0554:  CALL   1A4
0555:  MOVF   79,W
0556:  MOVWF  31
0557:  MOVF   78,W
0558:  MOVWF  30
....................    // set OCP threshold 
....................    reg_drive = set_register_bits(reg_drive, ocp_thr_addr, ocp_thr_size, ocpth); 
0559:  MOVF   31,W
055A:  MOVWF  3F
055B:  MOVF   30,W
055C:  MOVWF  3E
055D:  CLRF   40
055E:  MOVLW  02
055F:  MOVWF  41
0560:  CLRF   43
0561:  MOVF   3C,W
0562:  MOVWF  42
0563:  CALL   1A4
0564:  MOVF   79,W
0565:  MOVWF  31
0566:  MOVF   78,W
0567:  MOVWF  30
....................  
....................    // write register to SPI 
....................    write_register(reg_drive); 
0568:  MOVF   31,W
0569:  MOVWF  3F
056A:  MOVF   30,W
056B:  MOVWF  3E
056C:  CALL   207
.................... } 
.................... /* 
.................... // Sets high-side gate peak current 
.................... void set_hs_peak_cur(hs_peak_cur idrivep) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set high-side gate peak current 
....................    reg_drive = set_register_bits(reg_drive, hs_peak_cur_addr, hs_peak_cur_size, idrivep); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets low-side gate peak current 
.................... void set_ls_peak_cur(ls_peak_cur idriven) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set low-side gate peak current 
....................    reg_drive = set_register_bits(reg_drive, ls_peak_cur_addr, ls_peak_cur_size, idriven); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets high-side gate drive time 
.................... void set_hs_drive_time(hs_drive_time tdrivep) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set high-side gate drive time 
....................    reg_drive = set_register_bits(reg_drive, hs_drive_time_addr, hs_drive_time_size, tdrivep); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets low-side gate drive time 
.................... void set_ls_drive_time(ls_drive_time tdriven) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set low-side gate drive time 
....................    reg_drive = set_register_bits(reg_drive, ls_drive_time_addr, ls_drive_time_size, tdriven); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets OCP deglitch time 
.................... void set_ocp_deg_time(ocp_deg_time ocpdeg) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set OCP deglitch time 
....................    reg_drive = set_register_bits(reg_drive, ocp_deg_time_addr, ocp_deg_time_size, ocpdeg); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets OCP threshold 
.................... void set_ocp_thr(ocp_thr ocpth) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set OCP threshold 
....................    reg_drive = set_register_bits(reg_drive, ocp_thr_addr, ocp_thr_size, ocpth); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... */ 
.................... /* 
.................... // STATUS register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 111: STATUS reg 
.................... // Reserved                                        (bit 11-8) 
.................... // STDLAT (Stall clear flag)                 (R/W) (bit 7)     0: Normal operation 
.................... //                                                             1: Latched stall detect 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // STD (Stall detected flag)                 (R)   (bit 6)     0: Normal operation 
.................... //                                                             1: Stall detected 
.................... // UVLO (Undervoltage lockout flag)          (R)   (bit 5)     0: Normal operation 
.................... //                                                             1: Undervoltage lockout 
.................... //                                                             (UVLO bit will clear after VM has increased over VUVLO) 
.................... // BPDF (Channel B predriver fault flag)     (R/W) (bit 4)     0: Normal operation 
.................... //                                                             1: Channel B predriver fault 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // APDF (Channel A predriver fault flag)     (R/W) (bit 3)     0: Normal operation 
.................... //                                                             1: Channel A predriver fault 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // BOCP (Channel B overcurrent flag)         (R/W) (bit 2)     0: Normal operation 
.................... //                                                             1: Channel B overcurrent shutdown 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // AOCP (Channel A overcurrent flag)         (R/W) (bit 1)     0: Normal operation 
.................... //                                                             1: Channel A overcurrent shutdown 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // OTS (Overtemperature shutdown flag)       (R)   (bit 0)     0: Normal operation 
.................... //                                                             1: Device has entered overtemperature shutdown 
.................... //                                                             (OTS bit will clear once temperature has fallen to safe levels 
.................... ) 
.................... */ 
.................... enum reg_status_mask    {a_over_curr_flag_addr = 1, b_over_curr_flag_addr = 2, a_fault_flag_addr = 3, b_fault_flag_addr = 4, stall_flag_addr = 7}; 
.................... enum reg_status_size    {a_over_curr_flag_size = 1, b_over_curr_flag_size = 1, a_fault_flag_size = 1, b_fault_flag_size = 1, stall_flag_size = 1};  
.................... // Clears STATUS register 
.................... void clear_status_reg() 
.................... { 
....................    if(drv_debug) 
056D:  BTFSS  34.0
056E:  GOTO   576
....................       fprintf(RS232,"STATUS Register\t: "); 
056F:  MOVLW  03
0570:  MOVLB  03
0571:  MOVWF  11
0572:  MOVLW  01
0573:  MOVWF  12
0574:  MOVLB  00
0575:  CALL   159
....................        
....................    // clear the register 
....................    reg_status = 0b0000000000000000; 
0576:  CLRF   33
0577:  CLRF   32
....................       // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
0578:  MOVF   33,W
0579:  MOVWF  3F
057A:  MOVF   32,W
057B:  MOVWF  3E
057C:  MOVLW  0F
057D:  MOVWF  40
057E:  MOVLW  01
057F:  MOVWF  41
0580:  CLRF   43
0581:  CLRF   42
0582:  CALL   1A4
0583:  MOVF   79,W
0584:  MOVWF  33
0585:  MOVF   78,W
0586:  MOVWF  32
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
0587:  MOVF   33,W
0588:  MOVWF  3F
0589:  MOVF   32,W
058A:  MOVWF  3E
058B:  MOVLW  0C
058C:  MOVWF  40
058D:  MOVLW  03
058E:  MOVWF  41
058F:  CLRF   43
0590:  MOVLW  07
0591:  MOVWF  42
0592:  CALL   1A4
0593:  MOVF   79,W
0594:  MOVWF  33
0595:  MOVF   78,W
0596:  MOVWF  32
....................     
....................    // write register to SPI 
....................    write_register(reg_status); 
0597:  MOVF   33,W
0598:  MOVWF  3F
0599:  MOVF   32,W
059A:  MOVWF  3E
059B:  CALL   207
.................... } 
.................... /* 
.................... // Clears STATUS register 
.................... void clear_stall_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear stall flag 
....................    reg_status = set_register_bits(reg_status, stall_flag_addr, stall_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... // Clears STATUS register 
.................... void clear_b_fault_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear channel b predriver fault flag 
....................    reg_status = set_register_bits(reg_status, b_fault_flag_addr, b_fault_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... // Clears STATUS register 
.................... void clear_a_fault_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear channel a predriver fault flag 
....................    reg_status = set_register_bits(reg_status, a_fault_flag_addr, a_fault_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... // Clears STATUS register 
.................... void clear_b_over_curr_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear channel b overcurrent fault flag 
....................    reg_status = set_register_bits(reg_status, b_over_curr_flag_addr, b_over_curr_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... // Clears STATUS register 
.................... void clear_a_over_curr_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear channel a overcurrent fault flag 
....................    reg_status = set_register_bits(reg_status, a_over_curr_flag_addr, a_over_curr_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... */ 
.................... // Sets driver parameters 
.................... void set_driver() 
.................... { 
....................    delay = 10; 
*
0289:  MOVLW  0A
028A:  MOVWF  36
....................    // dead_time         :  dtime_400ns  
....................    //                      dtime_450ns  
....................    //                      dtime_650ns  
....................    //                      dtime_850ns 
....................    // curent_amp_gain   :  gain_5 
....................    //                      gain_10 
....................    //                      gain_20 
....................    //                      gain_40 
....................    // src_stall_detect  :  stall_int 
....................    //                      stall_ext 
....................    // microstepping     :  full_step 
....................    //                      half_step 
....................    //                      _4x 
....................    //                      _8x 
....................    //                      _16x 
....................    //                      _32x 
....................    //                      _64x 
....................    //                      _128x 
....................    //                      _256x 
....................    // single_step_out   :  no_action 
....................    //                      one_step 
....................    // dir_control       :  dir_pin 
....................    //                      inv_dir_pin 
....................    // motor_state       :  motor_disable 
....................    //                      motor_enable 
....................    set_ctrl_reg(dtime_400ns, gain_5, stall_int, _256x, no_action, dir_pin, motor_enable); 
028B:  CLRF   37
028C:  CLRF   38
028D:  CLRF   39
028E:  MOVLW  08
028F:  MOVWF  3A
0290:  CLRF   3B
0291:  CLRF   3C
0292:  MOVLW  01
0293:  MOVWF  3D
....................    //set_dead_time(dtime_400ns); 
....................    //set_amp_gain(gain_5); 
....................    //set_stall_detection(stall_int); 
....................    //set_microstepping_mode(_64x); 
....................    //set_rstep(no_action); 
....................    //set_dir_mode(dir_pin); 
....................    //set_motor_state(motor_enable); 
....................     
....................    // emf_samp_thr      :  emf_50us 
....................    //                      emf_100us 
....................    //                      emf_200us 
....................    //                      emf_300us 
....................    //                      emf_400us 
....................    //                      emf_600us 
....................    //                      emf_800us 
....................    //                      emf_1000us 
....................    set_torque_reg(emf_50us, 50); 
*
0330:  CLRF   37
0331:  MOVLW  32
0332:  MOVWF  38
....................    //set_emf_samp_thr(emf_50us); 
....................    //set_torque(200); 
....................     
....................    // pwm_mode          :  int_indexer 
....................    //                      ext_indexer 
....................    set_off_reg(int_indexer, 10); 
*
0381:  CLRF   37
0382:  MOVLW  0A
0383:  MOVWF  38
....................    //set_pwm_mode(int_indexer); 
....................    //set_off_time(70); 
....................     
....................    // adap_blank_state  :  disable_abt 
....................    //                      enable_abt 
....................    set_blank_reg(enable_abt, 90); 
*
03D2:  MOVLW  01
03D3:  MOVWF  37
03D4:  MOVLW  5A
03D5:  MOVWF  38
....................    //set_adap_blank_state(enable_abt); 
....................    //set_blank_time(125); 
....................     
....................    //decay_mode         :  force_slow_decay 
....................    //                      slow_mixed_decay 
....................    //                      force_fast_decay 
....................    //                      mixed_decay 
....................    //                      slow_auto_mixed_decay 
....................    //                      auto_mixed_decay 
....................    set_decay_reg(mixed_decay, 10); 
*
0423:  MOVLW  03
0424:  MOVWF  37
0425:  MOVLW  0A
0426:  MOVWF  38
....................    //set_decay_mode(auto_mixed_decay); 
....................    //set_decay_time(41); 
....................     
....................    // emf_vol_div       :  divide_by_32 
....................    //                      divide_by_16 
....................    //                      divide_by_8 
....................    //                      divide_by_4 
....................    // emf_samp_mode     :  after_1_step 
....................    //                      after_2_steps 
....................    //                      after_4_steps 
....................    //                      after_8_steps 
....................    set_stall_reg(divide_by_8, after_2_steps, 20); 
*
0475:  MOVLW  02
0476:  MOVWF  37
0477:  MOVLW  01
0478:  MOVWF  38
0479:  MOVLW  14
047A:  MOVWF  39
....................    //set_emf_vol_div(divide_by_8); 
....................    //set_emf_samp_mode(after_2_steps); 
....................    //set_stall_thr(20); 
....................     
....................    // hs_peak_cur       :  hs_50mA 
....................    //                      hs_100mA 
....................    //                      hs_150mA 
....................    //                      hs_200mA 
....................    // ls_peak_cur       :  ls_100mA 
....................    //                      ls_200mA 
....................    //                      ls_300mA 
....................    //                      ls_400mA 
....................    // hs_drive_time     :  hs_250ns 
....................    //                      hs_500ns 
....................    //                      hs_1us 
....................    //                      hs_2us 
....................    // ls_drive_time     :  ls_250ns 
....................    //                      ls_500ns 
....................    //                      ls_1us 
....................    //                      ls_2us 
....................    // ocp_deg_time      :  ocp_1us 
....................    //                      ocp_2us 
....................    //                      ocp_4us 
....................    //                      ocp_8us 
....................    // ocp_thr           :  ocp_250mV 
....................    //                      ocp_500mV 
....................    //                      ocp_750mV 
....................    //                      ocp_1000mV 
....................    set_drive_reg(hs_50mA, ls_100mA, hs_1us, ls_1us, ocp_1us, ocp_250mV); 
*
04D9:  CLRF   37
04DA:  CLRF   38
04DB:  MOVLW  02
04DC:  MOVWF  39
04DD:  MOVWF  3A
04DE:  CLRF   3B
04DF:  CLRF   3C
....................    //set_hs_peak_cur(hs_200mA); 
....................    //set_ls_peak_cur(ls_400mA); 
....................    //set_hs_drive_time(hs_1us); 
....................    //set_ls_drive_time(ls_1us); 
....................    //set_ocp_deg_time(ocp_1us); 
....................    //set_ocp_thr(ocp_250mV); 
....................     
....................    clear_status_reg(); 
....................    //clear_stall_flag(); 
....................    //clear_b_fault_flag(); 
....................    //clear_a_fault_flag(); 
....................    //clear_b_over_curr_flag(); 
....................    //clear_a_over_curr_flag(); 
....................     
....................    delay_ms(100); 
*
059C:  MOVLW  64
059D:  MOVWF  40
059E:  CALL   11F
059F:  MOVLP  00
05A0:  GOTO   5EB (RETURN)
.................... } 
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
.................... { 
....................    char command = fgetc(RS232); 
....................    unsigned int i=0; 
....................        
....................    switch (command) 
....................    { 
....................       case 'S':   unsigned int input_delay[3]; 
....................                   for(i=0; i<3; i++) 
....................                   { 
....................                      input_delay[i]=(unsigned)(fgetc(RS232)-48); 
....................                   } 
....................                    
....................                   delay=100*input_delay[0]+10*input_delay[1]+1*input_delay[2]; 
....................                   break; 
....................       case 'D':   drv_debug = !drv_debug; 
....................                   fprintf(RS232, "Driver Debug: %u", drv_debug); 
....................                   break; 
....................       case 'O':   unsigned int input_off[3]; 
....................                   for(i=0; i<3; i++) 
....................                   { 
....................                      input_off[i]=(unsigned)(fgetc(RS232)-48); 
....................                   } 
....................                    
....................                   unsigned int off = 100*input_off[0] + 10*input_off[1] + 1*input_off[2]; 
....................                   set_off_time(off); 
....................                   break; 
....................       case 'B':   unsigned int input_blank[3]; 
....................                   for(i=0; i<3; i++) 
....................                   { 
....................                      input_blank[i]=(unsigned)(fgetc(RS232)-48); 
....................                   } 
....................                    
....................                   unsigned int blank = 100*input_blank[0] + 10*input_blank[1] + 1*input_blank[2]; 
....................                   set_blank_time(blank); 
....................                   break; 
....................       default :   return;  
....................    } 
.................... } 
....................  
.................... #INT_RDA 
.................... void isr_rs232_message() 
.................... { 
....................    clear_interrupt(INT_RDA); 
*
0116:  MOVF   07,W
....................    disable_interrupts(INT_RDA); 
0117:  MOVLB  01
0118:  BCF    11.5
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1; 
0119:  MOVLW  01
011A:  MOVLB  00
011B:  MOVWF  35
011C:  BCF    11.5
011D:  MOVLP  00
011E:  GOTO   016
.................... }  
....................  
.................... void main() 
*
05B4:  MOVLW  F0
05B5:  MOVLB  01
05B6:  MOVWF  19
05B7:  MOVLB  02
05B8:  BSF    1E.0
05B9:  BSF    1D.7
05BA:  MOVLB  03
05BB:  BCF    1F.3
05BC:  MOVLW  0C
05BD:  MOVWF  1B
05BE:  MOVLW  A2
05BF:  MOVWF  1E
05C0:  MOVLW  90
05C1:  MOVWF  1D
05C2:  MOVLB  00
05C3:  CLRF   25
05C4:  CLRF   24
05C5:  CLRF   27
05C6:  CLRF   26
05C7:  CLRF   29
05C8:  CLRF   28
05C9:  CLRF   2B
05CA:  CLRF   2A
05CB:  CLRF   2D
05CC:  CLRF   2C
05CD:  CLRF   2F
05CE:  CLRF   2E
05CF:  CLRF   31
05D0:  CLRF   30
05D1:  CLRF   33
05D2:  CLRF   32
05D3:  BSF    34.0
05D4:  CLRF   35
05D5:  MOVLW  1E
05D6:  MOVWF  36
05D7:  MOVLB  03
05D8:  CLRF   0C
05D9:  CLRF   0D
05DA:  MOVLB  02
05DB:  CLRF   12
05DC:  CLRF   11
05DD:  CLRF   14
05DE:  CLRF   13
.................... { 
....................    delay_ms(10); 
05DF:  MOVLW  0A
05E0:  MOVLB  00
05E1:  MOVWF  40
05E2:  CALL   11F
....................     
....................    // Set I/O states of the ports 
....................    //           76543210                   
....................    set_tris_a(0b00101100);        
05E3:  MOVLW  2C
05E4:  TRIS   5
....................    set_tris_b(0b11001111); 
05E5:  MOVLW  CF
05E6:  TRIS   6
....................  
....................    // Set alternative pin functions 
....................    set_pins(); 
05E7:  GOTO   133
....................    // Set SPI parameters 
....................    set_SPI(); 
05E8:  GOTO   139
....................    // Set variables to default values 
....................    set_variables(); 
05E9:  GOTO   146
....................    // Set driver 
....................    set_driver(); 
05EA:  GOTO   289
....................  
....................    enable_interrupts(global); 
05EB:  MOVLW  C0
05EC:  IORWF  0B,F
....................    enable_interrupts(INT_RDA); 
05ED:  MOVLB  01
05EE:  BSF    11.5
....................     
....................    while(true) 
....................    {   
.................... //!      if(reg_rs232_message) 
.................... //!      {    
.................... //!         disable_interrupts(INT_RDA); 
.................... //!          
.................... //!         reg_rs232_message=0; 
.................... //!         rs232_message(); 
.................... //!          
.................... //!         enable_interrupts(INT_RDA); 
.................... //!      } 
....................          if(input(HOME_SWITCH)) 
05EF:  BSF    0D.3
05F0:  MOVLB  00
05F1:  BTFSC  0D.3
....................          { 
....................  
....................          } 
05F2:  GOTO   608
....................          else 
....................          { 
....................             output_high(DRV_STEP); 
05F3:  MOVLB  01
05F4:  BCF    0C.0
05F5:  MOVLB  02
05F6:  BSF    0C.0
....................             delay_us(5); 
05F7:  MOVLW  0C
05F8:  MOVWF  77
05F9:  DECFSZ 77,F
05FA:  GOTO   5F9
05FB:  GOTO   5FC
05FC:  NOP
....................             output_low(DRV_STEP); 
05FD:  MOVLB  01
05FE:  BCF    0C.0
05FF:  MOVLB  02
0600:  BCF    0C.0
....................             delay_us(delay - 5); 
0601:  MOVLW  05
0602:  MOVLB  00
0603:  SUBWF  36,W
0604:  MOVWF  37
0605:  MOVF   37,W
0606:  MOVWF  38
0607:  GOTO   5A1
....................          } 
0608:  MOVLB  01
0609:  GOTO   5EF
....................    }  
.................... } 
060A:  SLEEP

Configuration Fuses:
   Word  1: 0E04   INTRC_IO NOWDT PUT NOMCLR PROTECT CPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1AFC   WRT PLL_SW STVREN BORV25 NODEBUG NOLVP

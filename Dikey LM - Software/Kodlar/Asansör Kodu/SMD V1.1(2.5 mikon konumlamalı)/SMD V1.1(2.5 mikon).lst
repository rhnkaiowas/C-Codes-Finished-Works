CCS PCM C Compiler, Version 5.025d, 1               18-Tem-14 10:57
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   E:\File Server\Modesis\Proje Dosyalarý\SMD - Adým Motor Sürücü\Software\Asansör Kod DRV8711\SMD V1.1(2.5 mikon konumlamalý)\SMD V1.1(2.5 mikon).lst

               ROM used:   1174 words (57%)
                           Largest free fragment is 874
               RAM used:   6 (2%) at main() level
                           38 (11%) worst case
               Stack used: 2 locations
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   476
0002:  NOP
.................... #INCLUDE <16f1826.h>  
.................... //////////// Standard Header file for the PIC16F1826 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1826 
0003:  BRW
0004:  RETLW  91
0005:  RETLW  09
0006:  RETLW  F7
0007:  RETLW  03
0008:  RETLW  0B
0009:  RETLW  03
000A:  RETLW  90
000B:  RETLW  02
000C:  RETLW  42
000D:  RETLW  02
000E:  RETLW  0B
000F:  RETLW  02
0010:  RETLW  E1
0011:  RETLW  01
0012:  RETLW  BF
0013:  RETLW  01
0014:  RETLW  A4
0015:  RETLW  01
0016:  RETLW  8D
0017:  RETLW  01
0018:  RETLW  7A
0019:  RETLW  01
001A:  RETLW  69
001B:  RETLW  01
001C:  RETLW  5A
001D:  RETLW  01
001E:  RETLW  4D
001F:  RETLW  01
0020:  RETLW  42
0021:  RETLW  01
0022:  RETLW  37
0023:  RETLW  01
0024:  RETLW  2E
0025:  RETLW  01
0026:  RETLW  25
0027:  RETLW  01
0028:  RETLW  1D
0029:  RETLW  01
002A:  RETLW  15
002B:  RETLW  01
002C:  RETLW  0F
002D:  RETLW  01
002E:  RETLW  08
002F:  RETLW  01
0030:  RETLW  02
0031:  RETLW  01
0032:  RETLW  FD
0033:  RETLW  00
0034:  RETLW  F7
0035:  RETLW  00
0036:  RETLW  F3
0037:  RETLW  00
0038:  RETLW  EE
0039:  RETLW  00
003A:  RETLW  EA
003B:  RETLW  00
003C:  RETLW  E5
003D:  RETLW  00
003E:  RETLW  E2
003F:  RETLW  00
0040:  RETLW  DE
0041:  RETLW  00
0042:  RETLW  DA
0043:  RETLW  00
0044:  RETLW  D7
0045:  RETLW  00
0046:  RETLW  D4
0047:  RETLW  00
0048:  RETLW  D1
0049:  RETLW  00
004A:  RETLW  CE
004B:  RETLW  00
004C:  RETLW  CB
004D:  RETLW  00
004E:  RETLW  C8
004F:  RETLW  00
0050:  RETLW  C5
0051:  RETLW  00
0052:  RETLW  C3
0053:  RETLW  00
0054:  RETLW  C0
0055:  RETLW  00
0056:  RETLW  BE
0057:  RETLW  00
0058:  RETLW  BC
0059:  RETLW  00
005A:  RETLW  BA
005B:  RETLW  00
005C:  RETLW  B8
005D:  RETLW  00
005E:  RETLW  B6
005F:  RETLW  00
0060:  RETLW  B4
0061:  RETLW  00
0062:  RETLW  B2
0063:  RETLW  00
0064:  RETLW  B0
0065:  RETLW  00
0066:  RETLW  AE
0067:  RETLW  00
0068:  RETLW  AC
0069:  RETLW  00
006A:  RETLW  AB
006B:  RETLW  00
006C:  RETLW  A9
006D:  RETLW  00
006E:  RETLW  A7
006F:  RETLW  00
0070:  RETLW  A6
0071:  RETLW  00
0072:  RETLW  A4
0073:  RETLW  00
0074:  RETLW  A3
0075:  RETLW  00
0076:  RETLW  A2
0077:  RETLW  00
0078:  RETLW  A0
0079:  RETLW  00
007A:  RETLW  9F
007B:  RETLW  00
007C:  RETLW  9D
007D:  RETLW  00
007E:  RETLW  9C
007F:  RETLW  00
0080:  RETLW  9B
0081:  RETLW  00
0082:  RETLW  9A
0083:  RETLW  00
0084:  RETLW  98
0085:  RETLW  00
0086:  RETLW  97
0087:  RETLW  00
0088:  RETLW  96
0089:  RETLW  00
008A:  RETLW  95
008B:  RETLW  00
008C:  RETLW  94
008D:  RETLW  00
008E:  RETLW  93
008F:  RETLW  00
0090:  RETLW  92
0091:  RETLW  00
0092:  RETLW  91
0093:  RETLW  00
0094:  RETLW  90
0095:  RETLW  00
0096:  RETLW  8F
0097:  RETLW  00
0098:  RETLW  8E
0099:  RETLW  00
009A:  RETLW  8D
009B:  RETLW  00
009C:  RETLW  8C
009D:  RETLW  00
009E:  RETLW  8B
009F:  RETLW  00
00A0:  RETLW  8A
00A1:  RETLW  00
00A2:  RETLW  89
00A3:  RETLW  00
00A4:  RETLW  88
00A5:  RETLW  00
00A6:  RETLW  87
00A7:  RETLW  00
00A8:  RETLW  86
00A9:  RETLW  00
00AA:  RETLW  85
00AB:  RETLW  00
00AC:  RETLW  84
00AD:  RETLW  00
00AE:  RETLW  83
00AF:  RETLW  00
00B0:  RETLW  82
00B1:  RETLW  00
00B2:  RETLW  81
00B3:  RETLW  00
00B4:  RETLW  80
00B5:  RETLW  00
00B6:  RETLW  7F
00B7:  RETLW  00
00B8:  RETLW  7E
00B9:  RETLW  00
00BA:  RETLW  7D
00BB:  RETLW  00
00BC:  RETLW  7C
00BD:  RETLW  00
00BE:  RETLW  7B
00BF:  RETLW  00
00C0:  RETLW  7A
00C1:  RETLW  00
00C2:  RETLW  79
00C3:  RETLW  00
00C4:  RETLW  78
00C5:  RETLW  00
00C6:  RETLW  77
00C7:  RETLW  00
00C8:  RETLW  76
00C9:  RETLW  00
00CA:  RETLW  75
00CB:  RETLW  00
00CC:  RETLW  74
00CD:  RETLW  00
00CE:  RETLW  73
00CF:  RETLW  00
00D0:  RETLW  72
00D1:  RETLW  00
00D2:  RETLW  71
00D3:  RETLW  00
00D4:  RETLW  70
00D5:  RETLW  00
00D6:  RETLW  6F
00D7:  RETLW  00
00D8:  RETLW  6E
00D9:  RETLW  00
00DA:  RETLW  6D
00DB:  RETLW  00
00DC:  RETLW  6C
00DD:  RETLW  00
00DE:  RETLW  6B
00DF:  RETLW  00
00E0:  RETLW  6A
00E1:  RETLW  00
00E2:  RETLW  69
00E3:  RETLW  00
00E4:  RETLW  68
00E5:  RETLW  00
00E6:  RETLW  67
00E7:  RETLW  00
00E8:  RETLW  66
00E9:  RETLW  00
00EA:  RETLW  65
00EB:  RETLW  00
00EC:  RETLW  64
00ED:  RETLW  00
*
046D:  BCF    0A.0
046E:  BCF    0A.1
046F:  BSF    0A.2
0470:  ADDWF  02,F
0471:  GOTO   3F1
0472:  GOTO   3D4
0473:  GOTO   40D
0474:  GOTO   423
0475:  GOTO   43D
....................  
.................... #list 
....................  
....................  
.................... #FUSES INTRC_IO                                                      // High Speed Oscilator (>4 Mhz) crystal 
.................... #FUSES NOWDT                                                         // Watch Dog Timer disabled 
.................... #FUSES PUT                                                           // Power Up Timer enabled 
.................... #FUSES MCLR                                                          // Master Clear pin enabled 
.................... #FUSES BROWNOUT                                                      // Brownout Reset enabled 
.................... #FUSES BORV25                                                        // Brownout Reset at 2.5V 
.................... #FUSES NOLVP                                                         // Low Voltage Programming disabled 
.................... #FUSES CPD                                                           // Data EEPROM code protected 
.................... #FUSES PROTECT                                                       // Code protected from reads 
.................... #FUSES NOIESO                                                        // Internal External Switch Over Mode disabled 
.................... #FUSES NOFCMEN                                                       // Fail-safe clock monitor disabled 
....................  
.................... #USE   DELAY(clock=16000000)                                         // delay() func. adjusted for 20Mhz Primary Osc. 
*
00EE:  MOVLW  20
00EF:  MOVWF  05
00F0:  MOVLW  16
00F1:  MOVWF  04
00F2:  MOVF   00,W
00F3:  BTFSC  03.2
00F4:  GOTO   103
00F5:  MOVLW  05
00F6:  MOVWF  78
00F7:  CLRF   77
00F8:  DECFSZ 77,F
00F9:  GOTO   0F8
00FA:  DECFSZ 78,F
00FB:  GOTO   0F7
00FC:  MOVLW  2E
00FD:  MOVWF  77
00FE:  DECFSZ 77,F
00FF:  GOTO   0FE
0100:  GOTO   101
0101:  DECFSZ 00,F
0102:  GOTO   0F5
0103:  RETURN
*
02B6:  MOVLW  03
02B7:  SUBWF  2E,F
02B8:  BTFSS  03.0
02B9:  GOTO   2C5
02BA:  MOVLW  20
02BB:  MOVWF  05
02BC:  MOVLW  0E
02BD:  MOVWF  04
02BE:  MOVF   00,W
02BF:  BTFSC  03.2
02C0:  GOTO   2C5
02C1:  GOTO   2C3
02C2:  NOP
02C3:  DECFSZ 00,F
02C4:  GOTO   2C2
02C5:  RETURN
....................  
.................... // Pin assignments 
.................... #DEFINE DRV_STEP     PIN_A0                  // Step output pin 
.................... #DEFINE DRV_RESET    PIN_A1                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.) 
.................... #DEFINE LM_UP        PIN_A2                  // Up limit switch input pin 
.................... #DEFINE LM_DOWN      PIN_A3                  // Down limit switch input pin 
.................... #DEFINE DRV_DIR      PIN_A4                  // Direction output pin 
....................  
.................... #DEFINE SPI_SDO      PIN_A6                  // SPI data output pin 
.................... #DEFINE SPI_CS       PIN_A7                  // SPI chip select output pin 
....................  
.................... #DEFINE BT_DOWN      PIN_B0                  // Down button input pin 
.................... #DEFINE SPI_SDI      PIN_B1                  // SPI data input pin 
....................  
.................... #DEFINE BT_UP        PIN_B3                  // Up button input pin 
.................... #DEFINE SPI_SCK      PIN_B4                  // SPI clock output pin 
....................  
.................... #DEFINE DRV_STALL    PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut) 
.................... #DEFINE DRV_FAULT    PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut) 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //OPTION Register  
.................... #WORD OPTION         = 0x095 
.................... //Bits of Option Register 
.................... #BIT OPTION_WPUEN    = OPTION.7 
....................  
....................  
.................... // SPI Registers 
.................... #WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register 
.................... #WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register 
.................... #WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register 
.................... #WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register 
.................... // Pin function control registers 
.................... #WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0 
.................... #WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1 
....................  
.................... // Bits of SSP1CON1 register 
.................... #BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit 
.................... #BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit 
.................... #BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit 
.................... #BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits 
.................... #BIT SPI_MODE_2         = SPI_SSP1CON1.2    
.................... #BIT SPI_MODE_1         = SPI_SSP1CON1.1    
.................... #BIT SPI_MODE_0         = SPI_SSP1CON1.0   
....................  
.................... // Bits of SPI_SSP1STAT register 
.................... #BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit 
.................... #BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit 
.................... #BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit 
....................  
.................... // Bits of SPI_PIR1 register 
.................... #BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit 
....................  
.................... // Bits of PIN_APFCON0 register 
.................... #BIT PIN_RX_SELECT      = PIN_APFCON0.7      // RX pin selection bit 
.................... #BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit  
.................... #BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit  
....................  
.................... // Bits of PIN_APFCON1 register 
.................... #BIT PIN_TX_SELECT      = PIN_APFCON1.0      // TX pin selection bit 
....................  
....................  
.................... enum  State     {OFF = 0, ON   = 1};                                 // Motor states 
.................... enum  Direction {UP  = 0, DOWN = 1};                                 // Direction of motion 
.................... enum  Motion    {ACC = 0, WALK = 1, RUN  = 2, DEC = 3, STEADY = 4};  // State of the motion 
....................  
.................... int16 const run_lim          = 800;                                  // Duration of the slow motion (per count) before acclerating to high speed   
.................... int   const acc_lim          = 117;                                  // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... int16 const periods[acc_lim] = {2449,1015,779,656,578,523,481,447,420,397,378,361,346,333,322,311,302,293,285,277,271,264,258,253,247,243,238,234,229,226,222, 
.................... 218,215,212,209,206,203,200,197,195,192,190,188,186,184,182,180,178,176,174,172,171,169,167,166,164,163,162,160,159,157,156,155,154,152,151,150,149,148,147, 
.................... 146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108, 
.................... 107,106,105,104,103,102,101,100}; 
....................  
.................... int const off_time = 50;                                             // Off time of the pwm signal (should be smaller than period) 
.................... int8      motion_state = STEADY;                                     // Current state of the motion 
....................  
.................... void set_SPI() 
.................... { 
....................    // Disable SPI to set registers 
....................    SPI_ENABLE = 0; 
*
010A:  MOVLB  04
010B:  BCF    15.5
....................    // Set idle state of the clock to low  
....................    SPI_CLOCK_POLARITY = 0; 
010C:  BCF    15.4
....................    // Set SPI mode to SPI  
....................    SPI_MODE_3 = 0;  
010D:  BCF    15.3
....................    SPI_MODE_2 = 0; 
010E:  BCF    15.2
....................    SPI_MODE_1 = 1; 
010F:  BSF    15.1
....................    SPI_MODE_0 = 0; 
0110:  BCF    15.0
....................    // Input data sampled at the middle of data output time 
....................    SPI_INPUT_SAMPLE = 0; 
0111:  BCF    14.7
....................    // Transmit occurs on transition from active to idle clock state 
....................    SPI_CLOCK_EDGE = 1; 
0112:  BSF    14.6
....................  
....................    // Enable SPI 
....................    SPI_ENABLE = 1; 
0113:  BSF    15.5
0114:  MOVLP  00
0115:  MOVLB  00
0116:  GOTO   492 (RETURN)
.................... } 
....................  
.................... void set_variables() 
.................... { 
....................    output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction 
0117:  MOVLB  01
0118:  BCF    0C.7
0119:  MOVLB  02
011A:  BCF    0C.7
....................    output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver  
011B:  MOVLB  01
011C:  BCF    0C.1
011D:  MOVLB  02
011E:  BCF    0C.1
011F:  MOVLP  00
0120:  MOVLB  00
0121:  GOTO   493 (RETURN)
.................... } 
....................  
.................... void set_pins() 
.................... { 
....................    // Set RB2 as RX pin 
....................    //PIN_RX_SELECT = 1; 
....................    // Set RA6 as SDO pin 
....................    PIN_SDO_SELECT = 1; 
*
0104:  MOVLB  02
0105:  BSF    1D.6
....................    // Set RA5 as SS pin 
....................    PIN_SS_SELECT = 1; 
0106:  BSF    1D.5
0107:  MOVLP  00
0108:  MOVLB  00
0109:  GOTO   491 (RETURN)
....................    // Set RB5 as TX pin 
....................    //PIN_TX_SELECT = 1; 
.................... } 
....................  
....................  
.................... // Sets the motor state 
.................... void md_set_state(State value) 
.................... { 
....................    if (value == on) 
*
0122:  DECFSZ 31,W
0123:  GOTO   14A
....................    { 
....................    output_high(SPI_CS); 
0124:  MOVLB  01
0125:  BCF    0C.7
0126:  MOVLB  02
0127:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Ctrl_1     = 0b00001100; 
....................                     //76543210 
....................    int Ctrl_0     = 0b00011001;// Set enable pin to given motor state 
0128:  MOVLW  0C
0129:  MOVLB  00
012A:  MOVWF  32
012B:  MOVLW  19
012C:  MOVWF  33
....................    SPI_SSP1BUF = Ctrl_1; 
012D:  MOVLB  04
012E:  CLRF   12
012F:  MOVLB  00
0130:  MOVF   32,W
0131:  MOVLB  04
0132:  MOVWF  11
....................    while (!SPI_FLAG); 
0133:  MOVLB  00
0134:  BTFSS  11.3
0135:  GOTO   134
....................    SPI_FLAG = 0; 
0136:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0137:  MOVLB  04
0138:  CLRF   12
0139:  MOVLB  00
013A:  MOVF   33,W
013B:  MOVLB  04
013C:  MOVWF  11
....................    while (!SPI_FLAG); 
013D:  MOVLB  00
013E:  BTFSS  11.3
013F:  GOTO   13E
....................    SPI_FLAG = 0; 
0140:  BCF    11.3
....................    output_low(SPI_CS); 
0141:  MOVLB  01
0142:  BCF    0C.7
0143:  MOVLB  02
0144:  BCF    0C.7
....................    delay_ms(10); 
0145:  MOVLW  0A
0146:  MOVLB  00
0147:  MOVWF  36
0148:  CALL   0EE
....................    } 
0149:  GOTO   172
....................    else if (value == off) 
014A:  MOVF   31,F
014B:  BTFSS  03.2
014C:  GOTO   172
....................    { 
....................    output_high(SPI_CS); 
014D:  MOVLB  01
014E:  BCF    0C.7
014F:  MOVLB  02
0150:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Ctrl_1     = 0b00001100; 
....................                     //76543210 
....................    int Ctrl_0     = 0b00011000;// Set enable pin to given motor state 
0151:  MOVLW  0C
0152:  MOVLB  00
0153:  MOVWF  34
0154:  MOVLW  18
0155:  MOVWF  35
....................    SPI_SSP1BUF = Ctrl_1; 
0156:  MOVLB  04
0157:  CLRF   12
0158:  MOVLB  00
0159:  MOVF   34,W
015A:  MOVLB  04
015B:  MOVWF  11
....................    while (!SPI_FLAG); 
015C:  MOVLB  00
015D:  BTFSS  11.3
015E:  GOTO   15D
....................    SPI_FLAG = 0; 
015F:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0160:  MOVLB  04
0161:  CLRF   12
0162:  MOVLB  00
0163:  MOVF   35,W
0164:  MOVLB  04
0165:  MOVWF  11
....................    while (!SPI_FLAG); 
0166:  MOVLB  00
0167:  BTFSS  11.3
0168:  GOTO   167
....................    SPI_FLAG = 0; 
0169:  BCF    11.3
....................    output_low(SPI_CS); 
016A:  MOVLB  01
016B:  BCF    0C.7
016C:  MOVLB  02
016D:  BCF    0C.7
....................    delay_ms(10); 
016E:  MOVLW  0A
016F:  MOVLB  00
0170:  MOVWF  36
0171:  CALL   0EE
....................    } 
0172:  RETURN
.................... } 
.................... // Sets the motion direction 
.................... void md_set_direction(Direction value) 
.................... { 
....................       output_bit(DRV_DIR, !value);                                     // Set direction pin to given value 
*
02A9:  MOVF   2B,F
02AA:  BTFSC  03.2
02AB:  GOTO   2B0
02AC:  MOVLB  02
02AD:  BCF    0C.4
02AE:  GOTO   2B2
02AF:  MOVLB  00
02B0:  MOVLB  02
02B1:  BSF    0C.4
02B2:  MOVLB  01
02B3:  BCF    0C.4
02B4:  MOVLB  00
02B5:  RETURN
.................... } 
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_set_state(OFF);                                                 // Motor off 
*
0173:  CLRF   31
0174:  CALL   122
....................    output_high(DRV_DIR);                                              // Direction control pin can be in any state 
0175:  MOVLB  01
0176:  BCF    0C.4
0177:  MOVLB  02
0178:  BSF    0C.4
....................    output_high(DRV_STEP);                                             // Keep step input pin high (A low-to-high transition advances the motor one increment  
0179:  MOVLB  01
017A:  BCF    0C.0
017B:  MOVLB  02
017C:  BSF    0C.0
....................     
....................    output_high(SPI_CS); 
017D:  MOVLB  01
017E:  BCF    0C.7
017F:  MOVLB  02
0180:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Ctrl_1     = 0b00001100; 
....................                     //76543210 
....................    int Ctrl_0     = 0b00011000; 
0181:  MOVLW  0C
0182:  MOVLB  00
0183:  MOVWF  21
0184:  MOVLW  18
0185:  MOVWF  22
....................    SPI_SSP1BUF = Ctrl_1; 
0186:  MOVLB  04
0187:  CLRF   12
0188:  MOVLB  00
0189:  MOVF   21,W
018A:  MOVLB  04
018B:  MOVWF  11
....................    while (!SPI_FLAG); 
018C:  MOVLB  00
018D:  BTFSS  11.3
018E:  GOTO   18D
....................    SPI_FLAG = 0; 
018F:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0190:  MOVLB  04
0191:  CLRF   12
0192:  MOVLB  00
0193:  MOVF   22,W
0194:  MOVLB  04
0195:  MOVWF  11
....................    while (!SPI_FLAG); 
0196:  MOVLB  00
0197:  BTFSS  11.3
0198:  GOTO   197
....................    SPI_FLAG = 0; 
0199:  BCF    11.3
....................    output_low(SPI_CS); 
019A:  MOVLB  01
019B:  BCF    0C.7
019C:  MOVLB  02
019D:  BCF    0C.7
....................    delay_ms(10); 
019E:  MOVLW  0A
019F:  MOVLB  00
01A0:  MOVWF  36
01A1:  CALL   0EE
....................  
....................    output_high(SPI_CS); 
01A2:  MOVLB  01
01A3:  BCF    0C.7
01A4:  MOVLB  02
01A5:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Torque_1   = 0b00010000; 
....................                     //76543210 
....................    int Torque_0   = 0b10110111; 
01A6:  MOVLW  10
01A7:  MOVLB  00
01A8:  MOVWF  23
01A9:  MOVLW  B7
01AA:  MOVWF  24
....................    SPI_SSP1BUF = Torque_1; 
01AB:  MOVLB  04
01AC:  CLRF   12
01AD:  MOVLB  00
01AE:  MOVF   23,W
01AF:  MOVLB  04
01B0:  MOVWF  11
....................    while (!SPI_FLAG); 
01B1:  MOVLB  00
01B2:  BTFSS  11.3
01B3:  GOTO   1B2
....................    SPI_FLAG = 0; 
01B4:  BCF    11.3
....................    SPI_SSP1BUF = Torque_0; 
01B5:  MOVLB  04
01B6:  CLRF   12
01B7:  MOVLB  00
01B8:  MOVF   24,W
01B9:  MOVLB  04
01BA:  MOVWF  11
....................    while (!SPI_FLAG); 
01BB:  MOVLB  00
01BC:  BTFSS  11.3
01BD:  GOTO   1BC
....................    SPI_FLAG = 0; 
01BE:  BCF    11.3
....................    output_low(SPI_CS); 
01BF:  MOVLB  01
01C0:  BCF    0C.7
01C1:  MOVLB  02
01C2:  BCF    0C.7
....................    delay_ms(10); 
01C3:  MOVLW  0A
01C4:  MOVLB  00
01C5:  MOVWF  36
01C6:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
01C7:  MOVLB  01
01C8:  BCF    0C.7
01C9:  MOVLB  02
01CA:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Off_1      = 0b00100000; 
....................                     //76543210 
....................    int Off_0      = 0b01111001; 
01CB:  MOVLW  20
01CC:  MOVLB  00
01CD:  MOVWF  25
01CE:  MOVLW  79
01CF:  MOVWF  26
....................    SPI_SSP1BUF = Off_1; 
01D0:  MOVLB  04
01D1:  CLRF   12
01D2:  MOVLB  00
01D3:  MOVF   25,W
01D4:  MOVLB  04
01D5:  MOVWF  11
....................    while (!SPI_FLAG); 
01D6:  MOVLB  00
01D7:  BTFSS  11.3
01D8:  GOTO   1D7
....................    SPI_FLAG = 0; 
01D9:  BCF    11.3
....................    SPI_SSP1BUF = Off_0; 
01DA:  MOVLB  04
01DB:  CLRF   12
01DC:  MOVLB  00
01DD:  MOVF   26,W
01DE:  MOVLB  04
01DF:  MOVWF  11
....................    while (!SPI_FLAG); 
01E0:  MOVLB  00
01E1:  BTFSS  11.3
01E2:  GOTO   1E1
....................    SPI_FLAG = 0; 
01E3:  BCF    11.3
....................    output_low(SPI_CS); 
01E4:  MOVLB  01
01E5:  BCF    0C.7
01E6:  MOVLB  02
01E7:  BCF    0C.7
....................    delay_ms(10); 
01E8:  MOVLW  0A
01E9:  MOVLB  00
01EA:  MOVWF  36
01EB:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
01EC:  MOVLB  01
01ED:  BCF    0C.7
01EE:  MOVLB  02
01EF:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Blank_1    = 0b00110001; 
....................                     //76543210 
....................    int Blank_0    = 0b10010110; 
01F0:  MOVLW  31
01F1:  MOVLB  00
01F2:  MOVWF  27
01F3:  MOVLW  96
01F4:  MOVWF  28
....................    SPI_SSP1BUF = Blank_1; 
01F5:  MOVLB  04
01F6:  CLRF   12
01F7:  MOVLB  00
01F8:  MOVF   27,W
01F9:  MOVLB  04
01FA:  MOVWF  11
....................    while (!SPI_FLAG); 
01FB:  MOVLB  00
01FC:  BTFSS  11.3
01FD:  GOTO   1FC
....................    SPI_FLAG = 0; 
01FE:  BCF    11.3
....................    SPI_SSP1BUF = Blank_0; 
01FF:  MOVLB  04
0200:  CLRF   12
0201:  MOVLB  00
0202:  MOVF   28,W
0203:  MOVLB  04
0204:  MOVWF  11
....................    while (!SPI_FLAG); 
0205:  MOVLB  00
0206:  BTFSS  11.3
0207:  GOTO   206
....................    SPI_FLAG = 0; 
0208:  BCF    11.3
....................    output_low(SPI_CS); 
0209:  MOVLB  01
020A:  BCF    0C.7
020B:  MOVLB  02
020C:  BCF    0C.7
....................    delay_ms(10); 
020D:  MOVLW  0A
020E:  MOVLB  00
020F:  MOVWF  36
0210:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
0211:  MOVLB  01
0212:  BCF    0C.7
0213:  MOVLB  02
0214:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Decay_1    = 0b01000101; 
....................                     //76543210 
....................    int Decay_0    = 0b00011100; 
0215:  MOVLW  45
0216:  MOVLB  00
0217:  MOVWF  29
0218:  MOVLW  1C
0219:  MOVWF  2A
....................    SPI_SSP1BUF = Decay_1; 
021A:  MOVLB  04
021B:  CLRF   12
021C:  MOVLB  00
021D:  MOVF   29,W
021E:  MOVLB  04
021F:  MOVWF  11
....................    while (!SPI_FLAG); 
0220:  MOVLB  00
0221:  BTFSS  11.3
0222:  GOTO   221
....................    SPI_FLAG = 0; 
0223:  BCF    11.3
....................    SPI_SSP1BUF = Decay_0; 
0224:  MOVLB  04
0225:  CLRF   12
0226:  MOVLB  00
0227:  MOVF   2A,W
0228:  MOVLB  04
0229:  MOVWF  11
....................    while (!SPI_FLAG); 
022A:  MOVLB  00
022B:  BTFSS  11.3
022C:  GOTO   22B
....................    SPI_FLAG = 0; 
022D:  BCF    11.3
....................    output_low(SPI_CS); 
022E:  MOVLB  01
022F:  BCF    0C.7
0230:  MOVLB  02
0231:  BCF    0C.7
....................    delay_ms(10); 
0232:  MOVLW  0A
0233:  MOVLB  00
0234:  MOVWF  36
0235:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
0236:  MOVLB  01
0237:  BCF    0C.7
0238:  MOVLB  02
0239:  BSF    0C.7
....................    int Stall_1    = 0b01011001; 
....................    int Stall_0    = 0b00010100; 
023A:  MOVLW  59
023B:  MOVLB  00
023C:  MOVWF  2B
023D:  MOVLW  14
023E:  MOVWF  2C
....................    SPI_SSP1BUF = Stall_1; 
023F:  MOVLB  04
0240:  CLRF   12
0241:  MOVLB  00
0242:  MOVF   2B,W
0243:  MOVLB  04
0244:  MOVWF  11
....................    while (!SPI_FLAG); 
0245:  MOVLB  00
0246:  BTFSS  11.3
0247:  GOTO   246
....................    SPI_FLAG = 0; 
0248:  BCF    11.3
....................    SPI_SSP1BUF = Stall_0; 
0249:  MOVLB  04
024A:  CLRF   12
024B:  MOVLB  00
024C:  MOVF   2C,W
024D:  MOVLB  04
024E:  MOVWF  11
....................    while (!SPI_FLAG); 
024F:  MOVLB  00
0250:  BTFSS  11.3
0251:  GOTO   250
....................    SPI_FLAG = 0; 
0252:  BCF    11.3
....................    output_low(SPI_CS); 
0253:  MOVLB  01
0254:  BCF    0C.7
0255:  MOVLB  02
0256:  BCF    0C.7
....................    delay_ms(10); 
0257:  MOVLW  0A
0258:  MOVLB  00
0259:  MOVWF  36
025A:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
025B:  MOVLB  01
025C:  BCF    0C.7
025D:  MOVLB  02
025E:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Drive_1    = 0b01101010; 
....................                     //76543210 
....................    int Drive_0    = 0b10100000; 
025F:  MOVLW  6A
0260:  MOVLB  00
0261:  MOVWF  2D
0262:  MOVLW  A0
0263:  MOVWF  2E
....................    SPI_SSP1BUF = Drive_1; 
0264:  MOVLB  04
0265:  CLRF   12
0266:  MOVLB  00
0267:  MOVF   2D,W
0268:  MOVLB  04
0269:  MOVWF  11
....................    while (!SPI_FLAG); 
026A:  MOVLB  00
026B:  BTFSS  11.3
026C:  GOTO   26B
....................    SPI_FLAG = 0; 
026D:  BCF    11.3
....................    SPI_SSP1BUF = Drive_0; 
026E:  MOVLB  04
026F:  CLRF   12
0270:  MOVLB  00
0271:  MOVF   2E,W
0272:  MOVLB  04
0273:  MOVWF  11
....................    while (!SPI_FLAG); 
0274:  MOVLB  00
0275:  BTFSS  11.3
0276:  GOTO   275
....................    SPI_FLAG = 0; 
0277:  BCF    11.3
....................    output_low(SPI_CS); 
0278:  MOVLB  01
0279:  BCF    0C.7
027A:  MOVLB  02
027B:  BCF    0C.7
....................    delay_ms(10); 
027C:  MOVLW  0A
027D:  MOVLB  00
027E:  MOVWF  36
027F:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
0280:  MOVLB  01
0281:  BCF    0C.7
0282:  MOVLB  02
0283:  BSF    0C.7
....................    int Status_1   = 0b01110000; 
....................    int Status_0   = 0b00000000; 
0284:  MOVLW  70
0285:  MOVLB  00
0286:  MOVWF  2F
0287:  CLRF   30
....................    SPI_SSP1BUF = Status_1; 
0288:  MOVLB  04
0289:  CLRF   12
028A:  MOVLB  00
028B:  MOVF   2F,W
028C:  MOVLB  04
028D:  MOVWF  11
....................    while (!SPI_FLAG); 
028E:  MOVLB  00
028F:  BTFSS  11.3
0290:  GOTO   28F
....................    SPI_FLAG = 0; 
0291:  BCF    11.3
....................    SPI_SSP1BUF = Status_0; 
0292:  MOVLB  04
0293:  CLRF   12
0294:  MOVLB  00
0295:  MOVF   30,W
0296:  MOVLB  04
0297:  MOVWF  11
....................    while (!SPI_FLAG); 
0298:  MOVLB  00
0299:  BTFSS  11.3
029A:  GOTO   299
....................    SPI_FLAG = 0; 
029B:  BCF    11.3
....................    output_low(SPI_CS); 
029C:  MOVLB  01
029D:  BCF    0C.7
029E:  MOVLB  02
029F:  BCF    0C.7
....................    delay_ms(10); 
02A0:  MOVLW  0A
02A1:  MOVLB  00
02A2:  MOVWF  36
02A3:  CALL   0EE
....................  
....................    delay_ms(100); 
02A4:  MOVLW  64
02A5:  MOVWF  36
02A6:  CALL   0EE
02A7:  MOVLP  00
02A8:  GOTO   494 (RETURN)
.................... } 
....................  
.................... // Starts motion cycle 
.................... void motion_cycle() 
*
02C6:  CLRF   22
02C7:  CLRF   21
02C8:  CLRF   24
02C9:  CLRF   23
02CA:  BCF    25.0
02CB:  CLRF   29
02CC:  CLRF   28
02CD:  CLRF   27
02CE:  CLRF   26
.................... { 
....................    // Start cycle  
....................    int16 step_count  =  0; 
....................    int16 period      =  0; 
....................    int1  running     =  0; 
....................    int32 i=0;  
....................    while(true) 
....................    { 
....................       if(input(BT_UP)) 
02CF:  MOVLB  01
02D0:  BSF    0D.3
02D1:  MOVLB  00
02D2:  BTFSS  0D.3
02D3:  GOTO   347
....................       { 
....................          if(input(LM_UP) == 0 && running == 0) 
02D4:  MOVLB  01
02D5:  BSF    0C.2
02D6:  MOVLB  00
02D7:  BTFSC  0C.2
02D8:  GOTO   331
02D9:  BTFSC  25.0
02DA:  GOTO   331
....................          { 
....................             md_set_direction(UP); 
02DB:  CLRF   2B
02DC:  CALL   2A9
....................             md_set_state(ON); 
02DD:  MOVLW  01
02DE:  MOVWF  31
02DF:  CALL   122
....................              
....................             //2.5 mikro step git              
....................             for(i=0; i<2; i++) 
02E0:  CLRF   29
02E1:  CLRF   28
02E2:  CLRF   27
02E3:  CLRF   26
02E4:  MOVF   29,F
02E5:  BTFSS  03.2
02E6:  GOTO   318
02E7:  MOVF   28,F
02E8:  BTFSS  03.2
02E9:  GOTO   318
02EA:  MOVF   27,F
02EB:  BTFSS  03.2
02EC:  GOTO   318
02ED:  MOVF   26,W
02EE:  SUBLW  01
02EF:  BTFSS  03.0
02F0:  GOTO   318
....................             {  
....................                output_high(DRV_STEP);  //Rampa kalkýþ 
02F1:  MOVLB  01
02F2:  BCF    0C.0
02F3:  MOVLB  02
02F4:  BSF    0C.0
....................                delay_us(2449); 
02F5:  MOVLW  02
02F6:  MOVLB  00
02F7:  MOVWF  36
02F8:  CALL   0EE
02F9:  MOVLW  02
02FA:  MOVWF  2B
02FB:  MOVLW  DF
02FC:  MOVWF  2E
02FD:  CALL   2B6
02FE:  DECFSZ 2B,F
02FF:  GOTO   2FB
....................                output_low(DRV_STEP); 
0300:  MOVLB  01
0301:  BCF    0C.0
0302:  MOVLB  02
0303:  BCF    0C.0
....................                delay_us(2449); 
0304:  MOVLW  02
0305:  MOVLB  00
0306:  MOVWF  36
0307:  CALL   0EE
0308:  MOVLW  02
0309:  MOVWF  2B
030A:  MOVLW  DF
030B:  MOVWF  2E
030C:  CALL   2B6
030D:  DECFSZ 2B,F
030E:  GOTO   30A
030F:  MOVLW  01
0310:  ADDWF  26,F
0311:  BTFSC  03.0
0312:  INCF   27,F
0313:  BTFSC  03.2
0314:  INCF   28,F
0315:  BTFSC  03.2
0316:  INCF   29,F
0317:  GOTO   2E4
....................             } 
....................             md_set_state(OFF); 
0318:  CLRF   31
0319:  CALL   122
....................             delay_ms(200); 
031A:  MOVLW  C8
031B:  MOVWF  36
031C:  CALL   0EE
....................              
....................             if(input(BT_UP)){ 
031D:  MOVLB  01
031E:  BSF    0D.3
031F:  MOVLB  00
0320:  BTFSS  0D.3
0321:  GOTO   330
....................             delay_ms(300); 
0322:  MOVLW  02
0323:  MOVWF  2B
0324:  MOVLW  96
0325:  MOVWF  36
0326:  CALL   0EE
0327:  DECFSZ 2B,F
0328:  GOTO   324
....................                if(input(BT_UP))  { 
0329:  MOVLB  01
032A:  BSF    0D.3
032B:  MOVLB  00
032C:  BTFSS  0D.3
032D:  GOTO   330
....................                   motion_state = WALK; 
032E:  MOVLW  01
032F:  MOVWF  20
....................                                  } 
....................                             } 
....................             // 
....................  
....................          } 
0330:  GOTO   346
....................          else if(input(LM_UP) && running == 1) 
0331:  MOVLB  01
0332:  BSF    0C.2
0333:  MOVLB  00
0334:  BTFSS  0C.2
0335:  GOTO   346
0336:  BTFSS  25.0
0337:  GOTO   346
....................          { 
....................             if(motion_state == ACC || motion_state == RUN) 
0338:  MOVF   20,F
0339:  BTFSC  03.2
033A:  GOTO   33F
033B:  MOVF   20,W
033C:  SUBLW  02
033D:  BTFSS  03.2
033E:  GOTO   342
....................                motion_state = DEC; 
033F:  MOVLW  03
0340:  MOVWF  20
0341:  GOTO   346
....................             else if(motion_state == WALK) 
0342:  DECFSZ 20,W
0343:  GOTO   346
....................                motion_state = STEADY; 
0344:  MOVLW  04
0345:  MOVWF  20
....................          } 
....................       } 
0346:  GOTO   3CE
....................       else if(input(BT_DOWN)) 
0347:  MOVLB  01
0348:  BSF    0D.0
0349:  MOVLB  00
034A:  BTFSS  0D.0
034B:  GOTO   3C0
....................       { 
....................          if(input(LM_DOWN) == 0 && running == 0) 
034C:  MOVLB  01
034D:  BSF    0C.3
034E:  MOVLB  00
034F:  BTFSC  0C.3
0350:  GOTO   3AA
0351:  BTFSC  25.0
0352:  GOTO   3AA
....................          { 
....................             md_set_direction(DOWN); 
0353:  MOVLW  01
0354:  MOVWF  2B
0355:  CALL   2A9
....................             md_set_state(ON); 
0356:  MOVLW  01
0357:  MOVWF  31
0358:  CALL   122
....................             //2.5 mikro step git              
....................             for(i=0; i<2; i++) 
0359:  CLRF   29
035A:  CLRF   28
035B:  CLRF   27
035C:  CLRF   26
035D:  MOVF   29,F
035E:  BTFSS  03.2
035F:  GOTO   391
0360:  MOVF   28,F
0361:  BTFSS  03.2
0362:  GOTO   391
0363:  MOVF   27,F
0364:  BTFSS  03.2
0365:  GOTO   391
0366:  MOVF   26,W
0367:  SUBLW  01
0368:  BTFSS  03.0
0369:  GOTO   391
....................             {  
....................                output_high(DRV_STEP);  //Rampa kalkýþ 
036A:  MOVLB  01
036B:  BCF    0C.0
036C:  MOVLB  02
036D:  BSF    0C.0
....................                delay_us(2449); 
036E:  MOVLW  02
036F:  MOVLB  00
0370:  MOVWF  36
0371:  CALL   0EE
0372:  MOVLW  02
0373:  MOVWF  2B
0374:  MOVLW  DF
0375:  MOVWF  2E
0376:  CALL   2B6
0377:  DECFSZ 2B,F
0378:  GOTO   374
....................                output_low(DRV_STEP); 
0379:  MOVLB  01
037A:  BCF    0C.0
037B:  MOVLB  02
037C:  BCF    0C.0
....................                delay_us(2449); 
037D:  MOVLW  02
037E:  MOVLB  00
037F:  MOVWF  36
0380:  CALL   0EE
0381:  MOVLW  02
0382:  MOVWF  2B
0383:  MOVLW  DF
0384:  MOVWF  2E
0385:  CALL   2B6
0386:  DECFSZ 2B,F
0387:  GOTO   383
0388:  MOVLW  01
0389:  ADDWF  26,F
038A:  BTFSC  03.0
038B:  INCF   27,F
038C:  BTFSC  03.2
038D:  INCF   28,F
038E:  BTFSC  03.2
038F:  INCF   29,F
0390:  GOTO   35D
....................             } 
....................             md_set_state(OFF); 
0391:  CLRF   31
0392:  CALL   122
....................             delay_ms(200); 
0393:  MOVLW  C8
0394:  MOVWF  36
0395:  CALL   0EE
....................              
....................             if(input(BT_DOWN)){ 
0396:  MOVLB  01
0397:  BSF    0D.0
0398:  MOVLB  00
0399:  BTFSS  0D.0
039A:  GOTO   3A9
....................             delay_ms(300); 
039B:  MOVLW  02
039C:  MOVWF  2B
039D:  MOVLW  96
039E:  MOVWF  36
039F:  CALL   0EE
03A0:  DECFSZ 2B,F
03A1:  GOTO   39D
....................                if(input(BT_DOWN))  { 
03A2:  MOVLB  01
03A3:  BSF    0D.0
03A4:  MOVLB  00
03A5:  BTFSS  0D.0
03A6:  GOTO   3A9
....................                   motion_state = WALK; 
03A7:  MOVLW  01
03A8:  MOVWF  20
....................                                  } 
....................                             } 
....................          } 
03A9:  GOTO   3BF
....................          else if(input(LM_DOWN) && running == 1) 
03AA:  MOVLB  01
03AB:  BSF    0C.3
03AC:  MOVLB  00
03AD:  BTFSS  0C.3
03AE:  GOTO   3BF
03AF:  BTFSS  25.0
03B0:  GOTO   3BF
....................          { 
....................             if(motion_state == ACC || motion_state == RUN) 
03B1:  MOVF   20,F
03B2:  BTFSC  03.2
03B3:  GOTO   3B8
03B4:  MOVF   20,W
03B5:  SUBLW  02
03B6:  BTFSS  03.2
03B7:  GOTO   3BB
....................                motion_state = DEC; 
03B8:  MOVLW  03
03B9:  MOVWF  20
03BA:  GOTO   3BF
....................             else if(motion_state == WALK) 
03BB:  DECFSZ 20,W
03BC:  GOTO   3BF
....................                motion_state = STEADY; 
03BD:  MOVLW  04
03BE:  MOVWF  20
....................          } 
....................       } 
03BF:  GOTO   3CE
....................       else 
....................       { 
....................          if(motion_state == ACC || motion_state == RUN) 
03C0:  MOVF   20,F
03C1:  BTFSC  03.2
03C2:  GOTO   3C7
03C3:  MOVF   20,W
03C4:  SUBLW  02
03C5:  BTFSS  03.2
03C6:  GOTO   3CA
....................             motion_state = DEC; 
03C7:  MOVLW  03
03C8:  MOVWF  20
03C9:  GOTO   3CE
....................          else if(motion_state == WALK) 
03CA:  DECFSZ 20,W
03CB:  GOTO   3CE
....................             motion_state = STEADY; 
03CC:  MOVLW  04
03CD:  MOVWF  20
....................       } 
....................        
....................        
....................  
....................       switch(motion_state)  
03CE:  MOVF   20,W
03CF:  ADDLW  FB
03D0:  BTFSC  03.0
03D1:  GOTO   446
03D2:  ADDLW  05
03D3:  GOTO   46D
....................       {  
....................          case WALK: 
....................             step_count++; 
03D4:  INCF   21,F
03D5:  BTFSC  03.2
03D6:  INCF   22,F
....................           
....................             if(step_count == 1) 
03D7:  DECFSZ 21,W
03D8:  GOTO   3E5
03D9:  MOVF   22,F
03DA:  BTFSS  03.2
03DB:  GOTO   3E5
....................             { 
....................                running = 1; 
03DC:  BSF    25.0
....................                md_set_state(ON); 
03DD:  MOVLW  01
03DE:  MOVWF  31
03DF:  CALL   122
....................                period = periods[0]; 
03E0:  MOVLW  09
03E1:  MOVWF  24
03E2:  MOVLW  91
03E3:  MOVWF  23
....................             } 
03E4:  GOTO   3F0
....................             else if(step_count == run_lim) 
03E5:  MOVF   21,W
03E6:  SUBLW  20
03E7:  BTFSS  03.2
03E8:  GOTO   3F0
03E9:  MOVF   22,W
03EA:  SUBLW  03
03EB:  BTFSS  03.2
03EC:  GOTO   3F0
....................             { 
....................                step_count   = 0; 
03ED:  CLRF   22
03EE:  CLRF   21
....................                motion_state = ACC; 
03EF:  CLRF   20
....................             } 
....................             break; 
03F0:  GOTO   446
....................          case ACC: 
....................             if(step_count == acc_lim - 1) 
03F1:  MOVF   21,W
03F2:  SUBLW  74
03F3:  BTFSS  03.2
03F4:  GOTO   3FA
03F5:  MOVF   22,F
03F6:  BTFSS  03.2
03F7:  GOTO   3FA
....................             { 
....................                motion_state = RUN; 
03F8:  MOVLW  02
03F9:  MOVWF  20
....................             } 
....................                 
....................             period = periods[step_count]; 
03FA:  BCF    03.0
03FB:  RLF    21,W
03FC:  MOVWF  79
03FD:  RLF    22,W
03FE:  MOVWF  7A
03FF:  MOVF   79,W
0400:  MOVWF  2B
0401:  INCF   79,W
0402:  CALL   003
0403:  MOVWF  7A
0404:  MOVF   2B,W
0405:  CALL   003
0406:  MOVWF  23
0407:  MOVF   7A,W
0408:  MOVWF  24
....................             step_count++; 
0409:  INCF   21,F
040A:  BTFSC  03.2
040B:  INCF   22,F
....................             break; 
040C:  GOTO   446
....................              
....................          case RUN: 
....................             period = periods[step_count - 1]; 
040D:  MOVLW  01
040E:  SUBWF  21,W
040F:  MOVWF  2B
0410:  MOVLW  00
0411:  SUBWFC 22,W
0412:  MOVWF  2C
0413:  BCF    03.0
0414:  RLF    2B,W
0415:  MOVWF  79
0416:  RLF    2C,W
0417:  MOVWF  7A
0418:  MOVF   79,W
0419:  MOVWF  2B
041A:  INCF   79,W
041B:  CALL   003
041C:  MOVWF  7A
041D:  MOVF   2B,W
041E:  CALL   003
041F:  MOVWF  23
0420:  MOVF   7A,W
0421:  MOVWF  24
....................             break; 
0422:  GOTO   446
....................     
....................          case DEC: 
....................             step_count--; 
0423:  MOVF   21,W
0424:  BTFSC  03.2
0425:  DECF   22,F
0426:  DECFSZ 21,F
....................             // Check if we at last step 
....................             if(step_count == 0) 
0427:  GOTO   42D
0428:  MOVF   22,F
0429:  BTFSS  03.2
042A:  GOTO   42D
....................             { 
....................                motion_state = STEADY; 
042B:  MOVLW  04
042C:  MOVWF  20
....................             } 
....................                 
....................             period = periods[step_count]; 
042D:  BCF    03.0
042E:  RLF    21,W
042F:  MOVWF  79
0430:  RLF    22,W
0431:  MOVWF  7A
0432:  MOVF   79,W
0433:  MOVWF  2B
0434:  INCF   79,W
0435:  CALL   003
0436:  MOVWF  7A
0437:  MOVF   2B,W
0438:  CALL   003
0439:  MOVWF  23
043A:  MOVF   7A,W
043B:  MOVWF  24
....................             break; 
043C:  GOTO   446
....................              
....................          case STEADY: 
....................             if(running) 
043D:  BTFSS  25.0
043E:  GOTO   446
....................             { 
....................                running    = 0; 
043F:  BCF    25.0
....................                period     = 0; 
0440:  CLRF   24
0441:  CLRF   23
....................                step_count = 0; 
0442:  CLRF   22
0443:  CLRF   21
....................                md_set_state(OFF); 
0444:  CLRF   31
0445:  CALL   122
....................             } 
....................             break; 
....................       } 
....................     
....................       if(running) 
0446:  BTFSS  25.0
0447:  GOTO   46A
....................       {   
....................          delay_us(off_time); 
0448:  MOVLW  42
0449:  MOVWF  77
044A:  DECFSZ 77,F
044B:  GOTO   44A
044C:  NOP
....................          output_low(DRV_STEP); 
044D:  MOVLB  01
044E:  BCF    0C.0
044F:  MOVLB  02
0450:  BCF    0C.0
....................          delay_us(period - off_time); 
0451:  MOVLW  32
0452:  MOVLB  00
0453:  SUBWF  23,W
0454:  MOVWF  2B
0455:  MOVLW  00
0456:  SUBWFC 24,W
0457:  MOVWF  2C
0458:  MOVF   2C,W
0459:  MOVWF  2D
045A:  INCF   2D,F
045B:  DECF   2D,F
045C:  BTFSC  03.2
045D:  GOTO   462
045E:  MOVLW  FF
045F:  MOVWF  2E
0460:  CALL   2B6
0461:  GOTO   45B
0462:  MOVF   2B,W
0463:  MOVWF  2E
0464:  CALL   2B6
....................          output_high(DRV_STEP); 
0465:  MOVLB  01
0466:  BCF    0C.0
0467:  MOVLB  02
0468:  BSF    0C.0
0469:  MOVLB  00
....................       } 
046A:  GOTO   2CF
....................    } 
046B:  MOVLP  00
046C:  GOTO   495 (RETURN)
.................... } 
....................  
.................... // Main method 
.................... void main() 
*
0476:  MOVLW  7A
0477:  MOVLB  01
0478:  MOVWF  19
0479:  MOVLW  04
047A:  MOVLB  00
047B:  MOVWF  20
047C:  MOVLB  03
047D:  CLRF   0C
047E:  CLRF   0D
047F:  MOVLB  02
0480:  CLRF   12
0481:  CLRF   11
0482:  CLRF   14
0483:  CLRF   13
.................... { 
....................    //             76543210 
....................      set_tris_a(0b00101100);       // Set I/O states of the ports 
0484:  MOVLW  2C
0485:  TRIS   5
....................      set_tris_b(0b11001111); 
0486:  MOVLW  CF
0487:  TRIS   6
....................     
....................    delay_ms(500); 
0488:  MOVLW  02
0489:  MOVLB  00
048A:  MOVWF  21
048B:  MOVLW  FA
048C:  MOVWF  36
048D:  CALL   0EE
048E:  DECFSZ 21,F
048F:  GOTO   48B
....................     
....................    //fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING STAGE\n\n\r"); 
....................     
....................    set_pins(); 
0490:  GOTO   104
....................    set_SPI(); 
0491:  GOTO   10A
....................    set_variables(); 
0492:  GOTO   117
....................    md_init();                                                           // Initialize motor driver 
0493:  GOTO   173
....................    motion_cycle();                                                      // Start motion cycle 
0494:  GOTO   2C6
.................... } 
0495:  SLEEP

Configuration Fuses:
   Word  1: 0E44   INTRC_IO NOWDT PUT MCLR PROTECT CPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1AFF   NOWRT PLL_SW STVREN BORV25 NODEBUG NOLVP

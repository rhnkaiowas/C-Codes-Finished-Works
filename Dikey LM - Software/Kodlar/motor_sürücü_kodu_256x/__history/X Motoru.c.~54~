#INCLUDE <16f1826.h> 

#FUSES INTRC_IO      // Internal RC clock (OSC1 and OSC2 pins are normal I/O)
#FUSES NOWDT         // Watch Dog Timer disabled
#FUSES PUT           // Power Up Timer enabled
#FUSES NOMCLR        // Master Clear pin is used for I/O
#FUSES PROTECT       // Code protected from reads
#FUSES CPD           // Data EEPROM code protected
#FUSES BROWNOUT      // Brownout Reset enabled
#FUSES BORV25        // Brownout Reset at 2.5V
#FUSES NOCLKOUT      // Disable clock output on OSC2
#FUSES NOIESO        // Internal External Switch Over Mode disabled
#FUSES NOFCMEN       // Fail-safe clock monitor disabled
#FUSES WRT           // Program memory write protected                                              
#FUSES NOLVP         // Low Voltage Programming disabled

#USE   DELAY(internal = 32MHz)
#USE   RS232(stream=RS232, baud=38400, xmit=PIN_B5, rcv=PIN_B2, parity=N, bits=8, stop=1)

#DEFINE DRV_STEP           PIN_A0                  // Step output pin to driver (Rising edge causes the indexer to move one step)
#DEFINE DRV_RESET          PIN_A1                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.)
#DEFINE DRV_DIR            PIN_A4                  // Direction output pin to driver (Logic level, sets the direction of stepping)
#DEFINE SPI_SDO            PIN_A6                  // SPI data output pin
#DEFINE SPI_CS             PIN_A7                  // SPI chip select pin
#DEFINE SPI_SDI            PIN_B1                  // SPI data input pin
#DEFINE SPI_SCK            PIN_B4                  // SPI clock output pin
#DEFINE DRV_STALL          PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut)
#DEFINE DRV_FAULT          PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut)

#DEFINE LIMIT_SWITCH       PIN_A2                  // Fault output pin to user
#DEFINE USER_DIR           PIN_A3                  // Direction input pin from user
#DEFINE USER_STEP          PIN_B0                  // Step input pin from user
#DEFINE HOME_SWITCH        PIN_B3                  // Enable input pin from user

// SPI Registers
#WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register
#WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register
#WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register
#WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register
// Pin function control registers
#WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0
#WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1

// Bits of SSP1CON1 register
#BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit
#BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit
#BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit
#BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits
#BIT SPI_MODE_2         = SPI_SSP1CON1.2   
#BIT SPI_MODE_1         = SPI_SSP1CON1.1   
#BIT SPI_MODE_0         = SPI_SSP1CON1.0  

// Bits of SPI_SSP1STAT register
#BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit
#BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit
#BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit

// Bits of SPI_PIR1 register
#BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit

// Bits of PIN_APFCON0 register
#BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit 
#BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit 

unsigned int32 current_distance  = 0;
int1 reg_rs232_message           = 0;
int1 mode                        = 1; // mode = 0: 32x mode = 1: 256x

unsigned int16 pulse_per_turn    = 51200;   //limit bastýgýnda 1cm açabilmesi için gereken pulse
unsigned int16 delay             = 5;
unsigned int16 acc_lim           = 280;             // Number of steps before we hit max speed

unsigned int16 const periods[280]={1000,1000,1000,1000,1000,999,999,998,997,997,996,995,994,993,
992,991,990,989,987,986,984,983,981,980,978,976,974,972,971,969,966,964,962,960,958,955,953,950,
948,945,942,940,937,934,931,928,925,922,919,916,913,910,907,903,900,896,893,890,886,882,879,875,
871,868,864,860,856,852,848,844,840,836,832,828,824,819,815,811,807,802,798,793,789,784,780,775,
771,766,762,757,752,748,743,738,733,728,724,719,714,709,704,699,694,689,684,679,674,669,664,659,
654,648,643,638,633,628,623,617,612,607,602,596,591,586,581,575,570,565,559,554,549,543,538,533,
527,522,517,511,506,500,495,490,484,479,474,468,463,458,452,447,442,436,431,426,420,415,410,405,
399,394,389,384,378,373,368,363,358,352,347,342,337,332,327,322,317,312,307,302,297,292,287,282,
277,273,268,263,258,253,249,244,239,235,230,226,221,216,212,208,203,199,194,190,186,182,177,173,
169,165,161,157,153,149,145,141,137,133,130,126,122,119,115,111,108,104,101,98,94,91,88,85,82,79,
76,73,70,67,64,61,59,56,53,51,48,46,43,41,39,37,35,32,30,28,27,25,23,21,20,18,17,15,14,12,11,10,9,
8,7,6,5,4,4,3,2,2,1,1,1,1,1,0};

// Sets alternative pin functions
void set_pins()
{
   // Set RA6 as SDO pin
   PIN_SDO_SELECT = 1;
   // Set RA5 as SS pin
   PIN_SS_SELECT = 1;
   // Set RB5 as TX pin
}
// Sets SPI parameters
void set_SPI()
{
   // Disable SPI to set registers
   SPI_ENABLE = 0;
   
   // Set idle state of the clock to low 
   SPI_CLOCK_POLARITY = 0;
   // Set SPI mode to SPI 
   SPI_MODE_3 = 0; 
   SPI_MODE_2 = 0;
   SPI_MODE_1 = 1;
   SPI_MODE_0 = 0;
   // Input data sampled at the middle of data output time
   SPI_INPUT_SAMPLE = 0;
   // Transmit occurs on transition from active to idle clock state
   SPI_CLOCK_EDGE = 1;

   // Enable SPI
   SPI_ENABLE = 1;
}
// Sets variables to default values 
void set_variables()
{
   output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction 
   output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver 
   output_low(DRV_DIR);    // Set default direction
   output_low(DRV_STEP);   // Keep step output low until a step command is received from the user
}

// Writes the given register byte to the driver
void write_register_byte(unsigned int8 reg_byte)
{
   // write the byte to spi buffer
   SPI_SSP1BUF = reg_byte;
   // Wait until the end of the write operation
   while (!SPI_FLAG);
   // Clear the write-completed-flag of the spi module
   SPI_FLAG = 0;
}
// Writes the given register to the driver
void write_register(unsigned int16 reg)
{
   // start spi write operation by setting the chip select port to high
   output_high(SPI_CS);
   // Get and write the MSB of the register
   write_register_byte(make8(reg, 1));
   // Get and write the MSB of the register
   write_register_byte(make8(reg, 0));
   // stop spi write operation by setting the chip select port to low
   output_low(SPI_CS);
   delay_ms(10);
}
// Sets driver parameters
void set_driver()
{
   if(mode == 0)
      write_register(41); //32x microstepping
   else
      write_register(65); //256x microstepping
      
   //write_register(4310);//high current
   write_register(4146);//low current
   write_register(8272);
   write_register(12634);
   //write_register(17162);   //mixed decay when high torque
   write_register(17704); //auto mixed decay when paused when low torque
   write_register(22804);
   write_register(24736);
   //write_register(28672);
   delay_ms(10);
}

// Moves system by given number of steps 
void motion_cycle(int32 target_step)
{
   write_register(4310);//high current
   write_register(17162);   //mixed decay when high torque
   delay_ms(10);
   // System is moving
   putc('M');
   // Laser on
   putc('A');
      
   unsigned int32 i=0;

   if(target_step >= (2*acc_lim))
   {
      target_step=target_step-2*acc_lim;
      for(i=0; i<acc_lim; i++)
      {
         output_high(DRV_STEP);
         delay_us(3);
         output_low(DRV_STEP);
         delay_us(periods[i] + delay - 3);
      }
      
      for(i=0; i<(target_step); i++)
      {
         if(input(LIMIT_SWITCH) == 1)
         {
            // Limit switch is triggered
            putc('L');
            return;            
         }
         output_high(DRV_STEP);
         delay_us(2);
         output_low(DRV_STEP);
         delay_us(delay - 2);
      }
      
      for(i=acc_lim; i>0; i--)
      {
         output_high(DRV_STEP);
         delay_us(2);
         output_low(DRV_STEP);
         delay_us(periods[i-1] + delay - 2);
      }
   }
   else
   {
      for(i=0; i<target_step; i++)
      {
         if(input(LIMIT_SWITCH) == 1)
         {
            // Limit switch is triggered
            putc('L');
            return;            
         }
         output_high(DRV_STEP);
         delay_us(3);
         output_low(DRV_STEP);
         delay_us(periods[0] - 3);
      }
   } 
   
   // Laser off
   putc('D');
   // Reached to target destination
   putc('R');
   write_register(4146);//low current
   write_register(17704); //auto mixed decay when paused when low torque
}
// Sends system to home position
void homing_cycle()
{ 
   write_register(4310);//high current
   write_register(17162);   //mixed decay when high torque
   putc('M');
   
   output_low(DRV_DIR);
   delay_ms(100); 
   
   unsigned int16 i = 0;
   for(i=0; i<acc_lim; i++)
   {

      output_high(DRV_STEP);
      if(input(LIMIT_SWITCH) == 1)
      {
         // Limit switch is triggered
         putc('L');
         return;            
      }
      delay_us(1);
      output_low(DRV_STEP);
      delay_us(periods[i] + delay - 3);
   }
   while(input(HOME_SWITCH) == 1)
   {
      if(input(LIMIT_SWITCH) == 1)
      {
         // Limit switch is triggered
         putc('L');
         return;            
      }
      output_high(DRV_STEP);
      delay_us(3);
      output_low(DRV_STEP);
      delay_us(delay - 3);
   }
   for(i=acc_lim; i>0; i--)
   {
      if(input(LIMIT_SWITCH) == 1)
      {
         // Limit switch is triggered
         putc('L');
         return;            
      }
      output_high(DRV_STEP);
      delay_us(3);
      output_low(DRV_STEP);
      delay_us(periods[i-1] + delay - 3);
   }
   
   output_high(DRV_DIR);
   delay_ms(10);
   
   while(input(HOME_SWITCH) == 0)
   {
      if(input(LIMIT_SWITCH) == 1)
      {
         // Limit switch is triggered
         putc('L');
         return;            
      }
      output_high(DRV_STEP);
      delay_us(10);
      output_low(DRV_STEP);
      delay_us(periods[0]);
   }
   
   current_distance = 0;
   
   putc('R');
   write_register(4146);//low current
   write_register(17704); //auto mixed decay when paused when low torque
}
// Calculates the displacement
void go_position(int32 user_distance)
{
   if(user_distance>current_distance)
   {
      output_high(DRV_DIR);
      motion_cycle(user_distance - current_distance);
   }
   else if(user_distance<current_distance)
   {
      output_low(DRV_DIR);
      motion_cycle(current_distance-user_distance);
   }
   else
   {
      putc('M');
      putc('R');
   }
   
   current_distance = user_distance;
}

// Handles the messages of RS232 connection
void rs232_message()
{
   char command = fgetc(RS232);
   unsigned int i=0;
   unsigned int32 input[7];
      
   switch (command)
   {
      case 'G':   for(i=0; i<7; i++)
                  {
                     input[i]=(unsigned)(fgetc(RS232)-48);
                  }
                  
                  int32 data=1000000*input[0]+100000*input[1]+10000*input[2]+1000*input[3]+100*input[4]+10*input[5]+input[6];
                  
                  go_position(data);
                  break;
      case 'S':   if(mode == 0)
                  {        
                     for(i=0; i<3; i++)
                     {
                        input[i]=(unsigned)(fgetc(RS232)-48);
                     }
                     
                     delay = 100*input[0] + 10*input[1] + input[2];
                     
                     if(delay > 1000)
                        delay =  1000;
                     else if (delay < 10)
                        delay = 10;
                  }
                  break;
      default :   return; 
   }
}

#INT_RDA
void isr_rs232_message()
{
   disable_interrupts(INT_RDA);
   // Receive the RS232 message
   reg_rs232_message = 1;
} 

void main()
{
   // Set I/O states of the ports
   //           76543210                  
   set_tris_a(0b00101100);       
   set_tris_b(0b11001111);

   // Set alternative pin functions
   set_pins();
   // Set SPI parameters
   set_SPI();
   // Set variables to default values
   set_variables();
   // Set driver
   set_driver();
   // Send system to homme position
   homing_cycle();
   
   enable_interrupts(global);
   enable_interrupts(INT_RDA);

   while(true)
   {  
      if(input(LIMIT_SWITCH))
      {
         // Disable RS232 receive byte interrupt
         disable_interrupts(INT_RDA);

         output_toggle(DRV_DIR);
         delay_ms(100);
         for(unsigned int16 i=0; i <= pulse_per_turn; i++)
         {
            output_high(DRV_STEP);
            delay_us(10);
            output_low(DRV_STEP);
            delay_us(100);
         }
         homing_cycle();
         
         clear_interrupt(INT_RDA);
         enable_interrupts(INT_RDA);  
      }
      if(reg_rs232_message)
      {
         reg_rs232_message = 0;
         rs232_message();
         
         clear_interrupt(INT_RDA);
         enable_interrupts(INT_RDA);
      }
   }   
}

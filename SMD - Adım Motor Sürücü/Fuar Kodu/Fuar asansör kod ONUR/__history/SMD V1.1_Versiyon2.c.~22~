#INCLUDE <16f1826.h> 

#FUSES INTRC_IO                                                      // High Speed Oscilator (>4 Mhz) crystal
#FUSES NOWDT                                                         // Watch Dog Timer disabled
#FUSES PUT                                                           // Power Up Timer enabled
#FUSES MCLR                                                          // Master Clear pin enabled
#FUSES BROWNOUT                                                      // Brownout Reset enabled
#FUSES BORV25                                                        // Brownout Reset at 2.5V
#FUSES NOLVP                                                         // Low Voltage Programming disabled
#FUSES CPD                                                           // Data EEPROM code protected
#FUSES PROTECT                                                       // Code protected from reads
#FUSES NOIESO                                                        // Internal External Switch Over Mode disabled
#FUSES NOFCMEN                                                       // Fail-safe clock monitor disabled

#USE   DELAY(clock=16000000)                                         // delay() func. adjusted for 20Mhz Primary Osc.

// Pin assignments
#DEFINE DRV_STEP     PIN_A0                  // Step output pin
#DEFINE DRV_RESET    PIN_A1                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.)
#DEFINE LM_UP        PIN_A2                  // Up limit switch input pin
#DEFINE LM_DOWN      PIN_A3                  // Down limit switch input pin
#DEFINE DRV_DIR      PIN_A4                  // Direction output pin

#DEFINE SPI_SDO      PIN_A6                  // SPI data output pin
#DEFINE SPI_CS       PIN_A7                  // SPI chip select output pin

#DEFINE BT_DOWN      PIN_B0                  // Down button input pin
#DEFINE SPI_SDI      PIN_B1                  // SPI data input pin

#DEFINE BT_UP        PIN_B3                  // Up button input pin
#DEFINE SPI_SCK      PIN_B4                  // SPI clock output pin

#DEFINE DRV_STALL    PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut)
#DEFINE DRV_FAULT    PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut)






//OPTION Register 
#WORD OPTION         = 0x095
//Bits of Option Register
#BIT OPTION_WPUEN    = OPTION.7


// SPI Registers
#WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register
#WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register
#WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register
#WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register
// Pin function control registers
#WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0
#WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1

// Bits of SSP1CON1 register
#BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit
#BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit
#BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit
#BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits
#BIT SPI_MODE_2         = SPI_SSP1CON1.2   
#BIT SPI_MODE_1         = SPI_SSP1CON1.1   
#BIT SPI_MODE_0         = SPI_SSP1CON1.0  

// Bits of SPI_SSP1STAT register
#BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit
#BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit
#BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit

// Bits of SPI_PIR1 register
#BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit

// Bits of PIN_APFCON0 register
#BIT PIN_RX_SELECT      = PIN_APFCON0.7      // RX pin selection bit
#BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit 
#BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit 

// Bits of PIN_APFCON1 register
#BIT PIN_TX_SELECT      = PIN_APFCON1.0      // TX pin selection bit


enum  State     {OFF = 0, ON   = 1};                                 // Motor states
enum  Direction {UP  = 0, DOWN = 1};                                 // Direction of motion
enum  Motion    {ACC = 0, WALK = 1, RUN  = 2, DEC = 3, STEADY = 4};  // State of the motion

int16 step_count = 0;
int16 const run_lim          = 10;                                  // Duration of the slow motion (per count) before acclerating to high speed  
unsigned int16   const acc_lim          = 1000;                                  // Number of steps before we hit max speed. acc=10000 dec=10000 
unsigned int16 const periods[acc_lim] = {2610,2610,2610,2610,2610,2610,2610,2610,2610,2610,2610,2609,2609,2609,2609,2609,2608,2608,2608,2607,2607,2607,2606,2606,2606,2605,2605,2604,2604,2604,2603,2603,2602,2602,2601,2601,2600,2600,2599,2598,2598,2597,2596,2596,2595,2595,2594,2593,2592,2592,2591,2590,2589,2589,2588,2587,2586,2585,2584,2584,2583,2582,2581,2580,2579,2578,2577,2576,2575,2574,2573,2572,2571,2570,2569,2568,2567,2566,2564,2563,2562,2561,2560,2559,2557,2556,2555,2554,2552,2551,2550,2549,2547,2546,2545,2543,2542,2540,2539,2538,2536,2535,2533,2532,2531,2529,2528,2526,2525,2523,2522,2520,2518,2517,2515,2514,2512,2510,2509,2507,2506,2504,2502,2500,2499,2497,2495,2494,2492,2490,2488,2487,2485,2483,2481,2479,2477,2476,2474,2472,2470,2468,2466,2464,2462,2460,2458,2457,2455,2453,2451,2449,2447,2445,2442,2440,2438,2436,2434,2432,2430,2428,2426,2424,2422,2419,2417,2415,2413,2411,2408,2406,2404,2402,2399,2397,2395,2393,2390,2388,2386,2383,2381,2379,2376,2374,2372,2369,2367,2365,2362,2360,2357,2355,2352,2350,2348,2345,2343,2340,2338,2335,2333,2330,2328,2325,2322,2320,2317,2315,2312,2309,2307,2304,2302,2299,2296,2294,2291,2288,2286,2283,2280,2278,2275,2272,2269,2267,2264,2261,2258,2256,2253,2250,2247,2244,2242,2239,2236,2233,2230,2227,2225,2222,2219,2216,2213,2210,2207,2204,2201,2198,2195,2192,2190,2187,2184,2181,2178,2175,2172,2169,2166,2163,2160,2156,2153,2150,2147,2144,2141,2138,2135,2132,2129,2126,2123,2119,2116,2113,2110,2107,2104,2100,2097,2094,2091,2088,2085,2081,2078,2075,2072,2068,2065,2062,2059,2055,2052,2049,2046,2042,2039,2036,2032,2029,2026,2022,2019,2016,2012,2009,2006,2002,1999,1996,1992,1989,1986,1982,1979,1975,1972,1969,1965,1962,1958,1955,1951,1948,1945,1941,1938,1934,1931,1927,1924,1920,1917,1913,1910,1906,1903,1899,1896,1892,1889,1885,1881,1878,1874,1871,1867,1864,1860,1857,1853,1849,1846,1842,1839,1835,1831,1828,1824,1821,1817,1813,1810,1806,1802,1799,1795,1791,1788,1784,1781,1777,1773,1770,1766,1762,1758,1755,1751,1747,1744,1740,1736,1733,1729,1725,1721,1718,1714,1710,1707,1703,1699,1695,1692,1688,1684,1680,1677,1673,1669,1665,1661,1658,1654,1650,1646,1643,1639,1635,1631,1627,1624,1620,1616,1612,1608,1605,1601,1597,1593,1589,1586,1582,1578,1574,1570,1566,1563,1559,1555,1551,1547,1543,1540,1536,1532,1528,1524,1520,1516,1513,1509,1505,1501,1497,1493,1489,1486,1482,1478,1474,1470,1466,1462,1458,1455,1451,1447,1443,1439,1435,1431,1427,1423,1420,1416,1412,1408,1404,1400,1396,1392,1388,1385,1381,1377,1373,1369,1365,1361,1357,1353,1349,1346,1342,1338,1334,1330,1326,1322,1318,1314,1310,1307,1303,1299,1295,1291,1287,1283,1279,1275,1272,1268,1264,1260,1256,1252,1248,1244,1240,1236,1233,1229,1225,1221,1217,1213,1209,1205,1201,1198,1194,1190,1186,1182,1178,1174,1170,1166,1163,1159,1155,1151,1147,1143,1139,1135,1132,1128,1124,1120,1116,1112,1108,1105,1101,1097,1093,1089,1085,1081,1078,1074,1070,1066,1062,1058,1055,1051,1047,1043,1039,1035,1032,1028,1024,1020,1016,1013,1009,1005,1001,997,994,990,986,982,978,975,971,967,963,960,956,952,948,944,941,937,933,929,926,922,918,914,911,907,903,900,896,892,888,885,881,877,874,870,866,863,859,855,851,848,844,840,837,833,830,826,822,819,815,811,808,804,800,797,793,790,786,782,779,775,772,768,764,761,757,754,750,747,743,740,736,732,729,725,722,718,715,711,708,704,701,697,694,690,687,683,680,676,673,670,666,663,659,656,652,649,646,642,639,635,632,629,625,622,619,615,612,609,605,602,599,595,592,589,585,582,579,575,572,569,566,562,559,556,553,549,546,543,540,536,533,530,527,524,521,517,514,511,508,505,502,498,495,492,489,486,483,480,477,474,471,468,465,461,458,455,452,449,446,443,440,437,434,431,429,426,423,420,417,414,411,408,405,402,399,396,394,391,388,385,382,379,377,374,371,368,365,363,360,357,354,352,349,346,343,341,338,335,333,330,327,325,322,319,317,314,312,309,306,304,301,299,296,293,291,288,286,283,281,278,276,273,271,269,266,264,261,259,256,254,252,249,247,245,242,240,238,235,233,231,228,226,224,222,219,217,215,213,210,208,206,204,202,199,197,195,193,191,189,187,185,183,181,179,176,174,172,170,168,166,164,163,161,159,157,155,153,151,149,147,145,144,142,140,138,136,134,133,131,129,127,126,124,122,121,119,117,115,114,112,111,109,107,106,104,103,101,99,98,96,95,93,92,90,89,88,86,85,83,82,81,79,78,76,75,74,72,71,70,69,67,66,65,64,62,61,60,59,58,57,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,37,36,35,34,33,32,32,31,30,29,29,28,27,26,26,25,25,24,23,23,22,21,21,20,20,19,19,18,18,17,17,17,16,16,15,15,15,14,14,14,13,13,13,12,12,12,12,12,11,11,11,11,11,11,11,11,11,11,11,10
};

int const off_time = 5;                                             // Off time of the pwm signal (should be smaller than period)
int8      motion_state = STEADY;                                     // Current state of the motion

void set_SPI()
{
   // Disable SPI to set registers
   SPI_ENABLE = 0;
   // Set idle state of the clock to low 
   SPI_CLOCK_POLARITY = 0;
   // Set SPI mode to SPI 
   SPI_MODE_3 = 0; 
   SPI_MODE_2 = 0;
   SPI_MODE_1 = 1;
   SPI_MODE_0 = 0;
   // Input data sampled at the middle of data output time
   SPI_INPUT_SAMPLE = 0;
   // Transmit occurs on transition from active to idle clock state
   SPI_CLOCK_EDGE = 1;

   // Enable SPI
   SPI_ENABLE = 1;
}

void set_variables()
{
   output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction
   output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver 
}

void set_pins()
{
   // Set RB2 as RX pin
   //PIN_RX_SELECT = 1;
   // Set RA6 as SDO pin
   PIN_SDO_SELECT = 1;
   // Set RA5 as SS pin
   PIN_SS_SELECT = 1;
   // Set RB5 as TX pin
   //PIN_TX_SELECT = 1;
}


// Sets the motor state
void md_set_state(State value)
{
   if (value == on)
   {
   output_high(SPI_CS);
                    //FEDCBA98
   int Ctrl_1     = 0b00001100;
                    //76543210
   int Ctrl_0     = 0b00011001;// Set enable pin to given motor state
   SPI_SSP1BUF = Ctrl_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Ctrl_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);
   }
   else if (value == off)
   {
   output_high(SPI_CS);
                    //FEDCBA98
   int Ctrl_1     = 0b00001100;
                    //76543210
   int Ctrl_0     = 0b00011000;// Set enable pin to given motor state
   SPI_SSP1BUF = Ctrl_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Ctrl_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);
   }
}
// Sets the motion direction
void md_set_direction(Direction value)
{
      restart_wdt();//watchdog sýfýrlanacak
      output_bit(DRV_DIR, !value);                                     // Set direction pin to given value
}
// Initializes motor driver
void md_init()
{
   md_set_state(OFF);                                                 // Motor off
   output_high(DRV_DIR);                                              // Direction control pin can be in any state
   output_high(DRV_STEP);                                             // Keep step input pin high (A low-to-high transition advances the motor one increment 
   
   output_high(SPI_CS);
                    //FEDCBA98
   int Ctrl_1     = 0b00001100;
                    //76543210
   int Ctrl_0     = 0b00011000;
   SPI_SSP1BUF = Ctrl_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Ctrl_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);

   output_high(SPI_CS);
                    //FEDCBA98
   int Torque_1   = 0b00010000;
                    //76543210
   int Torque_0   = 0b10110111;
   SPI_SSP1BUF = Torque_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Torque_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);
   
   output_high(SPI_CS);
                    //FEDCBA98
   int Off_1      = 0b00100000;
                    //76543210
   int Off_0      = 0b01111001;
   SPI_SSP1BUF = Off_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Off_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);
   
   output_high(SPI_CS);
                    //FEDCBA98
   int Blank_1    = 0b00110001;
                    //76543210
   int Blank_0    = 0b10010110;
   SPI_SSP1BUF = Blank_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Blank_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);
   
   output_high(SPI_CS);
                    //FEDCBA98
   int Decay_1    = 0b01000101;
                    //76543210
   int Decay_0    = 0b00011100;
   SPI_SSP1BUF = Decay_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Decay_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);
   
   output_high(SPI_CS);
   int Stall_1    = 0b01011001;
   int Stall_0    = 0b00010100;
   SPI_SSP1BUF = Stall_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Stall_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);
   
   output_high(SPI_CS);
                    //FEDCBA98
   int Drive_1    = 0b01101010;
                    //76543210
   int Drive_0    = 0b10100000;
   SPI_SSP1BUF = Drive_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Drive_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);
   
   output_high(SPI_CS);
   int Status_1   = 0b01110000;
   int Status_0   = 0b00000000;
   SPI_SSP1BUF = Status_1;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   SPI_SSP1BUF = Status_0;
   while (!SPI_FLAG);
   SPI_FLAG = 0;
   output_low(SPI_CS);
   delay_ms(10);

   delay_ms(100);
}

// Starts motion cycle
void motion_cycle()
{
   // Start cycle
   int16 step_count = 0;
   int16 period     = 0;
   int1  running    = 0;
   int   upwards    = 1; 
   while(true)
   {
      if(upwards)
      {
         if(input(LM_UP)== 1)
         {
            upwards = 0;
            md_set_state(OFF);
            delay_ms(32000);
            md_set_state(ON);
            delay_ms(1000);
         }
         
         if(input(LM_UP) == 0 && running == 0)
         {
            md_set_direction(UP);
            motion_state = WALK;
         }
         else if(input(LM_UP) && running == 1)
         {
            if(motion_state == ACC || motion_state == RUN)
               motion_state = DEC;
            else if(motion_state == WALK)
               motion_state = STEADY;
         }
      }
      else
      {   
         if(input(LM_DOWN)== 1)
         {
            upwards= 1;
            md_set_state(OFF);
            delay_ms(32000);
            md_set_state(ON);
            delay_ms(1000);
         }
         
         if(input(LM_DOWN) == 0 && running == 0)
         {
            md_set_direction(DOWN);
            motion_state = WALK;
         }
         else if(input(LM_DOWN) && running == 1)
         {
            if(motion_state == ACC || motion_state == RUN)
               motion_state = DEC;
            else if(motion_state == WALK)
               motion_state = STEADY;
         }
      }
      
      

      switch(motion_state) 
      { 
         case WALK:
            step_count++;
         
            if(step_count == 1)
            {
               running = 1;
               md_set_state(ON);
               period = periods[0];
            }
            else if(step_count == run_lim)
            {
               step_count   = 0;
               motion_state = ACC;
            }
            break;
         case ACC:
            if(step_count == acc_lim - 1)
            {
               motion_state = RUN;
            }
               
            period = periods[step_count];
            step_count++;
            break;
            
         case RUN:
            period = periods[step_count - 1];
            break;
   
         case DEC:
            step_count--;
            // Check if we at last step
            if(step_count == 0)
            {
               motion_state = STEADY;
            }
               
            period = periods[step_count];
            break;
            
         case STEADY:
            if(running)
            {
               running    = 0;
               period     = 0;
               step_count = 0;
               md_set_state(OFF);
            }
            break;
      }
   
      if(running)
      {  
         delay_us(off_time);
         output_low(DRV_STEP);
         delay_us(period - off_time);
         output_high(DRV_STEP);
      }
   }
}

// Main method
void main()
{
   //             76543210
     set_tris_a(0b00101100);       // Set I/O states of the ports
     set_tris_b(0b11001111);
   
   delay_ms(500);
   
   //fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING STAGE\n\n\r");
   
   set_pins();
   set_SPI();
   set_variables();
   md_init();           // Initialize motor driver
   motion_cycle();      // Start motion cycle
}

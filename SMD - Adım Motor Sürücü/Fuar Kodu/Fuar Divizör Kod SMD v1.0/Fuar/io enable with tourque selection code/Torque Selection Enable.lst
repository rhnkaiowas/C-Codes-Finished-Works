CCS PCM C Compiler, Version 4.108, 15145               20-Mar-14 16:22

               Filename: E:\File Server\Modesis\Proje Dosyalarý\SMD - Adým Motor Sürücü\Fuar Kodu\Fuar Divizör Kod\Fuar\io enable with tourque selection code\Torque Selection Enable.lst

               ROM used: 886 words (43%)
                         Largest free fragment is 1162
               RAM used: 9 (3%) at main() level
                         46 (14%) worst case
               Stack:    2 locations

*
0000:  MOVLP  00
0001:  GOTO   1AD
0002:  NOP
.................... #INCLUDE <16f1826.h>  
.................... //////// Standard Header file for the PIC16F1826 device //////////////// 
.................... #device PIC16F1826 
.................... #list 
....................  
....................  
.................... #FUSES INTRC_IO      // Internal RC clock (OSC1 and OSC2 pins are normal I/O) 
.................... #FUSES NOWDT         // Watch Dog Timer disabled 
.................... #FUSES PUT           // Power Up Timer enabled 
.................... #FUSES NOMCLR        // Master Clear pin is used for I/O 
.................... #FUSES PROTECT       // Code protected from reads 
.................... #FUSES CPD           // Data EEPROM code protected 
.................... #FUSES BROWNOUT      // Brownout Reset enabled 
.................... #FUSES BORV25        // Brownout Reset at 2.5V 
.................... #FUSES NOCLKOUT      // Disable clock output on OSC2 
.................... #FUSES NOIESO        // Internal External Switch Over Mode disabled 
.................... #FUSES NOFCMEN       // Fail-safe clock monitor disabled 
.................... #FUSES WRT           // Program memory write protected                                               
.................... #FUSES NOLVP         // Low Voltage Programming disabled 
....................  
.................... #USE   DELAY(internal = 32MHz) 
*
0016:  MOVLW  20
0017:  MOVWF  05
0018:  MOVLW  1E
0019:  MOVWF  04
001A:  MOVF   00,W
001B:  BTFSC  03.2
001C:  GOTO   02A
001D:  MOVLW  0A
001E:  MOVWF  78
001F:  CLRF   77
0020:  DECFSZ 77,F
0021:  GOTO   020
0022:  DECFSZ 78,F
0023:  GOTO   01F
0024:  MOVLW  5F
0025:  MOVWF  77
0026:  DECFSZ 77,F
0027:  GOTO   026
0028:  DECFSZ 00,F
0029:  GOTO   01D
002A:  RETURN
*
019B:  MOVLW  02
019C:  SUBWF  2E,F
019D:  BTFSS  03.0
019E:  GOTO   1AC
019F:  MOVLW  20
01A0:  MOVWF  05
01A1:  MOVLW  0E
01A2:  MOVWF  04
01A3:  MOVF   00,W
01A4:  BTFSC  03.2
01A5:  GOTO   1AC
01A6:  GOTO   1AA
01A7:  GOTO   1A8
01A8:  GOTO   1A9
01A9:  NOP
01AA:  DECFSZ 00,F
01AB:  GOTO   1A7
01AC:  RETURN
.................... //#USE   RS232(stream=RS232, baud=38400, XMIT=PIN_B5, RCV=PIN_B2, parity=N, bits=8, stop=1) 
....................  
.................... #DEFINE DRV_RESET    PIN_A0                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.) 
.................... #DEFINE DRV_SLEEP    PIN_A1                  // Sleep output pin to driver (Logic high to enable device) 
.................... #DEFINE USER_FAULT   PIN_A2                  // Fault output pin to user 
.................... #DEFINE USER_DIR     PIN_A3                  // Direction input pin from user 
.................... #DEFINE DRV_DIR      PIN_A4                  // Direction output pin to driver (Logic level, sets the direction of stepping) 
.................... #DEFINE DRV_STEP     PIN_A7                  // Step output pin to driver (Rising edge causes the indexer to move one step) 
.................... #DEFINE USER_STEP    PIN_B0                  // Step input pin from user 
.................... #DEFINE USER_ENABLE  PIN_B3                  // Enable input pin from user 
.................... #DEFINE DRV_STALL    PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut) 
.................... #DEFINE DRV_FAULT    PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut) 
....................  
.................... #DEFINE SPI_SDI      PIN_B1                  // SPI data input pin 
.................... #DEFINE SPI_SDO      PIN_A6                  // SPI data output pin 
.................... #DEFINE SPI_SCK      PIN_B4                  // SPI clock output pin 
.................... #DEFINE SPI_CS       PIN_B2                  // SPI chip select pin 
....................  
.................... // Interrupt On Change Registers 
.................... #WORD IOC_INTCON     =0x00B 
.................... #WORD IOC_IOCBP      =0x394 
.................... #WORD IOC_IOCBN      =0x395 
.................... #WORD IOC_IOCBF      =0x396 
.................... #WORD ANSELB         =0x18d 
....................  
.................... //Bits of IOC_INTCON register 
.................... #BIT IOC_GIE           = IOC_INTCON.7        //General interrupt enable bit 
.................... #BIT IOC_PEIE          = IOC_INTCON.6        //Peripheral interrupt enable bit 
.................... #BIT IOC_IOCIE         = IOC_INTCON.3        //Interrupt on change enable bit 
....................  
.................... //Bits of IOC_IOCBP register 
.................... #BIT IOC_PINB3_RISING            = IOC_IOCBP.3        //Pin B3 interrupt on change enable bit(Rising Edge) 
....................  
.................... //Bits of IOC_IOCBN register 
.................... #BIT IOC_PINB3_FALLING           = IOC_IOCBN.3        //Pin B3 interrupt on change enable bit(Falling Edge) 
....................  
.................... //Bits of IOC_IOCBF register 
.................... #BIT IOC_PINB3_FLAG              = IOC_IOCBF.3        //Pin B3 interrupt on change interrupt flag bit(Both Rising and Falling Edges) 
.................... //Bits of ANSELB register 
....................  
.................... #BIT ANSELB_PINB3                = ANSELB.3           //Selection of Pin B3 as a Digial I/O (0) or an Analog input (1) selection bit 
....................  
.................... // SPI Registers 
.................... #WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register 
.................... #WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register 
.................... #WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register 
.................... #WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register 
.................... // Pin function control registers 
.................... #WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0 
.................... #WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1 
....................  
.................... // Bits of SSP1CON1 register 
.................... #BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit 
.................... #BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit 
.................... #BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit 
.................... #BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits 
.................... #BIT SPI_MODE_2         = SPI_SSP1CON1.2    
.................... #BIT SPI_MODE_1         = SPI_SSP1CON1.1    
.................... #BIT SPI_MODE_0         = SPI_SSP1CON1.0   
....................  
.................... // Bits of SPI_SSP1STAT register 
.................... #BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit 
.................... #BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit 
.................... #BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit 
....................  
.................... // Bits of SPI_PIR1 register 
.................... #BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit 
....................  
.................... // Bits of PIN_APFCON0 register 
.................... #BIT PIN_RX_SELECT      = PIN_APFCON0.7      // RX pin selection bit 
.................... #BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit  
.................... #BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit  
....................  
.................... // Bits of PIN_APFCON1 register 
.................... #BIT PIN_TX_SELECT      = PIN_APFCON1.0      // TX pin selection bit 
.................... int32 x; 
....................  
.................... /* 
.................... // Sets interrupt on change bits 
.................... void set_IOC(){ 
....................    IOC_GIE           = 1;                  //General interrupt enable bit 
....................    IOC_PEIE          = 1;                  //Peripheral interrupt enable bit 
....................    IOC_IOCIE         = 1;                  //Interrupt on change enable bit 
....................    IOC_PINB3_RISING  = 1; 
....................    IOC_PINB3_FALLING = 1;  
....................    IOC_PINB3_FLAG    = 0; 
....................    ANSELB_PINB3      = 0; 
....................     
.................... } 
.................... */ 
....................  
....................  
....................  
.................... // Sets alternative pin functions 
.................... void set_pins() 
.................... { 
....................    // Set RB2 as RX pin 
....................    //PIN_RX_SELECT = 1; 
....................    // Set RA6 as SDO pin 
....................    PIN_SDO_SELECT = 1; 
*
0003:  MOVLB  02
0004:  BSF    1D.6
....................    // Set RA5 as SS pin 
....................    PIN_SS_SELECT = 1; 
0005:  BSF    1D.5
....................    // Set RB5 as TX pin 
....................    //PIN_TX_SELECT = 1; 
.................... } 
0006:  MOVLP  00
0007:  MOVLB  00
0008:  GOTO   1C3 (RETURN)
.................... // Sets SPI parameters 
.................... void set_SPI() 
.................... { 
....................    // Disable SPI to set registers 
....................    SPI_ENABLE = 0; 
0009:  MOVLB  04
000A:  BCF    15.5
....................    // Set idle state of the clock to low  
....................    SPI_CLOCK_POLARITY = 0; 
000B:  BCF    15.4
....................    // Set SPI mode to SPI  
....................    SPI_MODE_3 = 0;  
000C:  BCF    15.3
....................    SPI_MODE_2 = 0; 
000D:  BCF    15.2
....................    SPI_MODE_1 = 1; 
000E:  BSF    15.1
....................    SPI_MODE_0 = 0; 
000F:  BCF    15.0
....................    // Input data sampled at the middle of data output time 
....................    SPI_INPUT_SAMPLE = 0; 
0010:  BCF    14.7
....................    // Transmit occurs on transition from active to idle clock state 
....................    SPI_CLOCK_EDGE = 1; 
0011:  BSF    14.6
....................  
....................    // Enable SPI 
....................    SPI_ENABLE = 1; 
0012:  BSF    15.5
.................... } 
0013:  MOVLP  00
0014:  MOVLB  00
0015:  GOTO   1C4 (RETURN)
.................... // Sets variables to default values  
.................... void set_variables() 
.................... { 
....................    output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction 
*
002B:  MOVLB  01
002C:  BCF    0D.2
002D:  MOVLB  02
002E:  BCF    0D.2
....................    output_low(USER_FAULT); // Clear fault status  
002F:  MOVLB  01
0030:  BCF    0C.2
0031:  MOVLB  02
0032:  BCF    0C.2
....................    output_high(DRV_SLEEP); // Put driver into awake mode 
0033:  MOVLB  01
0034:  BCF    0C.1
0035:  MOVLB  02
0036:  BSF    0C.1
....................    output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver  
0037:  MOVLB  01
0038:  BCF    0C.0
0039:  MOVLB  02
003A:  BCF    0C.0
....................    output_low(DRV_DIR);    // Set default direction 
003B:  MOVLB  01
003C:  BCF    0C.4
003D:  MOVLB  02
003E:  BCF    0C.4
....................    output_low(DRV_STEP);   // Keep step output low until a step command is received from the user 
003F:  MOVLB  01
0040:  BCF    0C.7
0041:  MOVLB  02
0042:  BCF    0C.7
.................... } 
0043:  MOVLP  00
0044:  MOVLB  00
0045:  GOTO   1D1 (RETURN)
.................... // Sets driver parameters to default values 
.................... void set_driver() 
.................... { 
....................    // Driver control register sets these parameters 
....................    // data operation type                       (bit 15)    1=read,  
....................    //                                                       0=write 
....................    // register adress                           (bit 14-12) 000=CTRL reg 
....................    // DTIME (dead time between MOSFET switching)(bit 11-10) 00=400ns,  
....................    //                                                       01=450ns,  
....................    //                                                       10=650ns,  
....................    //                                                       11=850ns 
....................    // ISGain (current amplifier gain)           (bit 9-8)   00=Gain of 5,  
....................    //                                                       01=Gain of 10,  
....................    //                                                       10=Gain of 20,  
....................    //                                                       11=Gain of 40 
....................    // EXSTALL (source of stall detection)       (bit 7)     0=Internal 
....................    //                                                       1=External 
....................    // MODE (microstepping mode)                 (bit 6-3)   0000=Full-step, 71% current 
....................    //                                                       0001=Half step 
....................    //                                                       0010=1/4 step 
....................    //                                                       0011=1/8 step 
....................    //                                                       0100=1/16 step 
....................    //                                                       0101=1/32 step 
....................    //                                                       0110=1/64 step 
....................    //                                                       0111=1/128 step 
....................    //                                                       1000=1/256 step 
....................    // RSTEP (single step output)                (bit 2)     0=No action 
....................    //                                                       1=Indexer will advance one step; automatically cleared after write 
....................    // direction                                 (bit 1)     0=Direction set by DIR pin 
....................    //                                                       1=Direction set by inverse of DIR pin 
....................    // enable                                    (bit 0)     0=Disable motor 
....................    //                                                       1=Enable motor 
....................    //   
....................    //                 76543210 
....................     
....................    output_high(SPI_CS); 
0046:  MOVLB  01
0047:  BCF    0D.2
0048:  MOVLB  02
0049:  BSF    0D.2
....................    int Ctrl_1     = 0b00000011; 
....................    int Ctrl_0     = 0b01000001; 
004A:  MOVLW  03
004B:  MOVLB  00
004C:  MOVWF  2E
004D:  MOVLW  41
004E:  MOVWF  2F
....................    SPI_SSP1BUF = Ctrl_1; 
004F:  MOVLB  04
0050:  CLRF   12
0051:  MOVLB  00
0052:  MOVF   2E,W
0053:  MOVLB  04
0054:  MOVWF  11
....................    while (!SPI_FLAG); 
0055:  MOVLB  00
0056:  BTFSS  11.3
0057:  GOTO   056
....................    SPI_FLAG = 0; 
0058:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0059:  MOVLB  04
005A:  CLRF   12
005B:  MOVLB  00
005C:  MOVF   2F,W
005D:  MOVLB  04
005E:  MOVWF  11
....................    while (!SPI_FLAG); 
005F:  MOVLB  00
0060:  BTFSS  11.3
0061:  GOTO   060
....................    SPI_FLAG = 0; 
0062:  BCF    11.3
....................    output_low(SPI_CS); 
0063:  MOVLB  01
0064:  BCF    0D.2
0065:  MOVLB  02
0066:  BCF    0D.2
....................    delay_ms(10); 
0067:  MOVLW  0A
0068:  MOVLB  00
0069:  MOVWF  3E
006A:  CALL   016
....................  
....................    output_high(SPI_CS); 
006B:  MOVLB  01
006C:  BCF    0D.2
006D:  MOVLB  02
006E:  BSF    0D.2
....................    int Torque_1   = 0b00010000; 
....................    int Torque_0   = 0b11001000; 
006F:  MOVLW  10
0070:  MOVLB  00
0071:  MOVWF  30
0072:  MOVLW  C8
0073:  MOVWF  31
....................    SPI_SSP1BUF = Torque_1; 
0074:  MOVLB  04
0075:  CLRF   12
0076:  MOVLB  00
0077:  MOVF   30,W
0078:  MOVLB  04
0079:  MOVWF  11
....................    while (!SPI_FLAG); 
007A:  MOVLB  00
007B:  BTFSS  11.3
007C:  GOTO   07B
....................    SPI_FLAG = 0; 
007D:  BCF    11.3
....................    SPI_SSP1BUF = Torque_0; 
007E:  MOVLB  04
007F:  CLRF   12
0080:  MOVLB  00
0081:  MOVF   31,W
0082:  MOVLB  04
0083:  MOVWF  11
....................    while (!SPI_FLAG); 
0084:  MOVLB  00
0085:  BTFSS  11.3
0086:  GOTO   085
....................    SPI_FLAG = 0; 
0087:  BCF    11.3
....................    output_low(SPI_CS); 
0088:  MOVLB  01
0089:  BCF    0D.2
008A:  MOVLB  02
008B:  BCF    0D.2
....................    delay_ms(10); 
008C:  MOVLW  0A
008D:  MOVLB  00
008E:  MOVWF  3E
008F:  CALL   016
....................     
....................    output_high(SPI_CS); 
0090:  MOVLB  01
0091:  BCF    0D.2
0092:  MOVLB  02
0093:  BSF    0D.2
....................    int Off_1      = 0b00100000; 
....................    int Off_0      = 0b01000110; 
0094:  MOVLW  20
0095:  MOVLB  00
0096:  MOVWF  32
0097:  MOVLW  46
0098:  MOVWF  33
....................    SPI_SSP1BUF = Off_1; 
0099:  MOVLB  04
009A:  CLRF   12
009B:  MOVLB  00
009C:  MOVF   32,W
009D:  MOVLB  04
009E:  MOVWF  11
....................    while (!SPI_FLAG); 
009F:  MOVLB  00
00A0:  BTFSS  11.3
00A1:  GOTO   0A0
....................    SPI_FLAG = 0; 
00A2:  BCF    11.3
....................    SPI_SSP1BUF = Off_0; 
00A3:  MOVLB  04
00A4:  CLRF   12
00A5:  MOVLB  00
00A6:  MOVF   33,W
00A7:  MOVLB  04
00A8:  MOVWF  11
....................    while (!SPI_FLAG); 
00A9:  MOVLB  00
00AA:  BTFSS  11.3
00AB:  GOTO   0AA
....................    SPI_FLAG = 0; 
00AC:  BCF    11.3
....................    output_low(SPI_CS); 
00AD:  MOVLB  01
00AE:  BCF    0D.2
00AF:  MOVLB  02
00B0:  BCF    0D.2
....................    delay_ms(10); 
00B1:  MOVLW  0A
00B2:  MOVLB  00
00B3:  MOVWF  3E
00B4:  CALL   016
....................     
....................    output_high(SPI_CS); 
00B5:  MOVLB  01
00B6:  BCF    0D.2
00B7:  MOVLB  02
00B8:  BSF    0D.2
....................    int Blank_1    = 0b00110001; 
....................    int Blank_0    = 0b01111101; 
00B9:  MOVLW  31
00BA:  MOVLB  00
00BB:  MOVWF  34
00BC:  MOVLW  7D
00BD:  MOVWF  35
....................    SPI_SSP1BUF = Blank_1; 
00BE:  MOVLB  04
00BF:  CLRF   12
00C0:  MOVLB  00
00C1:  MOVF   34,W
00C2:  MOVLB  04
00C3:  MOVWF  11
....................    while (!SPI_FLAG); 
00C4:  MOVLB  00
00C5:  BTFSS  11.3
00C6:  GOTO   0C5
....................    SPI_FLAG = 0; 
00C7:  BCF    11.3
....................    SPI_SSP1BUF = Blank_0; 
00C8:  MOVLB  04
00C9:  CLRF   12
00CA:  MOVLB  00
00CB:  MOVF   35,W
00CC:  MOVLB  04
00CD:  MOVWF  11
....................    while (!SPI_FLAG); 
00CE:  MOVLB  00
00CF:  BTFSS  11.3
00D0:  GOTO   0CF
....................    SPI_FLAG = 0; 
00D1:  BCF    11.3
....................    output_low(SPI_CS); 
00D2:  MOVLB  01
00D3:  BCF    0D.2
00D4:  MOVLB  02
00D5:  BCF    0D.2
....................    delay_ms(10); 
00D6:  MOVLW  0A
00D7:  MOVLB  00
00D8:  MOVWF  3E
00D9:  CALL   016
....................     
....................    output_high(SPI_CS); 
00DA:  MOVLB  01
00DB:  BCF    0D.2
00DC:  MOVLB  02
00DD:  BSF    0D.2
....................    int Decay_1    = 0b01000101; 
....................    int Decay_0    = 0b00101001; 
00DE:  MOVLW  45
00DF:  MOVLB  00
00E0:  MOVWF  36
00E1:  MOVLW  29
00E2:  MOVWF  37
....................    SPI_SSP1BUF = Decay_1; 
00E3:  MOVLB  04
00E4:  CLRF   12
00E5:  MOVLB  00
00E6:  MOVF   36,W
00E7:  MOVLB  04
00E8:  MOVWF  11
....................    while (!SPI_FLAG); 
00E9:  MOVLB  00
00EA:  BTFSS  11.3
00EB:  GOTO   0EA
....................    SPI_FLAG = 0; 
00EC:  BCF    11.3
....................    SPI_SSP1BUF = Decay_0; 
00ED:  MOVLB  04
00EE:  CLRF   12
00EF:  MOVLB  00
00F0:  MOVF   37,W
00F1:  MOVLB  04
00F2:  MOVWF  11
....................    while (!SPI_FLAG); 
00F3:  MOVLB  00
00F4:  BTFSS  11.3
00F5:  GOTO   0F4
....................    SPI_FLAG = 0; 
00F6:  BCF    11.3
....................    output_low(SPI_CS); 
00F7:  MOVLB  01
00F8:  BCF    0D.2
00F9:  MOVLB  02
00FA:  BCF    0D.2
....................    delay_ms(10); 
00FB:  MOVLW  0A
00FC:  MOVLB  00
00FD:  MOVWF  3E
00FE:  CALL   016
....................     
....................    output_high(SPI_CS); 
00FF:  MOVLB  01
0100:  BCF    0D.2
0101:  MOVLB  02
0102:  BSF    0D.2
....................    int Stall_1    = 0b01011001; 
....................    int Stall_0    = 0b00010100; 
0103:  MOVLW  59
0104:  MOVLB  00
0105:  MOVWF  38
0106:  MOVLW  14
0107:  MOVWF  39
....................    SPI_SSP1BUF = Stall_1; 
0108:  MOVLB  04
0109:  CLRF   12
010A:  MOVLB  00
010B:  MOVF   38,W
010C:  MOVLB  04
010D:  MOVWF  11
....................    while (!SPI_FLAG); 
010E:  MOVLB  00
010F:  BTFSS  11.3
0110:  GOTO   10F
....................    SPI_FLAG = 0; 
0111:  BCF    11.3
....................    SPI_SSP1BUF = Stall_0; 
0112:  MOVLB  04
0113:  CLRF   12
0114:  MOVLB  00
0115:  MOVF   39,W
0116:  MOVLB  04
0117:  MOVWF  11
....................    while (!SPI_FLAG); 
0118:  MOVLB  00
0119:  BTFSS  11.3
011A:  GOTO   119
....................    SPI_FLAG = 0; 
011B:  BCF    11.3
....................    output_low(SPI_CS); 
011C:  MOVLB  01
011D:  BCF    0D.2
011E:  MOVLB  02
011F:  BCF    0D.2
....................    delay_ms(10); 
0120:  MOVLW  0A
0121:  MOVLB  00
0122:  MOVWF  3E
0123:  CALL   016
....................     
....................    output_high(SPI_CS); 
0124:  MOVLB  01
0125:  BCF    0D.2
0126:  MOVLB  02
0127:  BSF    0D.2
....................    int Drive_1    = 0b01101111; 
....................    int Drive_0    = 0b10100000; 
0128:  MOVLW  6F
0129:  MOVLB  00
012A:  MOVWF  3A
012B:  MOVLW  A0
012C:  MOVWF  3B
....................    SPI_SSP1BUF = Drive_1; 
012D:  MOVLB  04
012E:  CLRF   12
012F:  MOVLB  00
0130:  MOVF   3A,W
0131:  MOVLB  04
0132:  MOVWF  11
....................    while (!SPI_FLAG); 
0133:  MOVLB  00
0134:  BTFSS  11.3
0135:  GOTO   134
....................    SPI_FLAG = 0; 
0136:  BCF    11.3
....................    SPI_SSP1BUF = Drive_0; 
0137:  MOVLB  04
0138:  CLRF   12
0139:  MOVLB  00
013A:  MOVF   3B,W
013B:  MOVLB  04
013C:  MOVWF  11
....................    while (!SPI_FLAG); 
013D:  MOVLB  00
013E:  BTFSS  11.3
013F:  GOTO   13E
....................    SPI_FLAG = 0; 
0140:  BCF    11.3
....................    output_low(SPI_CS); 
0141:  MOVLB  01
0142:  BCF    0D.2
0143:  MOVLB  02
0144:  BCF    0D.2
....................    delay_ms(10); 
0145:  MOVLW  0A
0146:  MOVLB  00
0147:  MOVWF  3E
0148:  CALL   016
....................     
....................    output_high(SPI_CS); 
0149:  MOVLB  01
014A:  BCF    0D.2
014B:  MOVLB  02
014C:  BSF    0D.2
....................    int Status_1   = 0b01110000; 
....................    int Status_0   = 0b00000000; 
014D:  MOVLW  70
014E:  MOVLB  00
014F:  MOVWF  3C
0150:  CLRF   3D
....................    SPI_SSP1BUF = Status_1; 
0151:  MOVLB  04
0152:  CLRF   12
0153:  MOVLB  00
0154:  MOVF   3C,W
0155:  MOVLB  04
0156:  MOVWF  11
....................    while (!SPI_FLAG); 
0157:  MOVLB  00
0158:  BTFSS  11.3
0159:  GOTO   158
....................    SPI_FLAG = 0; 
015A:  BCF    11.3
....................    SPI_SSP1BUF = Status_0; 
015B:  MOVLB  04
015C:  CLRF   12
015D:  MOVLB  00
015E:  MOVF   3D,W
015F:  MOVLB  04
0160:  MOVWF  11
....................    while (!SPI_FLAG); 
0161:  MOVLB  00
0162:  BTFSS  11.3
0163:  GOTO   162
....................    SPI_FLAG = 0; 
0164:  BCF    11.3
....................    output_low(SPI_CS); 
0165:  MOVLB  01
0166:  BCF    0D.2
0167:  MOVLB  02
0168:  BCF    0D.2
....................    delay_ms(10); 
0169:  MOVLW  0A
016A:  MOVLB  00
016B:  MOVWF  3E
016C:  CALL   016
....................     
....................    output_high(DRV_SLEEP); 
016D:  MOVLB  01
016E:  BCF    0C.1
016F:  MOVLB  02
0170:  BSF    0C.1
....................    delay_ms(100); 
0171:  MOVLW  64
0172:  MOVLB  00
0173:  MOVWF  3E
0174:  CALL   016
....................     
....................    output_high(SPI_CS); 
0175:  MOVLB  01
0176:  BCF    0D.2
0177:  MOVLB  02
0178:  BSF    0D.2
....................    Ctrl_1      = 0b00000000; 
0179:  MOVLB  00
017A:  CLRF   2E
....................    Ctrl_0      = 0b01000001; 
017B:  MOVLW  41
017C:  MOVWF  2F
....................    SPI_SSP1BUF = Ctrl_1; 
017D:  MOVLB  04
017E:  CLRF   12
017F:  MOVLB  00
0180:  MOVF   2E,W
0181:  MOVLB  04
0182:  MOVWF  11
....................    while (!SPI_FLAG); 
0183:  MOVLB  00
0184:  BTFSS  11.3
0185:  GOTO   184
....................    SPI_FLAG = 0; 
0186:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0187:  MOVLB  04
0188:  CLRF   12
0189:  MOVLB  00
018A:  MOVF   2F,W
018B:  MOVLB  04
018C:  MOVWF  11
....................    while (!SPI_FLAG); 
018D:  MOVLB  00
018E:  BTFSS  11.3
018F:  GOTO   18E
....................    SPI_FLAG = 0; 
0190:  BCF    11.3
....................    output_low(SPI_CS); 
0191:  MOVLB  01
0192:  BCF    0D.2
0193:  MOVLB  02
0194:  BCF    0D.2
....................    delay_ms(10); 
0195:  MOVLW  0A
0196:  MOVLB  00
0197:  MOVWF  3E
0198:  CALL   016
.................... } 
0199:  MOVLP  00
019A:  GOTO   1D2 (RETURN)
....................  
.................... void main() 
.................... { 
*
01AD:  CLRF   05
01AE:  CLRF   04
01AF:  MOVLW  1F
01B0:  ANDWF  03,F
01B1:  MOVLW  F4
01B2:  MOVLB  01
01B3:  MOVWF  19
01B4:  MOVLB  03
01B5:  CLRF   0C
01B6:  CLRF   0D
01B7:  MOVLB  02
01B8:  CLRF   12
01B9:  CLRF   11
01BA:  CLRF   14
01BB:  CLRF   13
.................... // Set I/O states of the ports 
....................    //           76543210                  
....................    set_tris_a(0b00001000);        
01BC:  MOVLW  08
01BD:  MOVLB  01
01BE:  MOVWF  0C
....................    set_tris_b(0b11001011); 
01BF:  MOVLW  CB
01C0:  MOVWF  0D
....................  
....................    // Set alternative pin functions 
....................    set_pins(); 
01C1:  MOVLB  00
01C2:  GOTO   003
....................    // Set SPI parameters 
....................    set_SPI(); 
01C3:  GOTO   009
....................    //set_IOC(); 
....................     
....................    // Give user a hint of system start by turning on fault led 
....................    output_high(USER_FAULT); 
01C4:  MOVLB  01
01C5:  BCF    0C.2
01C6:  MOVLB  02
01C7:  BSF    0C.2
....................    delay_ms(500); 
01C8:  MOVLW  02
01C9:  MOVLB  00
01CA:  MOVWF  2E
01CB:  MOVLW  FA
01CC:  MOVWF  3E
01CD:  CALL   016
01CE:  DECFSZ 2E,F
01CF:  GOTO   1CB
....................     
....................    // Set variables to default values 
....................    set_variables(); 
01D0:  GOTO   02B
....................    // Set driver variables to default values 
....................    set_driver(); 
01D1:  GOTO   046
....................           output_high(SPI_CS); 
01D2:  MOVLB  01
01D3:  BCF    0D.2
01D4:  MOVLB  02
01D5:  BSF    0D.2
....................           int Ctrl_1     = 0b00000000;   //yuksek tork 
....................           int Ctrl_0     = 0b01000001; 
01D6:  MOVLB  00
01D7:  CLRF   24
01D8:  MOVLW  41
01D9:  MOVWF  25
....................           SPI_SSP1BUF = Ctrl_1; 
01DA:  MOVLB  04
01DB:  CLRF   12
01DC:  MOVLB  00
01DD:  MOVF   24,W
01DE:  MOVLB  04
01DF:  MOVWF  11
....................           while (!SPI_FLAG); 
01E0:  MOVLB  00
01E1:  BTFSS  11.3
01E2:  GOTO   1E1
....................           SPI_FLAG = 0; 
01E3:  BCF    11.3
....................           SPI_SSP1BUF = Ctrl_0; 
01E4:  MOVLB  04
01E5:  CLRF   12
01E6:  MOVLB  00
01E7:  MOVF   25,W
01E8:  MOVLB  04
01E9:  MOVWF  11
....................           while (!SPI_FLAG); 
01EA:  MOVLB  00
01EB:  BTFSS  11.3
01EC:  GOTO   1EB
....................           SPI_FLAG = 0; 
01ED:  BCF    11.3
....................           output_low(SPI_CS); 
01EE:  MOVLB  01
01EF:  BCF    0D.2
01F0:  MOVLB  02
01F1:  BCF    0D.2
....................     
....................    while (true){ 
....................       x=26250; 
01F2:  MOVLB  00
01F3:  CLRF   23
01F4:  CLRF   22
01F5:  MOVLW  66
01F6:  MOVWF  21
01F7:  MOVLW  8A
01F8:  MOVWF  20
....................       //Sað 1 tur 
....................       while (x>0){ 
01F9:  MOVF   20,F
01FA:  BTFSS  03.2
01FB:  GOTO   205
01FC:  MOVF   21,F
01FD:  BTFSS  03.2
01FE:  GOTO   205
01FF:  MOVF   22,F
0200:  BTFSS  03.2
0201:  GOTO   205
0202:  MOVF   23,F
0203:  BTFSC  03.2
0204:  GOTO   222
....................       output_high(DRV_DIR); 
0205:  MOVLB  01
0206:  BCF    0C.4
0207:  MOVLB  02
0208:  BSF    0C.4
....................        
....................       output_high(DRV_STEP); 
0209:  MOVLB  01
020A:  BCF    0C.7
020B:  MOVLB  02
020C:  BSF    0C.7
....................       delay_us(150); 
020D:  MOVLW  96
020E:  MOVLB  00
020F:  MOVWF  2E
0210:  CALL   19B
....................       output_low(DRV_STEP); 
0211:  MOVLB  01
0212:  BCF    0C.7
0213:  MOVLB  02
0214:  BCF    0C.7
....................       delay_us(150); 
0215:  MOVLW  96
0216:  MOVLB  00
0217:  MOVWF  2E
0218:  CALL   19B
....................       x--; 
0219:  MOVLW  FF
021A:  ADDWF  20,F
021B:  BTFSS  03.0
021C:  ADDWF  21,F
021D:  BTFSS  03.0
021E:  ADDWF  22,F
021F:  BTFSS  03.0
0220:  ADDWF  23,F
....................       } 
0221:  GOTO   1F9
....................  
....................       //Sol 1 tur     
....................       x=26250; 
0222:  CLRF   23
0223:  CLRF   22
0224:  MOVLW  66
0225:  MOVWF  21
0226:  MOVLW  8A
0227:  MOVWF  20
....................       while (x>0){ 
0228:  MOVF   20,F
0229:  BTFSS  03.2
022A:  GOTO   234
022B:  MOVF   21,F
022C:  BTFSS  03.2
022D:  GOTO   234
022E:  MOVF   22,F
022F:  BTFSS  03.2
0230:  GOTO   234
0231:  MOVF   23,F
0232:  BTFSC  03.2
0233:  GOTO   251
....................       output_low(DRV_DIR); 
0234:  MOVLB  01
0235:  BCF    0C.4
0236:  MOVLB  02
0237:  BCF    0C.4
....................        
....................       output_high(DRV_STEP); 
0238:  MOVLB  01
0239:  BCF    0C.7
023A:  MOVLB  02
023B:  BSF    0C.7
....................       delay_us(150); 
023C:  MOVLW  96
023D:  MOVLB  00
023E:  MOVWF  2E
023F:  CALL   19B
....................       output_low(DRV_STEP); 
0240:  MOVLB  01
0241:  BCF    0C.7
0242:  MOVLB  02
0243:  BCF    0C.7
....................       delay_us(150); 
0244:  MOVLW  96
0245:  MOVLB  00
0246:  MOVWF  2E
0247:  CALL   19B
....................       x--; 
0248:  MOVLW  FF
0249:  ADDWF  20,F
024A:  BTFSS  03.0
024B:  ADDWF  21,F
024C:  BTFSS  03.0
024D:  ADDWF  22,F
024E:  BTFSS  03.0
024F:  ADDWF  23,F
....................       } 
0250:  GOTO   228
....................     
....................       //Sag Sol kýsa kýsa 
....................        x=5; 
0251:  CLRF   23
0252:  CLRF   22
0253:  CLRF   21
0254:  MOVLW  05
0255:  MOVWF  20
....................        while (x>0){ 
0256:  MOVF   20,F
0257:  BTFSS  03.2
0258:  GOTO   262
0259:  MOVF   21,F
025A:  BTFSS  03.2
025B:  GOTO   262
025C:  MOVF   22,F
025D:  BTFSS  03.2
025E:  GOTO   262
025F:  MOVF   23,F
0260:  BTFSC  03.2
0261:  GOTO   2C9
....................           
....................          int32 y=3000; 
0262:  CLRF   29
0263:  CLRF   28
0264:  MOVLW  0B
0265:  MOVWF  27
0266:  MOVLW  B8
0267:  MOVWF  26
....................          while (y>0){ 
0268:  MOVF   26,F
0269:  BTFSS  03.2
026A:  GOTO   274
026B:  MOVF   27,F
026C:  BTFSS  03.2
026D:  GOTO   274
026E:  MOVF   28,F
026F:  BTFSS  03.2
0270:  GOTO   274
0271:  MOVF   29,F
0272:  BTFSC  03.2
0273:  GOTO   291
....................        
....................          output_high(DRV_DIR); 
0274:  MOVLB  01
0275:  BCF    0C.4
0276:  MOVLB  02
0277:  BSF    0C.4
....................        
....................          output_high(DRV_STEP); 
0278:  MOVLB  01
0279:  BCF    0C.7
027A:  MOVLB  02
027B:  BSF    0C.7
....................          delay_us(150); 
027C:  MOVLW  96
027D:  MOVLB  00
027E:  MOVWF  2E
027F:  CALL   19B
....................          output_low(DRV_STEP); 
0280:  MOVLB  01
0281:  BCF    0C.7
0282:  MOVLB  02
0283:  BCF    0C.7
....................          delay_us(150); 
0284:  MOVLW  96
0285:  MOVLB  00
0286:  MOVWF  2E
0287:  CALL   19B
....................          y--; 
0288:  MOVLW  FF
0289:  ADDWF  26,F
028A:  BTFSS  03.0
028B:  ADDWF  27,F
028C:  BTFSS  03.0
028D:  ADDWF  28,F
028E:  BTFSS  03.0
028F:  ADDWF  29,F
....................          } 
0290:  GOTO   268
....................        
....................          y=3000; 
0291:  CLRF   29
0292:  CLRF   28
0293:  MOVLW  0B
0294:  MOVWF  27
0295:  MOVLW  B8
0296:  MOVWF  26
....................          while (y>0){ 
0297:  MOVF   26,F
0298:  BTFSS  03.2
0299:  GOTO   2A3
029A:  MOVF   27,F
029B:  BTFSS  03.2
029C:  GOTO   2A3
029D:  MOVF   28,F
029E:  BTFSS  03.2
029F:  GOTO   2A3
02A0:  MOVF   29,F
02A1:  BTFSC  03.2
02A2:  GOTO   2C0
....................        
....................          output_low(DRV_DIR); 
02A3:  MOVLB  01
02A4:  BCF    0C.4
02A5:  MOVLB  02
02A6:  BCF    0C.4
....................        
....................          output_high(DRV_STEP); 
02A7:  MOVLB  01
02A8:  BCF    0C.7
02A9:  MOVLB  02
02AA:  BSF    0C.7
....................          delay_us(150); 
02AB:  MOVLW  96
02AC:  MOVLB  00
02AD:  MOVWF  2E
02AE:  CALL   19B
....................          output_low(DRV_STEP); 
02AF:  MOVLB  01
02B0:  BCF    0C.7
02B1:  MOVLB  02
02B2:  BCF    0C.7
....................          delay_us(150); 
02B3:  MOVLW  96
02B4:  MOVLB  00
02B5:  MOVWF  2E
02B6:  CALL   19B
....................          y--; 
02B7:  MOVLW  FF
02B8:  ADDWF  26,F
02B9:  BTFSS  03.0
02BA:  ADDWF  27,F
02BB:  BTFSS  03.0
02BC:  ADDWF  28,F
02BD:  BTFSS  03.0
02BE:  ADDWF  29,F
....................          } 
02BF:  GOTO   297
....................         x--;  
02C0:  MOVLW  FF
02C1:  ADDWF  20,F
02C2:  BTFSS  03.0
02C3:  ADDWF  21,F
02C4:  BTFSS  03.0
02C5:  ADDWF  22,F
02C6:  BTFSS  03.0
02C7:  ADDWF  23,F
....................        }    
02C8:  GOTO   256
....................        
....................        //Sag Sol Daha kýsa kýsa 
....................         x=20; 
02C9:  CLRF   23
02CA:  CLRF   22
02CB:  CLRF   21
02CC:  MOVLW  14
02CD:  MOVWF  20
....................        while (x>0){ 
02CE:  MOVF   20,F
02CF:  BTFSS  03.2
02D0:  GOTO   2DA
02D1:  MOVF   21,F
02D2:  BTFSS  03.2
02D3:  GOTO   2DA
02D4:  MOVF   22,F
02D5:  BTFSS  03.2
02D6:  GOTO   2DA
02D7:  MOVF   23,F
02D8:  BTFSC  03.2
02D9:  GOTO   341
....................           
....................          int32 y=500; 
02DA:  CLRF   2D
02DB:  CLRF   2C
02DC:  MOVLW  01
02DD:  MOVWF  2B
02DE:  MOVLW  F4
02DF:  MOVWF  2A
....................          while (y>0){ 
02E0:  MOVF   2A,F
02E1:  BTFSS  03.2
02E2:  GOTO   2EC
02E3:  MOVF   2B,F
02E4:  BTFSS  03.2
02E5:  GOTO   2EC
02E6:  MOVF   2C,F
02E7:  BTFSS  03.2
02E8:  GOTO   2EC
02E9:  MOVF   2D,F
02EA:  BTFSC  03.2
02EB:  GOTO   309
....................        
....................          output_high(DRV_DIR); 
02EC:  MOVLB  01
02ED:  BCF    0C.4
02EE:  MOVLB  02
02EF:  BSF    0C.4
....................        
....................          output_high(DRV_STEP); 
02F0:  MOVLB  01
02F1:  BCF    0C.7
02F2:  MOVLB  02
02F3:  BSF    0C.7
....................          delay_us(150); 
02F4:  MOVLW  96
02F5:  MOVLB  00
02F6:  MOVWF  2E
02F7:  CALL   19B
....................          output_low(DRV_STEP); 
02F8:  MOVLB  01
02F9:  BCF    0C.7
02FA:  MOVLB  02
02FB:  BCF    0C.7
....................          delay_us(150); 
02FC:  MOVLW  96
02FD:  MOVLB  00
02FE:  MOVWF  2E
02FF:  CALL   19B
....................          y--; 
0300:  MOVLW  FF
0301:  ADDWF  2A,F
0302:  BTFSS  03.0
0303:  ADDWF  2B,F
0304:  BTFSS  03.0
0305:  ADDWF  2C,F
0306:  BTFSS  03.0
0307:  ADDWF  2D,F
....................          } 
0308:  GOTO   2E0
....................        
....................          y=500; 
0309:  CLRF   2D
030A:  CLRF   2C
030B:  MOVLW  01
030C:  MOVWF  2B
030D:  MOVLW  F4
030E:  MOVWF  2A
....................          while (y>0){ 
030F:  MOVF   2A,F
0310:  BTFSS  03.2
0311:  GOTO   31B
0312:  MOVF   2B,F
0313:  BTFSS  03.2
0314:  GOTO   31B
0315:  MOVF   2C,F
0316:  BTFSS  03.2
0317:  GOTO   31B
0318:  MOVF   2D,F
0319:  BTFSC  03.2
031A:  GOTO   338
....................        
....................          output_low(DRV_DIR); 
031B:  MOVLB  01
031C:  BCF    0C.4
031D:  MOVLB  02
031E:  BCF    0C.4
....................        
....................          output_high(DRV_STEP); 
031F:  MOVLB  01
0320:  BCF    0C.7
0321:  MOVLB  02
0322:  BSF    0C.7
....................          delay_us(150); 
0323:  MOVLW  96
0324:  MOVLB  00
0325:  MOVWF  2E
0326:  CALL   19B
....................          output_low(DRV_STEP); 
0327:  MOVLB  01
0328:  BCF    0C.7
0329:  MOVLB  02
032A:  BCF    0C.7
....................          delay_us(150); 
032B:  MOVLW  96
032C:  MOVLB  00
032D:  MOVWF  2E
032E:  CALL   19B
....................          y--; 
032F:  MOVLW  FF
0330:  ADDWF  2A,F
0331:  BTFSS  03.0
0332:  ADDWF  2B,F
0333:  BTFSS  03.0
0334:  ADDWF  2C,F
0335:  BTFSS  03.0
0336:  ADDWF  2D,F
....................          } 
0337:  GOTO   30F
....................         x--;  
0338:  MOVLW  FF
0339:  ADDWF  20,F
033A:  BTFSS  03.0
033B:  ADDWF  21,F
033C:  BTFSS  03.0
033D:  ADDWF  22,F
033E:  BTFSS  03.0
033F:  ADDWF  23,F
....................        }  
0340:  GOTO   2CE
....................     
....................     
....................   
....................        
....................     
....................       //Hýzlý 2 Tur 
....................        
....................       x=105000; 
0341:  CLRF   23
0342:  MOVLW  01
0343:  MOVWF  22
0344:  MOVLW  9A
0345:  MOVWF  21
0346:  MOVLW  28
0347:  MOVWF  20
....................       while (x>0){ 
0348:  MOVF   20,F
0349:  BTFSS  03.2
034A:  GOTO   354
034B:  MOVF   21,F
034C:  BTFSS  03.2
034D:  GOTO   354
034E:  MOVF   22,F
034F:  BTFSS  03.2
0350:  GOTO   354
0351:  MOVF   23,F
0352:  BTFSC  03.2
0353:  GOTO   374
....................       output_high(DRV_DIR); 
0354:  MOVLB  01
0355:  BCF    0C.4
0356:  MOVLB  02
0357:  BSF    0C.4
....................        
....................       output_high(DRV_STEP); 
0358:  MOVLB  01
0359:  BCF    0C.7
035A:  MOVLB  02
035B:  BSF    0C.7
....................       delay_us(25); 
035C:  MOVLW  42
035D:  MOVWF  77
035E:  DECFSZ 77,F
035F:  GOTO   35E
0360:  NOP
....................       output_low(DRV_STEP); 
0361:  MOVLB  01
0362:  BCF    0C.7
0363:  MOVLB  02
0364:  BCF    0C.7
....................       delay_us(25); 
0365:  MOVLW  42
0366:  MOVWF  77
0367:  DECFSZ 77,F
0368:  GOTO   367
0369:  NOP
....................       x--; 
036A:  MOVLW  FF
036B:  MOVLB  00
036C:  ADDWF  20,F
036D:  BTFSS  03.0
036E:  ADDWF  21,F
036F:  BTFSS  03.0
0370:  ADDWF  22,F
0371:  BTFSS  03.0
0372:  ADDWF  23,F
....................       } 
0373:  GOTO   348
....................            
....................            
....................     
....................     
....................    } 
0374:  GOTO   1F3
.................... } 
0375:  SLEEP

Configuration Fuses:
   Word  1: 0E04   NOWDT PUT PROTECT NOMCLR CPD BROWNOUT NOIESO NOFCMEN INTRC_IO NOCLKOUT
   Word  2: 1210   WRT NOVCAP PLL_SW STVREN BORV25 NODEBUG NOLVP

CCS PCM C Compiler, Version 5.008, 5967               11-Eyl-14 18:26

               Filename:   Z:\Modesis\Proje Dosyalarý\SMD - Adým Motor Sürücü\SMD Configuration Source Code\motor_sürücü_kodu_enum\X Motoru.lst

               ROM used:   2034 words (99%)
                           Largest free fragment is 13
               RAM used:   28 (8%) at main() level
                           63 (19%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   794
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  CLRF   05
0010:  MOVLW  91
0011:  MOVWF  04
0012:  BTFSS  00.5
0013:  GOTO   016
0014:  BTFSC  11.5
0015:  GOTO   116
0016:  MOVF   20,W
0017:  MOVWF  77
0018:  MOVF   21,W
0019:  MOVWF  78
001A:  MOVF   22,W
001B:  MOVWF  79
001C:  MOVF   23,W
001D:  MOVWF  7A
001E:  RETFIE
.................... #INCLUDE <16f1826.h>  
.................... //////// Standard Header file for the PIC16F1826 device //////////////// 
.................... #device PIC16F1826 
001F:  DATA 43,2A
0020:  DATA 52,26
0021:  DATA 20,29
0022:  DATA E5,33
0023:  DATA E9,39
0024:  DATA F4,32
0025:  DATA F2,04
0026:  DATA 3A,10
0027:  DATA 00,00
0028:  DATA 43,2A
0029:  DATA 52,26
002A:  DATA 20,29
002B:  DATA E5,33
002C:  DATA E9,39
002D:  DATA F4,32
002E:  DATA F2,04
002F:  DATA 3A,10
0030:  DATA 00,00
0031:  DATA 43,2A
0032:  DATA 52,26
0033:  DATA 20,29
0034:  DATA E5,33
0035:  DATA E9,39
0036:  DATA F4,32
0037:  DATA F2,04
0038:  DATA 3A,10
0039:  DATA 00,00
003A:  DATA 43,2A
003B:  DATA 52,26
003C:  DATA 20,29
003D:  DATA E5,33
003E:  DATA E9,39
003F:  DATA F4,32
0040:  DATA F2,04
0041:  DATA 3A,10
0042:  DATA 00,00
0043:  DATA 43,2A
0044:  DATA 52,26
0045:  DATA 20,29
0046:  DATA E5,33
0047:  DATA E9,39
0048:  DATA F4,32
0049:  DATA F2,04
004A:  DATA 3A,10
004B:  DATA 00,00
004C:  DATA 43,2A
004D:  DATA 52,26
004E:  DATA 20,29
004F:  DATA E5,33
0050:  DATA E9,39
0051:  DATA F4,32
0052:  DATA F2,04
0053:  DATA 3A,10
0054:  DATA 00,00
0055:  DATA 43,2A
0056:  DATA 52,26
0057:  DATA 20,29
0058:  DATA E5,33
0059:  DATA E9,39
005A:  DATA F4,32
005B:  DATA F2,04
005C:  DATA 3A,10
005D:  DATA 00,00
005E:  DATA 43,2A
005F:  DATA 52,26
0060:  DATA 20,29
0061:  DATA E5,33
0062:  DATA E9,39
0063:  DATA F4,32
0064:  DATA F2,04
0065:  DATA 3A,10
0066:  DATA 00,00
0067:  DATA D4,27
0068:  DATA D2,28
0069:  DATA D5,22
006A:  DATA 20,29
006B:  DATA E5,33
006C:  DATA E9,39
006D:  DATA F4,32
006E:  DATA F2,04
006F:  DATA 3A,10
0070:  DATA 00,00
0071:  DATA D4,27
0072:  DATA D2,28
0073:  DATA D5,22
0074:  DATA 20,29
0075:  DATA E5,33
0076:  DATA E9,39
0077:  DATA F4,32
0078:  DATA F2,04
0079:  DATA 3A,10
007A:  DATA 00,00
007B:  DATA D4,27
007C:  DATA D2,28
007D:  DATA D5,22
007E:  DATA 20,29
007F:  DATA E5,33
0080:  DATA E9,39
0081:  DATA F4,32
0082:  DATA F2,04
0083:  DATA 3A,10
0084:  DATA 00,00
0085:  DATA D4,27
0086:  DATA 46,23
0087:  DATA 20,29
0088:  DATA E5,33
0089:  DATA E9,39
008A:  DATA F4,32
008B:  DATA F2,04
008C:  DATA 3A,10
008D:  DATA 00,00
008E:  DATA D4,27
008F:  DATA 46,23
0090:  DATA 20,29
0091:  DATA E5,33
0092:  DATA E9,39
0093:  DATA F4,32
0094:  DATA F2,04
0095:  DATA 3A,10
0096:  DATA 00,00
0097:  DATA D4,27
0098:  DATA 46,23
0099:  DATA 20,29
009A:  DATA E5,33
009B:  DATA E9,39
009C:  DATA F4,32
009D:  DATA F2,04
009E:  DATA 3A,10
009F:  DATA 00,00
00A0:  DATA 42,26
00A1:  DATA 41,27
00A2:  DATA 4B,10
00A3:  DATA D2,32
00A4:  DATA E7,34
00A5:  DATA 73,3A
00A6:  DATA 65,39
00A7:  DATA 09,1D
00A8:  DATA 20,00
00A9:  DATA 42,26
00AA:  DATA 41,27
00AB:  DATA 4B,10
00AC:  DATA D2,32
00AD:  DATA E7,34
00AE:  DATA 73,3A
00AF:  DATA 65,39
00B0:  DATA 09,1D
00B1:  DATA 20,00
00B2:  DATA 42,26
00B3:  DATA 41,27
00B4:  DATA 4B,10
00B5:  DATA D2,32
00B6:  DATA E7,34
00B7:  DATA 73,3A
00B8:  DATA 65,39
00B9:  DATA 09,1D
00BA:  DATA 20,00
00BB:  DATA C4,22
00BC:  DATA C3,20
00BD:  DATA 59,10
00BE:  DATA D2,32
00BF:  DATA E7,34
00C0:  DATA 73,3A
00C1:  DATA 65,39
00C2:  DATA 09,1D
00C3:  DATA 20,00
00C4:  DATA C4,22
00C5:  DATA C3,20
00C6:  DATA 59,10
00C7:  DATA D2,32
00C8:  DATA E7,34
00C9:  DATA 73,3A
00CA:  DATA 65,39
00CB:  DATA 09,1D
00CC:  DATA 20,00
00CD:  DATA C4,22
00CE:  DATA C3,20
00CF:  DATA 59,10
00D0:  DATA D2,32
00D1:  DATA E7,34
00D2:  DATA 73,3A
00D3:  DATA 65,39
00D4:  DATA 09,1D
00D5:  DATA 20,00
00D6:  DATA 53,2A
00D7:  DATA 41,26
00D8:  DATA 4C,10
00D9:  DATA D2,32
00DA:  DATA E7,34
00DB:  DATA 73,3A
00DC:  DATA 65,39
00DD:  DATA 09,1D
00DE:  DATA 20,00
00DF:  DATA 53,2A
00E0:  DATA 41,26
00E1:  DATA 4C,10
00E2:  DATA D2,32
00E3:  DATA E7,34
00E4:  DATA 73,3A
00E5:  DATA 65,39
00E6:  DATA 09,1D
00E7:  DATA 20,00
00E8:  DATA 53,2A
00E9:  DATA 41,26
00EA:  DATA 4C,10
00EB:  DATA D2,32
00EC:  DATA E7,34
00ED:  DATA 73,3A
00EE:  DATA 65,39
00EF:  DATA 09,1D
00F0:  DATA 20,00
00F1:  DATA 53,2A
00F2:  DATA 41,26
00F3:  DATA 4C,10
00F4:  DATA D2,32
00F5:  DATA E7,34
00F6:  DATA 73,3A
00F7:  DATA 65,39
00F8:  DATA 09,1D
00F9:  DATA 20,00
00FA:  DATA 44,29
00FB:  DATA 49,2B
00FC:  DATA 45,10
00FD:  DATA D2,32
00FE:  DATA E7,34
00FF:  DATA 73,3A
0100:  DATA 65,39
0101:  DATA 09,1D
0102:  DATA 20,00
0103:  DATA 53,2A
0104:  DATA 41,2A
0105:  DATA D5,29
0106:  DATA 20,29
0107:  DATA E5,33
0108:  DATA E9,39
0109:  DATA F4,32
010A:  DATA F2,04
010B:  DATA 3A,10
010C:  DATA 00,00
010D:  DATA 44,39
010E:  DATA 69,3B
010F:  DATA 65,39
0110:  DATA 20,22
0111:  DATA 65,31
0112:  DATA F5,33
0113:  DATA 3A,10
0114:  DATA A5,3A
0115:  DATA 00,00
*
015A:  MOVF   0B,W
015B:  MOVWF  45
015C:  BCF    0B.7
015D:  MOVLB  03
015E:  BSF    15.7
015F:  BSF    15.0
0160:  NOP
0161:  NOP
0162:  MOVF   13,W
0163:  ANDLW  7F
0164:  BTFSC  03.2
0165:  GOTO   1A1
0166:  MOVLB  00
0167:  MOVWF  46
0168:  MOVLB  03
0169:  MOVF   11,W
016A:  MOVLB  00
016B:  MOVWF  47
016C:  MOVLB  03
016D:  MOVF   12,W
016E:  MOVLB  00
016F:  MOVWF  48
0170:  MOVF   46,W
0171:  BTFSS  11.4
0172:  GOTO   171
0173:  MOVLB  03
0174:  MOVWF  1A
0175:  MOVLB  00
0176:  MOVF   47,W
0177:  MOVLB  03
0178:  MOVWF  11
0179:  MOVLB  00
017A:  MOVF   48,W
017B:  MOVLB  03
017C:  MOVWF  12
017D:  BSF    15.7
017E:  BSF    15.0
017F:  NOP
0180:  NOP
0181:  RLF    13,W
0182:  RLF    14,W
0183:  ANDLW  7F
0184:  BTFSC  03.2
0185:  GOTO   1A1
0186:  MOVLB  00
0187:  MOVWF  46
0188:  MOVLB  03
0189:  MOVF   11,W
018A:  MOVLB  00
018B:  MOVWF  47
018C:  MOVLB  03
018D:  MOVF   12,W
018E:  MOVLB  00
018F:  MOVWF  48
0190:  MOVF   46,W
0191:  BTFSS  11.4
0192:  GOTO   191
0193:  MOVLB  03
0194:  MOVWF  1A
0195:  MOVLB  00
0196:  MOVF   47,W
0197:  MOVLB  03
0198:  MOVWF  11
0199:  MOVLB  00
019A:  MOVF   48,W
019B:  MOVLB  03
019C:  MOVWF  12
019D:  INCF   11,F
019E:  BTFSC  03.2
019F:  INCF   12,F
01A0:  GOTO   15E
01A1:  MOVLB  00
01A2:  BTFSC  45.7
01A3:  BSF    0B.7
01A4:  RETURN
*
0210:  MOVF   05,W
0211:  MOVWF  4F
0212:  MOVF   04,W
0213:  MOVWF  4E
0214:  SWAPF  48,W
0215:  IORLW  F0
0216:  MOVWF  4A
0217:  ADDWF  4A,F
0218:  ADDLW  E2
0219:  MOVWF  4B
021A:  ADDLW  32
021B:  MOVWF  4D
021C:  MOVF   48,W
021D:  ANDLW  0F
021E:  ADDWF  4B,F
021F:  ADDWF  4B,F
0220:  ADDWF  4D,F
0221:  ADDLW  E9
0222:  MOVWF  4C
0223:  ADDWF  4C,F
0224:  ADDWF  4C,F
0225:  SWAPF  47,W
0226:  ANDLW  0F
0227:  ADDWF  4C,F
0228:  ADDWF  4D,F
0229:  RLF    4C,F
022A:  RLF    4D,F
022B:  COMF   4D,F
022C:  RLF    4D,F
022D:  MOVF   47,W
022E:  ANDLW  0F
022F:  ADDWF  4D,F
0230:  RLF    4A,F
0231:  MOVLW  07
0232:  MOVWF  49
0233:  MOVLW  0A
0234:  ADDWF  4D,F
0235:  DECF   4C,F
0236:  BTFSS  03.0
0237:  GOTO   234
0238:  ADDWF  4C,F
0239:  DECF   4B,F
023A:  BTFSS  03.0
023B:  GOTO   238
023C:  ADDWF  4B,F
023D:  DECF   4A,F
023E:  BTFSS  03.0
023F:  GOTO   23C
0240:  ADDWF  4A,F
0241:  DECF   49,F
0242:  BTFSS  03.0
0243:  GOTO   240
0244:  CLRF   05
0245:  MOVLW  49
0246:  MOVWF  04
0247:  MOVLW  07
0248:  ANDWF  4E,W
0249:  BCF    4E.6
024A:  ADDWF  04,F
024B:  MOVLW  4D
024C:  SUBWF  04,W
024D:  BTFSC  03.2
024E:  BSF    4E.6
024F:  MOVF   00,W
0250:  MOVWF  77
0251:  BTFSS  03.2
0252:  GOTO   25B
0253:  BTFSC  4E.6
0254:  GOTO   25B
0255:  BTFSC  4E.4
0256:  GOTO   265
0257:  BTFSC  4E.3
0258:  GOTO   25B
0259:  MOVLW  20
025A:  GOTO   25E
025B:  BSF    4E.3
025C:  BCF    4E.4
025D:  MOVLW  30
025E:  ADDWF  77,F
025F:  MOVF   77,W
0260:  BTFSS  11.4
0261:  GOTO   260
0262:  MOVLB  03
0263:  MOVWF  1A
0264:  MOVLB  00
0265:  ADDFSR 01,FSR0
0266:  BTFSS  4E.6
0267:  GOTO   24B
*
05A1:  CLRF   77
05A2:  CLRF   78
05A3:  MOVF   45,W
05A4:  BCF    03.0
05A5:  BTFSC  46.0
05A6:  ADDWF  77,F
05A7:  RRF    77,F
05A8:  RRF    78,F
05A9:  BTFSC  46.1
05AA:  ADDWF  77,F
05AB:  RRF    77,F
05AC:  RRF    78,F
05AD:  BTFSC  46.2
05AE:  ADDWF  77,F
05AF:  RRF    77,F
05B0:  RRF    78,F
05B1:  BTFSC  46.3
05B2:  ADDWF  77,F
05B3:  RRF    77,F
05B4:  RRF    78,F
05B5:  BTFSC  46.4
05B6:  ADDWF  77,F
05B7:  RRF    77,F
05B8:  RRF    78,F
05B9:  BTFSC  46.5
05BA:  ADDWF  77,F
05BB:  RRF    77,F
05BC:  RRF    78,F
05BD:  BTFSC  46.6
05BE:  ADDWF  77,F
05BF:  RRF    77,F
05C0:  RRF    78,F
05C1:  BTFSC  46.7
05C2:  ADDWF  77,F
05C3:  RRF    77,F
05C4:  RRF    78,F
05C5:  RETURN
05C6:  MOVF   48,W
05C7:  CLRF   78
05C8:  SUBWF  47,W
05C9:  BTFSC  03.0
05CA:  GOTO   5CE
05CB:  MOVF   47,W
05CC:  MOVWF  77
05CD:  GOTO   5DA
05CE:  CLRF   77
05CF:  MOVLW  08
05D0:  MOVWF  49
05D1:  RLF    47,F
05D2:  RLF    77,F
05D3:  MOVF   48,W
05D4:  SUBWF  77,W
05D5:  BTFSC  03.0
05D6:  MOVWF  77
05D7:  RLF    78,F
05D8:  DECFSZ 49,F
05D9:  GOTO   5D1
05DA:  RETURN
*
0625:  MOVF   0B,W
0626:  MOVWF  46
0627:  BCF    0B.7
0628:  MOVLB  03
0629:  BSF    15.7
062A:  BSF    15.0
062B:  NOP
062C:  NOP
062D:  BTFSC  03.0
062E:  GOTO   654
062F:  MOVF   13,W
0630:  ANDLW  7F
0631:  MOVLB  00
0632:  MOVWF  47
0633:  MOVLB  03
0634:  MOVF   11,W
0635:  MOVLB  00
0636:  MOVWF  48
0637:  MOVLB  03
0638:  MOVF   12,W
0639:  MOVLB  00
063A:  MOVWF  49
063B:  MOVF   47,W
063C:  BTFSS  11.4
063D:  GOTO   63C
063E:  MOVLB  03
063F:  MOVWF  1A
0640:  MOVLB  00
0641:  MOVF   48,W
0642:  MOVLB  03
0643:  MOVWF  11
0644:  MOVLB  00
0645:  MOVF   49,W
0646:  MOVLB  03
0647:  MOVWF  12
0648:  BSF    15.7
0649:  BSF    15.0
064A:  NOP
064B:  NOP
064C:  MOVLB  00
064D:  DECFSZ 45,F
064E:  GOTO   650
064F:  GOTO   652
0650:  MOVLB  03
0651:  GOTO   654
0652:  GOTO   675
0653:  MOVLB  03
0654:  RLF    13,W
0655:  RLF    14,W
0656:  ANDLW  7F
0657:  MOVLB  00
0658:  MOVWF  47
0659:  MOVLB  03
065A:  MOVF   11,W
065B:  MOVLB  00
065C:  MOVWF  48
065D:  MOVLB  03
065E:  MOVF   12,W
065F:  MOVLB  00
0660:  MOVWF  49
0661:  MOVF   47,W
0662:  BTFSS  11.4
0663:  GOTO   662
0664:  MOVLB  03
0665:  MOVWF  1A
0666:  MOVLB  00
0667:  MOVF   48,W
0668:  MOVLB  03
0669:  MOVWF  11
066A:  MOVLB  00
066B:  MOVF   49,W
066C:  MOVLB  03
066D:  MOVWF  12
066E:  INCF   11,F
066F:  BTFSC  03.2
0670:  INCF   12,F
0671:  BCF    03.0
0672:  MOVLB  00
0673:  DECFSZ 45,F
0674:  GOTO   628
0675:  BTFSC  46.7
0676:  BSF    0B.7
*
067B:  MOVF   45,W
067C:  MOVWF  47
067D:  MOVLW  64
067E:  MOVWF  48
067F:  CALL   5C6
0680:  MOVF   77,W
0681:  MOVWF  45
0682:  MOVF   78,W
0683:  MOVLW  30
0684:  BTFSS  03.2
0685:  GOTO   68D
0686:  BTFSS  46.1
0687:  GOTO   697
0688:  BTFSC  46.3
0689:  GOTO   697
068A:  BTFSC  46.4
068B:  MOVLW  20
068C:  GOTO   690
068D:  BCF    46.3
068E:  BCF    46.4
068F:  BSF    46.0
0690:  ADDWF  78,F
0691:  MOVF   78,W
0692:  BTFSS  11.4
0693:  GOTO   692
0694:  MOVLB  03
0695:  MOVWF  1A
0696:  MOVLB  00
0697:  MOVF   45,W
0698:  MOVWF  47
0699:  MOVLW  0A
069A:  MOVWF  48
069B:  CALL   5C6
069C:  MOVF   77,W
069D:  MOVWF  45
069E:  MOVF   78,W
069F:  MOVLW  30
06A0:  BTFSS  03.2
06A1:  GOTO   6A8
06A2:  BTFSC  46.3
06A3:  GOTO   6AF
06A4:  BTFSS  46.0
06A5:  GOTO   6AF
06A6:  BTFSC  46.4
06A7:  MOVLW  20
06A8:  ADDWF  78,F
06A9:  MOVF   78,W
06AA:  BTFSS  11.4
06AB:  GOTO   6AA
06AC:  MOVLB  03
06AD:  MOVWF  1A
06AE:  MOVLB  00
06AF:  MOVLW  30
06B0:  ADDWF  45,F
06B1:  MOVF   45,W
06B2:  BTFSS  11.4
06B3:  GOTO   6B2
06B4:  MOVLB  03
06B5:  MOVWF  1A
....................  
.................... #list 
....................  
....................  
.................... #FUSES INTRC_IO      // Internal RC clock (OSC1 and OSC2 pins are normal I/O) 
.................... #FUSES NOWDT         // Watch Dog Timer disabled 
.................... #FUSES PUT           // Power Up Timer enabled 
.................... #FUSES NOMCLR        // Master Clear pin is used for I/O 
.................... #FUSES PROTECT       // Code protected from reads 
.................... #FUSES CPD           // Data EEPROM code protected 
.................... #FUSES BROWNOUT      // Brownout Reset enabled 
.................... #FUSES BORV25        // Brownout Reset at 2.5V 
.................... #FUSES NOCLKOUT      // Disable clock output on OSC2 
.................... #FUSES NOIESO        // Internal External Switch Over Mode disabled 
.................... #FUSES NOFCMEN       // Fail-safe clock monitor disabled 
.................... #FUSES WRT           // Program memory write protected                                               
.................... #FUSES NOLVP         // Low Voltage Programming disabled 
....................  
.................... #USE   DELAY(internal = 32MHz) 
*
011F:  MOVLW  20
0120:  MOVWF  05
0121:  MOVLW  27
0122:  MOVWF  04
0123:  MOVF   00,W
0124:  BTFSC  03.2
0125:  GOTO   133
0126:  MOVLW  0A
0127:  MOVWF  78
0128:  CLRF   77
0129:  DECFSZ 77,F
012A:  GOTO   129
012B:  DECFSZ 78,F
012C:  GOTO   128
012D:  MOVLW  5F
012E:  MOVWF  77
012F:  DECFSZ 77,F
0130:  GOTO   12F
0131:  DECFSZ 00,F
0132:  GOTO   126
0133:  RETURN
*
0781:  MOVLW  02
0782:  SUBWF  38,F
0783:  BTFSS  03.0
0784:  GOTO   792
0785:  MOVLW  20
0786:  MOVWF  05
0787:  MOVLW  18
0788:  MOVWF  04
0789:  MOVF   00,W
078A:  BTFSC  03.2
078B:  GOTO   792
078C:  GOTO   790
078D:  GOTO   78E
078E:  GOTO   78F
078F:  NOP
0790:  DECFSZ 00,F
0791:  GOTO   78D
0792:  MOVLP  00
0793:  GOTO   7F0 (RETURN)
.................... #USE   RS232(stream=RS232, baud=38400, xmit=PIN_B5, rcv=PIN_B2, parity=N, bits=8, stop=1) 
....................  
.................... #DEFINE DRV_STEP           PIN_A0                  // Step output pin to driver (Rising edge causes the indexer to move one step) 
.................... #DEFINE DRV_RESET          PIN_A1                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.) 
.................... #DEFINE DRV_DIR            PIN_A4                  // Direction output pin to driver (Logic level, sets the direction of stepping) 
.................... #DEFINE SPI_SDO            PIN_A6                  // SPI data output pin 
.................... #DEFINE SPI_CS             PIN_A7                  // SPI chip select pin 
.................... #DEFINE SPI_SDI            PIN_B1                  // SPI data input pin 
.................... #DEFINE SPI_SCK            PIN_B4                  // SPI clock output pin 
.................... #DEFINE DRV_STALL          PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut) 
.................... #DEFINE DRV_FAULT          PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut) 
....................  
.................... #DEFINE LIMIT_SWITCH       PIN_A2                  // Fault output pin to user 
.................... #DEFINE USER_DIR           PIN_A3                  // Direction input pin from user 
.................... #DEFINE USER_STEP          PIN_B0                  // Step input pin from user 
.................... #DEFINE HOME_SWITCH        PIN_B3                  // Enable input pin from user 
....................  
.................... // Interrupt On Change Registers 
.................... #WORD IOC_INTCON     =0x00B 
.................... #WORD IOC_IOCBP      =0x394 
.................... #WORD IOC_IOCBN      =0x395 
.................... #WORD IOC_IOCBF      =0x396 
.................... #WORD ANSELB         =0x18d 
....................  
.................... //Bits of IOC_INTCON register 
.................... #BIT IOC_GIE           = IOC_INTCON.7        //General interrupt enable bit 
.................... #BIT IOC_PEIE          = IOC_INTCON.6        //Peripheral interrupt enable bit 
.................... #BIT IOC_IOCIE         = IOC_INTCON.3        //Interrupt on change enable bit 
....................  
.................... //Bits of IOC_IOCBP register 
.................... #BIT IOC_PINB0_RISING            = IOC_IOCBP.0        //Pin B3 interrupt on change enable bit(Rising Edge) 
.................... #BIT IOC_PINB3_RISING            = IOC_IOCBP.3        //Pin B3 interrupt on change enable bit(Rising Edge) 
....................  
.................... //Bits of IOC_IOCBN register 
.................... #BIT IOC_PINB0_FALLING           = IOC_IOCBN.0        //Pin B3 interrupt on change enable bit(Falling Edge) 
.................... #BIT IOC_PINB3_FALLING           = IOC_IOCBN.3        //Pin B3 interrupt on change enable bit(Rising Edge) 
.................... /* 
.................... //Bits of IOC_IOCBF register 
.................... #BIT IOC_PINB3_FLAG              = IOC_IOCBF.3        //Pin B3 interrupt on change interrupt flag bit(Both Rising and Falling Edges) 
.................... #BIT IOC_PINB3_FLAG              = IOC_IOCBP.3        //Pin B3 interrupt on change enable bit(Rising Edge) 
....................  
.................... //Bits of ANSELB register 
.................... #BIT ANSELB_PINB3                = ANSELB.3           //Selection of Pin B3 as a Digial I/O (0) or an Analog input (1) selection bit 
.................... */ 
.................... // SPI Registers 
.................... #WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register 
.................... #WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register 
.................... #WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register 
.................... #WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register 
.................... // Pin function control registers 
.................... #WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0 
.................... #WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1 
....................  
.................... // Bits of SSP1CON1 register 
.................... #BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit 
.................... #BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit 
.................... #BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit 
.................... #BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits 
.................... #BIT SPI_MODE_2         = SPI_SSP1CON1.2    
.................... #BIT SPI_MODE_1         = SPI_SSP1CON1.1    
.................... #BIT SPI_MODE_0         = SPI_SSP1CON1.0   
....................  
.................... // Bits of SPI_SSP1STAT register 
.................... #BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit 
.................... #BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit 
.................... #BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit 
....................  
.................... // Bits of SPI_PIR1 register 
.................... #BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit 
....................  
.................... // Bits of PIN_APFCON0 register 
.................... //#BIT PIN_RX_SELECT      = PIN_APFCON0.7      // RX pin selection bit 
.................... #BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit  
.................... #BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit  
....................  
.................... // Bits of PIN_APFCON1 register 
.................... //#BIT PIN_TX_SELECT      = PIN_APFCON1.0      // TX pin selection bit 
....................  
.................... // CTRL register of the driver 
.................... unsigned int16 reg_ctrl = 0; 
.................... // TORQUE register of the driver 
.................... unsigned int16 reg_torque = 0; 
.................... // OFF register of the driver 
.................... unsigned int16 reg_off = 0; 
.................... // BLANK register of the driver 
.................... unsigned int16 reg_blank = 0; 
.................... // DECAY register of the driver 
.................... unsigned int16 reg_decay = 0; 
.................... // STALL register of the driver 
.................... unsigned int16 reg_stall = 0; 
.................... // DRIVE register of the driver 
.................... unsigned int16 reg_drive = 0; 
.................... // STATUS register of the driver 
.................... unsigned int16 reg_status = 0; 
.................... // Driver debug mode 
.................... int1 drv_debug = 1; 
....................  
.................... char reg_rs232_message = 0; 
....................  
.................... int delay = 20; 
....................  
.................... // Sets alternative pin functions 
.................... void set_pins() 
.................... { 
....................    // Set RB2 as RX pin 
....................    //PIN_RX_SELECT = 1; 
....................    // Set RA6 as SDO pin 
....................    PIN_SDO_SELECT = 1; 
*
0134:  MOVLB  02
0135:  BSF    1D.6
....................    // Set RA5 as SS pin 
....................    PIN_SS_SELECT = 1; 
0136:  BSF    1D.5
0137:  MOVLP  00
0138:  MOVLB  00
0139:  GOTO   7C8 (RETURN)
....................    // Set RB5 as TX pin 
.................... } 
.................... // Sets SPI parameters 
.................... void set_SPI() 
.................... { 
....................    // Disable SPI to set registers 
....................    SPI_ENABLE = 0; 
013A:  MOVLB  04
013B:  BCF    15.5
....................    // Set idle state of the clock to low  
....................    SPI_CLOCK_POLARITY = 0; 
013C:  BCF    15.4
....................    // Set SPI mode to SPI  
....................    SPI_MODE_3 = 0;  
013D:  BCF    15.3
....................    SPI_MODE_2 = 0; 
013E:  BCF    15.2
....................    SPI_MODE_1 = 1; 
013F:  BSF    15.1
....................    SPI_MODE_0 = 0; 
0140:  BCF    15.0
....................    // Input data sampled at the middle of data output time 
....................    SPI_INPUT_SAMPLE = 0; 
0141:  BCF    14.7
....................    // Transmit occurs on transition from active to idle clock state 
....................    SPI_CLOCK_EDGE = 1; 
0142:  BSF    14.6
....................  
....................    // Enable SPI 
....................    SPI_ENABLE = 1; 
0143:  BSF    15.5
0144:  MOVLP  00
0145:  MOVLB  00
0146:  GOTO   7C9 (RETURN)
.................... } 
.................... // Sets variables to default values  
.................... void set_variables() 
.................... { 
....................    output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction  
0147:  MOVLB  01
0148:  BCF    0C.7
0149:  MOVLB  02
014A:  BCF    0C.7
....................    output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver  
014B:  MOVLB  01
014C:  BCF    0C.1
014D:  MOVLB  02
014E:  BCF    0C.1
....................    output_low(DRV_DIR);    // Set default direction 
014F:  MOVLB  01
0150:  BCF    0C.4
0151:  MOVLB  02
0152:  BCF    0C.4
....................    output_low(DRV_STEP);   // Keep step output low until a step command is received from the user 
0153:  MOVLB  01
0154:  BCF    0C.0
0155:  MOVLB  02
0156:  BCF    0C.0
0157:  MOVLP  00
0158:  MOVLB  00
0159:  GOTO   7CA (RETURN)
.................... } 
....................  
.................... // Writes the given register byte to the driver 
.................... void write_register_byte(unsigned int8 reg_byte) 
.................... { 
....................    // write the byte to spi buffer 
....................    SPI_SSP1BUF = reg_byte; 
*
01FD:  MOVLB  04
01FE:  CLRF   12
01FF:  MOVLB  00
0200:  MOVF   48,W
0201:  MOVLB  04
0202:  MOVWF  11
....................    // Wait until the end of the write operation 
....................    while (!SPI_FLAG); 
0203:  MOVLB  00
0204:  BTFSS  11.3
0205:  GOTO   204
....................    // Clear the write-completed-flag of the spi module 
....................    SPI_FLAG = 0; 
0206:  BCF    11.3
0207:  RETURN
.................... } 
.................... // Writes the given register to the driver 
.................... void write_register(unsigned int16 reg) 
.................... { 
....................    if(drv_debug) 
0208:  BTFSS  34.0
0209:  GOTO   274
....................       fprintf(RS232,"%Lu\n\r", reg); 
020A:  MOVLW  10
020B:  MOVWF  04
020C:  MOVF   46,W
020D:  MOVWF  48
020E:  MOVF   45,W
020F:  MOVWF  47
*
0268:  MOVLW  0A
0269:  BTFSS  11.4
026A:  GOTO   269
026B:  MOVLB  03
026C:  MOVWF  1A
026D:  MOVLW  0D
026E:  MOVLB  00
026F:  BTFSS  11.4
0270:  GOTO   26F
0271:  MOVLB  03
0272:  MOVWF  1A
0273:  MOVLB  00
....................     
....................    // start spi write operation by setting the chip select port to high 
....................    output_high(SPI_CS); 
0274:  MOVLB  01
0275:  BCF    0C.7
0276:  MOVLB  02
0277:  BSF    0C.7
....................    // Get and write the MSB of the register 
....................    write_register_byte(make8(reg, 1)); 
0278:  MOVLB  00
0279:  MOVF   46,W
027A:  MOVWF  47
027B:  MOVWF  48
027C:  CALL   1FD
....................    // Get and write the MSB of the register 
....................    write_register_byte(make8(reg, 0)); 
027D:  MOVF   45,W
027E:  MOVWF  47
027F:  MOVWF  48
0280:  CALL   1FD
....................    // stop spi write operation by setting the chip select port to low 
....................    output_low(SPI_CS); 
0281:  MOVLB  01
0282:  BCF    0C.7
0283:  MOVLB  02
0284:  BCF    0C.7
....................    delay_ms(10); 
0285:  MOVLW  0A
0286:  MOVLB  00
0287:  MOVWF  47
0288:  CALL   11F
0289:  RETURN
.................... } 
.................... // Sets the given number of bits of the register from starting address to the given value 
.................... unsigned int16 set_register_bits(unsigned int16 reg, unsigned int8 bit_address, unsigned int8 bit_size, unsigned int16 value) 
.................... { 
....................    // bit address must be smaller then register size (16 bit) 
....................    if(bit_address > 15) return 0; 
*
01A5:  MOVF   47,W
01A6:  SUBLW  0F
01A7:  BTFSC  03.0
01A8:  GOTO   1AD
01A9:  MOVLW  00
01AA:  MOVWF  78
01AB:  MOVWF  79
01AC:  GOTO   1FC
....................    // bit size can't be larger then the number of bits between the given address and the last bit of the register 
....................    if(bit_size > (16 - bit_address)) return 0; 
01AD:  MOVF   47,W
01AE:  SUBLW  10
01AF:  SUBWF  48,W
01B0:  BTFSC  03.2
01B1:  GOTO   1B8
01B2:  BTFSS  03.0
01B3:  GOTO   1B8
01B4:  MOVLW  00
01B5:  MOVWF  78
01B6:  MOVWF  79
01B7:  GOTO   1FC
....................     
....................    //fprintf(RS232,"reg: %Lu adr: %u size: %u val: %lu\n\r", reg, bit_address, bit_size, value); 
....................     
....................    // Get the bits of the "value" and set it to the corresponding bit in the given address 
....................    for(int i=0; i<bit_size; i++) 
01B8:  CLRF   4B
01B9:  MOVF   48,W
01BA:  SUBWF  4B,W
01BB:  BTFSC  03.0
01BC:  GOTO   1F8
....................    { 
....................       if(bit_test(value, i) == 1) 
01BD:  MOVF   4A,W
01BE:  MOVWF  7A
01BF:  MOVF   49,W
01C0:  MOVWF  79
01C1:  MOVF   4B,W
01C2:  MOVWF  77
01C3:  BTFSC  03.2
01C4:  GOTO   1C9
01C5:  LSRF   7A,F
01C6:  RRF    79,F
01C7:  DECFSZ 77,F
01C8:  GOTO   1C5
01C9:  MOVF   79,W
01CA:  BTFSS  79.0
01CB:  GOTO   1DF
....................          bit_set(reg, bit_address + i); 
01CC:  MOVF   4B,W
01CD:  ADDWF  47,W
01CE:  MOVWF  4C
01CF:  CLRF   7A
01D0:  MOVLW  01
01D1:  MOVWF  79
01D2:  MOVF   4C,W
01D3:  MOVWF  77
01D4:  BTFSC  03.2
01D5:  GOTO   1DA
01D6:  LSLF   79,F
01D7:  RLF    7A,F
01D8:  DECFSZ 77,F
01D9:  GOTO   1D6
01DA:  MOVF   79,W
01DB:  IORWF  45,F
01DC:  MOVF   7A,W
01DD:  IORWF  46,F
01DE:  GOTO   1F6
....................       else 
....................          bit_clear(reg, bit_address + i); 
01DF:  MOVF   4B,W
01E0:  ADDWF  47,W
01E1:  MOVWF  4C
01E2:  CLRF   7A
01E3:  MOVLW  01
01E4:  MOVWF  79
01E5:  MOVF   4C,W
01E6:  MOVWF  77
01E7:  BTFSC  03.2
01E8:  GOTO   1ED
01E9:  LSLF   79,F
01EA:  RLF    7A,F
01EB:  DECFSZ 77,F
01EC:  GOTO   1E9
01ED:  MOVF   79,W
01EE:  XORLW  FF
01EF:  MOVWF  77
01F0:  MOVLW  FF
01F1:  XORWF  7A,F
01F2:  MOVF   77,W
01F3:  ANDWF  45,F
01F4:  MOVF   7A,W
01F5:  ANDWF  46,F
01F6:  INCF   4B,F
01F7:  GOTO   1B9
....................    } 
....................     
....................    //fprintf(RS232,"reg: %Lu\n\r", reg); 
....................     
....................    return reg; 
01F8:  MOVF   45,W
01F9:  MOVWF  78
01FA:  MOVF   46,W
01FB:  MOVWF  79
01FC:  RETURN
.................... } 
.................... /* 
.................... // Driver common register variables 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 000: CTRL register 
.................... //                                                             001: TORQUE register 
.................... //                                                             010: OFF register 
.................... //                                                             011: BLANK register 
.................... //                                                             100: DECAY register 
.................... //                                                             101: STALL register 
.................... //                                                             110: DRIVE register 
.................... //                                                             111: STATUS register 
.................... */ 
.................... enum reg_type           {type_ctrl = 0, type_torque = 1, type_off = 2, type_blank = 3, type_decay = 4, type_stall = 5, type_drive = 6, type_status = 7}; 
.................... enum op_type            {op_write = 0, op_read = 1}; 
.................... enum reg_common_mask    {reg_type_addr = 12, op_type_addr = 15}; 
.................... enum reg_common_size    {reg_type_size = 3, op_type_size = 1}; 
.................... /* 
.................... // CTRL register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 000: CTRL reg 
.................... // DTIME (dead time btw MOSFET switching)    (R/W) (bit 11-10) 00: 400 ns,  
.................... //                                                             01: 450 ns,  
.................... //                                                             10: 650 ns,  
.................... //                                                             11: 850 ns 
.................... // ISGain (current amplifier gain)           (R/W) (bit 9-8)   00: Gain of 5,  
.................... //                                                             01: Gain of 10,  
.................... //                                                             10: Gain of 20,  
.................... //                                                             11: Gain of 40 
.................... // EXSTALL (source of stall detection)       (R/W) (bit 7)     0: Internal 
.................... //                                                             1: External 
.................... // MODE (microstepping mode)                 (R/W) (bit 6-3)   0000: Full-step, 71% current 
.................... //                                                             0001: Half step 
.................... //                                                             0010: 1/4 step 
.................... //                                                             0011: 1/8 step 
.................... //                                                             0100: 1/16 step 
.................... //                                                             0101: 1/32 step 
.................... //                                                             0110: 1/64 step 
.................... //                                                             0111: 1/128 step 
.................... //                                                             1000: 1/256 step 
.................... // RSTEP (single step output)                (W)   (bit 2)     0: No action 
.................... //                                                             1: Indexer will advance one step; automatically cleared after write 
.................... // direction                                 (R/W) (bit 1)     0: Direction set by DIR pin 
.................... //                                                             1: Direction set by inverse of DIR pin 
.................... // motor state                               (R/W) (bit 0)     0: Disable motor 
.................... //                                                             1: Enable motor 
.................... */ 
.................... enum dead_time          {dtime_400ns = 0, dtime_450ns = 1, dtime_650ns = 2, dtime_850ns = 3}; 
.................... enum curent_amp_gain    {gain_5 = 0, gain_10 = 1, gain_20 = 2, gain_40 = 3}; 
.................... enum src_stall_detect   {stall_int = 0, stall_ext = 1}; 
.................... enum microstepping      {full_step = 0, half_step = 1, _4x = 2, _8x = 3, _16x = 4, _32x = 5, _64x = 6, _128x = 7, _256x = 8}; 
.................... enum single_step_out    {no_action = 0, one_step = 1}; 
.................... enum dir_control        {dir_pin = 0, inv_dir_pin = 1}; 
.................... enum motor_state        {motor_disable = 0, motor_enable = 1}; 
.................... enum reg_ctrl_mask      {motor_state_addr = 0, dir_control_addr = 1, single_step_out_addr = 2, microstepping_addr = 3, src_stall_detect_addr = 7, curent_amp_gain_addr = 8, dead_time_addr = 10}; 
.................... enum reg_ctrl_size      {motor_state_size = 1, dir_control_size = 1, single_step_out_size = 1, microstepping_size = 4, src_stall_detect_size = 1, curent_amp_gain_size = 2, dead_time_size = 2}; 
.................... // Sets CTRL register 
.................... void set_ctrl_reg(dead_time dtime, curent_amp_gain gain, src_stall_detect stall, microstepping mode, single_step_out rstep, dir_control dir, motor_state state) 
.................... { 
....................    if(drv_debug) 
*
0294:  BTFSS  34.0
0295:  GOTO   29D
....................       fprintf(RS232,"CTRL Register\t: "); 
0296:  MOVLW  1F
0297:  MOVLB  03
0298:  MOVWF  11
0299:  MOVLW  00
029A:  MOVWF  12
029B:  MOVLB  00
029C:  CALL   15A
....................     
....................    // clear the register 
....................    reg_ctrl = 0b0000000000000000; 
029D:  CLRF   25
029E:  CLRF   24
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
029F:  MOVF   25,W
02A0:  MOVWF  46
02A1:  MOVF   24,W
02A2:  MOVWF  45
02A3:  MOVLW  0F
02A4:  MOVWF  47
02A5:  MOVLW  01
02A6:  MOVWF  48
02A7:  CLRF   4A
02A8:  CLRF   49
02A9:  CALL   1A5
02AA:  MOVF   79,W
02AB:  MOVWF  25
02AC:  MOVF   78,W
02AD:  MOVWF  24
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
02AE:  MOVF   25,W
02AF:  MOVWF  46
02B0:  MOVF   24,W
02B1:  MOVWF  45
02B2:  MOVLW  0C
02B3:  MOVWF  47
02B4:  MOVLW  03
02B5:  MOVWF  48
02B6:  CLRF   4A
02B7:  CLRF   49
02B8:  CALL   1A5
02B9:  MOVF   79,W
02BA:  MOVWF  25
02BB:  MOVF   78,W
02BC:  MOVWF  24
....................    // set dead time between MOSFET switching 
....................    reg_ctrl = set_register_bits(reg_ctrl, dead_time_addr, dead_time_size, dtime);  
02BD:  MOVF   25,W
02BE:  MOVWF  46
02BF:  MOVF   24,W
02C0:  MOVWF  45
02C1:  MOVLW  0A
02C2:  MOVWF  47
02C3:  MOVLW  02
02C4:  MOVWF  48
02C5:  CLRF   4A
02C6:  MOVF   37,W
02C7:  MOVWF  49
02C8:  CALL   1A5
02C9:  MOVF   79,W
02CA:  MOVWF  25
02CB:  MOVF   78,W
02CC:  MOVWF  24
....................    // set current amplifier gain 
....................    reg_ctrl = set_register_bits(reg_ctrl, curent_amp_gain_addr, curent_amp_gain_size, gain); 
02CD:  MOVF   25,W
02CE:  MOVWF  46
02CF:  MOVF   24,W
02D0:  MOVWF  45
02D1:  MOVLW  08
02D2:  MOVWF  47
02D3:  MOVLW  02
02D4:  MOVWF  48
02D5:  CLRF   4A
02D6:  MOVF   38,W
02D7:  MOVWF  49
02D8:  CALL   1A5
02D9:  MOVF   79,W
02DA:  MOVWF  25
02DB:  MOVF   78,W
02DC:  MOVWF  24
....................    // set source of stall detection 
....................    reg_ctrl = set_register_bits(reg_ctrl, src_stall_detect_addr, src_stall_detect_size, stall); 
02DD:  MOVF   25,W
02DE:  MOVWF  46
02DF:  MOVF   24,W
02E0:  MOVWF  45
02E1:  MOVLW  07
02E2:  MOVWF  47
02E3:  MOVLW  01
02E4:  MOVWF  48
02E5:  CLRF   4A
02E6:  MOVF   39,W
02E7:  MOVWF  49
02E8:  CALL   1A5
02E9:  MOVF   79,W
02EA:  MOVWF  25
02EB:  MOVF   78,W
02EC:  MOVWF  24
....................    // set microstepping mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, microstepping_addr, microstepping_size, mode); 
02ED:  MOVF   25,W
02EE:  MOVWF  46
02EF:  MOVF   24,W
02F0:  MOVWF  45
02F1:  MOVLW  03
02F2:  MOVWF  47
02F3:  MOVLW  04
02F4:  MOVWF  48
02F5:  CLRF   4A
02F6:  MOVF   3A,W
02F7:  MOVWF  49
02F8:  CALL   1A5
02F9:  MOVF   79,W
02FA:  MOVWF  25
02FB:  MOVF   78,W
02FC:  MOVWF  24
....................    // set single step output mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, single_step_out_addr, single_step_out_size, rstep); 
02FD:  MOVF   25,W
02FE:  MOVWF  46
02FF:  MOVF   24,W
0300:  MOVWF  45
0301:  MOVLW  02
0302:  MOVWF  47
0303:  MOVLW  01
0304:  MOVWF  48
0305:  CLRF   4A
0306:  MOVF   3B,W
0307:  MOVWF  49
0308:  CALL   1A5
0309:  MOVF   79,W
030A:  MOVWF  25
030B:  MOVF   78,W
030C:  MOVWF  24
....................    // set direction 
....................    reg_ctrl = set_register_bits(reg_ctrl, dir_control_addr, dir_control_size, dir); 
030D:  MOVF   25,W
030E:  MOVWF  46
030F:  MOVF   24,W
0310:  MOVWF  45
0311:  MOVLW  01
0312:  MOVWF  47
0313:  MOVWF  48
0314:  CLRF   4A
0315:  MOVF   3C,W
0316:  MOVWF  49
0317:  CALL   1A5
0318:  MOVF   79,W
0319:  MOVWF  25
031A:  MOVF   78,W
031B:  MOVWF  24
....................    // set motor state 
....................    reg_ctrl = set_register_bits(reg_ctrl, motor_state_addr, motor_state_size, state); 
031C:  MOVF   25,W
031D:  MOVWF  46
031E:  MOVF   24,W
031F:  MOVWF  45
0320:  CLRF   47
0321:  MOVLW  01
0322:  MOVWF  48
0323:  CLRF   4A
0324:  MOVF   3D,W
0325:  MOVWF  49
0326:  CALL   1A5
0327:  MOVF   79,W
0328:  MOVWF  25
0329:  MOVF   78,W
032A:  MOVWF  24
....................  
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
032B:  MOVF   25,W
032C:  MOVWF  46
032D:  MOVF   24,W
032E:  MOVWF  45
032F:  CALL   208
.................... } 
.................... // Sets CTRL register 
.................... void set_dead_time(dead_time dtime) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set dead time between MOSFET switching 
....................    reg_ctrl = set_register_bits(reg_ctrl, dead_time_addr, dead_time_size, dtime);  
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_amp_gain(curent_amp_gain gain) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set current amplifier gain 
....................    reg_ctrl = set_register_bits(reg_ctrl, curent_amp_gain_addr, curent_amp_gain_size, gain); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_stall_detection(src_stall_detect stall) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set source of stall detection 
....................    reg_ctrl = set_register_bits(reg_ctrl, src_stall_detect_addr, src_stall_detect_size, stall); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_microstepping_mode(microstepping mode) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set microstepping mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, microstepping_addr, microstepping_size, mode); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_rstep(single_step_out rstep) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................          
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set single step output mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, single_step_out_addr, single_step_out_size, rstep); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_dir_mode(dir_control dir) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set direction mode 
....................    reg_ctrl = set_register_bits(reg_ctrl, dir_control_addr, dir_control_size, dir); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... // Sets CTRL register 
.................... void set_motor_state(motor_state state) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"CTRL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_ctrl = set_register_bits(reg_ctrl, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_ctrl = set_register_bits(reg_ctrl, reg_type_addr, reg_type_size, type_ctrl); 
....................    // set motor state 
....................    reg_ctrl = set_register_bits(reg_ctrl, motor_state_addr, motor_state_size, state); 
....................    // write register to SPI 
....................    write_register(reg_ctrl); 
.................... } 
.................... /* 
.................... // TORQUE register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 001: Torque reg 
.................... // Reserved                                        (bit 11) 
.................... // SMPLTH (Back EMF sample threshold)        (R/W) (bit 10-8)  000: 50 us,  
.................... //                                                             001: 100 us,  
.................... //                                                             010: 200 us,  
.................... //                                                             011: 300 us, 
.................... //                                                             100: 400 us, 
.................... //                                                             101: 600 us, 
.................... //                                                             110: 800 us,  
.................... //                                                             111: 1000 us, 
.................... // Torque (Output current for H-bridges)     (R/W) (bit 7-0)   0xFFh 
.................... */ 
.................... enum emf_samp_thr       {emf_50us = 0, emf_100us = 1, emf_200us = 2, emf_300us = 3, emf_400us = 4, emf_600us = 5, emf_800us = 6, emf_1000us = 7}; 
.................... enum reg_torque_mask    {torque_addr = 0, emf_samp_thr_addr = 8}; 
.................... enum reg_torque_size    {torque_size = 8, emf_samp_thr_size = 3}; 
.................... // Sets TORQUE register 
.................... void set_torque_reg(emf_samp_thr emf, unsigned int8 torque) 
.................... { 
....................    if(drv_debug) 
*
0334:  BTFSS  34.0
0335:  GOTO   33D
....................       fprintf(RS232,"TORQUE Register\t: "); 
0336:  MOVLW  67
0337:  MOVLB  03
0338:  MOVWF  11
0339:  MOVLW  00
033A:  MOVWF  12
033B:  MOVLB  00
033C:  CALL   15A
....................        
....................    // clear the register 
....................    reg_torque = 0b0000000000000000; 
033D:  CLRF   27
033E:  CLRF   26
....................    // set write operation 
....................    reg_torque = set_register_bits(reg_torque, op_type_addr, op_type_size, op_write);  
033F:  MOVF   27,W
0340:  MOVWF  46
0341:  MOVF   26,W
0342:  MOVWF  45
0343:  MOVLW  0F
0344:  MOVWF  47
0345:  MOVLW  01
0346:  MOVWF  48
0347:  CLRF   4A
0348:  CLRF   49
0349:  CALL   1A5
034A:  MOVF   79,W
034B:  MOVWF  27
034C:  MOVF   78,W
034D:  MOVWF  26
....................    // set register address 
....................    reg_torque = set_register_bits(reg_torque, reg_type_addr, reg_type_size, type_torque); 
034E:  MOVF   27,W
034F:  MOVWF  46
0350:  MOVF   26,W
0351:  MOVWF  45
0352:  MOVLW  0C
0353:  MOVWF  47
0354:  MOVLW  03
0355:  MOVWF  48
0356:  CLRF   4A
0357:  MOVLW  01
0358:  MOVWF  49
0359:  CALL   1A5
035A:  MOVF   79,W
035B:  MOVWF  27
035C:  MOVF   78,W
035D:  MOVWF  26
....................    // set back EMF sample threshold 
....................    reg_torque = set_register_bits(reg_torque, emf_samp_thr_addr, emf_samp_thr_size, emf); 
035E:  MOVF   27,W
035F:  MOVWF  46
0360:  MOVF   26,W
0361:  MOVWF  45
0362:  MOVLW  08
0363:  MOVWF  47
0364:  MOVLW  03
0365:  MOVWF  48
0366:  CLRF   4A
0367:  MOVF   37,W
0368:  MOVWF  49
0369:  CALL   1A5
036A:  MOVF   79,W
036B:  MOVWF  27
036C:  MOVF   78,W
036D:  MOVWF  26
....................    // set output current for H-bridges 
....................    reg_torque = set_register_bits(reg_torque, torque_addr, torque_size, torque); 
036E:  MOVF   27,W
036F:  MOVWF  46
0370:  MOVF   26,W
0371:  MOVWF  45
0372:  CLRF   47
0373:  MOVLW  08
0374:  MOVWF  48
0375:  CLRF   4A
0376:  MOVF   38,W
0377:  MOVWF  49
0378:  CALL   1A5
0379:  MOVF   79,W
037A:  MOVWF  27
037B:  MOVF   78,W
037C:  MOVWF  26
....................     
....................    // write register to SPI 
....................    write_register(reg_torque); 
037D:  MOVF   27,W
037E:  MOVWF  46
037F:  MOVF   26,W
0380:  MOVWF  45
0381:  CALL   208
.................... } 
.................... // Sets back EMF sample threshold 
.................... void set_emf_samp_thr(emf_samp_thr emf) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"TORQUE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_torque = set_register_bits(reg_torque, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_torque = set_register_bits(reg_torque, reg_type_addr, reg_type_size, type_torque); 
....................    // set back EMF sample threshold 
....................    reg_torque = set_register_bits(reg_torque, emf_samp_thr_addr, emf_samp_thr_size, emf); 
....................    // write register to SPI 
....................    write_register(reg_torque); 
.................... } 
.................... // Sets full-scale output current for both H-bridges 
.................... void set_torque(unsigned int8 torque) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"TORQUE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_torque = set_register_bits(reg_torque, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_torque = set_register_bits(reg_torque, reg_type_addr, reg_type_size, type_torque); 
....................    // set output current for H-bridges 
....................    reg_torque = set_register_bits(reg_torque, torque_addr, torque_size, torque); 
....................    // write register to SPI 
....................    write_register(reg_torque); 
.................... } 
.................... /* 
.................... // OFF register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 010: OFF reg 
.................... // Reserved                                        (bit 11-9) 
.................... // PWMMODE (indexer mode)                    (R/W) (bit 8)     0: Use internal indexer,  
.................... //                                                             1: Bypass indexer, use xINx inputs to control outputs  
.................... // TOFF (Sets fixed off time, 500ns steps)   (R/W) (bit 7-0)   0x00h: 500 ns 
.................... //                                                             0xFFh: 128 us 
.................... */ 
.................... enum pwm_mode           {int_indexer = 0, ext_indexer = 1}; 
.................... enum reg_off_mask       {toff_addr = 0, pwm_mode_addr = 8}; 
.................... enum reg_off_size       {toff_size = 8, pwm_mode_size = 1}; 
.................... // Sets OFF register 
.................... void set_off_reg(pwm_mode indexer, unsigned int8 toff) 
.................... { 
....................    if(drv_debug) 
*
0385:  BTFSS  34.0
0386:  GOTO   38E
....................       fprintf(RS232,"TOFF Register\t: "); 
0387:  MOVLW  85
0388:  MOVLB  03
0389:  MOVWF  11
038A:  MOVLW  00
038B:  MOVWF  12
038C:  MOVLB  00
038D:  CALL   15A
....................        
....................    // clear the register 
....................    reg_off = 0b0000000000000000; 
038E:  CLRF   29
038F:  CLRF   28
....................    // set write operation 
....................    reg_off = set_register_bits(reg_off, op_type_addr, op_type_size, op_write);  
0390:  MOVF   29,W
0391:  MOVWF  46
0392:  MOVF   28,W
0393:  MOVWF  45
0394:  MOVLW  0F
0395:  MOVWF  47
0396:  MOVLW  01
0397:  MOVWF  48
0398:  CLRF   4A
0399:  CLRF   49
039A:  CALL   1A5
039B:  MOVF   79,W
039C:  MOVWF  29
039D:  MOVF   78,W
039E:  MOVWF  28
....................    // set register address 
....................    reg_off = set_register_bits(reg_off, reg_type_addr, reg_type_size, type_off); 
039F:  MOVF   29,W
03A0:  MOVWF  46
03A1:  MOVF   28,W
03A2:  MOVWF  45
03A3:  MOVLW  0C
03A4:  MOVWF  47
03A5:  MOVLW  03
03A6:  MOVWF  48
03A7:  CLRF   4A
03A8:  MOVLW  02
03A9:  MOVWF  49
03AA:  CALL   1A5
03AB:  MOVF   79,W
03AC:  MOVWF  29
03AD:  MOVF   78,W
03AE:  MOVWF  28
....................    // set pwm indexer mode 
....................    reg_off = set_register_bits(reg_off, pwm_mode_addr, pwm_mode_size, indexer); 
03AF:  MOVF   29,W
03B0:  MOVWF  46
03B1:  MOVF   28,W
03B2:  MOVWF  45
03B3:  MOVLW  08
03B4:  MOVWF  47
03B5:  MOVLW  01
03B6:  MOVWF  48
03B7:  CLRF   4A
03B8:  MOVF   37,W
03B9:  MOVWF  49
03BA:  CALL   1A5
03BB:  MOVF   79,W
03BC:  MOVWF  29
03BD:  MOVF   78,W
03BE:  MOVWF  28
....................    // set fixed off time 
....................    reg_off = set_register_bits(reg_off, toff_addr, toff_size, toff); 
03BF:  MOVF   29,W
03C0:  MOVWF  46
03C1:  MOVF   28,W
03C2:  MOVWF  45
03C3:  CLRF   47
03C4:  MOVLW  08
03C5:  MOVWF  48
03C6:  CLRF   4A
03C7:  MOVF   38,W
03C8:  MOVWF  49
03C9:  CALL   1A5
03CA:  MOVF   79,W
03CB:  MOVWF  29
03CC:  MOVF   78,W
03CD:  MOVWF  28
....................  
....................    // write register to SPI 
....................    write_register(reg_off); 
03CE:  MOVF   29,W
03CF:  MOVWF  46
03D0:  MOVF   28,W
03D1:  MOVWF  45
03D2:  CALL   208
.................... } 
.................... // Sets pwm indexer mode 
.................... void set_pwm_mode(pwm_mode indexer) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"TOFF Register\t: "); 
....................        
....................    // set write operation 
....................    reg_off = set_register_bits(reg_off, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_off = set_register_bits(reg_off, reg_type_addr, reg_type_size, type_off); 
....................    // set pwm indexer mode 
....................    reg_off = set_register_bits(reg_off, pwm_mode_addr, pwm_mode_size, indexer); 
....................    // write register to SPI 
....................    write_register(reg_off); 
.................... } 
.................... // Sets fixed off time 
.................... void set_off_time(unsigned int8 toff) 
.................... { 
....................    if(drv_debug) 
*
06DF:  BTFSS  34.0
06E0:  GOTO   6E8
....................       fprintf(RS232,"TOFF Register\t: "); 
06E1:  MOVLW  97
06E2:  MOVLB  03
06E3:  MOVWF  11
06E4:  MOVLW  00
06E5:  MOVWF  12
06E6:  MOVLB  00
06E7:  CALL   15A
....................        
....................    // set write operation 
....................    reg_off = set_register_bits(reg_off, op_type_addr, op_type_size, op_write);  
06E8:  MOVF   29,W
06E9:  MOVWF  46
06EA:  MOVF   28,W
06EB:  MOVWF  45
06EC:  MOVLW  0F
06ED:  MOVWF  47
06EE:  MOVLW  01
06EF:  MOVWF  48
06F0:  CLRF   4A
06F1:  CLRF   49
06F2:  CALL   1A5
06F3:  MOVF   79,W
06F4:  MOVWF  29
06F5:  MOVF   78,W
06F6:  MOVWF  28
....................    // set register address 
....................    reg_off = set_register_bits(reg_off, reg_type_addr, reg_type_size, type_off); 
06F7:  MOVF   29,W
06F8:  MOVWF  46
06F9:  MOVF   28,W
06FA:  MOVWF  45
06FB:  MOVLW  0C
06FC:  MOVWF  47
06FD:  MOVLW  03
06FE:  MOVWF  48
06FF:  CLRF   4A
0700:  MOVLW  02
0701:  MOVWF  49
0702:  CALL   1A5
0703:  MOVF   79,W
0704:  MOVWF  29
0705:  MOVF   78,W
0706:  MOVWF  28
....................    // set fixed off time 
....................    reg_off = set_register_bits(reg_off, toff_addr, toff_size, toff); 
0707:  MOVF   29,W
0708:  MOVWF  46
0709:  MOVF   28,W
070A:  MOVWF  45
070B:  CLRF   47
070C:  MOVLW  08
070D:  MOVWF  48
070E:  CLRF   4A
070F:  MOVF   44,W
0710:  MOVWF  49
0711:  CALL   1A5
0712:  MOVF   79,W
0713:  MOVWF  29
0714:  MOVF   78,W
0715:  MOVWF  28
....................    // write register to SPI 
....................    write_register(reg_off); 
0716:  MOVF   29,W
0717:  MOVWF  46
0718:  MOVF   28,W
0719:  MOVWF  45
071A:  CALL   208
.................... } 
.................... /* 
.................... // BLANK register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 011: BLANK reg 
.................... // Reserved                                        (bit 11-9) 
.................... // ABT (adaptive blanking time state)        (R/W) (bit 8)     0: Disable adaptive blanking time,  
.................... //                                                             1: Enable adaptive blanking time 
.................... // TBLANK (Sets blanking time, 20ns steps)   (R/W) (bit 7-0)   0x00h: 1.00 us 
.................... //                                                             ... 
.................... //                                                             0x32h: 1.00 us 
.................... //                                                             0x33h: 1.02 us 
.................... //                                                             ... 
.................... //                                                             0xFEh: 5.10 us 
.................... //                                                             0xFFh: 5.12 us 
.................... */ 
.................... enum adap_blank_state   {disable_abt = 0, enable_abt = 1}; 
.................... enum reg_blank_mask     {tblank_addr = 0, adap_blank_time_addr = 8}; 
.................... enum reg_blank_size     {tblank_size = 8, adap_blank_time_size = 1}; 
.................... // Sets BLANK register 
.................... void set_blank_reg(adap_blank_state abt, unsigned int8 tblank) 
.................... { 
....................    if(drv_debug) 
*
03D7:  BTFSS  34.0
03D8:  GOTO   3E0
....................       fprintf(RS232,"BLANK Register\t: "); 
03D9:  MOVLW  A0
03DA:  MOVLB  03
03DB:  MOVWF  11
03DC:  MOVLW  00
03DD:  MOVWF  12
03DE:  MOVLB  00
03DF:  CALL   15A
....................        
....................    // clear the register 
....................    reg_blank = 0b0000000000000000; 
03E0:  CLRF   2B
03E1:  CLRF   2A
....................    // set write operation 
....................    reg_blank = set_register_bits(reg_blank, op_type_addr, op_type_size, op_write);  
03E2:  MOVF   2B,W
03E3:  MOVWF  46
03E4:  MOVF   2A,W
03E5:  MOVWF  45
03E6:  MOVLW  0F
03E7:  MOVWF  47
03E8:  MOVLW  01
03E9:  MOVWF  48
03EA:  CLRF   4A
03EB:  CLRF   49
03EC:  CALL   1A5
03ED:  MOVF   79,W
03EE:  MOVWF  2B
03EF:  MOVF   78,W
03F0:  MOVWF  2A
....................    // set register address 
....................    reg_blank = set_register_bits(reg_blank, reg_type_addr, reg_type_size, type_blank); 
03F1:  MOVF   2B,W
03F2:  MOVWF  46
03F3:  MOVF   2A,W
03F4:  MOVWF  45
03F5:  MOVLW  0C
03F6:  MOVWF  47
03F7:  MOVLW  03
03F8:  MOVWF  48
03F9:  CLRF   4A
03FA:  MOVWF  49
03FB:  CALL   1A5
03FC:  MOVF   79,W
03FD:  MOVWF  2B
03FE:  MOVF   78,W
03FF:  MOVWF  2A
....................    // set adaptive blanking time state 
....................    reg_blank = set_register_bits(reg_blank, adap_blank_time_addr, adap_blank_time_size, abt); 
0400:  MOVF   2B,W
0401:  MOVWF  46
0402:  MOVF   2A,W
0403:  MOVWF  45
0404:  MOVLW  08
0405:  MOVWF  47
0406:  MOVLW  01
0407:  MOVWF  48
0408:  CLRF   4A
0409:  MOVF   37,W
040A:  MOVWF  49
040B:  CALL   1A5
040C:  MOVF   79,W
040D:  MOVWF  2B
040E:  MOVF   78,W
040F:  MOVWF  2A
....................    // set blanking time 
....................    reg_blank = set_register_bits(reg_blank, tblank_addr, tblank_size, tblank); 
0410:  MOVF   2B,W
0411:  MOVWF  46
0412:  MOVF   2A,W
0413:  MOVWF  45
0414:  CLRF   47
0415:  MOVLW  08
0416:  MOVWF  48
0417:  CLRF   4A
0418:  MOVF   38,W
0419:  MOVWF  49
041A:  CALL   1A5
041B:  MOVF   79,W
041C:  MOVWF  2B
041D:  MOVF   78,W
041E:  MOVWF  2A
....................     
....................    // write register to SPI 
....................    write_register(reg_blank); 
041F:  MOVF   2B,W
0420:  MOVWF  46
0421:  MOVF   2A,W
0422:  MOVWF  45
0423:  CALL   208
.................... } 
.................... // Sets adaptive blank time state 
.................... void set_adap_blank_state(adap_blank_state abt) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"BLANK Register\t: "); 
....................        
....................    // set write operation 
....................    reg_blank = set_register_bits(reg_blank, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_blank = set_register_bits(reg_blank, reg_type_addr, reg_type_size, type_blank); 
....................    // set adaptive blanking time state 
....................    reg_blank = set_register_bits(reg_blank, adap_blank_time_addr, adap_blank_time_size, abt); 
....................    // write register to SPI 
....................    write_register(reg_blank); 
.................... } 
.................... // Sets blanking time 
.................... void set_blank_time(unsigned int8 tblank) 
.................... { 
....................    if(drv_debug) 
*
0743:  BTFSS  34.0
0744:  GOTO   74C
....................       fprintf(RS232,"BLANK Register\t: "); 
0745:  MOVLW  B2
0746:  MOVLB  03
0747:  MOVWF  11
0748:  MOVLW  00
0749:  MOVWF  12
074A:  MOVLB  00
074B:  CALL   15A
....................        
....................    // set write operation 
....................    reg_blank = set_register_bits(reg_blank, op_type_addr, op_type_size, op_write);  
074C:  MOVF   2B,W
074D:  MOVWF  46
074E:  MOVF   2A,W
074F:  MOVWF  45
0750:  MOVLW  0F
0751:  MOVWF  47
0752:  MOVLW  01
0753:  MOVWF  48
0754:  CLRF   4A
0755:  CLRF   49
0756:  CALL   1A5
0757:  MOVF   79,W
0758:  MOVWF  2B
0759:  MOVF   78,W
075A:  MOVWF  2A
....................    // set register address 
....................    reg_blank = set_register_bits(reg_blank, reg_type_addr, reg_type_size, type_blank); 
075B:  MOVF   2B,W
075C:  MOVWF  46
075D:  MOVF   2A,W
075E:  MOVWF  45
075F:  MOVLW  0C
0760:  MOVWF  47
0761:  MOVLW  03
0762:  MOVWF  48
0763:  CLRF   4A
0764:  MOVWF  49
0765:  CALL   1A5
0766:  MOVF   79,W
0767:  MOVWF  2B
0768:  MOVF   78,W
0769:  MOVWF  2A
....................    // set blanking time 
....................    reg_blank = set_register_bits(reg_blank, tblank_addr, tblank_size, tblank); 
076A:  MOVF   2B,W
076B:  MOVWF  46
076C:  MOVF   2A,W
076D:  MOVWF  45
076E:  CLRF   47
076F:  MOVLW  08
0770:  MOVWF  48
0771:  CLRF   4A
0772:  MOVF   44,W
0773:  MOVWF  49
0774:  CALL   1A5
0775:  MOVF   79,W
0776:  MOVWF  2B
0777:  MOVF   78,W
0778:  MOVWF  2A
....................    // write register to SPI 
....................    write_register(reg_blank); 
0779:  MOVF   2B,W
077A:  MOVWF  46
077B:  MOVF   2A,W
077C:  MOVWF  45
077D:  CALL   208
.................... } 
.................... /* 
.................... // DECAY register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 100: DECAY reg 
.................... // Reserved                                        (bit 11) 
.................... // DECMODE (decay modes)                     (R/W) (bit 10-8)  000: Force slow decay at all times 
.................... //                                                             001: Slow decay for increasing current, mixed decay for decreasing current (indexer mode only) 
.................... //                                                             010: Force fast decay at all times 
.................... //                                                             011: Use mixed decay at all times 
.................... //                                                             100: Slow decay for increasing current, auto mixed decay for decreasing current (indexer mode only) 
.................... //                                                             101: Use auto mixed decay at all times 
.................... //                                                             110-111: Reserved 
.................... // TDECAY (Sets transition time, 500ns steps)(R/W) (bit 7-0)   0x00h: 500 ns 
.................... //                                                             0xFFh: 128 us 
.................... */ 
.................... enum decay_mode         {force_slow_decay = 0, slow_mixed_decay = 1, force_fast_decay = 2, mixed_decay = 3, slow_auto_mixed_decay = 4, auto_mixed_decay = 5}; 
.................... enum reg_decay_mask     {tdecay_addr = 0, decay_mode_addr = 8}; 
.................... enum reg_decay_size     {tdecay_size = 8, decay_mode_size = 3}; 
.................... // Sets DECAY register 
.................... void set_decay_reg(decay_mode dmode, unsigned int8 tdecay) 
.................... { 
....................    if(drv_debug) 
*
0428:  BTFSS  34.0
0429:  GOTO   431
....................       fprintf(RS232,"DECAY Register\t: "); 
042A:  MOVLW  BB
042B:  MOVLB  03
042C:  MOVWF  11
042D:  MOVLW  00
042E:  MOVWF  12
042F:  MOVLB  00
0430:  CALL   15A
....................        
....................    // clear the register 
....................    reg_decay = 0b0000000000000000; 
0431:  CLRF   2D
0432:  CLRF   2C
....................    // set write operation 
....................    reg_decay = set_register_bits(reg_decay, op_type_addr, op_type_size, op_write);  
0433:  MOVF   2D,W
0434:  MOVWF  46
0435:  MOVF   2C,W
0436:  MOVWF  45
0437:  MOVLW  0F
0438:  MOVWF  47
0439:  MOVLW  01
043A:  MOVWF  48
043B:  CLRF   4A
043C:  CLRF   49
043D:  CALL   1A5
043E:  MOVF   79,W
043F:  MOVWF  2D
0440:  MOVF   78,W
0441:  MOVWF  2C
....................    // set register address 
....................    reg_decay = set_register_bits(reg_decay, reg_type_addr, reg_type_size, type_decay); 
0442:  MOVF   2D,W
0443:  MOVWF  46
0444:  MOVF   2C,W
0445:  MOVWF  45
0446:  MOVLW  0C
0447:  MOVWF  47
0448:  MOVLW  03
0449:  MOVWF  48
044A:  CLRF   4A
044B:  MOVLW  04
044C:  MOVWF  49
044D:  CALL   1A5
044E:  MOVF   79,W
044F:  MOVWF  2D
0450:  MOVF   78,W
0451:  MOVWF  2C
....................    // set decay mode 
....................    reg_decay = set_register_bits(reg_decay, decay_mode_addr, decay_mode_size, dmode); 
0452:  MOVF   2D,W
0453:  MOVWF  46
0454:  MOVF   2C,W
0455:  MOVWF  45
0456:  MOVLW  08
0457:  MOVWF  47
0458:  MOVLW  03
0459:  MOVWF  48
045A:  CLRF   4A
045B:  MOVF   37,W
045C:  MOVWF  49
045D:  CALL   1A5
045E:  MOVF   79,W
045F:  MOVWF  2D
0460:  MOVF   78,W
0461:  MOVWF  2C
....................    // set decay time 
....................    reg_decay = set_register_bits(reg_decay, tdecay_addr, tdecay_size, tdecay); 
0462:  MOVF   2D,W
0463:  MOVWF  46
0464:  MOVF   2C,W
0465:  MOVWF  45
0466:  CLRF   47
0467:  MOVLW  08
0468:  MOVWF  48
0469:  CLRF   4A
046A:  MOVF   38,W
046B:  MOVWF  49
046C:  CALL   1A5
046D:  MOVF   79,W
046E:  MOVWF  2D
046F:  MOVF   78,W
0470:  MOVWF  2C
....................  
....................    // write register to SPI 
....................    write_register(reg_decay); 
0471:  MOVF   2D,W
0472:  MOVWF  46
0473:  MOVF   2C,W
0474:  MOVWF  45
0475:  CALL   208
.................... } 
.................... // Sets decay (transition) mode 
.................... void set_decay_mode(decay_mode dmode) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DECAY Register\t: "); 
....................        
....................    // set write operation 
....................    reg_decay = set_register_bits(reg_decay, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_decay = set_register_bits(reg_decay, reg_type_addr, reg_type_size, type_decay); 
....................    // set decay mode 
....................    reg_decay = set_register_bits(reg_decay, decay_mode_addr, decay_mode_size, dmode); 
....................    // write register to SPI 
....................    write_register(reg_decay); 
.................... } 
.................... // Sets decay (transition) time 
.................... void set_decay_time(unsigned int8 tdecay) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DECAY Register\t: "); 
....................        
....................    // set write operation 
....................    reg_decay = set_register_bits(reg_decay, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_decay = set_register_bits(reg_decay, reg_type_addr, reg_type_size, type_decay); 
....................    // set decay time 
....................    reg_decay = set_register_bits(reg_decay, tdecay_addr, tdecay_size, tdecay); 
....................    // write register to SPI 
....................    write_register(reg_decay); 
.................... } 
.................... /* 
.................... // STALL register bits 
.................... // data operation type                             (bit 15)    0: write, 
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 101: STALL reg 
.................... // VDIV (Back EMF divider)                   (R/W) (bit 11-10) 00: Back EMF is divided by 32 
.................... //                                                             01: Back EMF is divided by 16 
.................... //                                                             10: Back EMF is divided by 8 
.................... //                                                             11: Back EMF is divided by 4 
.................... // SDCNT (Back EMF sample step mode)         (R/W) (bit 9-8)   00: STALLn asserted on first step with back EMF below SDTHR 
.................... //                                                             01: STALLn asserted after 2 steps 
.................... //                                                             10: STALLn asserted after 4 steps 
.................... //                                                             11: STALLn asserted after 8 steps 
.................... // SDTHR (Sets stall detect threshold)       (R/W) (bit 7-0)   0x00h: 0 
.................... //                                                             0xFFh: 255 
.................... */ 
.................... enum emf_vol_div        {divide_by_32 = 0, divide_by_16 = 1, divide_by_8 = 2, divide_by_4 = 3}; 
.................... enum emf_samp_mode      {after_1_step = 0, after_2_steps = 1, after_4_steps = 2, after_8_steps = 3}; 
.................... enum reg_stall_mask     {stall_thr_addr = 0, emf_samp_mode_addr = 8, emf_vol_div_addr = 10}; 
.................... enum reg_stall_size     {stall_thr_size = 8, emf_samp_mode_size = 2, emf_vol_div_size = 2};   
.................... // Sets STALL register 
.................... void set_stall_reg(emf_vol_div divider, emf_samp_mode smode, unsigned int8 stall_thr) 
.................... { 
....................    if(drv_debug) 
*
047B:  BTFSS  34.0
047C:  GOTO   484
....................       fprintf(RS232,"STALL Register\t: "); 
047D:  MOVLW  D6
047E:  MOVLB  03
047F:  MOVWF  11
0480:  MOVLW  00
0481:  MOVWF  12
0482:  MOVLB  00
0483:  CALL   15A
....................        
....................    // clear the register 
....................    reg_stall = 0b0000000000000000; 
0484:  CLRF   2F
0485:  CLRF   2E
....................    // set write operation 
....................    reg_stall = set_register_bits(reg_stall, op_type_addr, op_type_size, op_write);  
0486:  MOVF   2F,W
0487:  MOVWF  46
0488:  MOVF   2E,W
0489:  MOVWF  45
048A:  MOVLW  0F
048B:  MOVWF  47
048C:  MOVLW  01
048D:  MOVWF  48
048E:  CLRF   4A
048F:  CLRF   49
0490:  CALL   1A5
0491:  MOVF   79,W
0492:  MOVWF  2F
0493:  MOVF   78,W
0494:  MOVWF  2E
....................    // set register address 
....................    reg_stall = set_register_bits(reg_stall, reg_type_addr, reg_type_size, type_stall); 
0495:  MOVF   2F,W
0496:  MOVWF  46
0497:  MOVF   2E,W
0498:  MOVWF  45
0499:  MOVLW  0C
049A:  MOVWF  47
049B:  MOVLW  03
049C:  MOVWF  48
049D:  CLRF   4A
049E:  MOVLW  05
049F:  MOVWF  49
04A0:  CALL   1A5
04A1:  MOVF   79,W
04A2:  MOVWF  2F
04A3:  MOVF   78,W
04A4:  MOVWF  2E
....................    // set back EMF voltage divider 
....................    reg_stall = set_register_bits(reg_stall, emf_vol_div_addr, emf_vol_div_size, divider); 
04A5:  MOVF   2F,W
04A6:  MOVWF  46
04A7:  MOVF   2E,W
04A8:  MOVWF  45
04A9:  MOVLW  0A
04AA:  MOVWF  47
04AB:  MOVLW  02
04AC:  MOVWF  48
04AD:  CLRF   4A
04AE:  MOVF   37,W
04AF:  MOVWF  49
04B0:  CALL   1A5
04B1:  MOVF   79,W
04B2:  MOVWF  2F
04B3:  MOVF   78,W
04B4:  MOVWF  2E
....................    // set back EMF sample step mode 
....................    reg_stall = set_register_bits(reg_stall, emf_samp_mode_addr, emf_samp_mode_size, smode); 
04B5:  MOVF   2F,W
04B6:  MOVWF  46
04B7:  MOVF   2E,W
04B8:  MOVWF  45
04B9:  MOVLW  08
04BA:  MOVWF  47
04BB:  MOVLW  02
04BC:  MOVWF  48
04BD:  CLRF   4A
04BE:  MOVF   38,W
04BF:  MOVWF  49
04C0:  CALL   1A5
04C1:  MOVF   79,W
04C2:  MOVWF  2F
04C3:  MOVF   78,W
04C4:  MOVWF  2E
....................    // set stall detect threshold 
....................    reg_stall = set_register_bits(reg_stall, stall_thr_addr, stall_thr_size, stall_thr); 
04C5:  MOVF   2F,W
04C6:  MOVWF  46
04C7:  MOVF   2E,W
04C8:  MOVWF  45
04C9:  CLRF   47
04CA:  MOVLW  08
04CB:  MOVWF  48
04CC:  CLRF   4A
04CD:  MOVF   39,W
04CE:  MOVWF  49
04CF:  CALL   1A5
04D0:  MOVF   79,W
04D1:  MOVWF  2F
04D2:  MOVF   78,W
04D3:  MOVWF  2E
....................     
....................    // write register to SPI 
....................    write_register(reg_stall); 
04D4:  MOVF   2F,W
04D5:  MOVWF  46
04D6:  MOVF   2E,W
04D7:  MOVWF  45
04D8:  CALL   208
.................... } 
.................... // Sets back EMF voltage divider 
.................... void set_emf_vol_div(emf_vol_div divider) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STALL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_stall = set_register_bits(reg_stall, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_stall = set_register_bits(reg_stall, reg_type_addr, reg_type_size, type_stall); 
....................    // set back EMF voltage divider 
....................    reg_stall = set_register_bits(reg_stall, emf_vol_div_addr, emf_vol_div_size, divider); 
....................    // write register to SPI 
....................    write_register(reg_stall); 
.................... } 
.................... // Sets back EMF sample step mode 
.................... void set_emf_samp_mode(emf_samp_mode smode) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STALL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_stall = set_register_bits(reg_stall, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_stall = set_register_bits(reg_stall, reg_type_addr, reg_type_size, type_stall); 
....................    // set back EMF sample step mode 
....................    reg_stall = set_register_bits(reg_stall, emf_samp_mode_addr, emf_samp_mode_size, smode); 
....................    // write register to SPI 
....................    write_register(reg_stall); 
.................... } 
.................... // Sets stall detect threshold 
.................... void set_stall_thr(unsigned int8 stall_thr) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STALL Register\t: "); 
....................        
....................    // set write operation 
....................    reg_stall = set_register_bits(reg_stall, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_stall = set_register_bits(reg_stall, reg_type_addr, reg_type_size, type_stall); 
....................    // set stall detect threshold 
....................    reg_stall = set_register_bits(reg_stall, stall_thr_addr, stall_thr_size, stall_thr); 
....................    // write register to SPI 
....................    write_register(reg_stall); 
.................... } 
.................... /* 
.................... // DRIVE register bits 
.................... // data operation type                       (R/W) (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                          (R/W) (bit 14-12) 110: STALL reg 
.................... // IDRIVEP (High-side gate peak current)     (R/W) (bit 11-10) 00: 50 mA peak (source) 
.................... //                                                             01: 100 mA peak (source) 
.................... //                                                             10: 150 mA peak (source) 
.................... //                                                             11: 200 mA peak (source) 
.................... // IDRIVEN (Low-side gate peak current)      (R/W) (bit 9-8)   00: 100 mA peak (sink) 
.................... //                                                             01: 200 mA peak (sink) 
.................... //                                                             10: 300 mA peak (sink) 
.................... //                                                             11: 400 mA peak (sink) 
.................... // TDRIVEP (High-side gate drive time)       (R/W) (bit 7-6)   00: 250 ns 
.................... //                                                             01: 500 ns 
.................... //                                                             10: 1 us 
.................... //                                                             11: 2 us 
.................... // TDRIVEN (Low-side gate drive time)        (R/W) (bit 5-4)   00: 250 ns 
.................... //                                                             01: 500 ns 
.................... //                                                             10: 1 us 
.................... //                                                             11: 2 us 
.................... // OCPDEG (OCP deglitch time)                (R/W) (bit 3-2)   00: 1 us 
.................... //                                                             01: 2 us 
.................... //                                                             10: 4 us 
.................... //                                                             11: 8 us 
.................... // OCPTH (OCP threshold)                     (R/W) (bit 1-0)   00: 250 mV 
.................... //                                                             01: 500 mV 
.................... //                                                             10: 750 mV 
.................... //                                                             11: 1000 mV 
.................... */ 
.................... enum hs_peak_cur        {hs_50mA = 0, hs_100mA = 1, hs_150mA = 2, hs_200mA = 3}; 
.................... enum ls_peak_cur        {ls_100mA = 0, ls_200mA = 1, ls_300mA = 2, ls_400mA = 3}; 
.................... enum hs_drive_time      {hs_250ns = 0, hs_500ns = 1, hs_1us = 2, hs_2us = 3}; 
.................... enum ls_drive_time      {ls_250ns = 0, ls_500ns = 1, ls_1us = 2, ls_2us = 3}; 
.................... enum ocp_deg_time       {ocp_1us = 0, ocp_2us = 1, ocp_4us = 2, ocp_8us = 3}; 
.................... enum ocp_thr            {ocp_250mV = 0, ocp_500mV = 1, ocp_750mV = 2, ocp_1000mV = 3}; 
.................... enum reg_drive_mask     {ocp_thr_addr = 0, ocp_deg_time_addr = 2, ls_drive_time_addr = 4, hs_drive_time_addr = 6, ls_peak_cur_addr = 8, hs_peak_cur_addr = 10}; 
.................... enum reg_drive_size     {ocp_thr_size = 2, ocp_deg_time_size = 2, ls_drive_time_size = 2, hs_drive_time_size = 2, ls_peak_cur_size = 2, hs_peak_cur_size = 2};  
.................... // Sets DRIVE register 
.................... void set_drive_reg(hs_peak_cur idrivep, ls_peak_cur idriven, hs_drive_time tdrivep, ls_drive_time tdriven, ocp_deg_time ocpdeg, ocp_thr ocpth) 
.................... { 
....................    if(drv_debug) 
*
04E0:  BTFSS  34.0
04E1:  GOTO   4E9
....................       fprintf(RS232,"DRIVE Register\t: "); 
04E2:  MOVLW  FA
04E3:  MOVLB  03
04E4:  MOVWF  11
04E5:  MOVLW  00
04E6:  MOVWF  12
04E7:  MOVLB  00
04E8:  CALL   15A
....................        
....................    // clear the register 
....................    reg_drive = 0b0000000000000000; 
04E9:  CLRF   31
04EA:  CLRF   30
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
04EB:  MOVF   31,W
04EC:  MOVWF  46
04ED:  MOVF   30,W
04EE:  MOVWF  45
04EF:  MOVLW  0F
04F0:  MOVWF  47
04F1:  MOVLW  01
04F2:  MOVWF  48
04F3:  CLRF   4A
04F4:  CLRF   49
04F5:  CALL   1A5
04F6:  MOVF   79,W
04F7:  MOVWF  31
04F8:  MOVF   78,W
04F9:  MOVWF  30
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
04FA:  MOVF   31,W
04FB:  MOVWF  46
04FC:  MOVF   30,W
04FD:  MOVWF  45
04FE:  MOVLW  0C
04FF:  MOVWF  47
0500:  MOVLW  03
0501:  MOVWF  48
0502:  CLRF   4A
0503:  MOVLW  06
0504:  MOVWF  49
0505:  CALL   1A5
0506:  MOVF   79,W
0507:  MOVWF  31
0508:  MOVF   78,W
0509:  MOVWF  30
....................    // set high-side gate peak current 
....................    reg_drive = set_register_bits(reg_drive, hs_peak_cur_addr, hs_peak_cur_size, idrivep); 
050A:  MOVF   31,W
050B:  MOVWF  46
050C:  MOVF   30,W
050D:  MOVWF  45
050E:  MOVLW  0A
050F:  MOVWF  47
0510:  MOVLW  02
0511:  MOVWF  48
0512:  CLRF   4A
0513:  MOVF   37,W
0514:  MOVWF  49
0515:  CALL   1A5
0516:  MOVF   79,W
0517:  MOVWF  31
0518:  MOVF   78,W
0519:  MOVWF  30
....................    // set low-side gate peak current 
....................    reg_drive = set_register_bits(reg_drive, ls_peak_cur_addr, ls_peak_cur_size, idriven); 
051A:  MOVF   31,W
051B:  MOVWF  46
051C:  MOVF   30,W
051D:  MOVWF  45
051E:  MOVLW  08
051F:  MOVWF  47
0520:  MOVLW  02
0521:  MOVWF  48
0522:  CLRF   4A
0523:  MOVF   38,W
0524:  MOVWF  49
0525:  CALL   1A5
0526:  MOVF   79,W
0527:  MOVWF  31
0528:  MOVF   78,W
0529:  MOVWF  30
....................    // set high-side gate drive time 
....................    reg_drive = set_register_bits(reg_drive, hs_drive_time_addr, hs_drive_time_size, tdrivep); 
052A:  MOVF   31,W
052B:  MOVWF  46
052C:  MOVF   30,W
052D:  MOVWF  45
052E:  MOVLW  06
052F:  MOVWF  47
0530:  MOVLW  02
0531:  MOVWF  48
0532:  CLRF   4A
0533:  MOVF   39,W
0534:  MOVWF  49
0535:  CALL   1A5
0536:  MOVF   79,W
0537:  MOVWF  31
0538:  MOVF   78,W
0539:  MOVWF  30
....................    // set low-side gate drive time 
....................    reg_drive = set_register_bits(reg_drive, ls_drive_time_addr, ls_drive_time_size, tdriven); 
053A:  MOVF   31,W
053B:  MOVWF  46
053C:  MOVF   30,W
053D:  MOVWF  45
053E:  MOVLW  04
053F:  MOVWF  47
0540:  MOVLW  02
0541:  MOVWF  48
0542:  CLRF   4A
0543:  MOVF   3A,W
0544:  MOVWF  49
0545:  CALL   1A5
0546:  MOVF   79,W
0547:  MOVWF  31
0548:  MOVF   78,W
0549:  MOVWF  30
....................    // set OCP deglitch time 
....................    reg_drive = set_register_bits(reg_drive, ocp_deg_time_addr, ocp_deg_time_size, ocpdeg); 
054A:  MOVF   31,W
054B:  MOVWF  46
054C:  MOVF   30,W
054D:  MOVWF  45
054E:  MOVLW  02
054F:  MOVWF  47
0550:  MOVWF  48
0551:  CLRF   4A
0552:  MOVF   3B,W
0553:  MOVWF  49
0554:  CALL   1A5
0555:  MOVF   79,W
0556:  MOVWF  31
0557:  MOVF   78,W
0558:  MOVWF  30
....................    // set OCP threshold 
....................    reg_drive = set_register_bits(reg_drive, ocp_thr_addr, ocp_thr_size, ocpth); 
0559:  MOVF   31,W
055A:  MOVWF  46
055B:  MOVF   30,W
055C:  MOVWF  45
055D:  CLRF   47
055E:  MOVLW  02
055F:  MOVWF  48
0560:  CLRF   4A
0561:  MOVF   3C,W
0562:  MOVWF  49
0563:  CALL   1A5
0564:  MOVF   79,W
0565:  MOVWF  31
0566:  MOVF   78,W
0567:  MOVWF  30
....................  
....................    // write register to SPI 
....................    write_register(reg_drive); 
0568:  MOVF   31,W
0569:  MOVWF  46
056A:  MOVF   30,W
056B:  MOVWF  45
056C:  CALL   208
.................... } 
.................... /* 
.................... // Sets high-side gate peak current 
.................... void set_hs_peak_cur(hs_peak_cur idrivep) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set high-side gate peak current 
....................    reg_drive = set_register_bits(reg_drive, hs_peak_cur_addr, hs_peak_cur_size, idrivep); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets low-side gate peak current 
.................... void set_ls_peak_cur(ls_peak_cur idriven) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set low-side gate peak current 
....................    reg_drive = set_register_bits(reg_drive, ls_peak_cur_addr, ls_peak_cur_size, idriven); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets high-side gate drive time 
.................... void set_hs_drive_time(hs_drive_time tdrivep) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set high-side gate drive time 
....................    reg_drive = set_register_bits(reg_drive, hs_drive_time_addr, hs_drive_time_size, tdrivep); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets low-side gate drive time 
.................... void set_ls_drive_time(ls_drive_time tdriven) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set low-side gate drive time 
....................    reg_drive = set_register_bits(reg_drive, ls_drive_time_addr, ls_drive_time_size, tdriven); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets OCP deglitch time 
.................... void set_ocp_deg_time(ocp_deg_time ocpdeg) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set OCP deglitch time 
....................    reg_drive = set_register_bits(reg_drive, ocp_deg_time_addr, ocp_deg_time_size, ocpdeg); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... // Sets OCP threshold 
.................... void set_ocp_thr(ocp_thr ocpth) 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"DRIVE Register\t: "); 
....................        
....................    // set write operation 
....................    reg_drive = set_register_bits(reg_drive, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_drive = set_register_bits(reg_drive, reg_type_addr, reg_type_size, type_drive); 
....................    // set OCP threshold 
....................    reg_drive = set_register_bits(reg_drive, ocp_thr_addr, ocp_thr_size, ocpth); 
....................    // write register to SPI 
....................    write_register(reg_drive); 
.................... } 
.................... */ 
.................... /* 
.................... // STATUS register bits 
.................... // data operation type                             (bit 15)    0: write,  
.................... //                                                             1: read 
.................... // register address                                (bit 14-12) 111: STATUS reg 
.................... // Reserved                                        (bit 11-8) 
.................... // STDLAT (Stall clear flag)                 (R/W) (bit 7)     0: Normal operation 
.................... //                                                             1: Latched stall detect 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // STD (Stall detected flag)                 (R)   (bit 6)     0: Normal operation 
.................... //                                                             1: Stall detected 
.................... // UVLO (Undervoltage lockout flag)          (R)   (bit 5)     0: Normal operation 
.................... //                                                             1: Undervoltage lockout 
.................... //                                                             (UVLO bit will clear after VM has increased over VUVLO) 
.................... // BPDF (Channel B predriver fault flag)     (R/W) (bit 4)     0: Normal operation 
.................... //                                                             1: Channel B predriver fault 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // APDF (Channel A predriver fault flag)     (R/W) (bit 3)     0: Normal operation 
.................... //                                                             1: Channel A predriver fault 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // BOCP (Channel B overcurrent flag)         (R/W) (bit 2)     0: Normal operation 
.................... //                                                             1: Channel B overcurrent shutdown 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // AOCP (Channel A overcurrent flag)         (R/W) (bit 1)     0: Normal operation 
.................... //                                                             1: Channel A overcurrent shutdown 
.................... //                                                             (Write a '0' to this bit to clear the fault and resume operation) 
.................... // OTS (Overtemperature shutdown flag)       (R)   (bit 0)     0: Normal operation 
.................... //                                                             1: Device has entered overtemperature shutdown 
.................... //                                                             (OTS bit will clear once temperature has fallen to safe levels 
.................... ) 
.................... */ 
.................... enum reg_status_mask    {a_over_curr_flag_addr = 1, b_over_curr_flag_addr = 2, a_fault_flag_addr = 3, b_fault_flag_addr = 4, stall_flag_addr = 7}; 
.................... enum reg_status_size    {a_over_curr_flag_size = 1, b_over_curr_flag_size = 1, a_fault_flag_size = 1, b_fault_flag_size = 1, stall_flag_size = 1};  
.................... // Clears STATUS register 
.................... void clear_status_reg() 
.................... { 
....................    if(drv_debug) 
056D:  BTFSS  34.0
056E:  GOTO   576
....................       fprintf(RS232,"STATUS Register\t: "); 
056F:  MOVLW  03
0570:  MOVLB  03
0571:  MOVWF  11
0572:  MOVLW  01
0573:  MOVWF  12
0574:  MOVLB  00
0575:  CALL   15A
....................        
....................    // clear the register 
....................    reg_status = 0b0000000000000000; 
0576:  CLRF   33
0577:  CLRF   32
....................       // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
0578:  MOVF   33,W
0579:  MOVWF  46
057A:  MOVF   32,W
057B:  MOVWF  45
057C:  MOVLW  0F
057D:  MOVWF  47
057E:  MOVLW  01
057F:  MOVWF  48
0580:  CLRF   4A
0581:  CLRF   49
0582:  CALL   1A5
0583:  MOVF   79,W
0584:  MOVWF  33
0585:  MOVF   78,W
0586:  MOVWF  32
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
0587:  MOVF   33,W
0588:  MOVWF  46
0589:  MOVF   32,W
058A:  MOVWF  45
058B:  MOVLW  0C
058C:  MOVWF  47
058D:  MOVLW  03
058E:  MOVWF  48
058F:  CLRF   4A
0590:  MOVLW  07
0591:  MOVWF  49
0592:  CALL   1A5
0593:  MOVF   79,W
0594:  MOVWF  33
0595:  MOVF   78,W
0596:  MOVWF  32
....................     
....................    // write register to SPI 
....................    write_register(reg_status); 
0597:  MOVF   33,W
0598:  MOVWF  46
0599:  MOVF   32,W
059A:  MOVWF  45
059B:  CALL   208
.................... } 
.................... /* 
.................... // Clears STATUS register 
.................... void clear_stall_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear stall flag 
....................    reg_status = set_register_bits(reg_status, stall_flag_addr, stall_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... // Clears STATUS register 
.................... void clear_b_fault_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear channel b predriver fault flag 
....................    reg_status = set_register_bits(reg_status, b_fault_flag_addr, b_fault_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... // Clears STATUS register 
.................... void clear_a_fault_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear channel a predriver fault flag 
....................    reg_status = set_register_bits(reg_status, a_fault_flag_addr, a_fault_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... // Clears STATUS register 
.................... void clear_b_over_curr_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear channel b overcurrent fault flag 
....................    reg_status = set_register_bits(reg_status, b_over_curr_flag_addr, b_over_curr_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... // Clears STATUS register 
.................... void clear_a_over_curr_flag() 
.................... { 
....................    if(drv_debug) 
....................       fprintf(RS232,"STATUS Register\t: "); 
....................        
....................    // set write operation 
....................    reg_status = set_register_bits(reg_status, op_type_addr, op_type_size, op_write);  
....................    // set register address 
....................    reg_status = set_register_bits(reg_status, reg_type_addr, reg_type_size, type_status); 
....................    // clear channel a overcurrent fault flag 
....................    reg_status = set_register_bits(reg_status, a_over_curr_flag_addr, a_over_curr_flag_size, 0); 
....................    // write register to SPI 
....................    write_register(reg_status); 
.................... } 
.................... */ 
.................... // Sets driver parameters 
.................... void set_driver() 
.................... { 
....................    // dead_time         :  dtime_400ns  
....................    //                      dtime_450ns  
....................    //                      dtime_650ns  
....................    //                      dtime_850ns 
....................    // curent_amp_gain   :  gain_5 
....................    //                      gain_10 
....................    //                      gain_20 
....................    //                      gain_40 
....................    // src_stall_detect  :  stall_int 
....................    //                      stall_ext 
....................    // microstepping     :  full_step 
....................    //                      half_step 
....................    //                      _4x 
....................    //                      _8x 
....................    //                      _16x 
....................    //                      _32x 
....................    //                      _64x 
....................    //                      _128x 
....................    //                      _256x 
....................    // single_step_out   :  no_action 
....................    //                      one_step 
....................    // dir_control       :  dir_pin 
....................    //                      inv_dir_pin 
....................    // motor_state       :  motor_disable 
....................    //                      motor_enable 
....................    set_ctrl_reg(dtime_400ns, gain_10, stall_int, _256x, no_action, dir_pin, motor_enable); 
*
028A:  CLRF   37
028B:  MOVLW  01
028C:  MOVWF  38
028D:  CLRF   39
028E:  MOVLW  08
028F:  MOVWF  3A
0290:  CLRF   3B
0291:  CLRF   3C
0292:  MOVLW  01
0293:  MOVWF  3D
....................    //set_dead_time(dtime_400ns); 
....................    //set_amp_gain(gain_5); 
....................    //set_stall_detection(stall_int); 
....................    //set_microstepping_mode(_64x); 
....................    //set_rstep(no_action); 
....................    //set_dir_mode(dir_pin); 
....................    //set_motor_state(motor_enable); 
....................     
....................    // emf_samp_thr      :  emf_50us 
....................    //                      emf_100us 
....................    //                      emf_200us 
....................    //                      emf_300us 
....................    //                      emf_400us 
....................    //                      emf_600us 
....................    //                      emf_800us 
....................    //                      emf_1000us 
....................    set_torque_reg(emf_100us, 65); 
*
0330:  MOVLW  01
0331:  MOVWF  37
0332:  MOVLW  41
0333:  MOVWF  38
....................    //set_emf_samp_thr(emf_50us); 
....................    //set_torque(200); 
....................     
....................    // pwm_mode          :  int_indexer 
....................    //                      ext_indexer 
....................    set_off_reg(int_indexer, 18); 
*
0382:  CLRF   37
0383:  MOVLW  12
0384:  MOVWF  38
....................    //set_pwm_mode(int_indexer); 
....................    //set_off_time(70); 
....................     
....................    // adap_blank_state  :  disable_abt 
....................    //                      enable_abt 
....................    set_blank_reg(enable_abt, 125); 
*
03D3:  MOVLW  01
03D4:  MOVWF  37
03D5:  MOVLW  7D
03D6:  MOVWF  38
....................    //set_adap_blank_state(enable_abt); 
....................    //set_blank_time(125); 
....................     
....................    //decay_mode         :  force_slow_decay 
....................    //                      slow_mixed_decay 
....................    //                      force_fast_decay 
....................    //                      mixed_decay 
....................    //                      slow_auto_mixed_decay 
....................    //                      auto_mixed_decay 
....................    set_decay_reg(auto_mixed_decay, 6); 
*
0424:  MOVLW  05
0425:  MOVWF  37
0426:  MOVLW  06
0427:  MOVWF  38
....................    //set_decay_mode(auto_mixed_decay); 
....................    //set_decay_time(41); 
....................     
....................    // emf_vol_div       :  divide_by_32 
....................    //                      divide_by_16 
....................    //                      divide_by_8 
....................    //                      divide_by_4 
....................    // emf_samp_mode     :  after_1_step 
....................    //                      after_2_steps 
....................    //                      after_4_steps 
....................    //                      after_8_steps 
....................    set_stall_reg(divide_by_8, after_1_step, 60); 
*
0476:  MOVLW  02
0477:  MOVWF  37
0478:  CLRF   38
0479:  MOVLW  3C
047A:  MOVWF  39
....................    //set_emf_vol_div(divide_by_8); 
....................    //set_emf_samp_mode(after_2_steps); 
....................    //set_stall_thr(20); 
....................     
....................    // hs_peak_cur       :  hs_50mA 
....................    //                      hs_100mA 
....................    //                      hs_150mA 
....................    //                      hs_200mA 
....................    // ls_peak_cur       :  ls_100mA 
....................    //                      ls_200mA 
....................    //                      ls_300mA 
....................    //                      ls_400mA 
....................    // hs_drive_time     :  hs_250ns 
....................    //                      hs_500ns 
....................    //                      hs_1us 
....................    //                      hs_2us 
....................    // ls_drive_time     :  ls_250ns 
....................    //                      ls_500ns 
....................    //                      ls_1us 
....................    //                      ls_2us 
....................    // ocp_deg_time      :  ocp_1us 
....................    //                      ocp_2us 
....................    //                      ocp_4us 
....................    //                      ocp_8us 
....................    // ocp_thr           :  ocp_250mV 
....................    //                      ocp_500mV 
....................    //                      ocp_750mV 
....................    //                      ocp_1000mV 
....................    set_drive_reg(hs_50mA, ls_100mA, hs_1us, ls_1us, ocp_1us, ocp_250mV); 
*
04D9:  CLRF   37
04DA:  CLRF   38
04DB:  MOVLW  02
04DC:  MOVWF  39
04DD:  MOVWF  3A
04DE:  CLRF   3B
04DF:  CLRF   3C
....................    //set_hs_peak_cur(hs_200mA); 
....................    //set_ls_peak_cur(ls_400mA); 
....................    //set_hs_drive_time(hs_1us); 
....................    //set_ls_drive_time(ls_1us); 
....................    //set_ocp_deg_time(ocp_1us); 
....................    //set_ocp_thr(ocp_250mV); 
....................     
....................    clear_status_reg(); 
....................    //clear_stall_flag(); 
....................    //clear_b_fault_flag(); 
....................    //clear_a_fault_flag(); 
....................    //clear_b_over_curr_flag(); 
....................    //clear_a_over_curr_flag(); 
....................     
....................    delay_ms(100); 
*
059C:  MOVLW  64
059D:  MOVWF  47
059E:  CALL   11F
059F:  MOVLP  00
05A0:  GOTO   7CB (RETURN)
.................... } 
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
*
05DB:  BTFSS  11.5
05DC:  GOTO   5DB
05DD:  MOVLB  03
05DE:  MOVF   19,W
05DF:  MOVLB  00
05E0:  MOVWF  37
05E1:  CLRF   38
.................... { 
....................    char command = fgetc(RS232); 
....................    unsigned int i=0; 
....................        
....................    switch (command) 
05E2:  MOVF   37,W
05E3:  XORLW  53
05E4:  BTFSC  03.2
05E5:  GOTO   5F0
05E6:  XORLW  17
05E7:  BTFSC  03.2
05E8:  GOTO   616
05E9:  XORLW  0B
05EA:  BTFSC  03.2
05EB:  GOTO   6B8
05EC:  XORLW  0D
05ED:  BTFSC  03.2
05EE:  GOTO   71C
05EF:  GOTO   77F
....................    { 
....................       case 'S':   unsigned int input_delay[3]; 
....................                   for(i=0; i<3; i++) 
05F0:  CLRF   38
05F1:  MOVF   38,W
05F2:  SUBLW  02
05F3:  BTFSS  03.0
05F4:  GOTO   605
....................                   { 
....................                      input_delay[i]=(unsigned)(fgetc(RS232)-48); 
05F5:  MOVLW  19
05F6:  ADDWF  38,W
05F7:  MOVWF  04
05F8:  MOVLW  20
05F9:  MOVWF  05
05FA:  BTFSC  03.0
05FB:  INCF   05,F
05FC:  BTFSS  11.5
05FD:  GOTO   5FC
05FE:  MOVLB  03
05FF:  MOVF   19,W
0600:  ADDLW  D0
0601:  MOVWF  00
0602:  MOVLB  00
0603:  INCF   38,F
0604:  GOTO   5F1
....................                   } 
....................                    
....................                   delay=100*input_delay[0]+10*input_delay[1]+1*input_delay[2]; 
0605:  MOVLW  64
0606:  MOVWF  45
0607:  MOVF   39,W
0608:  MOVWF  46
0609:  CALL   5A1
060A:  MOVF   78,W
060B:  MOVWF  44
060C:  MOVLW  0A
060D:  MOVWF  45
060E:  MOVF   3A,W
060F:  MOVWF  46
0610:  CALL   5A1
0611:  MOVF   78,W
0612:  ADDWF  44,W
0613:  ADDWF  3B,W
0614:  MOVWF  36
....................                   break; 
0615:  GOTO   77F
....................       case 'D':   drv_debug = !drv_debug; 
0616:  MOVLW  01
0617:  XORWF  34,F
....................                   fprintf(RS232, "Driver Debug: %u", drv_debug); 
0618:  MOVLW  00
0619:  BTFSC  34.0
061A:  MOVLW  01
061B:  MOVWF  44
061C:  MOVLW  0D
061D:  MOVLB  03
061E:  MOVWF  11
061F:  MOVLW  01
0620:  MOVWF  12
0621:  BCF    03.0
0622:  MOVLW  0E
0623:  MOVLB  00
0624:  MOVWF  45
*
0677:  MOVF   44,W
0678:  MOVWF  45
0679:  MOVLW  1B
067A:  MOVWF  46
....................                   break; 
*
06B6:  MOVLB  00
06B7:  GOTO   77F
....................       case 'O':   unsigned int input_off[3]; 
....................                   for(i=0; i<3; i++) 
06B8:  CLRF   38
06B9:  MOVF   38,W
06BA:  SUBLW  02
06BB:  BTFSS  03.0
06BC:  GOTO   6CD
....................                   { 
....................                      input_off[i]=(unsigned)(fgetc(RS232)-48); 
06BD:  MOVLW  1C
06BE:  ADDWF  38,W
06BF:  MOVWF  04
06C0:  MOVLW  20
06C1:  MOVWF  05
06C2:  BTFSC  03.0
06C3:  INCF   05,F
06C4:  BTFSS  11.5
06C5:  GOTO   6C4
06C6:  MOVLB  03
06C7:  MOVF   19,W
06C8:  ADDLW  D0
06C9:  MOVWF  00
06CA:  MOVLB  00
06CB:  INCF   38,F
06CC:  GOTO   6B9
....................                   } 
....................                    
....................                   unsigned int off = 100*input_off[0] + 10*input_off[1] + 1*input_off[2]; 
06CD:  MOVLW  64
06CE:  MOVWF  45
06CF:  MOVF   3C,W
06D0:  MOVWF  46
06D1:  CALL   5A1
06D2:  MOVF   78,W
06D3:  MOVWF  44
06D4:  MOVLW  0A
06D5:  MOVWF  45
06D6:  MOVF   3D,W
06D7:  MOVWF  46
06D8:  CALL   5A1
06D9:  MOVF   78,W
06DA:  ADDWF  44,W
06DB:  ADDWF  3E,W
06DC:  MOVWF  3F
....................                   set_off_time(off); 
06DD:  MOVF   3F,W
06DE:  MOVWF  44
....................                   break; 
*
071B:  GOTO   77F
....................       case 'B':   unsigned int input_blank[3]; 
....................                   for(i=0; i<3; i++) 
071C:  CLRF   38
071D:  MOVF   38,W
071E:  SUBLW  02
071F:  BTFSS  03.0
0720:  GOTO   731
....................                   { 
....................                      input_blank[i]=(unsigned)(fgetc(RS232)-48); 
0721:  MOVLW  20
0722:  ADDWF  38,W
0723:  MOVWF  04
0724:  MOVLW  20
0725:  MOVWF  05
0726:  BTFSC  03.0
0727:  INCF   05,F
0728:  BTFSS  11.5
0729:  GOTO   728
072A:  MOVLB  03
072B:  MOVF   19,W
072C:  ADDLW  D0
072D:  MOVWF  00
072E:  MOVLB  00
072F:  INCF   38,F
0730:  GOTO   71D
....................                   } 
....................                    
....................                   unsigned int blank = 100*input_blank[0] + 10*input_blank[1] + 1*input_blank[2]; 
0731:  MOVLW  64
0732:  MOVWF  45
0733:  MOVF   40,W
0734:  MOVWF  46
0735:  CALL   5A1
0736:  MOVF   78,W
0737:  MOVWF  44
0738:  MOVLW  0A
0739:  MOVWF  45
073A:  MOVF   41,W
073B:  MOVWF  46
073C:  CALL   5A1
073D:  MOVF   78,W
073E:  ADDWF  44,W
073F:  ADDWF  42,W
0740:  MOVWF  43
....................                   set_blank_time(blank); 
0741:  MOVF   43,W
0742:  MOVWF  44
....................                   break; 
*
077E:  GOTO   77F
....................       default :   return;  
....................    } 
077F:  MOVLP  00
0780:  GOTO   7D8 (RETURN)
.................... } 
....................  
.................... #INT_RDA 
.................... void isr_rs232_message() 
.................... { 
....................    clear_interrupt(INT_RDA); 
*
0116:  MOVF   07,W
....................    disable_interrupts(INT_RDA); 
0117:  MOVLB  01
0118:  BCF    11.5
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1; 
0119:  MOVLW  01
011A:  MOVLB  00
011B:  MOVWF  35
011C:  BCF    11.5
011D:  MOVLP  00
011E:  GOTO   016
.................... }  
....................  
.................... void main() 
*
0794:  MOVLW  F0
0795:  MOVLB  01
0796:  MOVWF  19
0797:  MOVLB  02
0798:  BSF    1E.0
0799:  BSF    1D.7
079A:  MOVLB  03
079B:  BCF    1F.3
079C:  MOVLW  0C
079D:  MOVWF  1B
079E:  MOVLW  A2
079F:  MOVWF  1E
07A0:  MOVLW  90
07A1:  MOVWF  1D
07A2:  MOVLB  00
07A3:  CLRF   25
07A4:  CLRF   24
07A5:  CLRF   27
07A6:  CLRF   26
07A7:  CLRF   29
07A8:  CLRF   28
07A9:  CLRF   2B
07AA:  CLRF   2A
07AB:  CLRF   2D
07AC:  CLRF   2C
07AD:  CLRF   2F
07AE:  CLRF   2E
07AF:  CLRF   31
07B0:  CLRF   30
07B1:  CLRF   33
07B2:  CLRF   32
07B3:  BSF    34.0
07B4:  CLRF   35
07B5:  MOVLW  14
07B6:  MOVWF  36
07B7:  MOVLB  03
07B8:  CLRF   0C
07B9:  CLRF   0D
07BA:  MOVLB  02
07BB:  CLRF   12
07BC:  CLRF   11
07BD:  CLRF   14
07BE:  CLRF   13
.................... { 
....................    delay_ms(10); 
07BF:  MOVLW  0A
07C0:  MOVLB  00
07C1:  MOVWF  47
07C2:  CALL   11F
....................     
....................    // Set I/O states of the ports 
....................    //           76543210                   
....................    set_tris_a(0b00101100);        
07C3:  MOVLW  2C
07C4:  TRIS   5
....................    set_tris_b(0b11001111); 
07C5:  MOVLW  CF
07C6:  TRIS   6
....................  
....................    // Set alternative pin functions 
....................    set_pins(); 
07C7:  GOTO   134
....................    // Set SPI parameters 
....................    set_SPI(); 
07C8:  GOTO   13A
....................    // Set variables to default values 
....................    set_variables(); 
07C9:  GOTO   147
....................    // Set driver 
....................    set_driver(); 
07CA:  GOTO   28A
....................  
....................    enable_interrupts(global); 
07CB:  MOVLW  C0
07CC:  IORWF  0B,F
....................    enable_interrupts(INT_RDA); 
07CD:  MOVLB  01
07CE:  BSF    11.5
....................     
....................    while(true) 
....................    {   
....................       if(reg_rs232_message) 
07CF:  MOVLB  00
07D0:  MOVF   35,F
07D1:  BTFSC  03.2
07D2:  GOTO   7DC
....................       {    
....................          disable_interrupts(INT_RDA); 
07D3:  MOVLB  01
07D4:  BCF    11.5
....................           
....................          reg_rs232_message=0; 
07D5:  MOVLB  00
07D6:  CLRF   35
....................          rs232_message(); 
07D7:  GOTO   5DB
....................           
....................          enable_interrupts(INT_RDA); 
07D8:  MOVLB  01
07D9:  BSF    11.5
....................       } 
07DA:  GOTO   7F1
07DB:  MOVLB  00
....................       else 
....................       { 
....................          output_high(DRV_STEP); 
07DC:  MOVLB  01
07DD:  BCF    0C.0
07DE:  MOVLB  02
07DF:  BSF    0C.0
....................          delay_us(10); 
07E0:  MOVLW  1A
07E1:  MOVWF  77
07E2:  DECFSZ 77,F
07E3:  GOTO   7E2
07E4:  NOP
....................          output_low(DRV_STEP); 
07E5:  MOVLB  01
07E6:  BCF    0C.0
07E7:  MOVLB  02
07E8:  BCF    0C.0
....................          delay_us(delay - 10); 
07E9:  MOVLW  0A
07EA:  MOVLB  00
07EB:  SUBWF  36,W
07EC:  MOVWF  37
07ED:  MOVF   37,W
07EE:  MOVWF  38
07EF:  GOTO   781
07F0:  MOVLB  01
....................       } 
07F1:  GOTO   7CF
....................    }  
.................... } 
07F2:  SLEEP

Configuration Fuses:
   Word  1: 0E04   INTRC_IO NOWDT PUT NOMCLR PROTECT CPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1AFC   WRT PLL_SW STVREN BORV25 NODEBUG NOLVP

CCS PCM C Compiler, Version 4.108, 15145               30-Nis-14 13:59

               Filename: E:\File Server\Modesis\Proje Dosyalarý\SMD - Adým Motor Sürücü\Software\Divizör Kod\Test Card Code (Pulse Generator) V1.1\Test Card Code (Pulse Generator) V1.1.lst

               ROM used: 206 words (10%)
                         Largest free fragment is 1842
               RAM used: 5 (1%) at main() level
                         19 (6%) worst case
               Stack:    1 locations

*
0000:  MOVLP  00
0001:  GOTO   03D
0002:  NOP
.................... #INCLUDE <16f1826.h>  
.................... //////// Standard Header file for the PIC16F1826 device //////////////// 
.................... #device PIC16F1826 
.................... #list 
....................  
....................  
.................... #FUSES INTRC_IO      // Internal RC clock (OSC1 and OSC2 pins are normal I/O) 
.................... #FUSES NOWDT         // Watch Dog Timer disabled 
.................... #FUSES PUT           // Power Up Timer enabled 
.................... #FUSES NOMCLR        // Master Clear pin is used for I/O 
.................... #FUSES PROTECT       // Code protected from reads 
.................... #FUSES CPD           // Data EEPROM code protected 
.................... #FUSES BROWNOUT      // Brownout Reset enabled 
.................... #FUSES BORV25        // Brownout Reset at 2.5V 
.................... #FUSES NOCLKOUT      // Disable clock output on OSC2 
.................... #FUSES NOIESO        // Internal External Switch Over Mode disabled 
.................... #FUSES NOFCMEN       // Fail-safe clock monitor disabled 
.................... #FUSES WRT           // Program memory write protected                                               
.................... #FUSES NOLVP         // Low Voltage Programming disabled 
.................... #FUSES NODEBUG       // No debug mode for ICD 
....................  
.................... #USE   DELAY(internal = 32MHz) 
*
0016:  MOVLW  20
0017:  MOVWF  05
0018:  MOVLW  04
0019:  MOVWF  04
001A:  MOVF   00,W
001B:  BTFSC  03.2
001C:  GOTO   02A
001D:  MOVLW  0A
001E:  MOVWF  78
001F:  CLRF   77
0020:  DECFSZ 77,F
0021:  GOTO   020
0022:  DECFSZ 78,F
0023:  GOTO   01F
0024:  MOVLW  5F
0025:  MOVWF  77
0026:  DECFSZ 77,F
0027:  GOTO   026
0028:  DECFSZ 00,F
0029:  GOTO   01D
002A:  RETURN
002B:  MOVLW  02
002C:  SUBWF  23,F
002D:  BTFSS  03.0
002E:  GOTO   03C
002F:  MOVLW  20
0030:  MOVWF  05
0031:  MOVLW  03
0032:  MOVWF  04
0033:  MOVF   00,W
0034:  BTFSC  03.2
0035:  GOTO   03C
0036:  GOTO   03A
0037:  GOTO   038
0038:  GOTO   039
0039:  NOP
003A:  DECFSZ 00,F
003B:  GOTO   037
003C:  RETURN
.................... //#USE   RS232(stream=RS232, baud=38400, XMIT=PIN_B5, RCV=PIN_B2, parity=N, bits=8, stop=1) 
....................  
.................... #DEFINE DRV_STEP     PIN_A0                  // Step output pin to driver (Rising edge causes the indexer to move one step) 
.................... #DEFINE DRV_RESET    PIN_A1                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.) 
.................... #DEFINE USER_FAULT   PIN_A2                  // Fault output pin to user 
.................... #DEFINE USER_DIR     PIN_A3                  // Direction input pin from user 
.................... #DEFINE DRV_DIR      PIN_A4                  // Direction output pin to driver (Logic level, sets the direction of stepping) 
....................  
.................... #DEFINE SPI_SDO      PIN_A6                  // SPI data output pin 
.................... #DEFINE SPI_CS       PIN_A7                  // SPI chip select pin 
....................  
.................... #DEFINE USER_STEP    PIN_B0                  // Step input pin from user 
.................... #DEFINE SPI_SDI      PIN_B1                  // SPI data input pin 
....................  
.................... #DEFINE USER_ENABLE  PIN_B3                  // Enable input pin from user 
.................... #DEFINE SPI_SCK      PIN_B4                  // SPI clock output pin 
....................  
.................... #DEFINE DRV_STALL    PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut) 
.................... #DEFINE DRV_FAULT    PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut) 
....................  
.................... // SPI Registers 
.................... #WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register 
.................... #WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register 
.................... #WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register 
.................... #WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register 
.................... // Pin function control registers 
.................... #WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0 
.................... #WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1 
....................  
.................... // Bits of SSP1CON1 register 
.................... #BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit 
.................... #BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit 
.................... #BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit 
.................... #BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits 
.................... #BIT SPI_MODE_2         = SPI_SSP1CON1.2    
.................... #BIT SPI_MODE_1         = SPI_SSP1CON1.1    
.................... #BIT SPI_MODE_0         = SPI_SSP1CON1.0   
....................  
.................... // Bits of SPI_SSP1STAT register 
.................... #BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit 
.................... #BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit 
.................... #BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit 
....................  
.................... // Bits of SPI_PIR1 register 
.................... #BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit 
....................  
.................... // Bits of PIN_APFCON0 register 
.................... #BIT PIN_RX_SELECT      = PIN_APFCON0.7      // RX pin selection bit 
.................... #BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit  
.................... #BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit  
....................  
.................... // Bits of PIN_APFCON1 register 
.................... #BIT PIN_TX_SELECT      = PIN_APFCON1.0      // TX pin selection bit 
....................  
.................... // Sets alternative pin functions 
.................... void set_pins() 
.................... { 
....................    // Set RB2 as RX pin 
....................    //PIN_RX_SELECT = 1; 
....................    // Set RA6 as SDO pin 
....................    PIN_SDO_SELECT = 1; 
*
0003:  MOVLB  02
0004:  BSF    1D.6
....................    // Set RA5 as SS pin 
....................    PIN_SS_SELECT = 1; 
0005:  BSF    1D.5
....................    // Set RB5 as TX pin 
....................    //PIN_TX_SELECT = 1; 
.................... } 
0006:  MOVLP  00
0007:  MOVLB  00
0008:  GOTO   053 (RETURN)
.................... // Sets SPI parameters 
.................... void set_SPI() 
.................... { 
....................    // Disable SPI to set registers 
....................    SPI_ENABLE = 0; 
0009:  MOVLB  04
000A:  BCF    15.5
....................    // Set idle state of the clock to low  
....................    SPI_CLOCK_POLARITY = 0; 
000B:  BCF    15.4
....................    // Set SPI mode to SPI  
....................    SPI_MODE_3 = 0;  
000C:  BCF    15.3
....................    SPI_MODE_2 = 0; 
000D:  BCF    15.2
....................    SPI_MODE_1 = 1; 
000E:  BSF    15.1
....................    SPI_MODE_0 = 0; 
000F:  BCF    15.0
....................    // Input data sampled at the middle of data output time 
....................    SPI_INPUT_SAMPLE = 0; 
0010:  BCF    14.7
....................    // Transmit occurs on transition from active to idle clock state 
....................    SPI_CLOCK_EDGE = 1; 
0011:  BSF    14.6
....................  
....................    // Enable SPI 
....................    SPI_ENABLE = 1; 
0012:  BSF    15.5
.................... } 
0013:  MOVLP  00
0014:  MOVLB  00
0015:  GOTO   054 (RETURN)
.................... // Sets variables to default values  
.................... void set_variables() 
.................... { 
....................    output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction 
....................    output_low(USER_FAULT); // Clear fault status  
....................    output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver  
....................    output_low(DRV_DIR);    // Set default direction 
....................    output_low(DRV_STEP);   // Keep step output low until a step command is received from the user 
.................... } 
.................... // Sets driver parameters to default values 
.................... void set_driver() 
.................... { 
....................    // Driver control register sets these parameters 
....................    // data operation type                       (bit 15)    1=read,  
....................    //                                                       0=write 
....................    // register adress                           (bit 14-12) 000=CTRL reg 
....................    // DTIME (dead time between MOSFET switching)(bit 11-10) 00=400ns,  
....................    //                                                       01=450ns,  
....................    //                                                       10=650ns,  
....................    //                                                       11=850ns 
....................    // ISGain (current amplifier gain)           (bit 9-8)   00=Gain of 5,  
....................    //                                                       01=Gain of 10,  
....................    //                                                       10=Gain of 20,  
....................    //                                                       11=Gain of 40 
....................    // EXSTALL (source of stall detection)       (bit 7)     0=Internal 
....................    //                                                       1=External 
....................    // MODE (microstepping mode)                 (bit 6-3)   0000=Full-step, 71% current 
....................    //                                                       0001=Half step 
....................    //                                                       0010=1/4 step 
....................    //                                                       0011=1/8 step 
....................    //                                                       0100=1/16 step 
....................    //                                                       0101=1/32 step 
....................    //                                                       0110=1/64 step 
....................    //                                                       0111=1/128 step 
....................    //                                                       1000=1/256 step 
....................    // RSTEP (single step output)                (bit 2)     0=No action 
....................    //                                                       1=Indexer will advance one step; automatically cleared after write 
....................    // direction                                 (bit 1)     0=Direction set by DIR pin 
....................    //                                                       1=Direction set by inverse of DIR pin 
....................    // enable                                    (bit 0)     0=Disable motor 
....................    //                                                       1=Enable motor 
....................    //   
....................    //                 76543210 
....................     
....................    output_high(SPI_CS); 
....................    int Ctrl_1     = 0b00000011; 
....................    int Ctrl_0     = 0b01000001; 
....................    SPI_SSP1BUF = Ctrl_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Ctrl_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
....................  
....................    output_high(SPI_CS); 
....................    int Torque_1   = 0b00010000; 
....................    int Torque_0   = 0b10000100; 
....................    SPI_SSP1BUF = Torque_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Torque_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
....................     
....................    output_high(SPI_CS); 
....................    int Off_1      = 0b00100000; 
....................    int Off_0      = 0b01111000; 
....................    SPI_SSP1BUF = Off_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Off_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
....................     
....................    output_high(SPI_CS); 
....................    int Blank_1    = 0b00110001; 
....................    int Blank_0    = 0b11111111; 
....................    SPI_SSP1BUF = Blank_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Blank_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
....................     
....................    output_high(SPI_CS); 
....................    int Decay_1    = 0b01000101; 
....................    int Decay_0    = 0b01001010; 
....................    SPI_SSP1BUF = Decay_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Decay_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
....................     
....................    output_high(SPI_CS); 
....................    int Stall_1    = 0b01011001; 
....................    int Stall_0    = 0b00010100; 
....................    SPI_SSP1BUF = Stall_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Stall_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
....................     
....................    output_high(SPI_CS); 
....................    int Drive_1    = 0b01101111; 
....................    int Drive_0    = 0b10100000; 
....................    SPI_SSP1BUF = Drive_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Drive_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
....................     
....................    output_high(SPI_CS); 
....................    int Status_1   = 0b01110000; 
....................    int Status_0   = 0b00000000; 
....................    SPI_SSP1BUF = Status_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Status_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
....................     
....................    delay_ms(100); 
....................     
....................    output_high(SPI_CS); 
....................    Ctrl_1     = 0b00000001; 
....................    Ctrl_0     = 0b01000001; 
....................    SPI_SSP1BUF = Ctrl_1; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    SPI_SSP1BUF = Ctrl_0; 
....................    while (!SPI_FLAG); 
....................    SPI_FLAG = 0; 
....................    output_low(SPI_CS); 
....................    delay_ms(10); 
.................... } 
....................  
.................... void motion_cycle() 
.................... { 
....................    while(true) 
....................    { 
....................       /* 
....................       output_high(DRV_STEP); 
....................       delay_us(120); 
....................       output_low(DRV_STEP); 
....................       delay_us(120); 
....................        
....................       if(USER_STEP) 
....................          output_high(DRV_STEP); 
....................       else 
....................          output_low(DRV_STEP); 
....................           
....................       if(USER_DIR) 
....................          output_high(DRV_DIR); 
....................       else 
....................          output_low(DRV_DIR); 
....................          */ 
....................    } 
.................... } 
....................  
.................... void main() 
.................... { 
*
003D:  CLRF   05
003E:  CLRF   04
003F:  MOVLW  1F
0040:  ANDWF  03,F
0041:  MOVLW  F4
0042:  MOVLB  01
0043:  MOVWF  19
0044:  MOVLB  03
0045:  CLRF   0C
0046:  CLRF   0D
0047:  MOVLB  02
0048:  CLRF   12
0049:  CLRF   11
004A:  CLRF   14
004B:  CLRF   13
....................    // Set I/O states of the ports 
....................    //           76543210                  
....................    set_tris_a(0b00100100);        
004C:  MOVLW  24
004D:  MOVLB  01
004E:  MOVWF  0C
....................    set_tris_b(0b11000110); 
004F:  MOVLW  C6
0050:  MOVWF  0D
....................     
....................    // Set alternative pin functions 
....................    set_pins(); 
0051:  MOVLB  00
0052:  GOTO   003
....................    // Set SPI parameters 
....................    set_SPI(); 
0053:  GOTO   009
....................     
....................    // Give user a hint of system start by turning on fault led 
....................    output_high(USER_FAULT); 
0054:  MOVLB  01
0055:  BCF    0C.2
0056:  MOVLB  02
0057:  BSF    0C.2
....................    delay_ms(500); 
0058:  MOVLW  02
0059:  MOVLB  00
005A:  MOVWF  23
005B:  MOVLW  FA
005C:  MOVWF  24
005D:  CALL   016
005E:  DECFSZ 23,F
005F:  GOTO   05B
....................     
....................    unsigned int16 i; 
....................     
....................    while(true) 
....................    { 
....................       output_low(USER_DIR); 
0060:  MOVLB  01
0061:  BCF    0C.3
0062:  MOVLB  02
0063:  BCF    0C.3
....................       output_low(USER_ENABLE); 
0064:  MOVLB  01
0065:  BCF    0D.3
0066:  MOVLB  02
0067:  BCF    0D.3
....................        
....................       delay_ms(1000); 
0068:  MOVLW  04
0069:  MOVLB  00
006A:  MOVWF  23
006B:  MOVLW  FA
006C:  MOVWF  24
006D:  CALL   016
006E:  DECFSZ 23,F
006F:  GOTO   06B
....................       for(i=0; i<51200; ++i) 
0070:  CLRF   22
0071:  CLRF   21
0072:  MOVF   22,W
0073:  SUBLW  C7
0074:  BTFSS  03.0
0075:  GOTO   08A
....................       { 
....................          output_high(USER_STEP);   //yüksek tork bölümü (low enable) 
0076:  MOVLB  01
0077:  BCF    0D.0
0078:  MOVLB  02
0079:  BSF    0D.0
....................          delay_us(100); 
007A:  MOVLW  64
007B:  MOVLB  00
007C:  MOVWF  23
007D:  CALL   02B
....................          output_low(USER_STEP); 
007E:  MOVLB  01
007F:  BCF    0D.0
0080:  MOVLB  02
0081:  BCF    0D.0
....................          delay_us(100); 
0082:  MOVLW  64
0083:  MOVLB  00
0084:  MOVWF  23
0085:  CALL   02B
....................       } 
0086:  INCF   21,F
0087:  BTFSC  03.2
0088:  INCF   22,F
0089:  GOTO   072
....................       output_high(USER_ENABLE); 
008A:  MOVLB  01
008B:  BCF    0D.3
008C:  MOVLB  02
008D:  BSF    0D.3
....................       delay_ms(1000); 
008E:  MOVLW  04
008F:  MOVLB  00
0090:  MOVWF  23
0091:  MOVLW  FA
0092:  MOVWF  24
0093:  CALL   016
0094:  DECFSZ 23,F
0095:  GOTO   091
....................        
....................       output_high(USER_DIR); 
0096:  MOVLB  01
0097:  BCF    0C.3
0098:  MOVLB  02
0099:  BSF    0C.3
....................       output_high(USER_ENABLE); 
009A:  MOVLB  01
009B:  BCF    0D.3
009C:  MOVLB  02
009D:  BSF    0D.3
....................       delay_ms(1000); 
009E:  MOVLW  04
009F:  MOVLB  00
00A0:  MOVWF  23
00A1:  MOVLW  FA
00A2:  MOVWF  24
00A3:  CALL   016
00A4:  DECFSZ 23,F
00A5:  GOTO   0A1
....................       for(i=0; i<51200; ++i) 
00A6:  CLRF   22
00A7:  CLRF   21
00A8:  MOVF   22,W
00A9:  SUBLW  C7
00AA:  BTFSS  03.0
00AB:  GOTO   0C0
....................       { 
....................          output_high(USER_STEP);    //düsük tork bölümü (high enable) 
00AC:  MOVLB  01
00AD:  BCF    0D.0
00AE:  MOVLB  02
00AF:  BSF    0D.0
....................          delay_us(100); 
00B0:  MOVLW  64
00B1:  MOVLB  00
00B2:  MOVWF  23
00B3:  CALL   02B
....................          output_low(USER_STEP); 
00B4:  MOVLB  01
00B5:  BCF    0D.0
00B6:  MOVLB  02
00B7:  BCF    0D.0
....................          delay_us(100); 
00B8:  MOVLW  64
00B9:  MOVLB  00
00BA:  MOVWF  23
00BB:  CALL   02B
....................       } 
00BC:  INCF   21,F
00BD:  BTFSC  03.2
00BE:  INCF   22,F
00BF:  GOTO   0A8
....................       output_high(USER_ENABLE); 
00C0:  MOVLB  01
00C1:  BCF    0D.3
00C2:  MOVLB  02
00C3:  BSF    0D.3
....................       delay_ms(1000); 
00C4:  MOVLW  04
00C5:  MOVLB  00
00C6:  MOVWF  23
00C7:  MOVLW  FA
00C8:  MOVWF  24
00C9:  CALL   016
00CA:  DECFSZ 23,F
00CB:  GOTO   0C7
....................    } 
00CC:  GOTO   060
.................... } 
00CD:  SLEEP

Configuration Fuses:
   Word  1: 0E04   NOWDT PUT PROTECT NOMCLR CPD BROWNOUT NOIESO NOFCMEN INTRC_IO NOCLKOUT
   Word  2: 1210   WRT NOVCAP PLL_SW STVREN BORV25 NODEBUG NOLVP

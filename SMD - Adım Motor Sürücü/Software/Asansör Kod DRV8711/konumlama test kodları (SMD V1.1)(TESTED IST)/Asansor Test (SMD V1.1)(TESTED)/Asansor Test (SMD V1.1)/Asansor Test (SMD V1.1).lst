CCS PCM C Compiler, Version 4.108, 15145               16-Nis-14 11:01

               Filename: E:\File Server\Modesis\Proje Dosyalarý\SMD - Adým Motor Sürücü\Software\Asansör Kod DRV8711\konumlama test kodlarý (SMD V1.1)\Asansor Test (SMD V1.1)\Asansor Test (SMD V1.1)\Asansor Test (SMD V1.1).lst

               ROM used: 785 words (38%)
                         Largest free fragment is 1263
               RAM used: 9 (3%) at main() level
                         36 (11%) worst case
               Stack:    3 locations

*
0000:  MOVLP  00
0001:  GOTO   2CD
0002:  NOP
.................... #INCLUDE <16f1826.h>  
.................... //////// Standard Header file for the PIC16F1826 device //////////////// 
.................... #device PIC16F1826 
.................... #list 
....................  
....................  
.................... #FUSES INTRC_IO      // Internal RC clock (OSC1 and OSC2 pins are normal I/O) 
.................... #FUSES NOWDT         // Watch Dog Timer disabled 
.................... #FUSES PUT           // Power Up Timer enabled 
.................... #FUSES NOMCLR        // Master Clear pin is used for I/O 
.................... #FUSES PROTECT       // Code protected from reads 
.................... #FUSES CPD           // Data EEPROM code protected 
.................... #FUSES BROWNOUT      // Brownout Reset enabled 
.................... #FUSES BORV25        // Brownout Reset at 2.5V 
.................... #FUSES NOCLKOUT      // Disable clock output on OSC2 
.................... #FUSES NOIESO        // Internal External Switch Over Mode disabled 
.................... #FUSES NOFCMEN       // Fail-safe clock monitor disabled 
.................... #FUSES WRT           // Program memory write protected                                               
.................... #FUSES NOLVP         // Low Voltage Programming disabled 
....................  
.................... #USE   DELAY(internal = 32MHz) 
*
0029:  MOVLW  20
002A:  MOVWF  05
002B:  MOVLW  14
002C:  MOVWF  04
002D:  MOVF   00,W
002E:  BTFSC  03.2
002F:  GOTO   03D
0030:  MOVLW  0A
0031:  MOVWF  78
0032:  CLRF   77
0033:  DECFSZ 77,F
0034:  GOTO   033
0035:  DECFSZ 78,F
0036:  GOTO   032
0037:  MOVLW  5F
0038:  MOVWF  77
0039:  DECFSZ 77,F
003A:  GOTO   039
003B:  DECFSZ 00,F
003C:  GOTO   030
003D:  RETURN
.................... //#USE   RS232(stream=RS232, baud=38400, XMIT=PIN_B5, RCV=PIN_B2, parity=N, bits=8, stop=1) 
....................  
.................... #DEFINE DRV_STEP     PIN_A0                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.) 
.................... #DEFINE DRV_RESET    PIN_A1                  // Sleep output pin to driver (Logic high to enable device) 
.................... #DEFINE LIMIT_SWITCH PIN_A2                  // Limit Switches input pin(normal 0V, while trigged 5V) 
.................... #DEFINE USER_DIR     PIN_A3                  // Direction input pin from user 
.................... #DEFINE DRV_DIR      PIN_A4                  // Direction output pin to driver (Logic level, sets the direction of stepping) 
....................  
.................... #DEFINE SPI_SDO      PIN_A6                  // SPI data output pin 
.................... #DEFINE SPI_CS       PIN_A7                  // Step output pin to driver (Rising edge causes the indexer to move one step) 
....................  
.................... #DEFINE USER_STEP    PIN_B0                  // Step input pin from user 
.................... #DEFINE SPI_SDI      PIN_B1                  // SPI data input pin 
....................  
.................... #DEFINE USER_ENABLE  PIN_B3                  // Enable input pin from user 
.................... #DEFINE SPI_SCK      PIN_B4                  // SPI clock output pin 
....................  
.................... #DEFINE DRV_STALL    PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut) 
.................... #DEFINE DRV_FAULT    PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut) 
....................  
....................  
....................  
.................... // Interrupt On Change Registers 
.................... #WORD IOC_INTCON     =0x00B 
.................... #WORD IOC_IOCBP      =0x394 
.................... #WORD IOC_IOCBN      =0x395 
.................... #WORD IOC_IOCBF      =0x396 
.................... #WORD ANSELB         =0x18d 
....................  
.................... //Bits of IOC_INTCON register 
.................... #BIT IOC_GIE           = IOC_INTCON.7        //General interrupt enable bit 
.................... #BIT IOC_PEIE          = IOC_INTCON.6        //Peripheral interrupt enable bit 
.................... #BIT IOC_IOCIE         = IOC_INTCON.3        //Interrupt on change enable bit 
....................  
.................... //Bits of IOC_IOCBP register 
.................... #BIT IOC_PINB3_RISING            = IOC_IOCBP.3        //Pin B3 interrupt on change enable bit(Rising Edge) 
....................  
.................... //Bits of IOC_IOCBN register 
.................... #BIT IOC_PINB3_FALLING           = IOC_IOCBN.3        //Pin B3 interrupt on change enable bit(Falling Edge) 
....................  
.................... //Bits of IOC_IOCBF register 
.................... #BIT IOC_PINB3_FLAG              = IOC_IOCBF.3        //Pin B3 interrupt on change interrupt flag bit(Both Rising and Falling Edges) 
.................... //Bits of ANSELB register 
....................  
.................... #BIT ANSELB_PINB3                = ANSELB.3           //Selection of Pin B3 as a Digial I/O (0) or an Analog input (1) selection bit 
....................  
.................... // SPI Registers 
.................... #WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register 
.................... #WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register 
.................... #WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register 
.................... #WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register 
.................... // Pin function control registers 
.................... #WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0 
.................... #WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1 
....................  
.................... // Bits of SSP1CON1 register 
.................... #BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit 
.................... #BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit 
.................... #BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit 
.................... #BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits 
.................... #BIT SPI_MODE_2         = SPI_SSP1CON1.2    
.................... #BIT SPI_MODE_1         = SPI_SSP1CON1.1    
.................... #BIT SPI_MODE_0         = SPI_SSP1CON1.0   
....................  
.................... // Bits of SPI_SSP1STAT register 
.................... #BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit 
.................... #BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit 
.................... #BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit 
....................  
.................... // Bits of SPI_PIR1 register 
.................... #BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit 
....................  
.................... // Bits of PIN_APFCON0 register 
.................... #BIT PIN_RX_SELECT      = PIN_APFCON0.7      // RX pin selection bit 
.................... #BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit  
.................... #BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit  
....................  
.................... // Bits of PIN_APFCON1 register 
.................... #BIT PIN_TX_SELECT      = PIN_APFCON1.0      // TX pin selection bit 
....................  
.................... int1  dir         = 0; 
.................... int1  step        = 0; 
.................... int1 limit_old    = 0; 
.................... int8 up_lim_add   = 0; 
.................... int8 down_lim_add = 1; 
....................  
.................... // Sets alternative pin functions 
.................... void set_pins() 
.................... { 
....................    // Set RB2 as RX pin 
....................    //PIN_RX_SELECT = 1; 
....................    // Set RA6 as SDO pin 
....................    PIN_SDO_SELECT = 1; 
*
0003:  MOVLB  02
0004:  BSF    1D.6
....................    // Set RA5 as SS pin 
....................    PIN_SS_SELECT = 1; 
0005:  BSF    1D.5
....................    // Set RB5 as TX pin 
....................    //PIN_TX_SELECT = 1; 
.................... } 
0006:  MOVLP  00
0007:  MOVLB  00
0008:  GOTO   2EB (RETURN)
.................... // Sets SPI parameters 
.................... void set_SPI() 
.................... { 
....................    // Disable SPI to set registers 
....................    SPI_ENABLE = 0; 
0009:  MOVLB  04
000A:  BCF    15.5
....................    // Set idle state of the clock to low  
....................    SPI_CLOCK_POLARITY = 0; 
000B:  BCF    15.4
....................    // Set SPI mode to SPI  
....................    SPI_MODE_3 = 0;  
000C:  BCF    15.3
....................    SPI_MODE_2 = 0; 
000D:  BCF    15.2
....................    SPI_MODE_1 = 1; 
000E:  BSF    15.1
....................    SPI_MODE_0 = 0; 
000F:  BCF    15.0
....................    // Input data sampled at the middle of data output time 
....................    SPI_INPUT_SAMPLE = 0; 
0010:  BCF    14.7
....................    // Transmit occurs on transition from active to idle clock state 
....................    SPI_CLOCK_EDGE = 1; 
0011:  BSF    14.6
....................  
....................    // Enable SPI 
....................    SPI_ENABLE = 1; 
0012:  BSF    15.5
.................... } 
0013:  MOVLP  00
0014:  MOVLB  00
0015:  GOTO   2EC (RETURN)
.................... // Sets variables to default values  
.................... void set_variables() 
.................... { 
....................    output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction 
0016:  MOVLB  01
0017:  BCF    0C.7
0018:  MOVLB  02
0019:  BCF    0C.7
....................    output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver  
001A:  MOVLB  01
001B:  BCF    0C.1
001C:  MOVLB  02
001D:  BCF    0C.1
....................    output_low(DRV_DIR);    // Set default direction 
001E:  MOVLB  01
001F:  BCF    0C.4
0020:  MOVLB  02
0021:  BCF    0C.4
....................    output_low(DRV_STEP);   // Keep step output low until a step command is received from the user 
0022:  MOVLB  01
0023:  BCF    0C.0
0024:  MOVLB  02
0025:  BCF    0C.0
.................... } 
0026:  MOVLP  00
0027:  MOVLB  00
0028:  GOTO   2ED (RETURN)
.................... // Sets driver parameters to default values 
.................... void set_driver() 
.................... { 
....................    // Driver control register sets these parameters 
....................    // data operation type                       (bit 15)    1=read,  
....................    //                                                       0=write 
....................    // register adress                           (bit 14-12) 000=CTRL reg 
....................    // DTIME (dead time between MOSFET switching)(bit 11-10) 00=400ns,  
....................    //                                                       01=450ns,  
....................    //                                                       10=650ns,  
....................    //                                                       11=850ns 
....................    // ISGain (current amplifier gain)           (bit 9-8)   00=Gain of 5,  
....................    //                                                       01=Gain of 10,  
....................    //                                                       10=Gain of 20,  
....................    //                                                       11=Gain of 40 
....................    // EXSTALL (source of stall detection)       (bit 7)     0=Internal 
....................    //                                                       1=External 
....................    // MODE (microstepping mode)                 (bit 6-3)   0000=Full-step, 71% current 
....................    //                                                       0001=Half step 
....................    //                                                       0010=1/4 step 
....................    //                                                       0011=1/8 step 
....................    //                                                       0100=1/16 step 
....................    //                                                       0101=1/32 step 
....................    //                                                       0110=1/64 step 
....................    //                                                       0111=1/128 step 
....................    //                                                       1000=1/256 step 
....................    // RSTEP (single step output)                (bit 2)     0=No action 
....................    //                                                       1=Indexer will advance one step; automatically cleared after write 
....................    // direction                                 (bit 1)     0=Direction set by DIR pin 
....................    //                                                       1=Direction set by inverse of DIR pin 
....................    // enable                                    (bit 0)     0=Disable motor 
....................    //                                                       1=Enable motor 
....................    //   
....................    //                 76543210 
....................     
....................    output_high(SPI_CS); 
*
003E:  MOVLB  01
003F:  BCF    0C.7
0040:  MOVLB  02
0041:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Ctrl_1     = 0b00001100; 
....................                     //76543210 
....................    int Ctrl_0     = 0b00011001; 
0042:  MOVLW  0C
0043:  MOVLB  00
0044:  MOVWF  24
0045:  MOVLW  19
0046:  MOVWF  25
....................    SPI_SSP1BUF = Ctrl_1; 
0047:  MOVLB  04
0048:  CLRF   12
0049:  MOVLB  00
004A:  MOVF   24,W
004B:  MOVLB  04
004C:  MOVWF  11
....................    while (!SPI_FLAG); 
004D:  MOVLB  00
004E:  BTFSS  11.3
004F:  GOTO   04E
....................    SPI_FLAG = 0; 
0050:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0051:  MOVLB  04
0052:  CLRF   12
0053:  MOVLB  00
0054:  MOVF   25,W
0055:  MOVLB  04
0056:  MOVWF  11
....................    while (!SPI_FLAG); 
0057:  MOVLB  00
0058:  BTFSS  11.3
0059:  GOTO   058
....................    SPI_FLAG = 0; 
005A:  BCF    11.3
....................    output_low(SPI_CS); 
005B:  MOVLB  01
005C:  BCF    0C.7
005D:  MOVLB  02
005E:  BCF    0C.7
....................    delay_ms(10); 
005F:  MOVLW  0A
0060:  MOVLB  00
0061:  MOVWF  34
0062:  CALL   029
....................  
....................    output_high(SPI_CS); 
0063:  MOVLB  01
0064:  BCF    0C.7
0065:  MOVLB  02
0066:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Torque_1   = 0b00010000; 
....................                     //76543210 
....................    int Torque_0   = 0b10110111; 
0067:  MOVLW  10
0068:  MOVLB  00
0069:  MOVWF  26
006A:  MOVLW  B7
006B:  MOVWF  27
....................    SPI_SSP1BUF = Torque_1; 
006C:  MOVLB  04
006D:  CLRF   12
006E:  MOVLB  00
006F:  MOVF   26,W
0070:  MOVLB  04
0071:  MOVWF  11
....................    while (!SPI_FLAG); 
0072:  MOVLB  00
0073:  BTFSS  11.3
0074:  GOTO   073
....................    SPI_FLAG = 0; 
0075:  BCF    11.3
....................    SPI_SSP1BUF = Torque_0; 
0076:  MOVLB  04
0077:  CLRF   12
0078:  MOVLB  00
0079:  MOVF   27,W
007A:  MOVLB  04
007B:  MOVWF  11
....................    while (!SPI_FLAG); 
007C:  MOVLB  00
007D:  BTFSS  11.3
007E:  GOTO   07D
....................    SPI_FLAG = 0; 
007F:  BCF    11.3
....................    output_low(SPI_CS); 
0080:  MOVLB  01
0081:  BCF    0C.7
0082:  MOVLB  02
0083:  BCF    0C.7
....................    delay_ms(10); 
0084:  MOVLW  0A
0085:  MOVLB  00
0086:  MOVWF  34
0087:  CALL   029
....................     
....................    output_high(SPI_CS); 
0088:  MOVLB  01
0089:  BCF    0C.7
008A:  MOVLB  02
008B:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Off_1      = 0b00100000; 
....................                     //76543210 
....................    int Off_0      = 0b01111001; 
008C:  MOVLW  20
008D:  MOVLB  00
008E:  MOVWF  28
008F:  MOVLW  79
0090:  MOVWF  29
....................    SPI_SSP1BUF = Off_1; 
0091:  MOVLB  04
0092:  CLRF   12
0093:  MOVLB  00
0094:  MOVF   28,W
0095:  MOVLB  04
0096:  MOVWF  11
....................    while (!SPI_FLAG); 
0097:  MOVLB  00
0098:  BTFSS  11.3
0099:  GOTO   098
....................    SPI_FLAG = 0; 
009A:  BCF    11.3
....................    SPI_SSP1BUF = Off_0; 
009B:  MOVLB  04
009C:  CLRF   12
009D:  MOVLB  00
009E:  MOVF   29,W
009F:  MOVLB  04
00A0:  MOVWF  11
....................    while (!SPI_FLAG); 
00A1:  MOVLB  00
00A2:  BTFSS  11.3
00A3:  GOTO   0A2
....................    SPI_FLAG = 0; 
00A4:  BCF    11.3
....................    output_low(SPI_CS); 
00A5:  MOVLB  01
00A6:  BCF    0C.7
00A7:  MOVLB  02
00A8:  BCF    0C.7
....................    delay_ms(10); 
00A9:  MOVLW  0A
00AA:  MOVLB  00
00AB:  MOVWF  34
00AC:  CALL   029
....................     
....................    output_high(SPI_CS); 
00AD:  MOVLB  01
00AE:  BCF    0C.7
00AF:  MOVLB  02
00B0:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Blank_1    = 0b00110001; 
....................                     //76543210 
....................    int Blank_0    = 0b10010110; 
00B1:  MOVLW  31
00B2:  MOVLB  00
00B3:  MOVWF  2A
00B4:  MOVLW  96
00B5:  MOVWF  2B
....................    SPI_SSP1BUF = Blank_1; 
00B6:  MOVLB  04
00B7:  CLRF   12
00B8:  MOVLB  00
00B9:  MOVF   2A,W
00BA:  MOVLB  04
00BB:  MOVWF  11
....................    while (!SPI_FLAG); 
00BC:  MOVLB  00
00BD:  BTFSS  11.3
00BE:  GOTO   0BD
....................    SPI_FLAG = 0; 
00BF:  BCF    11.3
....................    SPI_SSP1BUF = Blank_0; 
00C0:  MOVLB  04
00C1:  CLRF   12
00C2:  MOVLB  00
00C3:  MOVF   2B,W
00C4:  MOVLB  04
00C5:  MOVWF  11
....................    while (!SPI_FLAG); 
00C6:  MOVLB  00
00C7:  BTFSS  11.3
00C8:  GOTO   0C7
....................    SPI_FLAG = 0; 
00C9:  BCF    11.3
....................    output_low(SPI_CS); 
00CA:  MOVLB  01
00CB:  BCF    0C.7
00CC:  MOVLB  02
00CD:  BCF    0C.7
....................    delay_ms(10); 
00CE:  MOVLW  0A
00CF:  MOVLB  00
00D0:  MOVWF  34
00D1:  CALL   029
....................     
....................    output_high(SPI_CS); 
00D2:  MOVLB  01
00D3:  BCF    0C.7
00D4:  MOVLB  02
00D5:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Decay_1    = 0b01000101; 
....................                     //76543210 
....................    int Decay_0    = 0b00011100; 
00D6:  MOVLW  45
00D7:  MOVLB  00
00D8:  MOVWF  2C
00D9:  MOVLW  1C
00DA:  MOVWF  2D
....................    SPI_SSP1BUF = Decay_1; 
00DB:  MOVLB  04
00DC:  CLRF   12
00DD:  MOVLB  00
00DE:  MOVF   2C,W
00DF:  MOVLB  04
00E0:  MOVWF  11
....................    while (!SPI_FLAG); 
00E1:  MOVLB  00
00E2:  BTFSS  11.3
00E3:  GOTO   0E2
....................    SPI_FLAG = 0; 
00E4:  BCF    11.3
....................    SPI_SSP1BUF = Decay_0; 
00E5:  MOVLB  04
00E6:  CLRF   12
00E7:  MOVLB  00
00E8:  MOVF   2D,W
00E9:  MOVLB  04
00EA:  MOVWF  11
....................    while (!SPI_FLAG); 
00EB:  MOVLB  00
00EC:  BTFSS  11.3
00ED:  GOTO   0EC
....................    SPI_FLAG = 0; 
00EE:  BCF    11.3
....................    output_low(SPI_CS); 
00EF:  MOVLB  01
00F0:  BCF    0C.7
00F1:  MOVLB  02
00F2:  BCF    0C.7
....................    delay_ms(10); 
00F3:  MOVLW  0A
00F4:  MOVLB  00
00F5:  MOVWF  34
00F6:  CALL   029
....................     
....................    output_high(SPI_CS); 
00F7:  MOVLB  01
00F8:  BCF    0C.7
00F9:  MOVLB  02
00FA:  BSF    0C.7
....................    int Stall_1    = 0b01011001; 
....................    int Stall_0    = 0b00010100; 
00FB:  MOVLW  59
00FC:  MOVLB  00
00FD:  MOVWF  2E
00FE:  MOVLW  14
00FF:  MOVWF  2F
....................    SPI_SSP1BUF = Stall_1; 
0100:  MOVLB  04
0101:  CLRF   12
0102:  MOVLB  00
0103:  MOVF   2E,W
0104:  MOVLB  04
0105:  MOVWF  11
....................    while (!SPI_FLAG); 
0106:  MOVLB  00
0107:  BTFSS  11.3
0108:  GOTO   107
....................    SPI_FLAG = 0; 
0109:  BCF    11.3
....................    SPI_SSP1BUF = Stall_0; 
010A:  MOVLB  04
010B:  CLRF   12
010C:  MOVLB  00
010D:  MOVF   2F,W
010E:  MOVLB  04
010F:  MOVWF  11
....................    while (!SPI_FLAG); 
0110:  MOVLB  00
0111:  BTFSS  11.3
0112:  GOTO   111
....................    SPI_FLAG = 0; 
0113:  BCF    11.3
....................    output_low(SPI_CS); 
0114:  MOVLB  01
0115:  BCF    0C.7
0116:  MOVLB  02
0117:  BCF    0C.7
....................    delay_ms(10); 
0118:  MOVLW  0A
0119:  MOVLB  00
011A:  MOVWF  34
011B:  CALL   029
....................     
....................    output_high(SPI_CS); 
011C:  MOVLB  01
011D:  BCF    0C.7
011E:  MOVLB  02
011F:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Drive_1    = 0b01101010; 
....................                     //76543210 
....................    int Drive_0    = 0b10100000; 
0120:  MOVLW  6A
0121:  MOVLB  00
0122:  MOVWF  30
0123:  MOVLW  A0
0124:  MOVWF  31
....................    SPI_SSP1BUF = Drive_1; 
0125:  MOVLB  04
0126:  CLRF   12
0127:  MOVLB  00
0128:  MOVF   30,W
0129:  MOVLB  04
012A:  MOVWF  11
....................    while (!SPI_FLAG); 
012B:  MOVLB  00
012C:  BTFSS  11.3
012D:  GOTO   12C
....................    SPI_FLAG = 0; 
012E:  BCF    11.3
....................    SPI_SSP1BUF = Drive_0; 
012F:  MOVLB  04
0130:  CLRF   12
0131:  MOVLB  00
0132:  MOVF   31,W
0133:  MOVLB  04
0134:  MOVWF  11
....................    while (!SPI_FLAG); 
0135:  MOVLB  00
0136:  BTFSS  11.3
0137:  GOTO   136
....................    SPI_FLAG = 0; 
0138:  BCF    11.3
....................    output_low(SPI_CS); 
0139:  MOVLB  01
013A:  BCF    0C.7
013B:  MOVLB  02
013C:  BCF    0C.7
....................    delay_ms(10); 
013D:  MOVLW  0A
013E:  MOVLB  00
013F:  MOVWF  34
0140:  CALL   029
....................     
....................    output_high(SPI_CS); 
0141:  MOVLB  01
0142:  BCF    0C.7
0143:  MOVLB  02
0144:  BSF    0C.7
....................    int Status_1   = 0b01110000; 
....................    int Status_0   = 0b00000000; 
0145:  MOVLW  70
0146:  MOVLB  00
0147:  MOVWF  32
0148:  CLRF   33
....................    SPI_SSP1BUF = Status_1; 
0149:  MOVLB  04
014A:  CLRF   12
014B:  MOVLB  00
014C:  MOVF   32,W
014D:  MOVLB  04
014E:  MOVWF  11
....................    while (!SPI_FLAG); 
014F:  MOVLB  00
0150:  BTFSS  11.3
0151:  GOTO   150
....................    SPI_FLAG = 0; 
0152:  BCF    11.3
....................    SPI_SSP1BUF = Status_0; 
0153:  MOVLB  04
0154:  CLRF   12
0155:  MOVLB  00
0156:  MOVF   33,W
0157:  MOVLB  04
0158:  MOVWF  11
....................    while (!SPI_FLAG); 
0159:  MOVLB  00
015A:  BTFSS  11.3
015B:  GOTO   15A
....................    SPI_FLAG = 0; 
015C:  BCF    11.3
....................    output_low(SPI_CS); 
015D:  MOVLB  01
015E:  BCF    0C.7
015F:  MOVLB  02
0160:  BCF    0C.7
....................    delay_ms(10); 
0161:  MOVLW  0A
0162:  MOVLB  00
0163:  MOVWF  34
0164:  CALL   029
....................  
.................... } 
0165:  MOVLP  00
0166:  GOTO   2EE (RETURN)
....................  
.................... void check_limit_state() 
.................... { 
*
01AA:  MOVLB  01
01AB:  BSF    0C.2
01AC:  MOVLB  00
01AD:  BCF    24.0
01AE:  BTFSC  0C.2
01AF:  BSF    24.0
....................    int1 limit_new = input(LIMIT_SWITCH); 
....................     
....................    if(limit_old == 0 && limit_new == 1) 
01B0:  BTFSC  20.2
01B1:  GOTO   211
01B2:  BTFSS  24.0
01B3:  GOTO   211
....................    { 
....................       if(input(USER_DIR) == true) 
01B4:  MOVLB  01
01B5:  BSF    0C.3
01B6:  MOVLB  00
01B7:  BTFSS  0C.3
01B8:  GOTO   1E2
....................       { 
....................          write_eeprom(up_lim_add, 1); 
01B9:  MOVF   21,W
01BA:  MOVLB  03
01BB:  MOVWF  11
01BC:  MOVLW  01
01BD:  MOVWF  13
01BE:  BCF    15.7
01BF:  BSF    15.2
01C0:  MOVF   0B,W
01C1:  MOVWF  77
01C2:  BCF    0B.7
01C3:  MOVLW  55
01C4:  MOVWF  16
01C5:  MOVLW  AA
01C6:  MOVWF  16
01C7:  BSF    15.1
01C8:  BTFSC  15.1
01C9:  GOTO   1C8
01CA:  BCF    15.2
01CB:  MOVF   77,W
01CC:  IORWF  0B,F
....................          write_eeprom(down_lim_add, 0); 
01CD:  MOVLB  00
01CE:  MOVF   22,W
01CF:  MOVLB  03
01D0:  MOVWF  11
01D1:  CLRF   13
01D2:  BCF    15.7
01D3:  BSF    15.2
01D4:  MOVF   0B,W
01D5:  MOVWF  77
01D6:  BCF    0B.7
01D7:  MOVLW  55
01D8:  MOVWF  16
01D9:  MOVLW  AA
01DA:  MOVWF  16
01DB:  BSF    15.1
01DC:  BTFSC  15.1
01DD:  GOTO   1DC
01DE:  BCF    15.2
01DF:  MOVF   77,W
01E0:  IORWF  0B,F
01E1:  MOVLB  00
....................       } 
....................       if(input(USER_DIR) == false) 
01E2:  MOVLB  01
01E3:  BSF    0C.3
01E4:  MOVLB  00
01E5:  BTFSC  0C.3
01E6:  GOTO   210
....................       { 
....................          write_eeprom(up_lim_add, 0); 
01E7:  MOVF   21,W
01E8:  MOVLB  03
01E9:  MOVWF  11
01EA:  CLRF   13
01EB:  BCF    15.7
01EC:  BSF    15.2
01ED:  MOVF   0B,W
01EE:  MOVWF  77
01EF:  BCF    0B.7
01F0:  MOVLW  55
01F1:  MOVWF  16
01F2:  MOVLW  AA
01F3:  MOVWF  16
01F4:  BSF    15.1
01F5:  BTFSC  15.1
01F6:  GOTO   1F5
01F7:  BCF    15.2
01F8:  MOVF   77,W
01F9:  IORWF  0B,F
....................          write_eeprom(down_lim_add, 1); 
01FA:  MOVLB  00
01FB:  MOVF   22,W
01FC:  MOVLB  03
01FD:  MOVWF  11
01FE:  MOVLW  01
01FF:  MOVWF  13
0200:  BCF    15.7
0201:  BSF    15.2
0202:  MOVF   0B,W
0203:  MOVWF  77
0204:  BCF    0B.7
0205:  MOVLW  55
0206:  MOVWF  16
0207:  MOVLW  AA
0208:  MOVWF  16
0209:  BSF    15.1
020A:  BTFSC  15.1
020B:  GOTO   20A
020C:  BCF    15.2
020D:  MOVF   77,W
020E:  IORWF  0B,F
020F:  MOVLB  00
....................       } 
....................    } 
....................    else if(limit_old == 1 && limit_new == 0) 
0210:  GOTO   23D
0211:  BTFSS  20.2
0212:  GOTO   23D
0213:  BTFSC  24.0
0214:  GOTO   23D
....................    { 
....................       write_eeprom(up_lim_add, 0); 
0215:  MOVF   21,W
0216:  MOVLB  03
0217:  MOVWF  11
0218:  CLRF   13
0219:  BCF    15.7
021A:  BSF    15.2
021B:  MOVF   0B,W
021C:  MOVWF  77
021D:  BCF    0B.7
021E:  MOVLW  55
021F:  MOVWF  16
0220:  MOVLW  AA
0221:  MOVWF  16
0222:  BSF    15.1
0223:  BTFSC  15.1
0224:  GOTO   223
0225:  BCF    15.2
0226:  MOVF   77,W
0227:  IORWF  0B,F
....................       write_eeprom(down_lim_add, 0); 
0228:  MOVLB  00
0229:  MOVF   22,W
022A:  MOVLB  03
022B:  MOVWF  11
022C:  CLRF   13
022D:  BCF    15.7
022E:  BSF    15.2
022F:  MOVF   0B,W
0230:  MOVWF  77
0231:  BCF    0B.7
0232:  MOVLW  55
0233:  MOVWF  16
0234:  MOVLW  AA
0235:  MOVWF  16
0236:  BSF    15.1
0237:  BTFSC  15.1
0238:  GOTO   237
0239:  BCF    15.2
023A:  MOVF   77,W
023B:  IORWF  0B,F
023C:  MOVLB  00
....................    } 
....................     
....................    limit_old = limit_new; 
023D:  BCF    20.2
023E:  BTFSC  24.0
023F:  BSF    20.2
.................... } 
.................... void set_enable(int1 state) 
.................... { 
*
0167:  MOVLW  0C
0168:  MOVWF  25
....................    int Ctrl_1 = 0b00001100; 
....................    int Ctrl_0; 
....................     
....................    if(state == true) 
0169:  DECFSZ 24,W
016A:  GOTO   16E
....................       Ctrl_0     = 0b00011001; 
016B:  MOVLW  19
016C:  MOVWF  26
....................    else 
016D:  GOTO   170
....................       Ctrl_0     = 0b00011000; 
016E:  MOVLW  18
016F:  MOVWF  26
....................     
....................    output_high(SPI_CS); 
0170:  MOVLB  01
0171:  BCF    0C.7
0172:  MOVLB  02
0173:  BSF    0C.7
....................    SPI_SSP1BUF = Ctrl_1; 
0174:  MOVLB  04
0175:  CLRF   12
0176:  MOVLB  00
0177:  MOVF   25,W
0178:  MOVLB  04
0179:  MOVWF  11
....................    while (!SPI_FLAG); 
017A:  MOVLB  00
017B:  BTFSS  11.3
017C:  GOTO   17B
....................    SPI_FLAG = 0; 
017D:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
017E:  MOVLB  04
017F:  CLRF   12
0180:  MOVLB  00
0181:  MOVF   26,W
0182:  MOVLB  04
0183:  MOVWF  11
....................    while (!SPI_FLAG); 
0184:  MOVLB  00
0185:  BTFSS  11.3
0186:  GOTO   185
....................    SPI_FLAG = 0; 
0187:  BCF    11.3
....................    output_low(SPI_CS); 
0188:  MOVLB  01
0189:  BCF    0C.7
018A:  MOVLB  02
018B:  BCF    0C.7
....................    delay_ms(10); 
018C:  MOVLW  0A
018D:  MOVLB  00
018E:  MOVWF  34
018F:  CALL   029
.................... } 
0190:  RETURN
.................... void set_direction() 
.................... { 
....................    if(dir != input(USER_DIR)) 
*
0240:  MOVLW  00
0241:  BTFSC  20.0
0242:  MOVLW  01
0243:  MOVWF  24
0244:  MOVLB  01
0245:  BSF    0C.3
0246:  MOVLW  00
0247:  MOVLB  00
0248:  BTFSC  0C.3
0249:  MOVLW  01
024A:  SUBWF  24,W
024B:  BTFSC  03.2
024C:  GOTO   25F
....................    { 
....................       output_bit(DRV_DIR, input(USER_DIR)); 
024D:  MOVLB  01
024E:  BSF    0C.3
024F:  MOVLB  00
0250:  BTFSC  0C.3
0251:  GOTO   256
0252:  MOVLB  02
0253:  BCF    0C.4
0254:  GOTO   258
0255:  MOVLB  00
0256:  MOVLB  02
0257:  BSF    0C.4
0258:  MOVLB  01
0259:  BCF    0C.4
....................       dir = input(USER_DIR); 
025A:  BSF    0C.3
025B:  MOVLB  00
025C:  BCF    20.0
025D:  BTFSC  0C.3
025E:  BSF    20.0
....................    } 
.................... } 
.................... void motion_cycle() 
.................... { 
....................    step  = input(USER_STEP); 
*
0191:  MOVLB  01
0192:  BSF    0D.0
0193:  MOVLB  00
0194:  BCF    20.1
0195:  BTFSC  0D.0
0196:  BSF    20.1
....................    dir   = input(USER_DIR); 
0197:  MOVLB  01
0198:  BSF    0C.3
0199:  MOVLB  00
019A:  BCF    20.0
019B:  BTFSC  0C.3
019C:  BSF    20.0
....................    while(true) 
....................    {  
....................       if(input(USER_ENABLE) == true) 
019D:  MOVLB  01
019E:  BSF    0D.3
019F:  MOVLB  00
01A0:  BTFSS  0D.3
01A1:  GOTO   2BE
....................       { 
....................          set_enable(true); 
01A2:  MOVLW  01
01A3:  MOVWF  24
01A4:  CALL   167
....................           
....................          while(input(USER_ENABLE)) 
....................          { 
01A5:  MOVLB  01
01A6:  BSF    0D.3
01A7:  MOVLB  00
01A8:  BTFSS  0D.3
01A9:  GOTO   2BD
....................             check_limit_state(); 
....................             set_direction (); 
....................              
....................             if(read_eeprom(up_lim_add) == 0 && dir == 1) 
*
025F:  MOVF   21,W
0260:  MOVLB  03
0261:  MOVWF  11
0262:  BCF    15.7
0263:  BSF    15.0
0264:  MOVF   13,W
0265:  BTFSS  03.2
0266:  GOTO   28D
0267:  MOVLB  00
0268:  BTFSC  20.0
0269:  GOTO   26C
026A:  MOVLB  03
026B:  GOTO   28D
....................             { 
....................                if(step != input(USER_STEP)) 
026C:  MOVLW  00
026D:  BTFSC  20.1
026E:  MOVLW  01
026F:  MOVWF  24
0270:  MOVLB  01
0271:  BSF    0D.0
0272:  MOVLW  00
0273:  MOVLB  00
0274:  BTFSC  0D.0
0275:  MOVLW  01
0276:  SUBWF  24,W
0277:  BTFSC  03.2
0278:  GOTO   28B
....................                { 
....................                   output_bit(DRV_STEP, input(USER_STEP)); 
0279:  MOVLB  01
027A:  BSF    0D.0
027B:  MOVLB  00
027C:  BTFSC  0D.0
027D:  GOTO   282
027E:  MOVLB  02
027F:  BCF    0C.0
0280:  GOTO   284
0281:  MOVLB  00
0282:  MOVLB  02
0283:  BSF    0C.0
0284:  MOVLB  01
0285:  BCF    0C.0
....................                   step = input(USER_STEP); 
0286:  BSF    0D.0
0287:  MOVLB  00
0288:  BCF    20.1
0289:  BTFSC  0D.0
028A:  BSF    20.1
....................                } 
....................             } 
....................             else if(read_eeprom (down_lim_add) == 0 && dir == 0) 
028B:  GOTO   2BA
028C:  MOVLB  03
028D:  MOVLB  00
028E:  MOVF   22,W
028F:  MOVLB  03
0290:  MOVWF  11
0291:  BCF    15.7
0292:  BSF    15.0
0293:  MOVF   13,W
0294:  BTFSS  03.2
0295:  GOTO   2BB
0296:  MOVLB  00
0297:  BTFSS  20.0
0298:  GOTO   29B
0299:  MOVLB  03
029A:  GOTO   2BB
....................             { 
....................                if(step != input(USER_STEP)) 
029B:  MOVLW  00
029C:  BTFSC  20.1
029D:  MOVLW  01
029E:  MOVWF  24
029F:  MOVLB  01
02A0:  BSF    0D.0
02A1:  MOVLW  00
02A2:  MOVLB  00
02A3:  BTFSC  0D.0
02A4:  MOVLW  01
02A5:  SUBWF  24,W
02A6:  BTFSC  03.2
02A7:  GOTO   2BA
....................                { 
....................                   output_bit(DRV_STEP, input(USER_STEP)); 
02A8:  MOVLB  01
02A9:  BSF    0D.0
02AA:  MOVLB  00
02AB:  BTFSC  0D.0
02AC:  GOTO   2B1
02AD:  MOVLB  02
02AE:  BCF    0C.0
02AF:  GOTO   2B3
02B0:  MOVLB  00
02B1:  MOVLB  02
02B2:  BSF    0C.0
02B3:  MOVLB  01
02B4:  BCF    0C.0
....................                   step = input(USER_STEP); 
02B5:  BSF    0D.0
02B6:  MOVLB  00
02B7:  BCF    20.1
02B8:  BTFSC  0D.0
02B9:  BSF    20.1
02BA:  MOVLB  03
....................                } 
....................              
....................             } 
....................          } 
02BB:  MOVLB  00
02BC:  GOTO   1A5
....................       } 
....................       else if (!input(USER_ENABLE) || input(LIMIT_SWITCH) ) 
02BD:  GOTO   2CA
02BE:  MOVLB  01
02BF:  BSF    0D.3
02C0:  MOVLB  00
02C1:  BTFSS  0D.3
02C2:  GOTO   2C8
02C3:  MOVLB  01
02C4:  BSF    0C.2
02C5:  MOVLB  00
02C6:  BTFSS  0C.2
02C7:  GOTO   2CA
....................       { 
....................          set_enable(false); 
02C8:  CLRF   24
02C9:  CALL   167
....................       } 
....................    } 
02CA:  GOTO   19D
.................... } 
02CB:  MOVLP  00
02CC:  GOTO   310 (RETURN)
....................  
.................... void main() 
.................... { 
02CD:  CLRF   05
02CE:  CLRF   04
02CF:  MOVLW  1F
02D0:  ANDWF  03,F
02D1:  MOVLW  F4
02D2:  MOVLB  01
02D3:  MOVWF  19
02D4:  MOVF   1A,W
02D5:  MOVLB  00
02D6:  BCF    20.0
02D7:  BCF    20.1
02D8:  BCF    20.2
02D9:  CLRF   21
02DA:  MOVLW  01
02DB:  MOVWF  22
02DC:  MOVLB  03
02DD:  CLRF   0C
02DE:  CLRF   0D
02DF:  MOVLB  02
02E0:  CLRF   12
02E1:  CLRF   11
02E2:  CLRF   14
02E3:  CLRF   13
.................... // Set I/O states of the ports 
....................    //           76543210                  
....................    set_tris_a(0b00101100);        
02E4:  MOVLW  2C
02E5:  MOVLB  01
02E6:  MOVWF  0C
....................    set_tris_b(0b11001111); 
02E7:  MOVLW  CF
02E8:  MOVWF  0D
....................  
....................    // Set alternative pin functions 
....................    set_pins(); 
02E9:  MOVLB  00
02EA:  GOTO   003
....................    // Set SPI parameters 
....................    set_SPI(); 
02EB:  GOTO   009
....................    //set_IOC(); 
....................     
....................    // Give user a hint of system start by turning on fault led 
....................     
....................    // Set variables to default values 
....................    set_variables(); 
02EC:  GOTO   016
....................    // Set driver variables to default values 
....................    set_driver(); 
02ED:  GOTO   03E
....................     
....................    int1 up_limit = read_eeprom (up_lim_add); 
....................    int1 down_limit = read_eeprom (down_lim_add); 
02EE:  MOVF   21,W
02EF:  MOVLB  03
02F0:  MOVWF  11
02F1:  BCF    15.7
02F2:  BSF    15.0
02F3:  MOVF   13,W
02F4:  MOVWF  78
02F5:  BTFSC  78.0
02F6:  GOTO   2FA
02F7:  MOVLB  00
02F8:  BCF    23.0
02F9:  MOVLB  03
02FA:  BTFSS  78.0
02FB:  GOTO   2FF
02FC:  MOVLB  00
02FD:  BSF    23.0
02FE:  MOVLB  03
02FF:  MOVLB  00
0300:  MOVF   22,W
0301:  MOVLB  03
0302:  MOVWF  11
0303:  BCF    15.7
0304:  BSF    15.0
0305:  MOVF   13,W
0306:  MOVWF  78
0307:  MOVLB  00
0308:  BCF    23.1
0309:  BTFSC  78.0
030A:  BSF    23.1
....................    if(up_limit == 1 || down_limit == 1) 
030B:  BTFSC  23.0
030C:  GOTO   30E
030D:  BTFSC  23.1
....................       limit_old = 1; 
030E:  BSF    20.2
....................        
....................    motion_cycle(); 
030F:  GOTO   191
.................... } 
0310:  SLEEP

Configuration Fuses:
   Word  1: 0E04   NOWDT PUT PROTECT NOMCLR CPD BROWNOUT NOIESO NOFCMEN INTRC_IO NOCLKOUT
   Word  2: 1210   WRT NOVCAP PLL_SW STVREN BORV25 NODEBUG NOLVP

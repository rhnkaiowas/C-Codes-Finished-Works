CCS PCM C Compiler, Version 5.008, 5967               26-Eyl-14 10:30

               Filename:   E:\File Server\Modesis\Proje Dosyalarý\SMD - Adým Motor Sürücü\Software\Asansör Kod DRV8711\SMD V1.1\SMD V1.1.lst

               ROM used:   1008 words (49%)
                           Largest free fragment is 1040
               RAM used:   6 (2%) at main() level
                           38 (11%) worst case
               Stack used: 3 locations
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   3D0
0002:  NOP
.................... #INCLUDE <16f1826.h>  
.................... //////// Standard Header file for the PIC16F1826 device //////////////// 
.................... #device PIC16F1826 
0003:  BRW
0004:  RETLW  91
0005:  RETLW  09
0006:  RETLW  F7
0007:  RETLW  03
0008:  RETLW  0B
0009:  RETLW  03
000A:  RETLW  90
000B:  RETLW  02
000C:  RETLW  42
000D:  RETLW  02
000E:  RETLW  0B
000F:  RETLW  02
0010:  RETLW  E1
0011:  RETLW  01
0012:  RETLW  BF
0013:  RETLW  01
0014:  RETLW  A4
0015:  RETLW  01
0016:  RETLW  8D
0017:  RETLW  01
0018:  RETLW  7A
0019:  RETLW  01
001A:  RETLW  69
001B:  RETLW  01
001C:  RETLW  5A
001D:  RETLW  01
001E:  RETLW  4D
001F:  RETLW  01
0020:  RETLW  42
0021:  RETLW  01
0022:  RETLW  37
0023:  RETLW  01
0024:  RETLW  2E
0025:  RETLW  01
0026:  RETLW  25
0027:  RETLW  01
0028:  RETLW  1D
0029:  RETLW  01
002A:  RETLW  15
002B:  RETLW  01
002C:  RETLW  0F
002D:  RETLW  01
002E:  RETLW  08
002F:  RETLW  01
0030:  RETLW  02
0031:  RETLW  01
0032:  RETLW  FD
0033:  RETLW  00
0034:  RETLW  F7
0035:  RETLW  00
0036:  RETLW  F3
0037:  RETLW  00
0038:  RETLW  EE
0039:  RETLW  00
003A:  RETLW  EA
003B:  RETLW  00
003C:  RETLW  E5
003D:  RETLW  00
003E:  RETLW  E2
003F:  RETLW  00
0040:  RETLW  DE
0041:  RETLW  00
0042:  RETLW  DA
0043:  RETLW  00
0044:  RETLW  D7
0045:  RETLW  00
0046:  RETLW  D4
0047:  RETLW  00
0048:  RETLW  D1
0049:  RETLW  00
004A:  RETLW  CE
004B:  RETLW  00
004C:  RETLW  CB
004D:  RETLW  00
004E:  RETLW  C8
004F:  RETLW  00
0050:  RETLW  C5
0051:  RETLW  00
0052:  RETLW  C3
0053:  RETLW  00
0054:  RETLW  C0
0055:  RETLW  00
0056:  RETLW  BE
0057:  RETLW  00
0058:  RETLW  BC
0059:  RETLW  00
005A:  RETLW  BA
005B:  RETLW  00
005C:  RETLW  B8
005D:  RETLW  00
005E:  RETLW  B6
005F:  RETLW  00
0060:  RETLW  B4
0061:  RETLW  00
0062:  RETLW  B2
0063:  RETLW  00
0064:  RETLW  B0
0065:  RETLW  00
0066:  RETLW  AE
0067:  RETLW  00
0068:  RETLW  AC
0069:  RETLW  00
006A:  RETLW  AB
006B:  RETLW  00
006C:  RETLW  A9
006D:  RETLW  00
006E:  RETLW  A7
006F:  RETLW  00
0070:  RETLW  A6
0071:  RETLW  00
0072:  RETLW  A4
0073:  RETLW  00
0074:  RETLW  A3
0075:  RETLW  00
0076:  RETLW  A2
0077:  RETLW  00
0078:  RETLW  A0
0079:  RETLW  00
007A:  RETLW  9F
007B:  RETLW  00
007C:  RETLW  9D
007D:  RETLW  00
007E:  RETLW  9C
007F:  RETLW  00
0080:  RETLW  9B
0081:  RETLW  00
0082:  RETLW  9A
0083:  RETLW  00
0084:  RETLW  98
0085:  RETLW  00
0086:  RETLW  97
0087:  RETLW  00
0088:  RETLW  96
0089:  RETLW  00
008A:  RETLW  95
008B:  RETLW  00
008C:  RETLW  94
008D:  RETLW  00
008E:  RETLW  93
008F:  RETLW  00
0090:  RETLW  92
0091:  RETLW  00
0092:  RETLW  91
0093:  RETLW  00
0094:  RETLW  90
0095:  RETLW  00
0096:  RETLW  8F
0097:  RETLW  00
0098:  RETLW  8E
0099:  RETLW  00
009A:  RETLW  8D
009B:  RETLW  00
009C:  RETLW  8C
009D:  RETLW  00
009E:  RETLW  8B
009F:  RETLW  00
00A0:  RETLW  8A
00A1:  RETLW  00
00A2:  RETLW  89
00A3:  RETLW  00
00A4:  RETLW  88
00A5:  RETLW  00
00A6:  RETLW  87
00A7:  RETLW  00
00A8:  RETLW  86
00A9:  RETLW  00
00AA:  RETLW  85
00AB:  RETLW  00
00AC:  RETLW  84
00AD:  RETLW  00
00AE:  RETLW  83
00AF:  RETLW  00
00B0:  RETLW  82
00B1:  RETLW  00
00B2:  RETLW  81
00B3:  RETLW  00
00B4:  RETLW  80
00B5:  RETLW  00
00B6:  RETLW  7F
00B7:  RETLW  00
00B8:  RETLW  7E
00B9:  RETLW  00
00BA:  RETLW  7D
00BB:  RETLW  00
00BC:  RETLW  7C
00BD:  RETLW  00
00BE:  RETLW  7B
00BF:  RETLW  00
00C0:  RETLW  7A
00C1:  RETLW  00
00C2:  RETLW  79
00C3:  RETLW  00
00C4:  RETLW  78
00C5:  RETLW  00
00C6:  RETLW  77
00C7:  RETLW  00
00C8:  RETLW  76
00C9:  RETLW  00
00CA:  RETLW  75
00CB:  RETLW  00
00CC:  RETLW  74
00CD:  RETLW  00
00CE:  RETLW  73
00CF:  RETLW  00
00D0:  RETLW  72
00D1:  RETLW  00
00D2:  RETLW  71
00D3:  RETLW  00
00D4:  RETLW  70
00D5:  RETLW  00
00D6:  RETLW  6F
00D7:  RETLW  00
00D8:  RETLW  6E
00D9:  RETLW  00
00DA:  RETLW  6D
00DB:  RETLW  00
00DC:  RETLW  6C
00DD:  RETLW  00
00DE:  RETLW  6B
00DF:  RETLW  00
00E0:  RETLW  6A
00E1:  RETLW  00
00E2:  RETLW  69
00E3:  RETLW  00
00E4:  RETLW  68
00E5:  RETLW  00
00E6:  RETLW  67
00E7:  RETLW  00
00E8:  RETLW  66
00E9:  RETLW  00
00EA:  RETLW  65
00EB:  RETLW  00
00EC:  RETLW  64
00ED:  RETLW  00
*
03C7:  BSF    0A.0
03C8:  BSF    0A.1
03C9:  BCF    0A.2
03CA:  ADDWF  02,F
03CB:  GOTO   34B
03CC:  GOTO   32E
03CD:  GOTO   367
03CE:  GOTO   37D
03CF:  GOTO   397
....................  
.................... #list 
....................  
....................  
.................... #FUSES INTRC_IO                                                      // High Speed Oscilator (>4 Mhz) crystal 
.................... #FUSES NOWDT                                                         // Watch Dog Timer disabled 
.................... #FUSES PUT                                                           // Power Up Timer enabled 
.................... #FUSES MCLR                                                          // Master Clear pin enabled 
.................... #FUSES BROWNOUT                                                      // Brownout Reset enabled 
.................... #FUSES BORV25                                                        // Brownout Reset at 2.5V 
.................... #FUSES NOLVP                                                         // Low Voltage Programming disabled 
.................... #FUSES CPD                                                           // Data EEPROM code protected 
.................... #FUSES PROTECT                                                       // Code protected from reads 
.................... #FUSES NOIESO                                                        // Internal External Switch Over Mode disabled 
.................... #FUSES NOFCMEN                                                       // Fail-safe clock monitor disabled 
....................  
.................... #USE   DELAY(clock=16000000)                                         // delay() func. adjusted for 20Mhz Primary Osc. 
*
00EE:  MOVLW  20
00EF:  MOVWF  05
00F0:  MOVLW  16
00F1:  MOVWF  04
00F2:  MOVF   00,W
00F3:  BTFSC  03.2
00F4:  GOTO   103
00F5:  MOVLW  05
00F6:  MOVWF  78
00F7:  CLRF   77
00F8:  DECFSZ 77,F
00F9:  GOTO   0F8
00FA:  DECFSZ 78,F
00FB:  GOTO   0F7
00FC:  MOVLW  2E
00FD:  MOVWF  77
00FE:  DECFSZ 77,F
00FF:  GOTO   0FE
0100:  GOTO   101
0101:  DECFSZ 00,F
0102:  GOTO   0F5
0103:  RETURN
*
02B6:  MOVLW  03
02B7:  SUBWF  29,F
02B8:  BTFSS  03.0
02B9:  GOTO   2C5
02BA:  MOVLW  20
02BB:  MOVWF  05
02BC:  MOVLW  09
02BD:  MOVWF  04
02BE:  MOVF   00,W
02BF:  BTFSC  03.2
02C0:  GOTO   2C5
02C1:  GOTO   2C3
02C2:  NOP
02C3:  DECFSZ 00,F
02C4:  GOTO   2C2
02C5:  RETURN
....................  
.................... // Pin assignments 
.................... #DEFINE DRV_STEP     PIN_A0                  // Step output pin 
.................... #DEFINE DRV_RESET    PIN_A1                  // Reset output pin to driver (Active-high reset input initializes all internal logic and disables the Hbridge outputs. Internal pulldown.) 
.................... #DEFINE LM_UP        PIN_A2                  // Up limit switch input pin 
.................... #DEFINE LM_DOWN      PIN_A3                  // Down limit switch input pin 
.................... #DEFINE DRV_DIR      PIN_A4                  // Direction output pin 
....................  
.................... #DEFINE SPI_SDO      PIN_A6                  // SPI data output pin 
.................... #DEFINE SPI_CS       PIN_A7                  // SPI chip select output pin 
....................  
.................... #DEFINE BT_DOWN      PIN_B0                  // Down button input pin 
.................... #DEFINE SPI_SDI      PIN_B1                  // SPI data input pin 
....................  
.................... #DEFINE BT_UP        PIN_B3                  // Up button input pin 
.................... #DEFINE SPI_SCK      PIN_B4                  // SPI clock output pin 
....................  
.................... #DEFINE DRV_STALL    PIN_B6                  // Stall input pin from driver (Internal stall detect mode: logic low when motor stall detected. Pull up mevcut) 
.................... #DEFINE DRV_FAULT    PIN_B7                  // Fault input pin from driver (Logic low when in fault condition. Pull up mevcut) 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //OPTION Register  
.................... #WORD OPTION         = 0x095 
.................... //Bits of Option Register 
.................... #BIT OPTION_WPUEN    = OPTION.7 
....................  
....................  
.................... // SPI Registers 
.................... #WORD SPI_SSP1CON1   = 0x215                 // Synchronous serial port control register 
.................... #WORD SPI_SSP1STAT   = 0x214                 // Synchronous serial port status register 
.................... #WORD SPI_SSP1BUF    = 0x211                 // Synchronous serial port buffer register 
.................... #WORD SPI_PIR1       = 0x011                 // Peripheral interrupt request register 
.................... // Pin function control registers 
.................... #WORD PIN_APFCON0    = 0x11D                 // Alternate pin function control register 0 
.................... #WORD PIN_APFCON1    = 0x11E                 // Alternate pin function control register 1 
....................  
.................... // Bits of SSP1CON1 register 
.................... #BIT SPI_WRITE_FLAG     = SPI_SSP1CON1.7     // Synchronous serial port write collision detect bit 
.................... #BIT SPI_ENABLE         = SPI_SSP1CON1.5     // Synchronous serial port enable bit 
.................... #BIT SPI_CLOCK_POLARITY = SPI_SSP1CON1.4     // Synchronous serial port clock polarity select bit 
.................... #BIT SPI_MODE_3         = SPI_SSP1CON1.3     // Synchronous serial port mode select bits 
.................... #BIT SPI_MODE_2         = SPI_SSP1CON1.2    
.................... #BIT SPI_MODE_1         = SPI_SSP1CON1.1    
.................... #BIT SPI_MODE_0         = SPI_SSP1CON1.0   
....................  
.................... // Bits of SPI_SSP1STAT register 
.................... #BIT SPI_INPUT_SAMPLE   = SPI_SSP1STAT.7     // Synchronous serial port data input sample bit 
.................... #BIT SPI_CLOCK_EDGE     = SPI_SSP1STAT.6     // Synchronous serial port clock edge select bit 
.................... #BIT SPI_BUFFER_STATUS  = SPI_SSP1STAT.0     // Synchronous serial port buffer full status bit 
....................  
.................... // Bits of SPI_PIR1 register 
.................... #BIT SPI_FLAG           = SPI_PIR1.3         // Synchronous serial port interrupt flag bit 
....................  
.................... // Bits of PIN_APFCON0 register 
.................... #BIT PIN_RX_SELECT      = PIN_APFCON0.7      // RX pin selection bit 
.................... #BIT PIN_SDO_SELECT     = PIN_APFCON0.6      // SDO pin selection bit  
.................... #BIT PIN_SS_SELECT      = PIN_APFCON0.5      // SS pin selection bit  
....................  
.................... // Bits of PIN_APFCON1 register 
.................... #BIT PIN_TX_SELECT      = PIN_APFCON1.0      // TX pin selection bit 
....................  
....................  
.................... enum  State     {OFF = 0, ON   = 1};                                 // Motor states 
.................... enum  Direction {UP  = 0, DOWN = 1};                                 // Direction of motion 
.................... enum  Motion    {ACC = 0, WALK = 1, RUN  = 2, DEC = 3, STEADY = 4};  // State of the motion 
....................  
.................... int16 const run_lim          = 800;                                  // Duration of the slow motion (per count) before acclerating to high speed   
.................... int   const acc_lim          = 117;                                  // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... int16 const periods[acc_lim] = {2449,1015,779,656,578,523,481,447,420,397,378,361,346,333,322,311,302,293,285,277,271,264,258,253,247,243,238,234,229,226,222, 
.................... 218,215,212,209,206,203,200,197,195,192,190,188,186,184,182,180,178,176,174,172,171,169,167,166,164,163,162,160,159,157,156,155,154,152,151,150,149,148,147, 
.................... 146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108, 
.................... 107,106,105,104,103,102,101,100}; 
....................  
.................... int const off_time = 50;                                             // Off time of the pwm signal (should be smaller than period) 
.................... int8      motion_state = STEADY;                                     // Current state of the motion 
....................  
.................... void set_SPI() 
.................... { 
....................    // Disable SPI to set registers 
....................    SPI_ENABLE = 0; 
*
010A:  MOVLB  04
010B:  BCF    15.5
....................    // Set idle state of the clock to low  
....................    SPI_CLOCK_POLARITY = 0; 
010C:  BCF    15.4
....................    // Set SPI mode to SPI  
....................    SPI_MODE_3 = 0;  
010D:  BCF    15.3
....................    SPI_MODE_2 = 0; 
010E:  BCF    15.2
....................    SPI_MODE_1 = 1; 
010F:  BSF    15.1
....................    SPI_MODE_0 = 0; 
0110:  BCF    15.0
....................    // Input data sampled at the middle of data output time 
....................    SPI_INPUT_SAMPLE = 0; 
0111:  BCF    14.7
....................    // Transmit occurs on transition from active to idle clock state 
....................    SPI_CLOCK_EDGE = 1; 
0112:  BSF    14.6
....................  
....................    // Enable SPI 
....................    SPI_ENABLE = 1; 
0113:  BSF    15.5
0114:  MOVLP  00
0115:  MOVLB  00
0116:  GOTO   3EC (RETURN)
.................... } 
....................  
.................... void set_variables() 
.................... { 
....................    output_low(SPI_CS);     // Chip select is active high so keep it low to prevent out-of-sync transaction 
0117:  MOVLB  01
0118:  BCF    0C.7
0119:  MOVLB  02
011A:  BCF    0C.7
....................    output_low(DRV_RESET);  // Reset is active high so keep reset pin low to activate driver  
011B:  MOVLB  01
011C:  BCF    0C.1
011D:  MOVLB  02
011E:  BCF    0C.1
011F:  MOVLP  00
0120:  MOVLB  00
0121:  GOTO   3ED (RETURN)
.................... } 
....................  
.................... void set_pins() 
.................... { 
....................    // Set RB2 as RX pin 
....................    //PIN_RX_SELECT = 1; 
....................    // Set RA6 as SDO pin 
....................    PIN_SDO_SELECT = 1; 
*
0104:  MOVLB  02
0105:  BSF    1D.6
....................    // Set RA5 as SS pin 
....................    PIN_SS_SELECT = 1; 
0106:  BSF    1D.5
0107:  MOVLP  00
0108:  MOVLB  00
0109:  GOTO   3EB (RETURN)
....................    // Set RB5 as TX pin 
....................    //PIN_TX_SELECT = 1; 
.................... } 
....................  
....................  
.................... // Sets the motor state 
.................... void md_set_state(State value) 
.................... { 
....................    if (value == on) 
*
0122:  DECFSZ 31,W
0123:  GOTO   14A
....................    { 
....................    output_high(SPI_CS); 
0124:  MOVLB  01
0125:  BCF    0C.7
0126:  MOVLB  02
0127:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Ctrl_1     = 0b00001100; 
....................                     //76543210 
....................    int Ctrl_0     = 0b00011001;// Set enable pin to given motor state 
0128:  MOVLW  0C
0129:  MOVLB  00
012A:  MOVWF  32
012B:  MOVLW  19
012C:  MOVWF  33
....................    SPI_SSP1BUF = Ctrl_1; 
012D:  MOVLB  04
012E:  CLRF   12
012F:  MOVLB  00
0130:  MOVF   32,W
0131:  MOVLB  04
0132:  MOVWF  11
....................    while (!SPI_FLAG); 
0133:  MOVLB  00
0134:  BTFSS  11.3
0135:  GOTO   134
....................    SPI_FLAG = 0; 
0136:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0137:  MOVLB  04
0138:  CLRF   12
0139:  MOVLB  00
013A:  MOVF   33,W
013B:  MOVLB  04
013C:  MOVWF  11
....................    while (!SPI_FLAG); 
013D:  MOVLB  00
013E:  BTFSS  11.3
013F:  GOTO   13E
....................    SPI_FLAG = 0; 
0140:  BCF    11.3
....................    output_low(SPI_CS); 
0141:  MOVLB  01
0142:  BCF    0C.7
0143:  MOVLB  02
0144:  BCF    0C.7
....................    delay_ms(10); 
0145:  MOVLW  0A
0146:  MOVLB  00
0147:  MOVWF  36
0148:  CALL   0EE
....................    } 
0149:  GOTO   172
....................    else if (value == off) 
014A:  MOVF   31,F
014B:  BTFSS  03.2
014C:  GOTO   172
....................    { 
....................    output_high(SPI_CS); 
014D:  MOVLB  01
014E:  BCF    0C.7
014F:  MOVLB  02
0150:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Ctrl_1     = 0b00001100; 
....................                     //76543210 
....................    int Ctrl_0     = 0b00011000;// Set enable pin to given motor state 
0151:  MOVLW  0C
0152:  MOVLB  00
0153:  MOVWF  34
0154:  MOVLW  18
0155:  MOVWF  35
....................    SPI_SSP1BUF = Ctrl_1; 
0156:  MOVLB  04
0157:  CLRF   12
0158:  MOVLB  00
0159:  MOVF   34,W
015A:  MOVLB  04
015B:  MOVWF  11
....................    while (!SPI_FLAG); 
015C:  MOVLB  00
015D:  BTFSS  11.3
015E:  GOTO   15D
....................    SPI_FLAG = 0; 
015F:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0160:  MOVLB  04
0161:  CLRF   12
0162:  MOVLB  00
0163:  MOVF   35,W
0164:  MOVLB  04
0165:  MOVWF  11
....................    while (!SPI_FLAG); 
0166:  MOVLB  00
0167:  BTFSS  11.3
0168:  GOTO   167
....................    SPI_FLAG = 0; 
0169:  BCF    11.3
....................    output_low(SPI_CS); 
016A:  MOVLB  01
016B:  BCF    0C.7
016C:  MOVLB  02
016D:  BCF    0C.7
....................    delay_ms(10); 
016E:  MOVLW  0A
016F:  MOVLB  00
0170:  MOVWF  36
0171:  CALL   0EE
....................    } 
0172:  RETURN
.................... } 
.................... // Sets the motion direction 
.................... void md_set_direction(Direction value) 
.................... { 
....................       output_bit(DRV_DIR, !value);                                     // Set direction pin to given value 
*
02A9:  MOVF   26,F
02AA:  BTFSC  03.2
02AB:  GOTO   2B0
02AC:  MOVLB  02
02AD:  BCF    0C.4
02AE:  GOTO   2B2
02AF:  MOVLB  00
02B0:  MOVLB  02
02B1:  BSF    0C.4
02B2:  MOVLB  01
02B3:  BCF    0C.4
02B4:  MOVLB  00
02B5:  RETURN
.................... } 
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_set_state(OFF);                                                 // Motor off 
*
0173:  CLRF   31
0174:  CALL   122
....................    output_high(DRV_DIR);                                              // Direction control pin can be in any state 
0175:  MOVLB  01
0176:  BCF    0C.4
0177:  MOVLB  02
0178:  BSF    0C.4
....................    output_high(DRV_STEP);                                             // Keep step input pin high (A low-to-high transition advances the motor one increment  
0179:  MOVLB  01
017A:  BCF    0C.0
017B:  MOVLB  02
017C:  BSF    0C.0
....................     
....................    output_high(SPI_CS); 
017D:  MOVLB  01
017E:  BCF    0C.7
017F:  MOVLB  02
0180:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Ctrl_1     = 0b00001100; 
....................                     //76543210 
....................    int Ctrl_0     = 0b00011000; 
0181:  MOVLW  0C
0182:  MOVLB  00
0183:  MOVWF  21
0184:  MOVLW  18
0185:  MOVWF  22
....................    SPI_SSP1BUF = Ctrl_1; 
0186:  MOVLB  04
0187:  CLRF   12
0188:  MOVLB  00
0189:  MOVF   21,W
018A:  MOVLB  04
018B:  MOVWF  11
....................    while (!SPI_FLAG); 
018C:  MOVLB  00
018D:  BTFSS  11.3
018E:  GOTO   18D
....................    SPI_FLAG = 0; 
018F:  BCF    11.3
....................    SPI_SSP1BUF = Ctrl_0; 
0190:  MOVLB  04
0191:  CLRF   12
0192:  MOVLB  00
0193:  MOVF   22,W
0194:  MOVLB  04
0195:  MOVWF  11
....................    while (!SPI_FLAG); 
0196:  MOVLB  00
0197:  BTFSS  11.3
0198:  GOTO   197
....................    SPI_FLAG = 0; 
0199:  BCF    11.3
....................    output_low(SPI_CS); 
019A:  MOVLB  01
019B:  BCF    0C.7
019C:  MOVLB  02
019D:  BCF    0C.7
....................    delay_ms(10); 
019E:  MOVLW  0A
019F:  MOVLB  00
01A0:  MOVWF  36
01A1:  CALL   0EE
....................  
....................    output_high(SPI_CS); 
01A2:  MOVLB  01
01A3:  BCF    0C.7
01A4:  MOVLB  02
01A5:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Torque_1   = 0b00010000; 
....................                     //76543210 
....................    int Torque_0   = 0b10110111; 
01A6:  MOVLW  10
01A7:  MOVLB  00
01A8:  MOVWF  23
01A9:  MOVLW  B7
01AA:  MOVWF  24
....................    SPI_SSP1BUF = Torque_1; 
01AB:  MOVLB  04
01AC:  CLRF   12
01AD:  MOVLB  00
01AE:  MOVF   23,W
01AF:  MOVLB  04
01B0:  MOVWF  11
....................    while (!SPI_FLAG); 
01B1:  MOVLB  00
01B2:  BTFSS  11.3
01B3:  GOTO   1B2
....................    SPI_FLAG = 0; 
01B4:  BCF    11.3
....................    SPI_SSP1BUF = Torque_0; 
01B5:  MOVLB  04
01B6:  CLRF   12
01B7:  MOVLB  00
01B8:  MOVF   24,W
01B9:  MOVLB  04
01BA:  MOVWF  11
....................    while (!SPI_FLAG); 
01BB:  MOVLB  00
01BC:  BTFSS  11.3
01BD:  GOTO   1BC
....................    SPI_FLAG = 0; 
01BE:  BCF    11.3
....................    output_low(SPI_CS); 
01BF:  MOVLB  01
01C0:  BCF    0C.7
01C1:  MOVLB  02
01C2:  BCF    0C.7
....................    delay_ms(10); 
01C3:  MOVLW  0A
01C4:  MOVLB  00
01C5:  MOVWF  36
01C6:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
01C7:  MOVLB  01
01C8:  BCF    0C.7
01C9:  MOVLB  02
01CA:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Off_1      = 0b00100000; 
....................                     //76543210 
....................    int Off_0      = 0b01111001; 
01CB:  MOVLW  20
01CC:  MOVLB  00
01CD:  MOVWF  25
01CE:  MOVLW  79
01CF:  MOVWF  26
....................    SPI_SSP1BUF = Off_1; 
01D0:  MOVLB  04
01D1:  CLRF   12
01D2:  MOVLB  00
01D3:  MOVF   25,W
01D4:  MOVLB  04
01D5:  MOVWF  11
....................    while (!SPI_FLAG); 
01D6:  MOVLB  00
01D7:  BTFSS  11.3
01D8:  GOTO   1D7
....................    SPI_FLAG = 0; 
01D9:  BCF    11.3
....................    SPI_SSP1BUF = Off_0; 
01DA:  MOVLB  04
01DB:  CLRF   12
01DC:  MOVLB  00
01DD:  MOVF   26,W
01DE:  MOVLB  04
01DF:  MOVWF  11
....................    while (!SPI_FLAG); 
01E0:  MOVLB  00
01E1:  BTFSS  11.3
01E2:  GOTO   1E1
....................    SPI_FLAG = 0; 
01E3:  BCF    11.3
....................    output_low(SPI_CS); 
01E4:  MOVLB  01
01E5:  BCF    0C.7
01E6:  MOVLB  02
01E7:  BCF    0C.7
....................    delay_ms(10); 
01E8:  MOVLW  0A
01E9:  MOVLB  00
01EA:  MOVWF  36
01EB:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
01EC:  MOVLB  01
01ED:  BCF    0C.7
01EE:  MOVLB  02
01EF:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Blank_1    = 0b00110001; 
....................                     //76543210 
....................    int Blank_0    = 0b10010110; 
01F0:  MOVLW  31
01F1:  MOVLB  00
01F2:  MOVWF  27
01F3:  MOVLW  96
01F4:  MOVWF  28
....................    SPI_SSP1BUF = Blank_1; 
01F5:  MOVLB  04
01F6:  CLRF   12
01F7:  MOVLB  00
01F8:  MOVF   27,W
01F9:  MOVLB  04
01FA:  MOVWF  11
....................    while (!SPI_FLAG); 
01FB:  MOVLB  00
01FC:  BTFSS  11.3
01FD:  GOTO   1FC
....................    SPI_FLAG = 0; 
01FE:  BCF    11.3
....................    SPI_SSP1BUF = Blank_0; 
01FF:  MOVLB  04
0200:  CLRF   12
0201:  MOVLB  00
0202:  MOVF   28,W
0203:  MOVLB  04
0204:  MOVWF  11
....................    while (!SPI_FLAG); 
0205:  MOVLB  00
0206:  BTFSS  11.3
0207:  GOTO   206
....................    SPI_FLAG = 0; 
0208:  BCF    11.3
....................    output_low(SPI_CS); 
0209:  MOVLB  01
020A:  BCF    0C.7
020B:  MOVLB  02
020C:  BCF    0C.7
....................    delay_ms(10); 
020D:  MOVLW  0A
020E:  MOVLB  00
020F:  MOVWF  36
0210:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
0211:  MOVLB  01
0212:  BCF    0C.7
0213:  MOVLB  02
0214:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Decay_1    = 0b01000101; 
....................                     //76543210 
....................    int Decay_0    = 0b00011100; 
0215:  MOVLW  45
0216:  MOVLB  00
0217:  MOVWF  29
0218:  MOVLW  1C
0219:  MOVWF  2A
....................    SPI_SSP1BUF = Decay_1; 
021A:  MOVLB  04
021B:  CLRF   12
021C:  MOVLB  00
021D:  MOVF   29,W
021E:  MOVLB  04
021F:  MOVWF  11
....................    while (!SPI_FLAG); 
0220:  MOVLB  00
0221:  BTFSS  11.3
0222:  GOTO   221
....................    SPI_FLAG = 0; 
0223:  BCF    11.3
....................    SPI_SSP1BUF = Decay_0; 
0224:  MOVLB  04
0225:  CLRF   12
0226:  MOVLB  00
0227:  MOVF   2A,W
0228:  MOVLB  04
0229:  MOVWF  11
....................    while (!SPI_FLAG); 
022A:  MOVLB  00
022B:  BTFSS  11.3
022C:  GOTO   22B
....................    SPI_FLAG = 0; 
022D:  BCF    11.3
....................    output_low(SPI_CS); 
022E:  MOVLB  01
022F:  BCF    0C.7
0230:  MOVLB  02
0231:  BCF    0C.7
....................    delay_ms(10); 
0232:  MOVLW  0A
0233:  MOVLB  00
0234:  MOVWF  36
0235:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
0236:  MOVLB  01
0237:  BCF    0C.7
0238:  MOVLB  02
0239:  BSF    0C.7
....................    int Stall_1    = 0b01011001; 
....................    int Stall_0    = 0b00010100; 
023A:  MOVLW  59
023B:  MOVLB  00
023C:  MOVWF  2B
023D:  MOVLW  14
023E:  MOVWF  2C
....................    SPI_SSP1BUF = Stall_1; 
023F:  MOVLB  04
0240:  CLRF   12
0241:  MOVLB  00
0242:  MOVF   2B,W
0243:  MOVLB  04
0244:  MOVWF  11
....................    while (!SPI_FLAG); 
0245:  MOVLB  00
0246:  BTFSS  11.3
0247:  GOTO   246
....................    SPI_FLAG = 0; 
0248:  BCF    11.3
....................    SPI_SSP1BUF = Stall_0; 
0249:  MOVLB  04
024A:  CLRF   12
024B:  MOVLB  00
024C:  MOVF   2C,W
024D:  MOVLB  04
024E:  MOVWF  11
....................    while (!SPI_FLAG); 
024F:  MOVLB  00
0250:  BTFSS  11.3
0251:  GOTO   250
....................    SPI_FLAG = 0; 
0252:  BCF    11.3
....................    output_low(SPI_CS); 
0253:  MOVLB  01
0254:  BCF    0C.7
0255:  MOVLB  02
0256:  BCF    0C.7
....................    delay_ms(10); 
0257:  MOVLW  0A
0258:  MOVLB  00
0259:  MOVWF  36
025A:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
025B:  MOVLB  01
025C:  BCF    0C.7
025D:  MOVLB  02
025E:  BSF    0C.7
....................                     //FEDCBA98 
....................    int Drive_1    = 0b01101010; 
....................                     //76543210 
....................    int Drive_0    = 0b10100000; 
025F:  MOVLW  6A
0260:  MOVLB  00
0261:  MOVWF  2D
0262:  MOVLW  A0
0263:  MOVWF  2E
....................    SPI_SSP1BUF = Drive_1; 
0264:  MOVLB  04
0265:  CLRF   12
0266:  MOVLB  00
0267:  MOVF   2D,W
0268:  MOVLB  04
0269:  MOVWF  11
....................    while (!SPI_FLAG); 
026A:  MOVLB  00
026B:  BTFSS  11.3
026C:  GOTO   26B
....................    SPI_FLAG = 0; 
026D:  BCF    11.3
....................    SPI_SSP1BUF = Drive_0; 
026E:  MOVLB  04
026F:  CLRF   12
0270:  MOVLB  00
0271:  MOVF   2E,W
0272:  MOVLB  04
0273:  MOVWF  11
....................    while (!SPI_FLAG); 
0274:  MOVLB  00
0275:  BTFSS  11.3
0276:  GOTO   275
....................    SPI_FLAG = 0; 
0277:  BCF    11.3
....................    output_low(SPI_CS); 
0278:  MOVLB  01
0279:  BCF    0C.7
027A:  MOVLB  02
027B:  BCF    0C.7
....................    delay_ms(10); 
027C:  MOVLW  0A
027D:  MOVLB  00
027E:  MOVWF  36
027F:  CALL   0EE
....................     
....................    output_high(SPI_CS); 
0280:  MOVLB  01
0281:  BCF    0C.7
0282:  MOVLB  02
0283:  BSF    0C.7
....................    int Status_1   = 0b01110000; 
....................    int Status_0   = 0b00000000; 
0284:  MOVLW  70
0285:  MOVLB  00
0286:  MOVWF  2F
0287:  CLRF   30
....................    SPI_SSP1BUF = Status_1; 
0288:  MOVLB  04
0289:  CLRF   12
028A:  MOVLB  00
028B:  MOVF   2F,W
028C:  MOVLB  04
028D:  MOVWF  11
....................    while (!SPI_FLAG); 
028E:  MOVLB  00
028F:  BTFSS  11.3
0290:  GOTO   28F
....................    SPI_FLAG = 0; 
0291:  BCF    11.3
....................    SPI_SSP1BUF = Status_0; 
0292:  MOVLB  04
0293:  CLRF   12
0294:  MOVLB  00
0295:  MOVF   30,W
0296:  MOVLB  04
0297:  MOVWF  11
....................    while (!SPI_FLAG); 
0298:  MOVLB  00
0299:  BTFSS  11.3
029A:  GOTO   299
....................    SPI_FLAG = 0; 
029B:  BCF    11.3
....................    output_low(SPI_CS); 
029C:  MOVLB  01
029D:  BCF    0C.7
029E:  MOVLB  02
029F:  BCF    0C.7
....................    delay_ms(10); 
02A0:  MOVLW  0A
02A1:  MOVLB  00
02A2:  MOVWF  36
02A3:  CALL   0EE
....................  
....................    delay_ms(100); 
02A4:  MOVLW  64
02A5:  MOVWF  36
02A6:  CALL   0EE
02A7:  MOVLP  00
02A8:  GOTO   3EE (RETURN)
.................... } 
....................  
.................... // Starts motion cycle 
.................... void motion_cycle() 
*
02C6:  CLRF   22
02C7:  CLRF   21
02C8:  CLRF   24
02C9:  CLRF   23
02CA:  BCF    25.0
.................... { 
....................    // Start cycle 
....................    int16 step_count = 0; 
....................    int16 period     = 0; 
....................    int1  running    = 0; 
....................     
....................    while(true) 
....................    { 
....................       if(input(BT_UP)) 
02CB:  MOVLB  01
02CC:  BSF    0D.3
02CD:  MOVLB  00
02CE:  BTFSS  0D.3
02CF:  GOTO   2F2
....................       { 
....................          if(input(LM_UP) == 0 && running == 0) 
02D0:  MOVLB  01
02D1:  BSF    0C.2
02D2:  MOVLB  00
02D3:  BTFSC  0C.2
02D4:  GOTO   2DC
02D5:  BTFSC  25.0
02D6:  GOTO   2DC
....................          { 
....................             md_set_direction(UP); 
02D7:  CLRF   26
02D8:  CALL   2A9
....................             motion_state = WALK; 
02D9:  MOVLW  01
02DA:  MOVWF  20
....................          } 
02DB:  GOTO   2F1
....................          else if(input(LM_UP) && running == 1) 
02DC:  MOVLB  01
02DD:  BSF    0C.2
02DE:  MOVLB  00
02DF:  BTFSS  0C.2
02E0:  GOTO   2F1
02E1:  BTFSS  25.0
02E2:  GOTO   2F1
....................          { 
....................             if(motion_state == ACC || motion_state == RUN) 
02E3:  MOVF   20,F
02E4:  BTFSC  03.2
02E5:  GOTO   2EA
02E6:  MOVF   20,W
02E7:  SUBLW  02
02E8:  BTFSS  03.2
02E9:  GOTO   2ED
....................                motion_state = DEC; 
02EA:  MOVLW  03
02EB:  MOVWF  20
02EC:  GOTO   2F1
....................             else if(motion_state == WALK) 
02ED:  DECFSZ 20,W
02EE:  GOTO   2F1
....................                motion_state = STEADY; 
02EF:  MOVLW  04
02F0:  MOVWF  20
....................          } 
....................       } 
02F1:  GOTO   328
....................       else if(input(BT_DOWN)) 
02F2:  MOVLB  01
02F3:  BSF    0D.0
02F4:  MOVLB  00
02F5:  BTFSS  0D.0
02F6:  GOTO   31A
....................       { 
....................          if(input(LM_DOWN) == 0 && running == 0) 
02F7:  MOVLB  01
02F8:  BSF    0C.3
02F9:  MOVLB  00
02FA:  BTFSC  0C.3
02FB:  GOTO   304
02FC:  BTFSC  25.0
02FD:  GOTO   304
....................          { 
....................             md_set_direction(DOWN); 
02FE:  MOVLW  01
02FF:  MOVWF  26
0300:  CALL   2A9
....................             motion_state = WALK; 
0301:  MOVLW  01
0302:  MOVWF  20
....................          } 
0303:  GOTO   319
....................          else if(input(LM_DOWN) && running == 1) 
0304:  MOVLB  01
0305:  BSF    0C.3
0306:  MOVLB  00
0307:  BTFSS  0C.3
0308:  GOTO   319
0309:  BTFSS  25.0
030A:  GOTO   319
....................          { 
....................             if(motion_state == ACC || motion_state == RUN) 
030B:  MOVF   20,F
030C:  BTFSC  03.2
030D:  GOTO   312
030E:  MOVF   20,W
030F:  SUBLW  02
0310:  BTFSS  03.2
0311:  GOTO   315
....................                motion_state = DEC; 
0312:  MOVLW  03
0313:  MOVWF  20
0314:  GOTO   319
....................             else if(motion_state == WALK) 
0315:  DECFSZ 20,W
0316:  GOTO   319
....................                motion_state = STEADY; 
0317:  MOVLW  04
0318:  MOVWF  20
....................          } 
....................       } 
0319:  GOTO   328
....................       else 
....................       { 
....................          if(motion_state == ACC || motion_state == RUN) 
031A:  MOVF   20,F
031B:  BTFSC  03.2
031C:  GOTO   321
031D:  MOVF   20,W
031E:  SUBLW  02
031F:  BTFSS  03.2
0320:  GOTO   324
....................             motion_state = DEC; 
0321:  MOVLW  03
0322:  MOVWF  20
0323:  GOTO   328
....................          else if(motion_state == WALK) 
0324:  DECFSZ 20,W
0325:  GOTO   328
....................             motion_state = STEADY; 
0326:  MOVLW  04
0327:  MOVWF  20
....................       } 
....................        
....................        
....................  
....................       switch(motion_state)  
0328:  MOVF   20,W
0329:  ADDLW  FB
032A:  BTFSC  03.0
032B:  GOTO   3A0
032C:  ADDLW  05
032D:  GOTO   3C7
....................       {  
....................          case WALK: 
....................             step_count++; 
032E:  INCF   21,F
032F:  BTFSC  03.2
0330:  INCF   22,F
....................           
....................             if(step_count == 1) 
0331:  DECFSZ 21,W
0332:  GOTO   33F
0333:  MOVF   22,F
0334:  BTFSS  03.2
0335:  GOTO   33F
....................             { 
....................                running = 1; 
0336:  BSF    25.0
....................                md_set_state(ON); 
0337:  MOVLW  01
0338:  MOVWF  31
0339:  CALL   122
....................                period = periods[0]; 
033A:  MOVLW  09
033B:  MOVWF  24
033C:  MOVLW  91
033D:  MOVWF  23
....................             } 
033E:  GOTO   34A
....................             else if(step_count == run_lim) 
033F:  MOVF   21,W
0340:  SUBLW  20
0341:  BTFSS  03.2
0342:  GOTO   34A
0343:  MOVF   22,W
0344:  SUBLW  03
0345:  BTFSS  03.2
0346:  GOTO   34A
....................             { 
....................                step_count   = 0; 
0347:  CLRF   22
0348:  CLRF   21
....................                motion_state = ACC; 
0349:  CLRF   20
....................             } 
....................             break; 
034A:  GOTO   3A0
....................          case ACC: 
....................             if(step_count == acc_lim - 1) 
034B:  MOVF   21,W
034C:  SUBLW  74
034D:  BTFSS  03.2
034E:  GOTO   354
034F:  MOVF   22,F
0350:  BTFSS  03.2
0351:  GOTO   354
....................             { 
....................                motion_state = RUN; 
0352:  MOVLW  02
0353:  MOVWF  20
....................             } 
....................                 
....................             period = periods[step_count]; 
0354:  BCF    03.0
0355:  RLF    21,W
0356:  MOVWF  79
0357:  RLF    22,W
0358:  MOVWF  7A
0359:  MOVF   79,W
035A:  MOVWF  26
035B:  INCF   79,W
035C:  CALL   003
035D:  MOVWF  7A
035E:  MOVF   26,W
035F:  CALL   003
0360:  MOVWF  23
0361:  MOVF   7A,W
0362:  MOVWF  24
....................             step_count++; 
0363:  INCF   21,F
0364:  BTFSC  03.2
0365:  INCF   22,F
....................             break; 
0366:  GOTO   3A0
....................              
....................          case RUN: 
....................             period = periods[step_count - 1]; 
0367:  MOVLW  01
0368:  SUBWF  21,W
0369:  MOVWF  26
036A:  MOVLW  00
036B:  SUBWFC 22,W
036C:  MOVWF  27
036D:  BCF    03.0
036E:  RLF    26,W
036F:  MOVWF  79
0370:  RLF    27,W
0371:  MOVWF  7A
0372:  MOVF   79,W
0373:  MOVWF  26
0374:  INCF   79,W
0375:  CALL   003
0376:  MOVWF  7A
0377:  MOVF   26,W
0378:  CALL   003
0379:  MOVWF  23
037A:  MOVF   7A,W
037B:  MOVWF  24
....................             break; 
037C:  GOTO   3A0
....................     
....................          case DEC: 
....................             step_count--; 
037D:  MOVF   21,W
037E:  BTFSC  03.2
037F:  DECF   22,F
0380:  DECFSZ 21,F
....................             // Check if we at last step 
....................             if(step_count == 0) 
0381:  GOTO   387
0382:  MOVF   22,F
0383:  BTFSS  03.2
0384:  GOTO   387
....................             { 
....................                motion_state = STEADY; 
0385:  MOVLW  04
0386:  MOVWF  20
....................             } 
....................                 
....................             period = periods[step_count]; 
0387:  BCF    03.0
0388:  RLF    21,W
0389:  MOVWF  79
038A:  RLF    22,W
038B:  MOVWF  7A
038C:  MOVF   79,W
038D:  MOVWF  26
038E:  INCF   79,W
038F:  CALL   003
0390:  MOVWF  7A
0391:  MOVF   26,W
0392:  CALL   003
0393:  MOVWF  23
0394:  MOVF   7A,W
0395:  MOVWF  24
....................             break; 
0396:  GOTO   3A0
....................              
....................          case STEADY: 
....................             if(running) 
0397:  BTFSS  25.0
0398:  GOTO   3A0
....................             { 
....................                running    = 0; 
0399:  BCF    25.0
....................                period     = 0; 
039A:  CLRF   24
039B:  CLRF   23
....................                step_count = 0; 
039C:  CLRF   22
039D:  CLRF   21
....................                md_set_state(OFF); 
039E:  CLRF   31
039F:  CALL   122
....................             } 
....................             break; 
....................       } 
....................     
....................       if(running) 
03A0:  BTFSS  25.0
03A1:  GOTO   3C4
....................       {   
....................          delay_us(off_time); 
03A2:  MOVLW  42
03A3:  MOVWF  77
03A4:  DECFSZ 77,F
03A5:  GOTO   3A4
03A6:  NOP
....................          output_low(DRV_STEP); 
03A7:  MOVLB  01
03A8:  BCF    0C.0
03A9:  MOVLB  02
03AA:  BCF    0C.0
....................          delay_us(period - off_time); 
03AB:  MOVLW  32
03AC:  MOVLB  00
03AD:  SUBWF  23,W
03AE:  MOVWF  26
03AF:  MOVLW  00
03B0:  SUBWFC 24,W
03B1:  MOVWF  27
03B2:  MOVF   27,W
03B3:  MOVWF  28
03B4:  INCF   28,F
03B5:  DECF   28,F
03B6:  BTFSC  03.2
03B7:  GOTO   3BC
03B8:  MOVLW  FF
03B9:  MOVWF  29
03BA:  CALL   2B6
03BB:  GOTO   3B5
03BC:  MOVF   26,W
03BD:  MOVWF  29
03BE:  CALL   2B6
....................          output_high(DRV_STEP); 
03BF:  MOVLB  01
03C0:  BCF    0C.0
03C1:  MOVLB  02
03C2:  BSF    0C.0
03C3:  MOVLB  00
....................       } 
03C4:  GOTO   2CB
....................    } 
03C5:  MOVLP  00
03C6:  GOTO   3EF (RETURN)
.................... } 
....................  
.................... // Main method 
.................... void main() 
*
03D0:  MOVLW  7A
03D1:  MOVLB  01
03D2:  MOVWF  19
03D3:  MOVLW  04
03D4:  MOVLB  00
03D5:  MOVWF  20
03D6:  MOVLB  03
03D7:  CLRF   0C
03D8:  CLRF   0D
03D9:  MOVLB  02
03DA:  CLRF   12
03DB:  CLRF   11
03DC:  CLRF   14
03DD:  CLRF   13
.................... { 
....................    //             76543210 
....................      set_tris_a(0b00101100);       // Set I/O states of the ports 
03DE:  MOVLW  2C
03DF:  TRIS   5
....................      set_tris_b(0b11001111); 
03E0:  MOVLW  CF
03E1:  TRIS   6
....................     
....................    delay_ms(500); 
03E2:  MOVLW  02
03E3:  MOVLB  00
03E4:  MOVWF  21
03E5:  MOVLW  FA
03E6:  MOVWF  36
03E7:  CALL   0EE
03E8:  DECFSZ 21,F
03E9:  GOTO   3E5
....................     
....................    //fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING STAGE\n\n\r"); 
....................     
....................    set_pins(); 
03EA:  GOTO   104
....................    set_SPI(); 
03EB:  GOTO   10A
....................    set_variables(); 
03EC:  GOTO   117
....................    md_init();                                                           // Initialize motor driver 
03ED:  GOTO   173
....................    motion_cycle();                                                      // Start motion cycle 
03EE:  GOTO   2C6
.................... } 
03EF:  SLEEP

Configuration Fuses:
   Word  1: 0E44   INTRC_IO NOWDT PUT MCLR PROTECT CPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1AFF   NOWRT PLL_SW STVREN BORV25 NODEBUG NOLVP

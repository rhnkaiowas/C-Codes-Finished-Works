CCS PCD C Compiler, Version 4.108, 15145               23-Tem-14 11:39

               Filename: \\192.168.1.33\File Server\Modesis\Proje Dosyalarý\LPS - Lazer Projeksiyon Sistemi\Software\SLS_Software_v2.0\Control_Card_v2.0.lst

               ROM used: 19762 bytes (20%)
                         Largest free fragment is 45774
               RAM used: 209 (3%) at main() level
                         447 (5%) worst case
               Stack:    9 worst case (8 in main + 1 for interrupts)

*
00000:  GOTO    4AF6
*
00044:  DATA    6C,16,00
.................... #INCLUDE <30f6015.h>  
.................... //////// Standard Header file for the DSPIC30F6015 device //////////////// 
.................... #device DSPIC30F6015 
.................... #list 
....................  
.................... #DEVICE ADC=10                                                    // Configures the read_adc return size as 10 bit 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                                                      // No Watch Dog Timer  
.................... #FUSES FRC                                                        // Internal Fast RC Oscillator 
.................... #FUSES NOCKSFSM                                                   // Clock Switching is disabled, fail Safe clock monitor is disabled  
.................... #FUSES NOBROWNOUT                                                 // Not reset when brownout detected  
.................... #FUSES PROTECT                                                    // Code is protected from reading  
.................... #FUSES NOWRT                                                      // Program memory not write protected  
.................... #FUSES NODEBUG                                                    // No Debug mode for ICD 
....................  
.................... #USE DELAY(clock=7370000)                                         // delay() func. adjusted for internal osc clock speed. 
*
0168A:  CP0     W0
0168C:  BTSC.B  42.1
0168E:  BRA     1698
01690:  REPEAT  #72B
01692:  NOP     
01694:  DEC     W0,W0
01696:  BRA     168A
01698:  RETURN  
*
02344:  LSR     W0,#0,W0
02346:  CP0     W0
02348:  BTSC.B  42.1
0234A:  BRA     2350
0234C:  DEC     W0,W0
0234E:  BRA     2346
02350:  RETURN  
.................... #USE RS232(stream=RS485,UART1,baud=38400,parity=N,bits=8,stop=1)  // Set UART1 as RS485 stream 
.................... #USE RS232(stream=RS232,UART2,baud=38400,parity=N,bits=8,stop=1)  // Set UART2 as RS232 stream 
....................  
.................... //Register for Reset Info 
.................... #WORD RCON                 = 0x740           //Reset control register 
.................... #BIT RCON_POR              = RCON.0          //POR 
.................... #BIT RCON_BOR              = RCON.1          //BOR 
.................... #BIT RCON_IDLE             = RCON.2 
.................... #BIT RCON_SLEEP            = RCON.3 
.................... #BIT RCON_WDTO             = RCON.4 
.................... #BIT RCON_SWDTEN           = RCON.5 
.................... #BIT RCON_SWR              = RCON.6 
.................... #BIT RCON_EXTR             = RCON.7         //MCLR Reset during normal operation 
.................... #BIT RCON_BGST             = RCON.13 
.................... #BIT RCON_IOPUWR           = RCON.14 
.................... #BIT RCON_TRAPR            = RCON.15 
....................  
.................... // Registers of quadrature encoder interface module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD QEI_QEICON        = 0x122           // Control and status register QEICON allows control of the QEI operation and status flags indicating the module state. 
.................... #WORD QEI_DFLTCON       = 0x124           // Digital filter control register DFLTCON allows control of the digital input filter operation. 
.................... #WORD QEI_POSCNT        = 0x126           // Position count register POSCNT allows reading and writing of the 16-bit position counter. 
.................... #WORD QEI_MAXCNT        = 0x128           // Maximum count register MAXCNT holds a value that will be compared to the POSCNT counter in some operations. 
.................... // Bits of the QEICON register 
.................... #BIT QEI_QEICON_CNTERR  = QEI_QEICON.15   // Count error status flag bit 
.................... #BIT QEI_QEICON_QEISIDL = QEI_QEICON.13   // Stop in idle mode bit 
.................... #BIT QEI_QEICON_INDEX   = QEI_QEICON.12   // Index pin state status bit (read only) 
.................... #BIT QEI_QEICON_UPDN    = QEI_QEICON.11   // Position counter direction status bit (read only) 
.................... #BIT QEI_QEICON_QEIM2   = QEI_QEICON.10   // Quadrature encoder interface mode select bits 
.................... #BIT QEI_QEICON_QEIM1   = QEI_QEICON.9 
.................... #BIT QEI_QEICON_QEIM0   = QEI_QEICON.8 
.................... #BIT QEI_QEICON_SWPAB   = QEI_QEICON.7    // Phase A and phase B input swap select bit  
.................... #BIT QEI_QEICON_PCDOUT  = QEI_QEICON.6    // Position counter direction state output rnable bit 
.................... #BIT QEI_QEICON_TQGATE  = QEI_QEICON.5    // Timer gated time accumulation rnable bit 
.................... #BIT QEI_QEICON_TQCKPS1 = QEI_QEICON.4    // Timer input clock prescale select bits 
.................... #BIT QEI_QEICON_TQCKPS0 = QEI_QEICON.3 
.................... #BIT QEI_QEICON_POSRES  = QEI_QEICON.2    // Position counter reset enable bit 
.................... #BIT QEI_QEICON_TQCS    = QEI_QEICON.1    // Timer clock source select bit 
.................... #BIT QEI_QEICON_UDSRC   = QEI_QEICON.0    // Position counter direction selection control bit 
.................... // Bits of the DFLTCON register 
.................... #BIT QEI_DFLTCON_IMV1   = QEI_DFLTCON.10  // Index match value bits 
.................... #BIT QEI_DFLTCON_IMV0   = QEI_DFLTCON.9   // These bits allow the user to specify the state of the QEA and QEB input pins during an Index pulse when the POSCNT register is to be reset. 
.................... #BIT QEI_DFLTCON_CEID   = QEI_DFLTCON.8   // Count error interrupt disable bit 
.................... #BIT QEI_DFLTCON_QEOUT  = QEI_DFLTCON.7   // QEA/QEB/IND digital filter output enable bit  
.................... #BIT QEI_DFLTCON_QECK2  = QEI_DFLTCON.6   // QEA/QEB/IND digital filter clock divide select bits 
.................... #BIT QEI_DFLTCON_QECK1  = QEI_DFLTCON.5      
.................... #BIT QEI_DFLTCON_QECK0  = QEI_DFLTCON.4 
....................  
.................... // Registers of the motor control PWM module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD PWM_PTCON         = 0x1C0           // PWM Time base control register 
.................... #WORD PWM_PTPER         = 0x1C4           // PWM Time base period register 
.................... #WORD PWM_PWMCON1       = 0x1C8           // PWM Control register #1 
.................... #WORD PWM_PWMCON2       = 0x1CA           // PWM Control register #2 
.................... #WORD PWM_PDC1          = 0x1D6           // PWM Duty cycle register #1 
.................... #WORD PWM_IEC2          = 0x090           // PWM Interrupt Enable Control Register 
.................... #WORD PWM_IFS2          = 0x088           // PWM Interrupt Flag Status Register 
.................... // Bits of the PTCON register 
.................... #BIT PWM_PTCON_PTEN     = PWM_PTCON.15    // PWM Time base timer enable bit 
.................... #BIT PWM_PTCON_PTOPS3   = PWM_PTCON.7     // PWM Time base output postscale select bits  
.................... #BIT PWM_PTCON_PTOPS2   = PWM_PTCON.6 
.................... #BIT PWM_PTCON_PTOPS1   = PWM_PTCON.5 
.................... #BIT PWM_PTCON_PTOPS0   = PWM_PTCON.4 
.................... #BIT PWM_PTCON_PTCKPS1  = PWM_PTCON.3     // PWM Time base input clock prescale select bits 
.................... #BIT PWM_PTCON_PTCKPS0  = PWM_PTCON.2     
.................... #BIT PWM_PTCON_PTMOD1   = PWM_PTCON.1     // PWM Time base mode select bits 
.................... #BIT PWM_PTCON_PTMOD0   = PWM_PTCON.0 
.................... // Bits of the PWMCON1 register 
.................... #BIT PWM_PWMCON1_PMOD1  = PWM_PWMCON1.8   // PWM1 I/O pin pair mode bit 
.................... #BIT PWM_PWMCON1_PEN1H  = PWM_PWMCON1.4   // PWM1H I/O pin enable bit 
.................... #BIT PWM_PWMCON1_PEN1L  = PWM_PWMCON1.0   // PWM1L I/O pin enable bit 
.................... // Bits of the PWMCON2 register   
.................... #BIT PWM_PWMCON2_IUE    = PWM_PWMCON2.2   // Immediate update enable bit 
.................... #BIT PWM_PWMCON2_OSYNC  = PWM_PWMCON2.1   // Output override synchronization bit 
.................... #BIT PWM_PWMCON2_UDIS   = PWM_PWMCON2.0   // PWM update disable bit 
.................... // Bits of the IEC2 register 
.................... #BIT PWM_IEC2_PWMIE     = PWM_IEC2.7      // PWM Interrupt enable bit  
.................... // Bits of the IFS2 register 
.................... #BIT PWM_IFS2_PWMIF     = PWM_IFS2.7      // PWM Interrupt flag status bit     
....................  
.................... // Registers of the UART1 module 
.................... #WORD UART_IFS0          = 0x088           // UART Interrupt Flag Status Register 
.................... // Bits of the IFS0 register 
.................... #BIT UART_IFS0_U1RXIF    = UART_IFS0.9     // UART Receiver Interrupt flag status bit   
.................... #BIT UART_IFS0_U1TXIF    = UART_IFS0.10    // UART Transmiter Interrupt flag status bit   
....................  
.................... // Led pins 
.................... #DEFINE LED          PIN_B8               // Led used in debugging 
....................  
.................... // Laser pins 
.................... #DEFINE LAS_1        PIN_B0               // Control pin of the first laser 
.................... #DEFINE LAS_2        PIN_B1               // Control pin of the second laser 
.................... #DEFINE LAS_3        PIN_D6               // Control pin of the third laser 
....................  
.................... //Parallel Port Pin Assignments 
.................... #DEFINE PP_D0        PIN_D8               // Parallel port data pin first bit 
.................... #DEFINE PP_D1        PIN_D9               // Parallel port data pin second bit 
.................... #DEFINE PP_D2        PIN_D0               // Parallel port data pin third bit 
.................... #DEFINE PP_D3        PIN_C13              // Parallel port data pin fourth bit 
.................... #DEFINE PP_D4        PIN_C14              // Parallel port data pin fifth bit 
.................... #DEFINE PP_D5        PIN_D1               // Parallel port data pin sixth bit 
.................... #DEFINE PP_D6        PIN_D2               // Parallel port data pin seventh bit 
.................... #DEFINE PP_D7        PIN_D3               // Parallel port data pin eigth bit 
.................... #DEFINE PP_STR       PIN_D10              // Parallel port strobe pin 
.................... #DEFINE PP_ACK       PIN_D4               // Parallel port acknowledge pin used to  
.................... #DEFINE PP_RDY       PIN_D5               // Parallel port ready pin 
....................  
.................... // Pins used to control digital potentiometer 
.................... #DEFINE DP_CS        PIN_G9               // Digital potentiometer chip select pin assignment (active low) 
.................... #DEFINE DP_UD        PIN_G8               // Digital potentiometer up/down control pin assignment 
....................  
.................... // Pins used to control motor driver 
.................... #DEFINE MD_MS1       PIN_F0               // Step resolution select pin 1 assignment 
.................... #DEFINE MD_MS2       PIN_D7               // Step resolution select pin 2 assignment 
.................... #DEFINE MD_SR        PIN_F1               // Active mode (synchronous rectification) input pin assignment 
.................... #DEFINE MD_RESET     PIN_E0               // Reset input pin assignment (active low) 
.................... #DEFINE MD_STEP      PIN_E1               // Step input pin assignment 
.................... #DEFINE MD_ENABLE    PIN_E2               // Enable input pin assignment (active low) 
.................... #DEFINE MD_SLEEP     PIN_E3               // Sleep input pin assignment (active low) 
.................... #DEFINE MD_DIR       PIN_E4               // Direction input pin assignment 
.................... #DEFINE MD_SW        PIN_D11              // Homing switch input pin assignment 
....................  
.................... // Pins used to control FRAM 
.................... #DEFINE FR_CS        PIN_G7               // FRAM chip select pin assignment (active low) 
.................... #DEFINE FR_WP        PIN_G6               // FRAM write protection pin assignment (active low) 
.................... #DEFINE FR_SCK       PIN_E5               // FRAM serial clock pin assignment 
.................... #DEFINE FR_SI        PIN_E6               // FRAM serial input pin assignment 
.................... #DEFINE FR_SO        PIN_E7               // FRAM serial output pin assignment 
....................  
.................... // Speed ramp states 
.................... #DEFINE HOME         0 
.................... #DEFINE ACCEL        1 
.................... #DEFINE DECEL        2 
.................... #DEFINE RUN          3 
.................... #DEFINE POS          4 
....................  
.................... // PWM module operating modes 
.................... #DEFINE FREE         0 
.................... #DEFINE SINGLE       1 
....................  
.................... int1           debug_mode_dp     = 0;              // Debug state of digital potentiometer 
.................... int1           debug_mode_pp     = 0;              // Debug state of parallel port communication 
.................... int1           debug_mode_fr     = 0;              // Debug state of FRAM 
.................... int1           debug_mode_md     = 0;              // Debug state of motor driver 
.................... int1           debug_mode_pwm    = 0;              // Debug state of motor control PWM module 
.................... int1           debug_mode_qei    = 0;              // Debug state of quadrature encoder 
....................  
.................... unsigned int   dp_tap_limit      = 32;             // Digital potentiometer maximum tap level 
.................... unsigned int   dp_voltage_limit  = 1023;           // Digital potentiometer maximum voltage level 
....................  
.................... unsigned int   mt_voltage_limit  = 803;            // Motor torque control voltage is limited to 4V (which is defined in driver specs) 
.................... unsigned int   mt_percent_trip   = 70;             // Motor torque percent while system is moving 
.................... unsigned int   mt_percent_rest   = 28;             // Motor torque percent while system is stationary 
....................  
.................... unsigned int   md_conv_const     = 0;              // Constant used to convert encoder count to motor step 
.................... unsigned int   md_move_range     = 400;            // Movement range of the device 
.................... unsigned int   md_home_pos       = 45;             // Sets the number of encoder counts between the home position and homing switch position 
.................... unsigned int   md_end_pos        = 1000;           // Sets the number of encoder counts between the home position and the end of movement range 
.................... unsigned int   md_end_offset     = 50;             // Offset of the maximum count number from the end position 
.................... unsigned int   md_home_offset    = 100;            // Offset of the maximum count number from the home position 
.................... unsigned int   md_min_distance   = 70;             // Minimum distance between symmetricaly moving lasers 
.................... unsigned int   md_target_count   = 0;              // Target position count 
....................  
.................... unsigned int   md_accel          = 3000;           // Acceleration of the motor (0.01 mm/s2) 
.................... unsigned int   md_decel          = 3000;           // Deceleration of the motor (0.01 mm/s2) 
....................  
.................... unsigned int   md_min_delay      = 100;            // Minimum time delay (max speed) 
.................... unsigned char  md_run_state      = 0;              // What part of the speed ramp we are in. 
.................... unsigned int   md_decel_lim      = 0;              // What step_pos to start decelaration 
.................... unsigned int   md_accel_lim      = 0;              // What step_pos to end accelaration 
.................... unsigned int   md_decel_count    = 0;              // Counter used when decelerateing to calculate step_delay. 
.................... unsigned int   md_pos_iter       = 0;              // Number of iterations performed during positioning 
.................... int            md_error          = 0;              // Positioning error 
.................... unsigned int   md_backlash       = 0;              // Backlash of the positioning system 
....................  
.................... unsigned int   md_cc_step        = 0;              // Motor count used in conversion constant conversion 
.................... unsigned int   md_cc_count       = 0;              // Encoder count used in conversion constant conversion 
....................  
.................... unsigned int   fr_serial_no      = 0;              // External adress of product serial no 
.................... unsigned int   fr_move_range     = 13;             // External adress of movement range 
.................... unsigned int   fr_home_pos       = 15;             // External adress of home position 
.................... unsigned int   fr_end_pos        = 17;             // External addres of end position 
.................... unsigned int   fr_conv_const     = 19;             // External adress of conversion constant 
.................... unsigned int   fr_backlash       = 21;             // External adress of backlash compensation 
.................... unsigned int   fr_comm_type      = 23;             // External adress of communication type 
.................... unsigned int   fr_last_pos       = 24;             // External adress of last position 
.................... unsigned int   fr_pos_table      = 26;             // External adress of position table 
....................  
.................... unsigned int   pp_str_check      = 1000;           // Parallel port strobe signal filter iteration number 
.................... unsigned int   pp_str_delay      = 1;              // Parallel port strobe signal filter pause time (ms) 
.................... unsigned int   pp_ack_delay      = 10;            // Parallel port acknowledge signal pause time (ms) 
.................... unsigned int   pp_rdy_delay      = 10;            // Parallel port ready signal pause time (ms) 
....................  
.................... int1           reg_comm_type     = 0;              // Communication type register 
.................... int1           reg_pp_stop       = 0;              // Parallel port emergency stop signal register 
.................... int1           reg_md_home       = 0;              // Homing action register 
.................... int1           reg_md_home_return= 0;              // Home correction return register 
.................... int1           reg_rs232_message = 0;              // RS232 message flag 
.................... int1           reg_md_cc_sample  = 0;              // Special case register for conversion constant calculation 
....................  
.................... #DEFINE ACC_15 
....................  
.................... #IFDEF ACC_10 
.................... unsigned int   md_max_acc_lim    = 116;             // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... unsigned int const delays[116]={2449,1015,779,656,578,523,481,447,420,397,378,361,346,333,322,311,302,293,285,277,271,264,258,253,247,243,238,234,229,226,222,218,215,212,209,206,203,200,197,195,192,190,188,186,184,182,180, 
.................... 178,176,174,172,171,169,167,166,164,163,162,160,159,157,156,155,154,152,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115, 
.................... 114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_15 
.................... unsigned int   md_max_acc_lim    = 88;             // Number of steps before we hit max speed. acc=15000 dec=15000 
.................... unsigned int const delays[88]={2000,828,636,536,472,427,393,365,343,325,309,295,283,272,263,254,246,239,233,226,221,216,211,206,202,198,194,191,187,184,181,178,175,173,170,168,166,163,161,159,157,155,153,152,150,148,147, 
.................... 145,144,142,141,139,138,137,135,134,133,132,131,130,129,128,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_20 
.................... unsigned int   md_max_acc_lim    = 71;             // Number of steps before we hit max speed. acc=20000 dec=20000  
.................... unsigned int const delays[71]={1732,717,551,464,409,370,340,316,297,281,267,255,245,236,227,220,213,207,201,196,191,187,183,179,175,172,168,165,162,159,157,154,152,150,147,145,143,141,140,138,136,134,133,131,130,128,127, 
.................... 126,124,123,122,121,120,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_25 
.................... unsigned int   md_max_acc_lim    = 59;             // Number of steps before we hit max speed. acc=25000 dec=25000  
.................... unsigned int const delays[59]={1549,642,492,415,366,331,304,283,266,251,239,228,219,211,203,197,191,185,180,175,171,167,163,160,157,153,150,148,145,143,140,138,136,134,132,130,128,126,125,123,122,120,119,117,116,115,114, 
.................... 112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_30 
.................... unsigned int   md_max_acc_lim    = 50;             // Number of steps before we hit max speed. acc=30000 dec=30000  
.................... unsigned int const delays[50]={1414,586,449,379,334,302,278,258,243,229,218,209,200,192,186,180,174,169,164,160,156,153,149,146,143,140,137,135,132,130,128,126,124,122,120,119,117,115,114,113,111,110,108,107,106,105,104, 
.................... 103,102,101}; 
.................... #ENDIF 
....................  
.................... void move_pos(unsigned int16 position); 
.................... unsigned int16 qei_get_count(); 
....................  
.................... // Initializes digital potentiometer 
.................... void dp_init()  
.................... { 
....................    output_high(DP_CS);                       // Chip select is active low so keep it disabled 
*
01B18:  BCLR.B  2E5.1
01B1A:  BSET.B  2E9.1
....................    output_low(DP_UD);                        // Up/down control pin can be in any state 
01B1C:  BCLR.B  2E5.0
01B1E:  BCLR.B  2E9.0
.................... } 
01B20:  RETURN  
.................... // Increases digital potentiometer by given tap 
.................... void dp_up(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
*
01BA6:  MOV     802,W0
01BA8:  MOV     8C6,W4
01BAA:  CP      W4,W0
01BAC:  BRA     LEU,1BB2
....................       tap=dp_tap_limit; 
01BAE:  PUSH    802
01BB0:  POP     8C6
....................        
....................    output_high(DP_UD);        // Set U/D to high before activating digital potentiometer 
01BB2:  BCLR.B  2E5.0
01BB4:  BSET.B  2E9.0
....................    delay_us(1); 
01BB6:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
01BB8:  BCLR.B  2E5.1
01BBA:  BCLR.B  2E9.1
....................    delay_us(1); 
01BBC:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
01BBE:  CLR     8C8
01BC0:  MOV     8C8,W0
01BC2:  MOV     8C6,W4
01BC4:  CP      W4,W0
01BC6:  BRA     LEU,1BE0
....................    { 
....................       output_low(DP_UD);      // Low part of pulse 
01BC8:  BCLR.B  2E5.0
01BCA:  BCLR.B  2E9.0
....................       delay_us(1); 
01BCC:  NOP     
....................       output_high(DP_UD);     // High part of pulse 
01BCE:  BCLR.B  2E5.0
01BD0:  BSET.B  2E9.0
....................       delay_us(1); 
01BD2:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
01BD4:  BCLR.B  2E5.0
01BD6:  BCLR.B  2E9.0
....................       delay_us(1);  
01BD8:  NOP     
....................    } 
01BDA:  INC     08C8
01BDC:  GOTO    1BC0
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer   
01BE0:  BCLR.B  2E5.1
01BE2:  BSET.B  2E9.1
.................... } 
01BE4:  RETURN  
.................... // Decreases digital potentiometer by given tap 
.................... void dp_down(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
01BE6:  MOV     802,W0
01BE8:  MOV     8C6,W4
01BEA:  CP      W4,W0
01BEC:  BRA     LEU,1BF2
....................       tap=dp_tap_limit; 
01BEE:  PUSH    802
01BF0:  POP     8C6
....................        
....................    output_low(DP_UD);         // Set U/D to low before activating digital potentiometer 
01BF2:  BCLR.B  2E5.0
01BF4:  BCLR.B  2E9.0
....................    delay_us(1); 
01BF6:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
01BF8:  BCLR.B  2E5.1
01BFA:  BCLR.B  2E9.1
....................    delay_us(1);             
01BFC:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
01BFE:  CLR     8C8
01C00:  MOV     8C8,W0
01C02:  MOV     8C6,W4
01C04:  CP      W4,W0
01C06:  BRA     LEU,1C1A
....................    { 
....................       output_high(DP_UD);     // High part of pulse 
01C08:  BCLR.B  2E5.0
01C0A:  BSET.B  2E9.0
....................       delay_us(1); 
01C0C:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
01C0E:  BCLR.B  2E5.0
01C10:  BCLR.B  2E9.0
....................       delay_us(1);   
01C12:  NOP     
....................    } 
01C14:  INC     08C8
01C16:  GOTO    1C00
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer 
01C1A:  BCLR.B  2E5.1
01C1C:  BSET.B  2E9.1
.................... } 
01C1E:  RETURN  
.................... // Sets digital potentiometer to given voltage 
.................... void dp_set(unsigned int voltage) 
.................... { 
01C20:  MOV     W5,[W15++]
01C22:  MOV     #3,W4
01C24:  MOV     W4,8B2
01C26:  CLR     8B4
01C28:  MOV     #F,W4
01C2A:  MOV     W4,8B6
01C2C:  MOV     8B0,W4
01C2E:  MOV     802,W3
01C30:  MUL.UU  W4,W3,W0
01C32:  MOV     W0,W5
01C34:  MOV     W5,W4
01C36:  MOV     804,W3
01C38:  REPEAT  #11
01C3A:  DIV.U   W4,W3
01C3C:  MOV     W0,8B8
01C3E:  BCLR.B  2A0.0
01C40:  BSET.B  2A0.1
01C42:  BTSS.B  2A0.0
01C44:  BRA     1C42
01C46:  PUSH    280
01C48:  POP     8BA
01C4A:  MOV     8B0,W4
01C4C:  MOV     8BA,W3
01C4E:  SUB     W4,W3,W5
01C50:  MOV     W5,W0
01C52:  MOV     W5,8BC
....................    unsigned int iteration_limit=3;                                   // Maximum number of iterations to be performed to set voltage 
....................    unsigned int iteration=0;                                         // Number of iterations performed to set voltage 
....................    unsigned int region=15;                                           // We want the voltage to be inside this region (+/-)  
....................    unsigned int tap_desired=voltage*dp_tap_limit/dp_voltage_limit;   // Find the desired potentiometer tap 
....................    unsigned int voltage_current=read_adc();                          // Read the current voltage 
....................    unsigned int voltage_diff=abs(voltage-voltage_current);           // Find the difference between the current and desired voltage  
....................    unsigned int tap_current;                                         // Current tap value 
....................     
....................    if(debug_mode_dp) 
01C54:  BTSS.B  800.0
01C56:  BRA     1D26
....................    { 
....................       fprintf(RS232,"\n\r\tVoltage Desired: %u",voltage); 
01C58:  MOV     #0,W1
01C5A:  MOV     W1,W0
01C5C:  CALL    19A
01C60:  INC     W1,W1
01C62:  MOV     W1,[W15++]
01C64:  BTSC.B  219.1
01C66:  BRA     1C64
01C68:  MOV     W0,21A
01C6A:  MOV     [--W15],W1
01C6C:  MOV     #13,W0
01C6E:  CPSGT   W1,W0
01C70:  BRA     1C5A
01C72:  MOV     8B0,W0
01C74:  MOV     #0,W4
01C76:  CALL    169A
....................       fprintf(RS232,"\n\r\tTap Desired: %u",dp_tap_limit*voltage/dp_voltage_limit); 
01C7A:  MOV     802,W4
01C7C:  MOV     8B0,W3
01C7E:  MUL.UU  W4,W3,W0
01C80:  MOV     W0,W5
01C82:  MOV     W5,W4
01C84:  MOV     804,W3
01C86:  REPEAT  #11
01C88:  DIV.U   W4,W3
01C8A:  MOV     W0,W5
01C8C:  MOV     #0,W1
01C8E:  MOV     W1,W0
01C90:  CALL    1C2
01C94:  INC     W1,W1
01C96:  MOV     W1,[W15++]
01C98:  BTSC.B  219.1
01C9A:  BRA     1C98
01C9C:  MOV     W0,21A
01C9E:  MOV     [--W15],W1
01CA0:  MOV     #F,W0
01CA2:  CPSGT   W1,W0
01CA4:  BRA     1C8E
01CA6:  MOV     W5,W0
01CA8:  MOV     #0,W4
01CAA:  CALL    169A
....................       fprintf(RS232,"\n\r\tVoltage Current: %u",voltage_current); 
01CAE:  MOV     #0,W1
01CB0:  MOV     W1,W0
01CB2:  CALL    1E6
01CB6:  INC     W1,W1
01CB8:  MOV     W1,[W15++]
01CBA:  BTSC.B  219.1
01CBC:  BRA     1CBA
01CBE:  MOV     W0,21A
01CC0:  MOV     [--W15],W1
01CC2:  MOV     #13,W0
01CC4:  CPSGT   W1,W0
01CC6:  BRA     1CB0
01CC8:  MOV     8BA,W0
01CCA:  MOV     #0,W4
01CCC:  CALL    169A
....................       fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01CD0:  MOV     802,W4
01CD2:  MOV     8BA,W3
01CD4:  MUL.UU  W4,W3,W0
01CD6:  MOV     W0,W5
01CD8:  MOV     W5,W4
01CDA:  MOV     804,W3
01CDC:  REPEAT  #11
01CDE:  DIV.U   W4,W3
01CE0:  MOV     W0,W5
01CE2:  MOV     #0,W1
01CE4:  MOV     W1,W0
01CE6:  CALL    20E
01CEA:  INC     W1,W1
01CEC:  MOV     W1,[W15++]
01CEE:  BTSC.B  219.1
01CF0:  BRA     1CEE
01CF2:  MOV     W0,21A
01CF4:  MOV     [--W15],W1
01CF6:  MOV     #F,W0
01CF8:  CPSGT   W1,W0
01CFA:  BRA     1CE4
01CFC:  MOV     W5,W0
01CFE:  MOV     #0,W4
01D00:  CALL    169A
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",voltage_diff); 
01D04:  MOV     #0,W1
01D06:  MOV     W1,W0
01D08:  CALL    232
01D0C:  INC     W1,W1
01D0E:  MOV     W1,[W15++]
01D10:  BTSC.B  219.1
01D12:  BRA     1D10
01D14:  MOV     W0,21A
01D16:  MOV     [--W15],W1
01D18:  MOV     #16,W0
01D1A:  CPSGT   W1,W0
01D1C:  BRA     1D06
01D1E:  MOV     8BC,W0
01D20:  MOV     #0,W4
01D22:  CALL    169A
....................    } 
....................     
....................    while(voltage_diff>region)                                        // Try until voltage is found 
....................    {                                                                 // or iteration limit is reached  
01D26:  MOV     8B6,W0
01D28:  MOV     8BC,W4
01D2A:  CP      W4,W0
01D2C:  BRA     LEU,1E90
....................       if(iteration <iteration_limit)                      
01D2E:  MOV     8B4,W0
01D30:  MOV     8B2,W4
01D32:  CP      W4,W0
01D34:  BRA     LEU,1E6C
....................       { 
....................          iteration++;                                                // Set iteration number 
01D36:  INC     08B4
....................          tap_current=dp_tap_limit*voltage_current/dp_voltage_limit;  // Convert new voltage to tap 
01D38:  MOV     802,W4
01D3A:  MOV     8BA,W3
01D3C:  MUL.UU  W4,W3,W0
01D3E:  MOV     W0,W5
01D40:  MOV     W5,W4
01D42:  MOV     804,W3
01D44:  REPEAT  #11
01D46:  DIV.U   W4,W3
01D48:  MOV     W0,8BE
....................  
....................          if(tap_desired>tap_current)                                 // Set the digital potentiometer to desired tap 
01D4A:  MOV     8BE,W0
01D4C:  MOV     8B8,W4
01D4E:  CP      W4,W0
01D50:  BRA     LEU,1D62
....................          { 
....................             dp_up(tap_desired-tap_current); 
01D52:  MOV     8B8,W4
01D54:  MOV     8BE,W3
01D56:  SUB     W4,W3,W5
01D58:  MOV     W5,8C6
01D5A:  CALL    1BA6
....................          } 
....................          else if(tap_desired<tap_current) 
01D5E:  GOTO    1D96
01D62:  MOV     8B8,W0
01D64:  MOV     8BE,W4
01D66:  CP      W4,W0
01D68:  BRA     LEU,1D7A
....................          { 
....................             dp_down(tap_current-tap_desired); 
01D6A:  MOV     8BE,W4
01D6C:  MOV     8B8,W3
01D6E:  SUB     W4,W3,W5
01D70:  MOV     W5,8C6
01D72:  CALL    1BE6
....................          } 
....................          else                                                        // If tap level is same as the previous one and it still outside the region 
01D76:  GOTO    1D96
....................          {                                                           // then go one step up or down according to desired voltage 
....................             if(voltage>voltage_current) 
01D7A:  MOV     8BA,W0
01D7C:  MOV     8B0,W4
01D7E:  CP      W4,W0
01D80:  BRA     LEU,1D8E
....................                dp_up(1); 
01D82:  MOV     #1,W4
01D84:  MOV     W4,8C6
01D86:  CALL    1BA6
....................             else 
01D8A:  GOTO    1D96
....................                dp_down(1); 
01D8E:  MOV     #1,W4
01D90:  MOV     W4,8C6
01D92:  CALL    1BE6
....................          } 
....................           
....................          delay_ms(2); 
01D96:  REPEAT  #E62
01D98:  NOP     
....................              
....................          voltage_current=read_adc();                                 // Read the new voltage 
01D9A:  BCLR.B  2A0.0
01D9C:  BSET.B  2A0.1
01D9E:  BTSS.B  2A0.0
01DA0:  BRA     1D9E
01DA2:  PUSH    280
01DA4:  POP     8BA
....................           
....................          if(voltage>voltage_current)                                 // Find the difference between the new and desired voltages for next iteration check 
01DA6:  MOV     8BA,W0
01DA8:  MOV     8B0,W4
01DAA:  CP      W4,W0
01DAC:  BRA     LEU,1DBA
....................             voltage_diff=voltage - voltage_current; 
01DAE:  MOV     8B0,W4
01DB0:  MOV     8BA,W3
01DB2:  SUB     W4,W3,W0
01DB4:  MOV     W0,8BC
....................          else 
01DB6:  GOTO    1DC2
....................             voltage_diff=voltage_current - voltage; 
01DBA:  MOV     8BA,W4
01DBC:  MOV     8B0,W3
01DBE:  SUB     W4,W3,W0
01DC0:  MOV     W0,8BC
....................           
....................          if(debug_mode_dp) 
01DC2:  BTSS.B  800.0
01DC4:  BRA     1E68
....................          { 
....................             fprintf(RS232,"\n\rITERATION: %u",iteration); 
01DC6:  MOV     #0,W1
01DC8:  MOV     W1,W0
01DCA:  CALL    25C
01DCE:  INC     W1,W1
01DD0:  MOV     W1,[W15++]
01DD2:  BTSC.B  219.1
01DD4:  BRA     1DD2
01DD6:  MOV     W0,21A
01DD8:  MOV     [--W15],W1
01DDA:  MOV     #C,W0
01DDC:  CPSGT   W1,W0
01DDE:  BRA     1DC8
01DE0:  MOV     8B4,W0
01DE2:  MOV     #0,W4
01DE4:  CALL    169A
....................             fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01DE8:  MOV     802,W4
01DEA:  MOV     8BA,W3
01DEC:  MUL.UU  W4,W3,W0
01DEE:  MOV     W0,W5
01DF0:  MOV     W5,W4
01DF2:  MOV     804,W3
01DF4:  REPEAT  #11
01DF6:  DIV.U   W4,W3
01DF8:  MOV     W0,W5
01DFA:  MOV     #0,W1
01DFC:  MOV     W1,W0
01DFE:  CALL    20E
01E02:  INC     W1,W1
01E04:  MOV     W1,[W15++]
01E06:  BTSC.B  219.1
01E08:  BRA     1E06
01E0A:  MOV     W0,21A
01E0C:  MOV     [--W15],W1
01E0E:  MOV     #F,W0
01E10:  CPSGT   W1,W0
01E12:  BRA     1DFC
01E14:  MOV     W5,W0
01E16:  MOV     #0,W4
01E18:  CALL    169A
....................             fprintf(RS232,"\n\r\tVoltage Current : %u",voltage_current); 
01E1C:  MOV     #0,W1
01E1E:  MOV     W1,W0
01E20:  CALL    27C
01E24:  INC     W1,W1
01E26:  MOV     W1,[W15++]
01E28:  BTSC.B  219.1
01E2A:  BRA     1E28
01E2C:  MOV     W0,21A
01E2E:  MOV     [--W15],W1
01E30:  MOV     #14,W0
01E32:  CPSGT   W1,W0
01E34:  BRA     1E1E
01E36:  MOV     8BA,W0
01E38:  MOV     #0,W4
01E3A:  CALL    169A
....................             fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-voltage_current)); 
01E3E:  MOV     8B0,W4
01E40:  MOV     8BA,W3
01E42:  SUB     W4,W3,W5
01E44:  MOV     W5,W0
01E46:  MOV     #0,W1
01E48:  MOV     W1,W0
01E4A:  CALL    232
01E4E:  INC     W1,W1
01E50:  MOV     W1,[W15++]
01E52:  BTSC.B  219.1
01E54:  BRA     1E52
01E56:  MOV     W0,21A
01E58:  MOV     [--W15],W1
01E5A:  MOV     #16,W0
01E5C:  CPSGT   W1,W0
01E5E:  BRA     1E48
01E60:  MOV     W5,W0
01E62:  MOV     #0,W4
01E64:  CALL    169A
....................          } 
....................       } 
....................       else 
01E68:  GOTO    1E8C
....................       { 
....................          if(debug_mode_dp) 
01E6C:  BTSS.B  800.0
01E6E:  BRA     1E8A
....................             fprintf(RS232,"\n\rIteration limit reached"); 
01E70:  MOV     #0,W1
01E72:  MOV     W1,W0
01E74:  CALL    2A4
01E78:  INC     W1,W1
01E7A:  MOV     W1,[W15++]
01E7C:  BTSC.B  219.1
01E7E:  BRA     1E7C
01E80:  MOV     W0,21A
01E82:  MOV     [--W15],W1
01E84:  MOV     #18,W0
01E86:  CPSGT   W1,W0
01E88:  BRA     1E72
....................          return; 
01E8A:  BRA     1F40
....................       } 
....................    } 
01E8C:  GOTO    1D26
....................     
....................    if(debug_mode_dp) 
01E90:  BTSS.B  800.0
01E92:  BRA     1F40
....................    { 
....................       fprintf(RS232,"\n\rFOUND!"); 
01E94:  MOV     #0,W1
01E96:  MOV     W1,W0
01E98:  CALL    2CE
01E9C:  INC     W1,W1
01E9E:  MOV     W1,[W15++]
01EA0:  BTSC.B  219.1
01EA2:  BRA     1EA0
01EA4:  MOV     W0,21A
01EA6:  MOV     [--W15],W1
01EA8:  MOV     #7,W0
01EAA:  CPSGT   W1,W0
01EAC:  BRA     1E96
....................       fprintf(RS232,"\n\r\tTap Current : %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01EAE:  MOV     802,W4
01EB0:  MOV     8BA,W3
01EB2:  MUL.UU  W4,W3,W0
01EB4:  MOV     W0,W5
01EB6:  MOV     W5,W4
01EB8:  MOV     804,W3
01EBA:  REPEAT  #11
01EBC:  DIV.U   W4,W3
01EBE:  MOV     W0,W5
01EC0:  MOV     #0,W1
01EC2:  MOV     W1,W0
01EC4:  CALL    2E8
01EC8:  INC     W1,W1
01ECA:  MOV     W1,[W15++]
01ECC:  BTSC.B  219.1
01ECE:  BRA     1ECC
01ED0:  MOV     W0,21A
01ED2:  MOV     [--W15],W1
01ED4:  MOV     #10,W0
01ED6:  CPSGT   W1,W0
01ED8:  BRA     1EC2
01EDA:  MOV     W5,W0
01EDC:  MOV     #0,W4
01EDE:  CALL    169A
....................       fprintf(RS232,"\n\r\tVoltage Current : %u",read_adc()); 
01EE2:  BCLR.B  2A0.0
01EE4:  BSET.B  2A0.1
01EE6:  BTSS.B  2A0.0
01EE8:  BRA     1EE6
01EEA:  MOV     280,W5
01EEC:  MOV     #0,W1
01EEE:  MOV     W1,W0
01EF0:  CALL    27C
01EF4:  INC     W1,W1
01EF6:  MOV     W1,[W15++]
01EF8:  BTSC.B  219.1
01EFA:  BRA     1EF8
01EFC:  MOV     W0,21A
01EFE:  MOV     [--W15],W1
01F00:  MOV     #14,W0
01F02:  CPSGT   W1,W0
01F04:  BRA     1EEE
01F06:  MOV     W5,W0
01F08:  MOV     #0,W4
01F0A:  CALL    169A
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-read_adc())); 
01F0E:  BCLR.B  2A0.0
01F10:  BSET.B  2A0.1
01F12:  BTSS.B  2A0.0
01F14:  BRA     1F12
01F16:  MOV     280,W0
01F18:  MOV     8B0,W4
01F1A:  SUB     W4,W0,W5
01F1C:  MOV     W5,W0
01F1E:  MOV     #0,W1
01F20:  MOV     W1,W0
01F22:  CALL    232
01F26:  INC     W1,W1
01F28:  MOV     W1,[W15++]
01F2A:  BTSC.B  219.1
01F2C:  BRA     1F2A
01F2E:  MOV     W0,21A
01F30:  MOV     [--W15],W1
01F32:  MOV     #16,W0
01F34:  CPSGT   W1,W0
01F36:  BRA     1F20
01F38:  MOV     W5,W0
01F3A:  MOV     #0,W4
01F3C:  CALL    169A
....................    } 
.................... } 
01F40:  MOV     [--W15],W5
01F42:  RETURN  
....................  
.................... // Returns current motor torque in percent (%0-100) 
.................... unsigned int md_mt_get() 
.................... { 
01F44:  MOV     W5,[W15++]
01F46:  MOV     W6,[W15++]
01F48:  BCLR.B  2A0.0
01F4A:  BSET.B  2A0.1
01F4C:  BTSS.B  2A0.0
01F4E:  BRA     1F4C
01F50:  MOV     280,W0
01F52:  MOV     #0,W1
01F54:  MOV     W0,W2
01F56:  MOV     W1,W3
01F58:  MOV     #64,W0
01F5A:  MOV     #0,W1
01F5C:  CALL    1B22
01F60:  MOV     W0,W5
01F62:  MOV     W1,W6
01F64:  BCLR.B  43.0
01F66:  MOV     W5,W0
01F68:  MOV     W6,W1
01F6A:  MOV     806,W2
01F6C:  MOV     #0,W3
01F6E:  CALL    1B52
01F72:  MOV     W0,8B2
....................    unsigned int analog=read_adc();                                         // Read the voltage level 
....................    unsigned int percent=100*(unsigned int32)analog/mt_voltage_limit;       // Convert voltage to percent 
....................     
....................    if(debug_mode_dp) 
01F74:  BTSS.B  800.0
01F76:  BRA     1FAA
....................       fprintf(RS232,"\n\r\tPercent Current: %u\n\r",percent); 
01F78:  MOV     #0,W1
01F7A:  MOV     W1,W0
01F7C:  CALL    30C
01F80:  INC     W1,W1
01F82:  MOV     W1,[W15++]
01F84:  BTSC.B  219.1
01F86:  BRA     1F84
01F88:  MOV     W0,21A
01F8A:  MOV     [--W15],W1
01F8C:  MOV     #13,W0
01F8E:  CPSGT   W1,W0
01F90:  BRA     1F7A
01F92:  MOV     8B2,W0
01F94:  MOV     #0,W4
01F96:  CALL    169A
01F9A:  BTSC.B  219.1
01F9C:  BRA     1F9A
01F9E:  MOV     #A,W4
01FA0:  MOV     W4,21A
01FA2:  BTSC.B  219.1
01FA4:  BRA     1FA2
01FA6:  MOV     #D,W4
01FA8:  MOV     W4,21A
....................        
....................    return percent;   
01FAA:  PUSH    8B2
01FAC:  POP     0
.................... } 
01FAE:  MOV     [--W15],W6
01FB0:  MOV     [--W15],W5
01FB2:  RETURN  
.................... // Sets motor torque approximate to desired percent and returns the actual percent (%0-100) 
.................... unsigned int md_mt_set(unsigned int percent) 
.................... { 
01FB4:  MOV     W5,[W15++]
01FB6:  MOV     W6,[W15++]
....................    // percent must be between 0 and 100 
....................    if(percent>100) 
01FB8:  MOV     8AA,W4
01FBA:  MOV     #64,W3
01FBC:  CP      W3,W4
01FBE:  BRA     C,1FC4
....................       percent=100; 
01FC0:  MOV     #64,W4
01FC2:  MOV     W4,8AA
....................        
....................    if(debug_mode_dp) 
01FC4:  BTSS.B  800.0
01FC6:  BRA     1FEA
....................    { 
....................       fprintf(RS232,"\n\r\tPercent Desired:"); 
01FC8:  MOV     #0,W1
01FCA:  MOV     W1,W0
01FCC:  CALL    336
01FD0:  INC     W1,W1
01FD2:  MOV     W1,[W15++]
01FD4:  BTSC.B  219.1
01FD6:  BRA     1FD4
01FD8:  MOV     W0,21A
01FDA:  MOV     [--W15],W1
01FDC:  MOV     #12,W0
01FDE:  CPSGT   W1,W0
01FE0:  BRA     1FCA
....................       fprintf(RS232,"%u",percent); 
01FE2:  MOV     8AA,W0
01FE4:  MOV     #0,W4
01FE6:  CALL    169A
....................    } 
....................     
....................    unsigned int voltage=(unsigned int32)percent*mt_voltage_limit/100;      // convert percent to voltage 
01FEA:  MOV     8AA,W5
01FEC:  MOV     #0,W6
01FEE:  MOV     W5,W0
01FF0:  MOV     W6,W1
01FF2:  MOV     806,W2
01FF4:  MOV     #0,W3
01FF6:  CALL    1B22
01FFA:  MOV     W0,W5
01FFC:  MOV     W1,W6
01FFE:  BCLR.B  43.0
02000:  MOV     W5,W0
02002:  MOV     W6,W1
02004:  MOV     #64,W2
02006:  MOV     #0,W3
02008:  CALL    1B52
0200C:  MOV     W0,8AC
....................    dp_set(voltage);                                      // set digital potentiometer 
0200E:  PUSH    8AC
02010:  POP     8B0
02012:  CALL    1C20
....................     
....................    return md_mt_get(); 
02016:  CALL    1F44
0201A:  MOV     W0,0
.................... } 
0201C:  MOV     [--W15],W6
0201E:  MOV     [--W15],W5
02020:  RETURN  
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_mt_set(mt_percent_rest);               // Set motor torque before initialization of motor driver 
02022:  PUSH    80A
02024:  POP     8AA
02026:  CALL    1FB4
....................  
....................    output_high(MD_RESET);                    // Reset is active low so keep it disabled 
0202A:  BCLR.B  2D8.0
0202C:  BSET.B  2DC.0
....................    output_high(MD_SLEEP);                    // Sleep is active low so keep it disabled 
0202E:  BCLR.B  2D8.3
02030:  BSET.B  2DC.3
....................    output_low(MD_SR);                        // Activate synchronous rectification 
02032:  BCLR.B  2DE.1
02034:  BCLR.B  2E2.1
....................    output_high(MD_DIR);                      // Direction control pin can be in any state 
02036:  BCLR.B  2D8.4
02038:  BSET.B  2DC.4
....................    output_high(MD_MS1);                      // MS1 and MS2 high enables 8x microstepping mode 
0203A:  BCLR.B  2DE.0
0203C:  BSET.B  2E2.0
....................    output_high(MD_MS2); 
0203E:  BCLR.B  2D2.7
02040:  BSET.B  2D6.7
....................    output_low(MD_ENABLE);                    // Enable is active so keep it high 
02042:  BCLR.B  2D8.2
02044:  BCLR.B  2DC.2
....................    output_low(MD_STEP);                      // A low-to-high transition advances the motor one increment so keep step input low 
02046:  BCLR.B  2D8.1
02048:  BCLR.B  2DC.1
.................... } 
0204A:  RETURN  
....................  
.................... // Initializes external EEPROM (FRAM) 
.................... void fr_init()  
.................... { 
....................    output_high(FR_CS);     // Chip select is active low when it is high the device enters low-power standby mode so initialy keep it high 
0204C:  BCLR.B  2E4.7
0204E:  BSET.B  2E8.7
....................    output_low(FR_WP);      // Write protection pin is active low and prevents write operations to the status register so initially keep it low 
02050:  BCLR.B  2E4.6
02052:  BCLR.B  2E8.6
....................    output_low(FR_SI);      // Serial input pin is driven to high logic state during communication so initially keep it low 
02054:  BCLR.B  2D8.6
02056:  BCLR.B  2DC.6
....................    output_low(FR_SCK);     // Inputs are latched on the rising edge and outputs occur on the falling edge so initially serial clock can be in any state  
02058:  BCLR.B  2D8.5
0205A:  BCLR.B  2DC.5
.................... } 
0205C:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... void fr_write_byte(unsigned int16 address, unsigned int8 data)  
.................... { 
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    unsigned int8 wren; 
....................    unsigned int8 write; 
....................    unsigned int8 wrdi; 
....................     
....................    //     76543210     
....................    wren=0b00000110; 
*
0269E:  MOV.B   #6,W0L
026A0:  MOV.B   W0L,8B6
....................    //      76543210  
....................    write=0b00000010; 
026A2:  MOV.B   #2,W0L
026A4:  MOV.B   W0L,8B7
....................    //     76543210 
....................    wrdi=0b00000100; 
026A6:  MOV.B   #4,W0L
026A8:  MOV.B   W0L,8B8
....................     
....................    cmd[0]=data; 
026AA:  MOV.B   8B0,W0L
026AC:  MOV.B   W0L,8B2
....................    cmd[1]=address; 
026AE:  MOV.B   8AE,W0L
026B0:  MOV.B   W0L,8B3
....................    cmd[2]=address/256; 
026B2:  MOV.B   8AF,W0L
026B4:  MOV.B   W0L,8B4
....................    cmd[3]=write; 
026B6:  MOV.B   8B7,W0L
026B8:  MOV.B   W0L,8B5
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    output_low(FR_CS); 
026BA:  BCLR.B  2E4.7
026BC:  BCLR.B  2E8.7
....................    delay_us(1); 
026BE:  NOP     
....................    for(i=0; i<8; ++i) 
026C0:  CLR.B   8B1
026C2:  MOV     8B0,W4
026C4:  LSR     W4,#8,W4
026C6:  CP.B    W4L,#8
026C8:  BRA     C,26F2
....................    { 
....................       output_bit(FR_SI, shift_left(&wren,1,0)); 
026CA:  BCLR.B  42.0
026CC:  RLC.B   8B6
026CE:  BRA     C,26D4
026D0:  BCLR.B  2DC.6
026D2:  BRA     26D6
026D4:  BSET.B  2DC.6
026D6:  BCLR.B  2D8.6
....................       delay_us(1); 
026D8:  NOP     
....................       output_high(FR_SCK); 
026DA:  BCLR.B  2D8.5
026DC:  BSET.B  2DC.5
....................       delay_us(1); 
026DE:  NOP     
....................       output_low(FR_SI); 
026E0:  BCLR.B  2D8.6
026E2:  BCLR.B  2DC.6
....................       delay_us(1); 
026E4:  NOP     
....................       output_low(FR_SCK); 
026E6:  BCLR.B  2D8.5
026E8:  BCLR.B  2DC.5
....................       delay_us(1); 
026EA:  NOP     
....................    } 
026EC:  INC.B   08B1
026EE:  GOTO    26C2
....................    delay_us(1); 
026F2:  NOP     
....................    output_high(FR_CS); 
026F4:  BCLR.B  2E4.7
026F6:  BSET.B  2E8.7
....................    delay_us(1); 
026F8:  NOP     
....................     
....................    output_low(FR_CS); 
026FA:  BCLR.B  2E4.7
026FC:  BCLR.B  2E8.7
....................    delay_us(1); 
026FE:  NOP     
....................    for(i=0; i<32; ++i) 
02700:  CLR.B   8B1
02702:  MOV     8B0,W4
02704:  LSR     W4,#8,W4
02706:  MOV     #20,W3
02708:  CP.B    W3L,W4L
0270A:  BRA     LEU,2736
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,4,0)); 
0270C:  BCLR.B  42.0
0270E:  RLC     8B2
02710:  RLC     8B4
02712:  BRA     C,2718
02714:  BCLR.B  2DC.6
02716:  BRA     271A
02718:  BSET.B  2DC.6
0271A:  BCLR.B  2D8.6
....................       delay_us(1); 
0271C:  NOP     
....................       output_high(FR_SCK); 
0271E:  BCLR.B  2D8.5
02720:  BSET.B  2DC.5
....................       delay_us(1); 
02722:  NOP     
....................       output_low(FR_SI); 
02724:  BCLR.B  2D8.6
02726:  BCLR.B  2DC.6
....................       delay_us(1); 
02728:  NOP     
....................       output_low(FR_SCK); 
0272A:  BCLR.B  2D8.5
0272C:  BCLR.B  2DC.5
....................       delay_us(1); 
0272E:  NOP     
....................    } 
02730:  INC.B   08B1
02732:  GOTO    2702
....................    delay_us(1); 
02736:  NOP     
....................    output_high(FR_CS); 
02738:  BCLR.B  2E4.7
0273A:  BSET.B  2E8.7
....................    delay_us(1); 
0273C:  NOP     
....................     
....................    output_low(FR_CS); 
0273E:  BCLR.B  2E4.7
02740:  BCLR.B  2E8.7
....................    delay_us(1); 
02742:  NOP     
....................    for(i=0; i<8; ++i) 
02744:  CLR.B   8B1
02746:  MOV     8B0,W4
02748:  LSR     W4,#8,W4
0274A:  CP.B    W4L,#8
0274C:  BRA     C,2776
....................    { 
....................       output_bit(FR_SI, shift_left(&wrdi,1,0)); 
0274E:  BCLR.B  42.0
02750:  RLC.B   8B8
02752:  BRA     C,2758
02754:  BCLR.B  2DC.6
02756:  BRA     275A
02758:  BSET.B  2DC.6
0275A:  BCLR.B  2D8.6
....................       delay_us(1); 
0275C:  NOP     
....................       output_high(FR_SCK); 
0275E:  BCLR.B  2D8.5
02760:  BSET.B  2DC.5
....................       delay_us(1); 
02762:  NOP     
....................       output_low(FR_SI); 
02764:  BCLR.B  2D8.6
02766:  BCLR.B  2DC.6
....................       delay_us(1); 
02768:  NOP     
....................       output_low(FR_SCK); 
0276A:  BCLR.B  2D8.5
0276C:  BCLR.B  2DC.5
....................       delay_us(1); 
0276E:  NOP     
....................    } 
02770:  INC.B   08B1
02772:  GOTO    2746
....................    delay_us(1); 
02776:  NOP     
....................    output_high(FR_CS); 
02778:  BCLR.B  2E4.7
0277A:  BSET.B  2E8.7
....................    delay_us(1); 
0277C:  NOP     
.................... } 
0277E:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... unsigned int8 fr_read_byte(unsigned int16 address)  
.................... { 
....................    unsigned int8 cmd[3]; 
....................    unsigned int8 i,data; 
....................    unsigned int8 read; 
....................     
....................    //     76543210  
....................    read=0b00000011; 
*
0205E:  MOV.B   #3,W0L
02060:  MOV.B   W0L,8B7
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Read on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    cmd[0]=address; 
02062:  MOV.B   8B0,W0L
02064:  MOV.B   W0L,8B2
....................    cmd[1]=address/256; 
02066:  MOV.B   8B1,W0L
02068:  MOV.B   W0L,8B3
....................    cmd[2]=read; 
0206A:  MOV.B   8B7,W0L
0206C:  MOV.B   W0L,8B4
....................  
....................    output_low(FR_CS); 
0206E:  BCLR.B  2E4.7
02070:  BCLR.B  2E8.7
....................    delay_us(1); 
02072:  NOP     
....................    for(i=0; i<24; ++i) 
02074:  CLR.B   8B5
02076:  MOV     8B4,W4
02078:  LSR     W4,#8,W4
0207A:  CP.B    W4L,#18
0207C:  BRA     C,20A8
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,3,0)); 
0207E:  BCLR.B  42.0
02080:  RLC     8B2
02082:  RLC.B   8B4
02084:  BRA     C,208A
02086:  BCLR.B  2DC.6
02088:  BRA     208C
0208A:  BSET.B  2DC.6
0208C:  BCLR.B  2D8.6
....................       delay_us(1); 
0208E:  NOP     
....................       output_high(FR_SCK); 
02090:  BCLR.B  2D8.5
02092:  BSET.B  2DC.5
....................       delay_us(1); 
02094:  NOP     
....................       output_low(FR_SI); 
02096:  BCLR.B  2D8.6
02098:  BCLR.B  2DC.6
....................       delay_us(1); 
0209A:  NOP     
....................       output_low(FR_SCK); 
0209C:  BCLR.B  2D8.5
0209E:  BCLR.B  2DC.5
....................       delay_us(1); 
020A0:  NOP     
....................    } 
020A2:  INC.B   08B5
020A4:  GOTO    2076
....................    for(i=0; i<8; ++i) 
020A8:  CLR.B   8B5
020AA:  MOV     8B4,W4
020AC:  LSR     W4,#8,W4
020AE:  CP.B    W4L,#8
020B0:  BRA     C,20D6
....................    { 
....................       delay_us(1); 
020B2:  NOP     
....................       shift_left(&data,1,input(FR_SO)); 
020B4:  BSET.B  2D8.7
020B6:  BTSC.B  2DA.7
020B8:  BRA     20BE
020BA:  BCLR.B  42.0
020BC:  BRA     20C0
020BE:  BSET.B  42.0
020C0:  RLC.B   8B6
....................       output_high(FR_SCK); 
020C2:  BCLR.B  2D8.5
020C4:  BSET.B  2DC.5
....................       delay_us(1); 
020C6:  NOP     
....................       delay_us(1); 
020C8:  NOP     
....................       output_low(FR_SCK); 
020CA:  BCLR.B  2D8.5
020CC:  BCLR.B  2DC.5
....................       delay_us(1); 
020CE:  NOP     
....................    } 
020D0:  INC.B   08B5
020D2:  GOTO    20AA
....................    output_high(FR_CS); 
020D6:  BCLR.B  2E4.7
020D8:  BSET.B  2E8.7
....................    delay_us(1); 
020DA:  NOP     
....................     
....................    return(data); 
020DC:  MOV.B   8B6,W0L
020DE:  MOV.B   W0L,0
.................... } 
020E0:  RETURN  
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... void fr_write(unsigned int16 address,unsigned int16 data) 
.................... { 
*
02780:  MOV     W5,[W15++]
....................    unsigned int8 data_high; 
....................    unsigned int8 data_low; 
....................    data_low=(unsigned int8)data; 
02782:  MOV.B   8A2,W0L
02784:  MOV.B   W0L,8A5
....................    data_high=(unsigned int8)(data>>8); 
02786:  MOV.B   8A3,W0L
02788:  CLR.B   1
0278A:  MOV.B   W0L,8A4
....................     
....................    fr_write_byte(address,data_low); 
0278C:  MOV.B   8A5,W0L
0278E:  MOV.B   W0L,8B0
02790:  PUSH    8A0
02792:  POP     8AE
02794:  CALL    269E
....................    fr_write_byte(address+1,data_high); 
02798:  MOV     8A0,W4
0279A:  ADD     W4,#1,W4
0279C:  MOV     W4,W5
0279E:  MOV.B   8A4,W0L
027A0:  MOV.B   W0L,8B0
027A2:  MOV     W5,8AE
027A4:  CALL    269E
....................     
....................    return; 
.................... } 
027A8:  MOV     [--W15],W5
027AA:  RETURN  
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... unsigned int16 fr_read(unsigned int16 address) 
.................... { 
*
020E2:  MOV     W5,[W15++]
....................    unsigned int16 data_buffer; 
....................    unsigned int16 data_low; 
....................    unsigned int16 data_high; 
....................     
....................    data_low=fr_read_byte(address); 
020E4:  PUSH    8A2
020E6:  POP     8B0
020E8:  CALL    205E
020EC:  MOV.B   W0L,8A6
020EE:  CLR.B   8A7
....................    data_high=fr_read_byte(address+1); 
020F0:  MOV     8A2,W4
020F2:  ADD     W4,#1,W4
020F4:  MOV     W4,W5
020F6:  MOV     W5,8B0
020F8:  CALL    205E
020FC:  MOV.B   W0L,8A8
020FE:  CLR.B   8A9
....................     
....................    data_buffer=(data_high<<8)+data_low; 
02100:  MOV.B   8A8,W0L
02102:  MOV.B   W0L,B
02104:  CLR.B   W5
02106:  MOV     W5,W0
02108:  ADD     8A6,W0
0210A:  MOV     W0,8A4
....................     
....................    return data_buffer; 
0210C:  PUSH    8A4
0210E:  POP     0
.................... } 
02110:  MOV     [--W15],W5
02112:  RETURN  
....................  
.................... // Returns serial number of the device via RS232 
.................... void data_get_serial_no() 
.................... { 
*
03E6E:  MOV     W5,[W15++]
03E70:  MOV     W6,[W15++]
....................    if(!debug_mode_fr)  
03E72:  BTSC.B  800.2
03E74:  BRA     3E78
....................       return; 
03E76:  BRA     3EE2
....................        
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
03E78:  CLR.B   892
....................     
....................    fprintf(RS232, "Serial No:"); 
03E7A:  MOV     #0,W1
03E7C:  MOV     W1,W0
03E7E:  CALL    35A
03E82:  INC     W1,W1
03E84:  MOV     W1,[W15++]
03E86:  BTSC.B  219.1
03E88:  BRA     3E86
03E8A:  MOV     W0,21A
03E8C:  MOV     [--W15],W1
03E8E:  MOV     #9,W0
03E90:  CPSGT   W1,W0
03E92:  BRA     3E7C
....................    for(i=0; i<13; i++) 
03E94:  CLR.B   892
03E96:  MOV     892,W4
03E98:  CP.B    W4L,#D
03E9A:  BRA     C,3ED2
....................    { 
....................       input[i]=fr_read_byte(fr_serial_no+i); 
03E9C:  MOV     892,W4
03E9E:  CLR.B   9
03EA0:  MOV     #894,W3
03EA2:  ADD     W4,W3,W5
03EA4:  MOV     892,W4
03EA6:  CLR.B   9
03EA8:  MOV     832,W3
03EAA:  ADD     W3,W4,W6
03EAC:  MOV     W6,8B0
03EAE:  CALL    205E
03EB2:  MOV.B   W0L,[W5]
....................       fputc(input[i]+48,RS232); 
03EB4:  MOV     892,W4
03EB6:  CLR.B   9
03EB8:  MOV     #894,W3
03EBA:  ADD     W4,W3,W0
03EBC:  MOV     #30,W4
03EBE:  MOV.B   [W0],W3L
03EC0:  ADD.B   W3L,W4L,W5L
03EC2:  MOV.B   W5L,W0L
03EC4:  BTSC.B  219.1
03EC6:  BRA     3EC4
03EC8:  MOV.B   W0L,21A
03ECA:  CLR.B   21B
....................    } 
03ECC:  INC.B   0892
03ECE:  GOTO    3E96
....................    fprintf(RS232, "\n\r"); 
03ED2:  BTSC.B  219.1
03ED4:  BRA     3ED2
03ED6:  MOV     #A,W4
03ED8:  MOV     W4,21A
03EDA:  BTSC.B  219.1
03EDC:  BRA     3EDA
03EDE:  MOV     #D,W4
03EE0:  MOV     W4,21A
.................... } 
03EE2:  MOV     [--W15],W6
03EE4:  MOV     [--W15],W5
03EE6:  RETURN  
.................... // Returns movement range of the device 
.................... unsigned int16 data_get_move_range() 
.................... { 
*
02114:  PUSH    834
02116:  POP     8A2
02118:  CALL    20E2
0211C:  MOV     W0,892
....................    unsigned int16 range = fr_read(fr_move_range); 
....................     
....................    if(debug_mode_fr)  
0211E:  BTSS.B  800.2
02120:  BRA     215E
....................       fprintf(RS232, "Movement Range: %u mm\n\r", range); 
02122:  MOV     #0,W1
02124:  MOV     W1,W0
02126:  CALL    376
0212A:  INC     W1,W1
0212C:  MOV     W1,[W15++]
0212E:  BTSC.B  219.1
02130:  BRA     212E
02132:  MOV     W0,21A
02134:  MOV     [--W15],W1
02136:  MOV     #F,W0
02138:  CPSGT   W1,W0
0213A:  BRA     2124
0213C:  MOV     892,W0
0213E:  MOV     #0,W4
02140:  CALL    169A
02144:  MOV     #12,W1
02146:  MOV     W1,W0
02148:  CALL    376
0214C:  INC     W1,W1
0214E:  MOV     W1,[W15++]
02150:  BTSC.B  219.1
02152:  BRA     2150
02154:  MOV     W0,21A
02156:  MOV     [--W15],W1
02158:  MOV     #16,W0
0215A:  CPSGT   W1,W0
0215C:  BRA     2146
....................     
....................    return range; 
0215E:  PUSH    892
02160:  POP     0
.................... } 
02162:  RETURN  
.................... // Returns home position 
.................... unsigned int16 data_get_home_pos() 
.................... { 
02164:  PUSH    836
02166:  POP     8A2
02168:  CALL    20E2
0216C:  MOV     W0,8A0
....................    unsigned int16 home_pos = fr_read(fr_home_pos); 
....................     
....................    if(debug_mode_fr)  
0216E:  BTSS.B  800.2
02170:  BRA     21AE
....................       fprintf(RS232, "Home Distance: %u counts\n\r", home_pos); 
02172:  MOV     #0,W1
02174:  MOV     W1,W0
02176:  CALL    39E
0217A:  INC     W1,W1
0217C:  MOV     W1,[W15++]
0217E:  BTSC.B  219.1
02180:  BRA     217E
02182:  MOV     W0,21A
02184:  MOV     [--W15],W1
02186:  MOV     #E,W0
02188:  CPSGT   W1,W0
0218A:  BRA     2174
0218C:  MOV     8A0,W0
0218E:  MOV     #0,W4
02190:  CALL    169A
02194:  MOV     #11,W1
02196:  MOV     W1,W0
02198:  CALL    39E
0219C:  INC     W1,W1
0219E:  MOV     W1,[W15++]
021A0:  BTSC.B  219.1
021A2:  BRA     21A0
021A4:  MOV     W0,21A
021A6:  MOV     [--W15],W1
021A8:  MOV     #19,W0
021AA:  CPSGT   W1,W0
021AC:  BRA     2196
....................        
....................    return home_pos; 
021AE:  PUSH    8A0
021B0:  POP     0
.................... } 
021B2:  RETURN  
.................... // Returns end position 
.................... unsigned int16 data_get_end_pos() 
.................... { 
021B4:  PUSH    838
021B6:  POP     8A2
021B8:  CALL    20E2
021BC:  MOV     W0,892
....................    unsigned int16 end = fr_read(fr_end_pos); 
....................     
....................    if(debug_mode_fr) 
021BE:  BTSS.B  800.2
021C0:  BRA     21FE
....................       fprintf(RS232, "End Distance: %u counts\n\r", end); 
021C2:  MOV     #0,W1
021C4:  MOV     W1,W0
021C6:  CALL    3CA
021CA:  INC     W1,W1
021CC:  MOV     W1,[W15++]
021CE:  BTSC.B  219.1
021D0:  BRA     21CE
021D2:  MOV     W0,21A
021D4:  MOV     [--W15],W1
021D6:  MOV     #D,W0
021D8:  CPSGT   W1,W0
021DA:  BRA     21C4
021DC:  MOV     892,W0
021DE:  MOV     #0,W4
021E0:  CALL    169A
021E4:  MOV     #10,W1
021E6:  MOV     W1,W0
021E8:  CALL    3CA
021EC:  INC     W1,W1
021EE:  MOV     W1,[W15++]
021F0:  BTSC.B  219.1
021F2:  BRA     21F0
021F4:  MOV     W0,21A
021F6:  MOV     [--W15],W1
021F8:  MOV     #18,W0
021FA:  CPSGT   W1,W0
021FC:  BRA     21E6
....................     
....................    return end; 
021FE:  PUSH    892
02200:  POP     0
.................... } 
02202:  RETURN  
.................... // Returns positioning velocity 
.................... unsigned int16 data_get_conv_const() 
.................... { 
*
02298:  PUSH    83A
0229A:  POP     8A2
0229C:  CALL    20E2
022A0:  MOV     W0,892
....................    unsigned int16 conv_const = fr_read(fr_conv_const); 
....................     
....................    if((conv_const < 12000)||(conv_const > 13000)) 
022A2:  MOV     892,W4
022A4:  MOV     #2EE0,W3
022A6:  CP      W3,W4
022A8:  BRA     GTU,22B2
022AA:  MOV     892,W4
022AC:  MOV     #32C8,W3
022AE:  CP      W3,W4
022B0:  BRA     C,22B6
....................       conv_const = 12500; 
022B2:  MOV     #30D4,W4
022B4:  MOV     W4,892
....................     
....................    if(debug_mode_fr)  
022B6:  BTSS.B  800.2
022B8:  BRA     22F4
....................       fprintf(RS232, "Conversion Constant: %u \n\r", conv_const); 
022BA:  MOV     #0,W1
022BC:  MOV     W1,W0
022BE:  CALL    3F4
022C2:  INC     W1,W1
022C4:  MOV     W1,[W15++]
022C6:  BTSC.B  219.1
022C8:  BRA     22C6
022CA:  MOV     W0,21A
022CC:  MOV     [--W15],W1
022CE:  MOV     #14,W0
022D0:  CPSGT   W1,W0
022D2:  BRA     22BC
022D4:  MOV     892,W0
022D6:  MOV     #0,W4
022D8:  CALL    169A
022DC:  BTSC.B  219.1
022DE:  BRA     22DC
022E0:  MOV     #20,W4
022E2:  MOV     W4,21A
022E4:  BTSC.B  219.1
022E6:  BRA     22E4
022E8:  MOV     #A,W4
022EA:  MOV     W4,21A
022EC:  BTSC.B  219.1
022EE:  BRA     22EC
022F0:  MOV     #D,W4
022F2:  MOV     W4,21A
....................     
....................    return conv_const; 
022F4:  PUSH    892
022F6:  POP     0
.................... } 
022F8:  RETURN  
.................... // Returns the backlash of the system 
.................... unsigned int16 data_get_backlash() 
.................... { 
*
02204:  PUSH    83C
02206:  POP     8A2
02208:  CALL    20E2
0220C:  MOV     W0,892
....................    unsigned int16 backlash = fr_read(fr_backlash); 
....................  
....................    if(debug_mode_fr)  
0220E:  BTSS.B  800.2
02210:  BRA     224E
....................       fprintf(RS232, "Backlash: %u counts\n\r", backlash); 
02212:  MOV     #0,W1
02214:  MOV     W1,W0
02216:  CALL    420
0221A:  INC     W1,W1
0221C:  MOV     W1,[W15++]
0221E:  BTSC.B  219.1
02220:  BRA     221E
02222:  MOV     W0,21A
02224:  MOV     [--W15],W1
02226:  MOV     #9,W0
02228:  CPSGT   W1,W0
0222A:  BRA     2214
0222C:  MOV     892,W0
0222E:  MOV     #0,W4
02230:  CALL    169A
02234:  MOV     #C,W1
02236:  MOV     W1,W0
02238:  CALL    420
0223C:  INC     W1,W1
0223E:  MOV     W1,[W15++]
02240:  BTSC.B  219.1
02242:  BRA     2240
02244:  MOV     W0,21A
02246:  MOV     [--W15],W1
02248:  MOV     #14,W0
0224A:  CPSGT   W1,W0
0224C:  BRA     2236
....................     
....................    return backlash; 
0224E:  PUSH    892
02250:  POP     0
.................... } 
02252:  RETURN  
.................... // Returns communication type 
.................... unsigned int8 data_get_comm_type() 
.................... { 
*
0322C:  PUSH    83E
0322E:  POP     8B0
03230:  CALL    205E
03234:  MOV.B   W0L,892
....................    unsigned int8 comm_type=fr_read_byte(fr_comm_type); 
....................     
....................    if(debug_mode_fr) 
03236:  BTSS.B  800.2
03238:  BRA     32A2
....................       switch (comm_type) 
....................       { 
0323A:  MOV.B   892,W0L
0323C:  CLR.B   1
0323E:  XOR     #0,W0
03240:  BRA     Z,3248
03242:  XOR     #1,W0
03244:  BRA     Z,3266
03246:  BRA     3284
....................          case 0   :  fprintf(RS232,"Communication Type: Parallel Port\n\r"); 
03248:  MOV     #0,W1
0324A:  MOV     W1,W0
0324C:  CALL    446
03250:  INC     W1,W1
03252:  MOV     W1,[W15++]
03254:  BTSC.B  219.1
03256:  BRA     3254
03258:  MOV     W0,21A
0325A:  MOV     [--W15],W1
0325C:  MOV     #22,W0
0325E:  CPSGT   W1,W0
03260:  BRA     324A
....................                      break; 
03262:  GOTO    32A2
....................          case 1   :  fprintf(RS232,"Communication Type: Serial Port\n\r"); 
03266:  MOV     #0,W1
03268:  MOV     W1,W0
0326A:  CALL    47A
0326E:  INC     W1,W1
03270:  MOV     W1,[W15++]
03272:  BTSC.B  219.1
03274:  BRA     3272
03276:  MOV     W0,21A
03278:  MOV     [--W15],W1
0327A:  MOV     #20,W0
0327C:  CPSGT   W1,W0
0327E:  BRA     3268
....................                      break; 
03280:  GOTO    32A2
....................          default  :  fprintf(RS232,"Communication Type: Undefined\n\r"); 
03284:  MOV     #0,W1
03286:  MOV     W1,W0
03288:  CALL    4AC
0328C:  INC     W1,W1
0328E:  MOV     W1,[W15++]
03290:  BTSC.B  219.1
03292:  BRA     3290
03294:  MOV     W0,21A
03296:  MOV     [--W15],W1
03298:  MOV     #1E,W0
0329A:  CPSGT   W1,W0
0329C:  BRA     3286
....................                      break; 
0329E:  GOTO    32A2
....................       } 
....................        
....................    return comm_type; 
032A2:  MOV.B   892,W0L
032A4:  MOV.B   W0L,0
.................... } 
032A6:  RETURN  
.................... // Returns last position 
.................... unsigned int16 data_get_last_pos() 
.................... { 
*
0264E:  PUSH    840
02650:  POP     8A2
02652:  CALL    20E2
02656:  MOV     W0,892
....................    unsigned int16 position=fr_read(fr_last_pos); 
....................     
....................    if(debug_mode_fr)  
02658:  BTSS.B  800.2
0265A:  BRA     2698
....................       fprintf(RS232, "Last Position: %u mm\n\r", position); 
0265C:  MOV     #0,W1
0265E:  MOV     W1,W0
02660:  CALL    4DC
02664:  INC     W1,W1
02666:  MOV     W1,[W15++]
02668:  BTSC.B  219.1
0266A:  BRA     2668
0266C:  MOV     W0,21A
0266E:  MOV     [--W15],W1
02670:  MOV     #E,W0
02672:  CPSGT   W1,W0
02674:  BRA     265E
02676:  MOV     892,W0
02678:  MOV     #0,W4
0267A:  CALL    169A
0267E:  MOV     #11,W1
02680:  MOV     W1,W0
02682:  CALL    4DC
02686:  INC     W1,W1
02688:  MOV     W1,[W15++]
0268A:  BTSC.B  219.1
0268C:  BRA     268A
0268E:  MOV     W0,21A
02690:  MOV     [--W15],W1
02692:  MOV     #15,W0
02694:  CPSGT   W1,W0
02696:  BRA     2680
....................     
....................    return position; 
02698:  PUSH    892
0269A:  POP     0
.................... } 
0269C:  RETURN  
.................... // Returns the position in the given index 
.................... unsigned int16 data_get_pos(unsigned int8 index) 
.................... { 
*
03816:  MOV     W5,[W15++]
03818:  MOV.B   898,W0L
0381A:  SL      W0,#1,W0
0381C:  ZE      W0,W0
0381E:  CLR.B   1
03820:  MOV     842,W4
03822:  ADD     W0,W4,W5
03824:  MOV     W5,8A2
03826:  CALL    20E2
0382A:  MOV     W0,89A
....................    unsigned int16 position=fr_read(fr_pos_table+index*2); 
....................     
....................    if(debug_mode_fr) 
0382C:  BTSS.B  800.2
0382E:  BRA     3890
....................       fprintf(RS232,"Index: %u, Position: %u mm\n\r", index, position); 
03830:  MOV     #0,W1
03832:  MOV     W1,W0
03834:  CALL    504
03838:  INC     W1,W1
0383A:  MOV     W1,[W15++]
0383C:  BTSC.B  219.1
0383E:  BRA     383C
03840:  MOV     W0,21A
03842:  MOV     [--W15],W1
03844:  MOV     #6,W0
03846:  CPSGT   W1,W0
03848:  BRA     3832
0384A:  MOV.B   898,W0L
0384C:  CLR.B   1
0384E:  MOV     #0,W4
03850:  CALL    169A
03854:  MOV     #9,W1
03856:  MOV     W1,W0
03858:  CALL    504
0385C:  INC     W1,W1
0385E:  MOV     W1,[W15++]
03860:  BTSC.B  219.1
03862:  BRA     3860
03864:  MOV     W0,21A
03866:  MOV     [--W15],W1
03868:  MOV     #14,W0
0386A:  CPSGT   W1,W0
0386C:  BRA     3856
0386E:  MOV     89A,W0
03870:  MOV     #0,W4
03872:  CALL    169A
03876:  MOV     #17,W1
03878:  MOV     W1,W0
0387A:  CALL    504
0387E:  INC     W1,W1
03880:  MOV     W1,[W15++]
03882:  BTSC.B  219.1
03884:  BRA     3882
03886:  MOV     W0,21A
03888:  MOV     [--W15],W1
0388A:  MOV     #1B,W0
0388C:  CPSGT   W1,W0
0388E:  BRA     3878
....................     
....................    return position; 
03890:  PUSH    89A
03892:  POP     0
.................... } 
03894:  MOV     [--W15],W5
03896:  RETURN  
.................... // Returns position table via RS232 
.................... void data_get_pos_table() 
.................... { 
*
03F38:  MOV     W5,[W15++]
....................    debug_mode_fr=1; 
03F3A:  BSET.B  800.2
....................     
....................    unsigned int input; 
....................    unsigned int i; 
....................    unsigned int index; 
....................     
....................    input=(unsigned)(fgetc(RS232)-48); 
03F3C:  BTSS.B  218.0
03F3E:  BRA     3F3C
03F40:  MOV     21C,W0
03F42:  MOV     #30,W4
03F44:  SUB.B   W0L,W4L,W0L
03F46:  MOV.B   W0L,892
03F48:  CLR.B   893
....................    fputc(input+48,RS232); 
03F4A:  MOV     #30,W4
03F4C:  MOV     892,W3
03F4E:  ADD     W3,W4,W5
03F50:  MOV.B   W5L,W0L
03F52:  BTSC.B  219.1
03F54:  BRA     3F52
03F56:  MOV.B   W0L,21A
03F58:  CLR.B   21B
....................  
....................    if(input>9) 
03F5A:  MOV     892,W4
03F5C:  CP      W4,#9
03F5E:  BRA     LEU,3F64
....................       input=9; 
03F60:  MOV     #9,W4
03F62:  MOV     W4,892
....................  
....................    fprintf(RS232,"\n\r"); 
03F64:  BTSC.B  219.1
03F66:  BRA     3F64
03F68:  MOV     #A,W4
03F6A:  MOV     W4,21A
03F6C:  BTSC.B  219.1
03F6E:  BRA     3F6C
03F70:  MOV     #D,W4
03F72:  MOV     W4,21A
....................     
....................    for(i=0; i<10; i++) 
03F74:  CLR     894
03F76:  MOV     894,W4
03F78:  CP      W4,#A
03F7A:  BRA     C,3F96
....................    { 
....................       index=input*10+i; 
03F7C:  MOV     892,W4
03F7E:  MUL.UU  W4,#A,W0
03F80:  MOV     W0,W5
03F82:  MOV     W5,W0
03F84:  ADD     894,W0
03F86:  MOV     W0,896
....................       data_get_pos(index); 
03F88:  MOV.B   896,W0L
03F8A:  MOV.B   W0L,898
03F8C:  CALL    3816
....................    } 
03F90:  INC     0894
03F92:  GOTO    3F76
....................     
....................    debug_mode_fr=0; 
03F96:  BCLR.B  800.2
.................... } 
03F98:  MOV     [--W15],W5
03F9A:  RETURN  
.................... // Returns all system data via RS232 
.................... void data_get_sys_data() 
.................... { 
....................    fprintf(RS232,"MODESIS LASER POSITIONING SYSTEM\n\n\r"); 
*
03EE8:  MOV     #0,W1
03EEA:  MOV     W1,W0
03EEC:  CALL    532
03EF0:  INC     W1,W1
03EF2:  MOV     W1,[W15++]
03EF4:  BTSC.B  219.1
03EF6:  BRA     3EF4
03EF8:  MOV     W0,21A
03EFA:  MOV     [--W15],W1
03EFC:  MOV     #22,W0
03EFE:  CPSGT   W1,W0
03F00:  BRA     3EEA
....................    debug_mode_fr=1; 
03F02:  BSET.B  800.2
....................    data_get_serial_no(); 
03F04:  CALL    3E6E
....................    data_get_move_range(); 
03F08:  CALL    2114
....................    data_get_home_pos(); 
03F0C:  CALL    2164
....................    data_get_end_pos(); 
03F10:  CALL    21B4
....................    data_get_conv_const(); 
03F14:  CALL    2298
....................    data_get_backlash(); 
03F18:  CALL    2204
....................    data_get_comm_type(); 
03F1C:  CALL    322C
....................    data_get_last_pos(); 
03F20:  CALL    264E
....................    debug_mode_fr=0; 
03F24:  BCLR.B  800.2
....................    fprintf(RS232,"\n\r"); 
03F26:  BTSC.B  219.1
03F28:  BRA     3F26
03F2A:  MOV     #A,W4
03F2C:  MOV     W4,21A
03F2E:  BTSC.B  219.1
03F30:  BRA     3F2E
03F32:  MOV     #D,W4
03F34:  MOV     W4,21A
.................... } 
03F36:  RETURN  
.................... // Returns the reset register state of he microcontroller 
.................... void data_get_reset_state() 
.................... { 
*
01750:  MOV     W5,[W15++]
....................    fprintf(RS232,"RCON REGISTER VALUE(10'luk Tabanda):  "); 
01752:  MOV     #0,W1
01754:  MOV     W1,W0
01756:  CALL    566
0175A:  INC     W1,W1
0175C:  MOV     W1,[W15++]
0175E:  BTSC.B  219.1
01760:  BRA     175E
01762:  MOV     W0,21A
01764:  MOV     [--W15],W1
01766:  MOV     #25,W0
01768:  CPSGT   W1,W0
0176A:  BRA     1754
....................    fprintf(RS232,"%u",RCON); 
0176C:  MOV     740,W0
0176E:  MOV     #0,W4
01770:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
01774:  BTSC.B  219.1
01776:  BRA     1774
01778:  MOV     #A,W4
0177A:  MOV     W4,21A
0177C:  BTSC.B  219.1
0177E:  BRA     177C
01780:  MOV     #D,W4
01782:  MOV     W4,21A
....................    fprintf(RS232,"RCON REGISTER BITLERI:"); 
01784:  MOV     #0,W1
01786:  MOV     W1,W0
01788:  CALL    59E
0178C:  INC     W1,W1
0178E:  MOV     W1,[W15++]
01790:  BTSC.B  219.1
01792:  BRA     1790
01794:  MOV     W0,21A
01796:  MOV     [--W15],W1
01798:  MOV     #15,W0
0179A:  CPSGT   W1,W0
0179C:  BRA     1786
....................    fprintf(RS232,"\n\r"); 
0179E:  BTSC.B  219.1
017A0:  BRA     179E
017A2:  MOV     #A,W4
017A4:  MOV     W4,21A
017A6:  BTSC.B  219.1
017A8:  BRA     17A6
017AA:  MOV     #D,W4
017AC:  MOV     W4,21A
....................     
....................    fprintf(RS232,"POR:    "); 
017AE:  MOV     #0,W1
017B0:  MOV     W1,W0
017B2:  CALL    5C6
017B6:  INC     W1,W1
017B8:  MOV     W1,[W15++]
017BA:  BTSC.B  219.1
017BC:  BRA     17BA
017BE:  MOV     W0,21A
017C0:  MOV     [--W15],W1
017C2:  MOV     #7,W0
017C4:  CPSGT   W1,W0
017C6:  BRA     17B0
....................    fprintf(RS232,"%u",RCON_POR); 
017C8:  CLR.B   W0
017CA:  BTSC.B  740.0
017CC:  INC     W0,W0
017CE:  MOV.B   W0L,W5L
017D0:  MOV.B   W5L,W0L
017D2:  CLR.B   1
017D4:  MOV     #0,W4
017D6:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
017DA:  BTSC.B  219.1
017DC:  BRA     17DA
017DE:  MOV     #A,W4
017E0:  MOV     W4,21A
017E2:  BTSC.B  219.1
017E4:  BRA     17E2
017E6:  MOV     #D,W4
017E8:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BOR:    "); 
017EA:  MOV     #0,W1
017EC:  MOV     W1,W0
017EE:  CALL    5E0
017F2:  INC     W1,W1
017F4:  MOV     W1,[W15++]
017F6:  BTSC.B  219.1
017F8:  BRA     17F6
017FA:  MOV     W0,21A
017FC:  MOV     [--W15],W1
017FE:  MOV     #7,W0
01800:  CPSGT   W1,W0
01802:  BRA     17EC
....................    fprintf(RS232,"%u",RCON_BOR); 
01804:  CLR.B   W0
01806:  BTSC.B  740.1
01808:  INC     W0,W0
0180A:  MOV.B   W0L,W5L
0180C:  MOV.B   W5L,W0L
0180E:  CLR.B   1
01810:  MOV     #0,W4
01812:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
01816:  BTSC.B  219.1
01818:  BRA     1816
0181A:  MOV     #A,W4
0181C:  MOV     W4,21A
0181E:  BTSC.B  219.1
01820:  BRA     181E
01822:  MOV     #D,W4
01824:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IDLE:   "); 
01826:  MOV     #0,W1
01828:  MOV     W1,W0
0182A:  CALL    5FA
0182E:  INC     W1,W1
01830:  MOV     W1,[W15++]
01832:  BTSC.B  219.1
01834:  BRA     1832
01836:  MOV     W0,21A
01838:  MOV     [--W15],W1
0183A:  MOV     #7,W0
0183C:  CPSGT   W1,W0
0183E:  BRA     1828
....................    fprintf(RS232,"%u",RCON_IDLE); 
01840:  CLR.B   W0
01842:  BTSC.B  740.2
01844:  INC     W0,W0
01846:  MOV.B   W0L,W5L
01848:  MOV.B   W5L,W0L
0184A:  CLR.B   1
0184C:  MOV     #0,W4
0184E:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
01852:  BTSC.B  219.1
01854:  BRA     1852
01856:  MOV     #A,W4
01858:  MOV     W4,21A
0185A:  BTSC.B  219.1
0185C:  BRA     185A
0185E:  MOV     #D,W4
01860:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SLEEP:  "); 
01862:  MOV     #0,W1
01864:  MOV     W1,W0
01866:  CALL    614
0186A:  INC     W1,W1
0186C:  MOV     W1,[W15++]
0186E:  BTSC.B  219.1
01870:  BRA     186E
01872:  MOV     W0,21A
01874:  MOV     [--W15],W1
01876:  MOV     #7,W0
01878:  CPSGT   W1,W0
0187A:  BRA     1864
....................    fprintf(RS232,"%u",RCON_SLEEP); 
0187C:  CLR.B   W0
0187E:  BTSC.B  740.3
01880:  INC     W0,W0
01882:  MOV.B   W0L,W5L
01884:  MOV.B   W5L,W0L
01886:  CLR.B   1
01888:  MOV     #0,W4
0188A:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
0188E:  BTSC.B  219.1
01890:  BRA     188E
01892:  MOV     #A,W4
01894:  MOV     W4,21A
01896:  BTSC.B  219.1
01898:  BRA     1896
0189A:  MOV     #D,W4
0189C:  MOV     W4,21A
....................     
....................    fprintf(RS232,"WDTO:   "); 
0189E:  MOV     #0,W1
018A0:  MOV     W1,W0
018A2:  CALL    62E
018A6:  INC     W1,W1
018A8:  MOV     W1,[W15++]
018AA:  BTSC.B  219.1
018AC:  BRA     18AA
018AE:  MOV     W0,21A
018B0:  MOV     [--W15],W1
018B2:  MOV     #7,W0
018B4:  CPSGT   W1,W0
018B6:  BRA     18A0
....................    fprintf(RS232,"%u",RCON_WDTO); 
018B8:  CLR.B   W0
018BA:  BTSC.B  740.4
018BC:  INC     W0,W0
018BE:  MOV.B   W0L,W5L
018C0:  MOV.B   W5L,W0L
018C2:  CLR.B   1
018C4:  MOV     #0,W4
018C6:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
018CA:  BTSC.B  219.1
018CC:  BRA     18CA
018CE:  MOV     #A,W4
018D0:  MOV     W4,21A
018D2:  BTSC.B  219.1
018D4:  BRA     18D2
018D6:  MOV     #D,W4
018D8:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWDTEN: "); 
018DA:  MOV     #0,W1
018DC:  MOV     W1,W0
018DE:  CALL    648
018E2:  INC     W1,W1
018E4:  MOV     W1,[W15++]
018E6:  BTSC.B  219.1
018E8:  BRA     18E6
018EA:  MOV     W0,21A
018EC:  MOV     [--W15],W1
018EE:  MOV     #7,W0
018F0:  CPSGT   W1,W0
018F2:  BRA     18DC
....................    fprintf(RS232,"%u",RCON_SWDTEN); 
018F4:  CLR.B   W0
018F6:  BTSC.B  740.5
018F8:  INC     W0,W0
018FA:  MOV.B   W0L,W5L
018FC:  MOV.B   W5L,W0L
018FE:  CLR.B   1
01900:  MOV     #0,W4
01902:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
01906:  BTSC.B  219.1
01908:  BRA     1906
0190A:  MOV     #A,W4
0190C:  MOV     W4,21A
0190E:  BTSC.B  219.1
01910:  BRA     190E
01912:  MOV     #D,W4
01914:  MOV     W4,21A
....................     
....................    fprintf(RS232,"SWR:    "); 
01916:  MOV     #0,W1
01918:  MOV     W1,W0
0191A:  CALL    662
0191E:  INC     W1,W1
01920:  MOV     W1,[W15++]
01922:  BTSC.B  219.1
01924:  BRA     1922
01926:  MOV     W0,21A
01928:  MOV     [--W15],W1
0192A:  MOV     #7,W0
0192C:  CPSGT   W1,W0
0192E:  BRA     1918
....................    fprintf(RS232,"%u",RCON_SWR); 
01930:  CLR.B   W0
01932:  BTSC.B  740.6
01934:  INC     W0,W0
01936:  MOV.B   W0L,W5L
01938:  MOV.B   W5L,W0L
0193A:  CLR.B   1
0193C:  MOV     #0,W4
0193E:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
01942:  BTSC.B  219.1
01944:  BRA     1942
01946:  MOV     #A,W4
01948:  MOV     W4,21A
0194A:  BTSC.B  219.1
0194C:  BRA     194A
0194E:  MOV     #D,W4
01950:  MOV     W4,21A
....................     
....................    fprintf(RS232,"EXTR:   "); 
01952:  MOV     #0,W1
01954:  MOV     W1,W0
01956:  CALL    67C
0195A:  INC     W1,W1
0195C:  MOV     W1,[W15++]
0195E:  BTSC.B  219.1
01960:  BRA     195E
01962:  MOV     W0,21A
01964:  MOV     [--W15],W1
01966:  MOV     #7,W0
01968:  CPSGT   W1,W0
0196A:  BRA     1954
....................    fprintf(RS232,"%u",RCON_EXTR); 
0196C:  CLR.B   W0
0196E:  BTSC.B  740.7
01970:  INC     W0,W0
01972:  MOV.B   W0L,W5L
01974:  MOV.B   W5L,W0L
01976:  CLR.B   1
01978:  MOV     #0,W4
0197A:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
0197E:  BTSC.B  219.1
01980:  BRA     197E
01982:  MOV     #A,W4
01984:  MOV     W4,21A
01986:  BTSC.B  219.1
01988:  BRA     1986
0198A:  MOV     #D,W4
0198C:  MOV     W4,21A
....................     
....................    fprintf(RS232,"BGST:   "); 
0198E:  MOV     #0,W1
01990:  MOV     W1,W0
01992:  CALL    696
01996:  INC     W1,W1
01998:  MOV     W1,[W15++]
0199A:  BTSC.B  219.1
0199C:  BRA     199A
0199E:  MOV     W0,21A
019A0:  MOV     [--W15],W1
019A2:  MOV     #7,W0
019A4:  CPSGT   W1,W0
019A6:  BRA     1990
....................    fprintf(RS232,"%u",RCON_BGST); 
019A8:  CLR.B   W0
019AA:  BTSC.B  741.5
019AC:  INC     W0,W0
019AE:  MOV.B   W0L,W5L
019B0:  MOV.B   W5L,W0L
019B2:  CLR.B   1
019B4:  MOV     #0,W4
019B6:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
019BA:  BTSC.B  219.1
019BC:  BRA     19BA
019BE:  MOV     #A,W4
019C0:  MOV     W4,21A
019C2:  BTSC.B  219.1
019C4:  BRA     19C2
019C6:  MOV     #D,W4
019C8:  MOV     W4,21A
....................     
....................    fprintf(RS232,"IOPUWR: "); 
019CA:  MOV     #0,W1
019CC:  MOV     W1,W0
019CE:  CALL    6B0
019D2:  INC     W1,W1
019D4:  MOV     W1,[W15++]
019D6:  BTSC.B  219.1
019D8:  BRA     19D6
019DA:  MOV     W0,21A
019DC:  MOV     [--W15],W1
019DE:  MOV     #7,W0
019E0:  CPSGT   W1,W0
019E2:  BRA     19CC
....................    fprintf(RS232,"%u",RCON_IOPUWR); 
019E4:  CLR.B   W0
019E6:  BTSC.B  741.6
019E8:  INC     W0,W0
019EA:  MOV.B   W0L,W5L
019EC:  MOV.B   W5L,W0L
019EE:  CLR.B   1
019F0:  MOV     #0,W4
019F2:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
019F6:  BTSC.B  219.1
019F8:  BRA     19F6
019FA:  MOV     #A,W4
019FC:  MOV     W4,21A
019FE:  BTSC.B  219.1
01A00:  BRA     19FE
01A02:  MOV     #D,W4
01A04:  MOV     W4,21A
....................     
....................    fprintf(RS232,"TRAPR:  "); 
01A06:  MOV     #0,W1
01A08:  MOV     W1,W0
01A0A:  CALL    6CA
01A0E:  INC     W1,W1
01A10:  MOV     W1,[W15++]
01A12:  BTSC.B  219.1
01A14:  BRA     1A12
01A16:  MOV     W0,21A
01A18:  MOV     [--W15],W1
01A1A:  MOV     #7,W0
01A1C:  CPSGT   W1,W0
01A1E:  BRA     1A08
....................    fprintf(RS232,"%u",RCON_TRAPR); 
01A20:  CLR.B   W0
01A22:  BTSC.B  741.7
01A24:  INC     W0,W0
01A26:  MOV.B   W0L,W5L
01A28:  MOV.B   W5L,W0L
01A2A:  CLR.B   1
01A2C:  MOV     #0,W4
01A2E:  CALL    169A
....................    fprintf(RS232,"\n\r"); 
01A32:  BTSC.B  219.1
01A34:  BRA     1A32
01A36:  MOV     #A,W4
01A38:  MOV     W4,21A
01A3A:  BTSC.B  219.1
01A3C:  BRA     1A3A
01A3E:  MOV     #D,W4
01A40:  MOV     W4,21A
....................     
....................    fprintf(RS232,"Register Ekrana Yazdirilip Sifirlandi"); 
01A42:  MOV     #0,W1
01A44:  MOV     W1,W0
01A46:  CALL    6E4
01A4A:  INC     W1,W1
01A4C:  MOV     W1,[W15++]
01A4E:  BTSC.B  219.1
01A50:  BRA     1A4E
01A52:  MOV     W0,21A
01A54:  MOV     [--W15],W1
01A56:  MOV     #24,W0
01A58:  CPSGT   W1,W0
01A5A:  BRA     1A44
....................    fprintf(RS232,"\n\r"); 
01A5C:  BTSC.B  219.1
01A5E:  BRA     1A5C
01A60:  MOV     #A,W4
01A62:  MOV     W4,21A
01A64:  BTSC.B  219.1
01A66:  BRA     1A64
01A68:  MOV     #D,W4
01A6A:  MOV     W4,21A
....................    RCON = 0x0000; 
01A6C:  CLR     740
.................... } 
01A6E:  MOV     [--W15],W5
01A70:  RETURN  
....................  
.................... // Sets serial nuber of the device 
.................... void data_set_serial_no() 
.................... { 
*
03A06:  MOV     W5,[W15++]
03A08:  MOV     W6,[W15++]
03A0A:  CLR.B   892
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
....................    for(i=0; i<13; i++) 
03A0C:  CLR.B   892
03A0E:  MOV     892,W4
03A10:  CP.B    W4L,#D
03A12:  BRA     C,3A64
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03A14:  MOV     892,W4
03A16:  CLR.B   9
03A18:  MOV     #894,W3
03A1A:  ADD     W4,W3,W5
03A1C:  BTSS.B  218.0
03A1E:  BRA     3A1C
03A20:  MOV     21C,W0
03A22:  SUB.B   #30,W0L
03A24:  CLR.B   1
03A26:  MOV.B   W0L,[W5]
....................       fr_write_byte(fr_serial_no+i, input[i]); 
03A28:  MOV     892,W4
03A2A:  CLR.B   9
03A2C:  MOV     832,W3
03A2E:  ADD     W3,W4,W5
03A30:  MOV     892,W4
03A32:  CLR.B   9
03A34:  MOV     #894,W3
03A36:  ADD     W4,W3,W0
03A38:  MOV.B   [W0],W6L
03A3A:  PUSH    8B0
03A3C:  MOV.B   W6L,[W15-#2]
03A3E:  POP     8B0
03A40:  MOV     W5,8AE
03A42:  CALL    269E
....................       fputc(input[i]+48,RS232); 
03A46:  MOV     892,W4
03A48:  CLR.B   9
03A4A:  MOV     #894,W3
03A4C:  ADD     W4,W3,W0
03A4E:  MOV     #30,W4
03A50:  MOV.B   [W0],W3L
03A52:  ADD.B   W3L,W4L,W5L
03A54:  MOV.B   W5L,W0L
03A56:  BTSC.B  219.1
03A58:  BRA     3A56
03A5A:  MOV.B   W0L,21A
03A5C:  CLR.B   21B
....................    } 
03A5E:  INC.B   0892
03A60:  GOTO    3A0E
.................... } 
03A64:  MOV     [--W15],W6
03A66:  MOV     [--W15],W5
03A68:  RETURN  
.................... // Sets movement range of the device 
.................... void data_set_move_range() 
.................... { 
03A6A:  MOV     W5,[W15++]
03A6C:  MOV     W6,[W15++]
03A6E:  CLR.B   892
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0;i<4;i++) 
03A70:  CLR.B   892
03A72:  MOV     892,W4
03A74:  CP.B    W4L,#4
03A76:  BRA     C,3AAC
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03A78:  MOV.B   892,W0L
03A7A:  CLR.B   1
03A7C:  SL      W0,#1,W0
03A7E:  MOV     #894,W4
03A80:  ADD     W0,W4,W5
03A82:  BTSS.B  218.0
03A84:  BRA     3A82
03A86:  MOV     21C,W0
03A88:  SUB.B   #30,W0L
03A8A:  CLR.B   1
03A8C:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03A8E:  MOV.B   892,W0L
03A90:  CLR.B   1
03A92:  SL      W0,#1,W0
03A94:  MOV     #894,W4
03A96:  ADD     W0,W4,W0
03A98:  MOV     [W0],W5
03A9A:  ADD     #30,W5
03A9C:  MOV.B   W5L,W0L
03A9E:  BTSC.B  219.1
03AA0:  BRA     3A9E
03AA2:  MOV.B   W0L,21A
03AA4:  CLR.B   21B
....................    } 
03AA6:  INC.B   0892
03AA8:  GOTO    3A72
....................    unsigned int range=1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
03AAC:  MOV     #3E8,W4
03AAE:  MOV     894,W3
03AB0:  MUL.UU  W4,W3,W0
03AB2:  MOV     W0,W5
03AB4:  MOV     #64,W4
03AB6:  MOV     896,W3
03AB8:  MUL.UU  W4,W3,W0
03ABA:  ADD     W0,W5,W5
03ABC:  MOV     898,W4
03ABE:  MUL.UU  W4,#A,W0
03AC0:  ADD     W0,W5,W5
03AC2:  MOV     W5,W0
03AC4:  ADD     89A,W0
03AC6:  MOV     W0,89C
....................     
....................    if(range<400) 
03AC8:  MOV     89C,W4
03ACA:  MOV     #190,W3
03ACC:  CP      W3,W4
03ACE:  BRA     LEU,3AF2
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be smaller than 400 mm. Movement range is set to 400 mm."); 
03AD0:  MOV     #0,W1
03AD2:  MOV     W1,W0
03AD4:  CALL    71A
03AD8:  INC     W1,W1
03ADA:  MOV     W1,[W15++]
03ADC:  BTSC.B  219.1
03ADE:  BRA     3ADC
03AE0:  MOV     W0,21A
03AE2:  MOV     [--W15],W1
03AE4:  MOV     #5E,W0
03AE6:  CPSGT   W1,W0
03AE8:  BRA     3AD2
....................       range=400; 
03AEA:  MOV     #190,W4
03AEC:  MOV     W4,89C
....................    } 
....................    else if(range>2000) 
03AEE:  GOTO    3B18
03AF2:  MOV     89C,W4
03AF4:  MOV     #7D0,W3
03AF6:  CP      W3,W4
03AF8:  BRA     C,3B18
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be larger than 2000 mm. Movement range is set to 2000 mm."); 
03AFA:  MOV     #0,W1
03AFC:  MOV     W1,W0
03AFE:  CALL    77A
03B02:  INC     W1,W1
03B04:  MOV     W1,[W15++]
03B06:  BTSC.B  219.1
03B08:  BRA     3B06
03B0A:  MOV     W0,21A
03B0C:  MOV     [--W15],W1
03B0E:  MOV     #5F,W0
03B10:  CPSGT   W1,W0
03B12:  BRA     3AFC
....................       range=2000; 
03B14:  MOV     #7D0,W4
03B16:  MOV     W4,89C
....................    } 
....................     
....................    if(range==2000) 
03B18:  MOV     89C,W4
03B1A:  MOV     #7D0,W3
03B1C:  CP      W3,W4
03B1E:  BRA     NZ,3B28
....................       md_min_distance=120; 
03B20:  MOV     #78,W4
03B22:  MOV     W4,818
....................    else 
03B24:  GOTO    3B2C
....................       md_min_distance=70; 
03B28:  MOV     #46,W4
03B2A:  MOV     W4,818
....................        
....................    fr_write(fr_move_range, range); 
03B2C:  PUSH    834
03B2E:  POP     8A0
03B30:  PUSH    89C
03B32:  POP     8A2
03B34:  CALL    2780
....................    md_move_range=range; 
03B38:  PUSH    89C
03B3A:  POP     80E
.................... } 
03B3C:  MOV     [--W15],W6
03B3E:  MOV     [--W15],W5
03B40:  RETURN  
.................... // Sets home position 
.................... void data_set_home_pos() 
.................... { 
03B42:  MOV     W5,[W15++]
03B44:  MOV     W6,[W15++]
03B46:  CLR.B   892
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0; i<4; i++) 
03B48:  CLR.B   892
03B4A:  MOV     892,W4
03B4C:  CP.B    W4L,#4
03B4E:  BRA     C,3B84
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03B50:  MOV.B   892,W0L
03B52:  CLR.B   1
03B54:  SL      W0,#1,W0
03B56:  MOV     #894,W4
03B58:  ADD     W0,W4,W5
03B5A:  BTSS.B  218.0
03B5C:  BRA     3B5A
03B5E:  MOV     21C,W0
03B60:  SUB.B   #30,W0L
03B62:  CLR.B   1
03B64:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03B66:  MOV.B   892,W0L
03B68:  CLR.B   1
03B6A:  SL      W0,#1,W0
03B6C:  MOV     #894,W4
03B6E:  ADD     W0,W4,W0
03B70:  MOV     [W0],W5
03B72:  ADD     #30,W5
03B74:  MOV.B   W5L,W0L
03B76:  BTSC.B  219.1
03B78:  BRA     3B76
03B7A:  MOV.B   W0L,21A
03B7C:  CLR.B   21B
....................    } 
03B7E:  INC.B   0892
03B80:  GOTO    3B4A
....................    unsigned int home_pos = 1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
03B84:  MOV     #3E8,W4
03B86:  MOV     894,W3
03B88:  MUL.UU  W4,W3,W0
03B8A:  MOV     W0,W5
03B8C:  MOV     #64,W4
03B8E:  MOV     896,W3
03B90:  MUL.UU  W4,W3,W0
03B92:  ADD     W0,W5,W5
03B94:  MOV     898,W4
03B96:  MUL.UU  W4,#A,W0
03B98:  ADD     W0,W5,W5
03B9A:  MOV     W5,W0
03B9C:  ADD     89A,W0
03B9E:  MOV     W0,89C
....................     
....................    if(home_pos<10) 
03BA0:  MOV     89C,W4
03BA2:  CP      W4,#A
03BA4:  BRA     C,3BC2
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Home position cannot be smaller than 10. Home position is not changed"); 
03BA6:  MOV     #0,W1
03BA8:  MOV     W1,W0
03BAA:  CALL    7DC
03BAE:  INC     W1,W1
03BB0:  MOV     W1,[W15++]
03BB2:  BTSC.B  219.1
03BB4:  BRA     3BB2
03BB6:  MOV     W0,21A
03BB8:  MOV     [--W15],W1
03BBA:  MOV     #55,W0
03BBC:  CPSGT   W1,W0
03BBE:  BRA     3BA8
....................       return; 
03BC0:  BRA     3BD2
....................    } 
....................     
....................    fr_write(fr_home_pos,home_pos); 
03BC2:  PUSH    836
03BC4:  POP     8A0
03BC6:  PUSH    89C
03BC8:  POP     8A2
03BCA:  CALL    2780
....................    md_home_pos=home_pos; 
03BCE:  PUSH    89C
03BD0:  POP     810
.................... } 
03BD2:  MOV     [--W15],W6
03BD4:  MOV     [--W15],W5
03BD6:  RETURN  
.................... // Sets end position 
.................... void data_set_end_pos() 
.................... { 
03BD8:  MOV     W5,[W15++]
03BDA:  MOV     W6,[W15++]
03BDC:  CLR.B   892
....................    unsigned int8 i=0; 
....................    unsigned int input[5]; 
....................    for(i=0; i<5; i++) 
03BDE:  CLR.B   892
03BE0:  MOV     892,W4
03BE2:  CP.B    W4L,#5
03BE4:  BRA     C,3C1A
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03BE6:  MOV.B   892,W0L
03BE8:  CLR.B   1
03BEA:  SL      W0,#1,W0
03BEC:  MOV     #894,W4
03BEE:  ADD     W0,W4,W5
03BF0:  BTSS.B  218.0
03BF2:  BRA     3BF0
03BF4:  MOV     21C,W0
03BF6:  SUB.B   #30,W0L
03BF8:  CLR.B   1
03BFA:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03BFC:  MOV.B   892,W0L
03BFE:  CLR.B   1
03C00:  SL      W0,#1,W0
03C02:  MOV     #894,W4
03C04:  ADD     W0,W4,W0
03C06:  MOV     [W0],W5
03C08:  ADD     #30,W5
03C0A:  MOV.B   W5L,W0L
03C0C:  BTSC.B  219.1
03C0E:  BRA     3C0C
03C10:  MOV.B   W0L,21A
03C12:  CLR.B   21B
....................    } 
03C14:  INC.B   0892
03C16:  GOTO    3BE0
....................    unsigned int end=10000*input[0]+1000*input[1]+100*input[2]+10*input[3]+1*input[4]; 
03C1A:  MOV     #2710,W4
03C1C:  MOV     894,W3
03C1E:  MUL.UU  W4,W3,W0
03C20:  MOV     W0,W5
03C22:  MOV     #3E8,W4
03C24:  MOV     896,W3
03C26:  MUL.UU  W4,W3,W0
03C28:  ADD     W0,W5,W5
03C2A:  MOV     #64,W4
03C2C:  MOV     898,W3
03C2E:  MUL.UU  W4,W3,W0
03C30:  ADD     W0,W5,W5
03C32:  MOV     89A,W4
03C34:  MUL.UU  W4,#A,W0
03C36:  ADD     W0,W5,W5
03C38:  MOV     W5,W0
03C3A:  ADD     89C,W0
03C3C:  MOV     W0,89E
....................     
....................    if(end<md_home_pos) 
03C3E:  MOV     89E,W0
03C40:  MOV     810,W4
03C42:  CP      W4,W0
03C44:  BRA     LEU,3C6C
....................    { 
....................       end=data_get_home_pos()+50; 
03C46:  CALL    2164
03C4A:  MOV     W0,W5
03C4C:  MOV     #32,W4
03C4E:  ADD     W5,W4,W0
03C50:  MOV     W0,89E
....................       fprintf(RS232, "\n\rInvalid entry: End position cannot be smaller than home position. End position is set to its default."); 
03C52:  MOV     #0,W1
03C54:  MOV     W1,W0
03C56:  CALL    836
03C5A:  INC     W1,W1
03C5C:  MOV     W1,[W15++]
03C5E:  BTSC.B  219.1
03C60:  BRA     3C5E
03C62:  MOV     W0,21A
03C64:  MOV     [--W15],W1
03C66:  MOV     #66,W0
03C68:  CPSGT   W1,W0
03C6A:  BRA     3C54
....................    } 
....................     
....................    fr_write(fr_end_pos,end); 
03C6C:  PUSH    838
03C6E:  POP     8A0
03C70:  PUSH    89E
03C72:  POP     8A2
03C74:  CALL    2780
....................    md_end_pos=end; 
03C78:  PUSH    89E
03C7A:  POP     812
.................... } 
03C7C:  MOV     [--W15],W6
03C7E:  MOV     [--W15],W5
03C80:  RETURN  
.................... // Sets positioning velocity 
.................... void data_set_conv_const() 
.................... { 
03C82:  MOV     W5,[W15++]
03C84:  MOV     W6,[W15++]
....................    md_conv_const = 12500; 
03C86:  MOV     #30D4,W4
03C88:  MOV     W4,80C
....................    md_cc_step = 0; 
03C8A:  CLR     82E
....................    md_cc_count = 0; 
03C8C:  CLR     830
....................     
....................    move_pos(md_min_distance); 
03C8E:  PUSH    818
03C90:  POP     896
03C92:  CALL    2EE4
....................  
....................    unsigned int cc_first_count = qei_get_count(); 
03C96:  CALL    23C4
03C9A:  MOV     W0,892
....................     
....................    reg_md_cc_sample =1; 
03C9C:  BSET.B  84C.3
....................    move_pos(md_move_range); 
03C9E:  PUSH    80E
03CA0:  POP     896
03CA2:  CALL    2EE4
....................     
....................    unsigned int conv_const = ((float)(cc_first_count - md_cc_count)/(float)md_cc_step)*10000; 
03CA6:  MOV     892,W4
03CA8:  MOV     830,W3
03CAA:  SUB     W4,W3,W0
03CAC:  CALL    27BA
*
03CDA:  MOV     W0,894
....................  
....................    fprintf(RS232, "Count: %u counts\n\r", cc_first_count-md_cc_count); 
03CDC:  MOV     892,W4
03CDE:  MOV     830,W3
03CE0:  SUB     W4,W3,W5
03CE2:  MOV     #0,W1
03CE4:  MOV     W1,W0
03CE6:  CALL    89C
03CEA:  INC     W1,W1
03CEC:  MOV     W1,[W15++]
03CEE:  BTSC.B  219.1
03CF0:  BRA     3CEE
03CF2:  MOV     W0,21A
03CF4:  MOV     [--W15],W1
03CF6:  MOV     #6,W0
03CF8:  CPSGT   W1,W0
03CFA:  BRA     3CE4
03CFC:  MOV     W5,W0
03CFE:  MOV     #0,W4
03D00:  CALL    169A
03D04:  MOV     #9,W1
03D06:  MOV     W1,W0
03D08:  CALL    89C
03D0C:  INC     W1,W1
03D0E:  MOV     W1,[W15++]
03D10:  BTSC.B  219.1
03D12:  BRA     3D10
03D14:  MOV     W0,21A
03D16:  MOV     [--W15],W1
03D18:  MOV     #11,W0
03D1A:  CPSGT   W1,W0
03D1C:  BRA     3D06
....................    fprintf(RS232, "Step: %u steps\n\r", md_cc_step); 
03D1E:  MOV     #0,W1
03D20:  MOV     W1,W0
03D22:  CALL    8C0
03D26:  INC     W1,W1
03D28:  MOV     W1,[W15++]
03D2A:  BTSC.B  219.1
03D2C:  BRA     3D2A
03D2E:  MOV     W0,21A
03D30:  MOV     [--W15],W1
03D32:  MOV     #5,W0
03D34:  CPSGT   W1,W0
03D36:  BRA     3D20
03D38:  MOV     82E,W0
03D3A:  MOV     #0,W4
03D3C:  CALL    169A
03D40:  MOV     #8,W1
03D42:  MOV     W1,W0
03D44:  CALL    8C0
03D48:  INC     W1,W1
03D4A:  MOV     W1,[W15++]
03D4C:  BTSC.B  219.1
03D4E:  BRA     3D4C
03D50:  MOV     W0,21A
03D52:  MOV     [--W15],W1
03D54:  MOV     #F,W0
03D56:  CPSGT   W1,W0
03D58:  BRA     3D42
....................    fprintf(RS232, "Conversion Constant: %u counts\n\r", conv_const); 
03D5A:  MOV     #0,W1
03D5C:  MOV     W1,W0
03D5E:  CALL    8E2
03D62:  INC     W1,W1
03D64:  MOV     W1,[W15++]
03D66:  BTSC.B  219.1
03D68:  BRA     3D66
03D6A:  MOV     W0,21A
03D6C:  MOV     [--W15],W1
03D6E:  MOV     #14,W0
03D70:  CPSGT   W1,W0
03D72:  BRA     3D5C
03D74:  MOV     894,W0
03D76:  MOV     #0,W4
03D78:  CALL    169A
03D7C:  MOV     #17,W1
03D7E:  MOV     W1,W0
03D80:  CALL    8E2
03D84:  INC     W1,W1
03D86:  MOV     W1,[W15++]
03D88:  BTSC.B  219.1
03D8A:  BRA     3D88
03D8C:  MOV     W0,21A
03D8E:  MOV     [--W15],W1
03D90:  MOV     #1F,W0
03D92:  CPSGT   W1,W0
03D94:  BRA     3D7E
....................    
....................    fr_write(fr_conv_const,conv_const); 
03D96:  PUSH    83A
03D98:  POP     8A0
03D9A:  PUSH    894
03D9C:  POP     8A2
03D9E:  CALL    2780
....................    md_conv_const = conv_const; 
03DA2:  PUSH    894
03DA4:  POP     80C
.................... } 
03DA6:  MOV     [--W15],W6
03DA8:  MOV     [--W15],W5
03DAA:  RETURN  
.................... // Sets backlash 
.................... void data_set_backlash() 
.................... { 
03DAC:  MOV     W5,[W15++]
03DAE:  MOV     W6,[W15++]
03DB0:  CLR.B   892
....................    unsigned int8 i=0; 
....................    unsigned int input[2]; 
....................    for(i=0; i<2; i++) 
03DB2:  CLR.B   892
03DB4:  MOV     892,W4
03DB6:  CP.B    W4L,#2
03DB8:  BRA     C,3DEE
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03DBA:  MOV.B   892,W0L
03DBC:  CLR.B   1
03DBE:  SL      W0,#1,W0
03DC0:  MOV     #894,W4
03DC2:  ADD     W0,W4,W5
03DC4:  BTSS.B  218.0
03DC6:  BRA     3DC4
03DC8:  MOV     21C,W0
03DCA:  SUB.B   #30,W0L
03DCC:  CLR.B   1
03DCE:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03DD0:  MOV.B   892,W0L
03DD2:  CLR.B   1
03DD4:  SL      W0,#1,W0
03DD6:  MOV     #894,W4
03DD8:  ADD     W0,W4,W0
03DDA:  MOV     [W0],W5
03DDC:  ADD     #30,W5
03DDE:  MOV.B   W5L,W0L
03DE0:  BTSC.B  219.1
03DE2:  BRA     3DE0
03DE4:  MOV.B   W0L,21A
03DE6:  CLR.B   21B
....................    } 
03DE8:  INC.B   0892
03DEA:  GOTO    3DB4
....................    unsigned int backlash = 10*input[0]+1*input[1]; 
03DEE:  MOV     894,W4
03DF0:  MUL.UU  W4,#A,W0
03DF2:  MOV     W0,W5
03DF4:  MOV     W5,W0
03DF6:  ADD     896,W0
03DF8:  MOV     W0,898
....................     
....................    fr_write(fr_backlash,backlash); 
03DFA:  PUSH    83C
03DFC:  POP     8A0
03DFE:  PUSH    898
03E00:  POP     8A2
03E02:  CALL    2780
....................    md_backlash = backlash; 
03E06:  PUSH    898
03E08:  POP     82C
.................... } 
03E0A:  MOV     [--W15],W6
03E0C:  MOV     [--W15],W5
03E0E:  RETURN  
.................... // Sets communication type 
.................... void data_set_comm_type() 
.................... { 
03E10:  MOV     W5,[W15++]
03E12:  BTSS.B  218.0
03E14:  BRA     3E12
03E16:  MOV     21C,W0
03E18:  MOV     #30,W4
03E1A:  SUB.B   W0L,W4L,W0L
03E1C:  MOV.B   W0L,892
....................    unsigned int8 input=(unsigned)(fgetc(RS232)-48); 
....................    fputc(input+48,RS232); 
03E1E:  MOV     #30,W4
03E20:  MOV     892,W3
03E22:  ADD.B   W3L,W4L,W5L
03E24:  MOV.B   W5L,W0L
03E26:  BTSC.B  219.1
03E28:  BRA     3E26
03E2A:  MOV.B   W0L,21A
03E2C:  CLR.B   21B
....................    switch (input) 
....................    { 
03E2E:  MOV.B   892,W0L
03E30:  CLR.B   1
03E32:  XOR     #1,W0
03E34:  BRA     Z,3E3C
03E36:  XOR     #1,W0
03E38:  BRA     Z,3E54
03E3A:  BRA     3E54
....................       case 1   :  output_low(PP_ACK); 
03E3C:  BCLR.B  2D2.4
03E3E:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
03E40:  BCLR.B  2D2.5
03E42:  BCLR.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 1); 
03E44:  MOV.B   #1,W0L
03E46:  MOV.B   W0L,8B0
03E48:  PUSH    83E
03E4A:  POP     8AE
03E4C:  CALL    269E
....................                   break; 
03E50:  GOTO    3E6A
....................       case 0   :     
....................       default  :  output_high(PP_ACK); 
03E54:  BCLR.B  2D2.4
03E56:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
03E58:  BCLR.B  2D2.5
03E5A:  BSET.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 0); 
03E5C:  CLR.B   8B0
03E5E:  PUSH    83E
03E60:  POP     8AE
03E62:  CALL    269E
....................                   break; 
03E66:  GOTO    3E6A
....................    } 
.................... } 
03E6A:  MOV     [--W15],W5
03E6C:  RETURN  
.................... // Sets last position 
.................... void data_set_last_pos(unsigned int16 position) 
.................... { 
....................    fr_write(fr_last_pos, position); 
*
027AC:  PUSH    840
027AE:  POP     8A0
027B0:  PUSH    89C
027B2:  POP     8A2
027B4:  CALL    2780
.................... } 
027B8:  RETURN  
.................... // Sets position to given index 
.................... void data_set_pos(unsigned int8 index, unsigned int16 position) 
.................... { 
*
03704:  MOV     W5,[W15++]
....................    fr_write(fr_pos_table+index*2, position); 
03706:  MOV.B   894,W0L
03708:  SL      W0,#1,W0
0370A:  ZE      W0,W0
0370C:  CLR.B   1
0370E:  MOV     842,W4
03710:  ADD     W0,W4,W5
03712:  MOV     W5,8A0
03714:  PUSH    896
03716:  POP     8A2
03718:  CALL    2780
.................... } 
0371C:  MOV     [--W15],W5
0371E:  RETURN  
....................  
.................... // Initializes the quadrature encoder interface module by using default values 
.................... void qei_init() 
.................... { 
....................    // Disable QEI module  
....................    QEI_QEICON_QEIM0=0; 
*
01A72:  BCLR.B  123.0
....................    QEI_QEICON_QEIM1=0; 
01A74:  BCLR.B  123.1
....................    QEI_QEICON_QEIM2=0; 
01A76:  BCLR.B  123.2
....................    // Clear any count errors 
....................    QEI_QEICON_CNTERR=0; 
01A78:  BCLR.B  123.7
....................    // Continue module operation during sleep 
....................    QEI_QEICON_QEISIDL=0; 
01A7A:  BCLR.B  123.5
....................    // QEA and QEB not swapped 
....................    QEI_QEICON_SWPAB=0; 
01A7C:  BCLR.B  122.7
....................    // Normal I/O pin operation 
....................    QEI_QEICON_PCDOUT=0; 
01A7E:  BCLR.B  122.6
....................    // Timer gated time accumulation disabled 
....................    QEI_QEICON_TQGATE=0; 
01A80:  BCLR.B  122.5
....................    // 1:1 timer input clock prescale 
....................    QEI_QEICON_TQCKPS0=0; 
01A82:  BCLR.B  122.3
....................    QEI_QEICON_TQCKPS1=0; 
01A84:  BCLR.B  122.4
....................    // Index pulse does not reset the position counter 
....................    QEI_QEICON_POSRES = 0; 
01A86:  BCLR.B  122.2
....................    // Internal clock as timer clock source 
....................    QEI_QEICON_TQCS = 0; 
01A88:  BCLR.B  122.1
....................    // QEI_QEICON_UPDN defines timer counter (QEI_POSCNT) direction 
....................    QEI_QEICON_UDSRC = 0; 
01A8A:  BCLR.B  122.0
....................     
....................    // Count error interrupts enabled 
....................    QEI_DFLTCON_CEID = 0;  
01A8C:  BCLR.B  125.0
....................    // Digital filter outputs enabled 
....................    QEI_DFLTCON_QEOUT = 0;  
01A8E:  BCLR.B  124.7
....................    // 1:256 clock divide for digital filter 
....................    QEI_DFLTCON_QECK2 = 1; 
01A90:  BSET.B  124.6
....................    QEI_DFLTCON_QECK1 = 1; 
01A92:  BSET.B  124.5
....................    QEI_DFLTCON_QECK0 = 0; 
01A94:  BCLR.B  124.4
....................     
....................    // Reset position counter 
....................    QEI_POSCNT = 0x0000; 
01A96:  CLR     126
....................     
....................    // Set maximum count 
....................    QEI_MAXCNT = 0xFFFF; 
01A98:  SETM    128
....................     
....................    // QEI module enabled in x4 mode with position counter reset by QEI_MAXCNT match 
....................    QEI_QEICON_QEIM2 = 1; 
01A9A:  BSET.B  123.2
....................    QEI_QEICON_QEIM1 = 1; 
01A9C:  BSET.B  123.1
....................    QEI_QEICON_QEIM0 = 1; 
01A9E:  BSET.B  123.0
....................     
....................    if(debug_mode_qei) 
01AA0:  BTSS.B  800.5
01AA2:  BRA     1ABE
....................       fprintf(RS232,"Quadrature Encoder Initialized\n\n\r"); 
01AA4:  MOV     #0,W1
01AA6:  MOV     W1,W0
01AA8:  CALL    914
01AAC:  INC     W1,W1
01AAE:  MOV     W1,[W15++]
01AB0:  BTSC.B  219.1
01AB2:  BRA     1AB0
01AB4:  MOV     W0,21A
01AB6:  MOV     [--W15],W1
01AB8:  MOV     #20,W0
01ABA:  CPSGT   W1,W0
01ABC:  BRA     1AA6
.................... } 
01ABE:  RETURN  
.................... // Sets the position counter to given value 
.................... void qei_set_count(unsigned int16 value) 
.................... {  
....................    QEI_POSCNT = value; 
*
02380:  PUSH    8AA
02382:  POP     126
....................     
....................    if(debug_mode_qei) 
02384:  BTSS.B  800.5
02386:  BRA     23C2
....................       fprintf(RS232,"Quadrature Encoder Count Set: %u\n\n\r", value); 
02388:  MOV     #0,W1
0238A:  MOV     W1,W0
0238C:  CALL    946
02390:  INC     W1,W1
02392:  MOV     W1,[W15++]
02394:  BTSC.B  219.1
02396:  BRA     2394
02398:  MOV     W0,21A
0239A:  MOV     [--W15],W1
0239C:  MOV     #1D,W0
0239E:  CPSGT   W1,W0
023A0:  BRA     238A
023A2:  MOV     8AA,W0
023A4:  MOV     #0,W4
023A6:  CALL    169A
023AA:  BTSC.B  219.1
023AC:  BRA     23AA
023AE:  MOV     #A,W4
023B0:  MOV     W4,21A
023B2:  BTSC.B  219.1
023B4:  BRA     23B2
023B6:  MOV     #A,W4
023B8:  MOV     W4,21A
023BA:  BTSC.B  219.1
023BC:  BRA     23BA
023BE:  MOV     #D,W4
023C0:  MOV     W4,21A
.................... } 
023C2:  RETURN  
.................... // Sets the maximum count to given value 
.................... void qei_set_max_count(unsigned int16 value) 
.................... {  
....................    QEI_MAXCNT = value; 
*
02254:  PUSH    858
02256:  POP     128
....................     
....................    if(debug_mode_qei) 
02258:  BTSS.B  800.5
0225A:  BRA     2296
....................       fprintf(RS232,"Quadrature Encoder Maximum Count Set: %u\n\n\r", value); 
0225C:  MOV     #0,W1
0225E:  MOV     W1,W0
02260:  CALL    97A
02264:  INC     W1,W1
02266:  MOV     W1,[W15++]
02268:  BTSC.B  219.1
0226A:  BRA     2268
0226C:  MOV     W0,21A
0226E:  MOV     [--W15],W1
02270:  MOV     #25,W0
02272:  CPSGT   W1,W0
02274:  BRA     225E
02276:  MOV     858,W0
02278:  MOV     #0,W4
0227A:  CALL    169A
0227E:  BTSC.B  219.1
02280:  BRA     227E
02282:  MOV     #A,W4
02284:  MOV     W4,21A
02286:  BTSC.B  219.1
02288:  BRA     2286
0228A:  MOV     #A,W4
0228C:  MOV     W4,21A
0228E:  BTSC.B  219.1
02290:  BRA     228E
02292:  MOV     #D,W4
02294:  MOV     W4,21A
.................... } 
02296:  RETURN  
.................... // Returns the value of the position counter 
.................... unsigned int16 qei_get_count(){ return QEI_POSCNT;} 
*
023C4:  PUSH    126
023C6:  POP     0
023C8:  RETURN  
....................  
.................... // Sets the operating mode of the PWM module 
.................... void pwm_select_mode(unsigned int mode) 
.................... { 
....................    if(mode == FREE) 
*
01AC0:  CP0     8AA
01AC2:  BRA     NZ,1ACC
....................    { 
....................       // Select free running PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
01AC4:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 0; 
01AC6:  BCLR.B  1C0.0
....................    } 
....................    else if(mode == SINGLE) 
01AC8:  GOTO    1AD6
01ACC:  MOV     8AA,W4
01ACE:  CP      W4,#1
01AD0:  BRA     NZ,1AD6
....................    { 
....................       // Select single event PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
01AD2:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 1; 
01AD4:  BSET.B  1C0.0
....................    } 
.................... } 
01AD6:  RETURN  
.................... // Initializes the PWM module by using default values 
.................... void pwm_init() 
.................... { 
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN       = 0; 
01AD8:  BCLR.B  1C1.7
....................     
....................    // Select 1:1 output postscale 
....................    PWM_PTCON_PTOPS3     = 0; 
01ADA:  BCLR.B  1C0.7
....................    PWM_PTCON_PTOPS2     = 0; 
01ADC:  BCLR.B  1C0.6
....................    PWM_PTCON_PTOPS1     = 0; 
01ADE:  BCLR.B  1C0.5
....................    PWM_PTCON_PTOPS0     = 0; 
01AE0:  BCLR.B  1C0.4
....................    // Select 1:1 input prescale 
....................    PWM_PTCON_PTCKPS1    = 0; 
01AE2:  BCLR.B  1C0.3
....................    PWM_PTCON_PTCKPS0    = 0; 
01AE4:  BCLR.B  1C0.2
....................     
....................    // Set the operating mode of PWM module 
....................    pwm_select_mode(FREE); 
01AE6:  CLR     8AA
01AE8:  CALL    1AC0
....................  
....................    // Select independent output mode for PWM1 I/O pair 
....................    PWM_PWMCON1_PMOD1    = 1; 
01AEC:  BSET.B  1C9.0
....................    // Set PWM1H pin as PWM output 
....................    PWM_PWMCON1_PEN1H    = 1; 
01AEE:  BSET.B  1C8.4
....................     
....................    // Synchronize PDC registers to the PWM time base 
....................    PWM_PWMCON2_IUE      = 0; 
01AF0:  BCLR.B  1CA.2
....................    // Enable PWM interrupt 
....................    PWM_IEC2_PWMIE       = 0; 
01AF2:  BCLR.B  90.7
....................     
....................    // Set time base period value 
....................    PWM_PTPER            = 0; 
01AF4:  CLR     1C4
....................    // Set time base duty cycle 
....................    PWM_PDC1             = 0; 
01AF6:  CLR     1D6
....................  
....................    if(debug_mode_md) 
01AF8:  BTSS.B  800.3
01AFA:  BRA     1B16
....................       fprintf(RS232,"PWM Module Initialized\n\n\r"); 
01AFC:  MOV     #0,W1
01AFE:  MOV     W1,W0
01B00:  CALL    9B8
01B04:  INC     W1,W1
01B06:  MOV     W1,[W15++]
01B08:  BTSC.B  219.1
01B0A:  BRA     1B08
01B0C:  MOV     W0,21A
01B0E:  MOV     [--W15],W1
01B10:  MOV     #18,W0
01B12:  CPSGT   W1,W0
01B14:  BRA     1AFE
.................... } 
01B16:  RETURN  
.................... // Set PWM period time (us) 
.................... void pwm_set_period(unsigned int16 period) 
.................... { 
*
022FA:  MOV     W5,[W15++]
022FC:  MOV     W6,[W15++]
....................    // PWM period 
....................    unsigned int16 pwm_period;  
....................     
....................    // Set the PWM period 
....................    if(period==0) 
022FE:  CP0     8AE
02300:  BRA     NZ,2308
....................       pwm_period = 0; 
02302:  CLR     8B0
....................    else 
02304:  GOTO    2332
....................       pwm_period =  (7 * period / 400) + (3 * period / 40) + ( 7 * period / 4) - 1; 
02308:  MOV     8AE,W4
0230A:  MUL.UU  W4,#7,W0
0230C:  MOV     W0,W5
0230E:  MOV     W5,W4
02310:  MOV     #190,W3
02312:  REPEAT  #11
02314:  DIV.U   W4,W3
02316:  MOV     W0,W5
02318:  MOV     8AE,W4
0231A:  MUL.UU  W4,#3,W6
0231C:  MOV     W6,W4
0231E:  MOV     #28,W3
02320:  REPEAT  #11
02322:  DIV.U   W4,W3
02324:  ADD     W0,W5,W5
02326:  MOV     8AE,W4
02328:  MUL.UU  W4,#7,W6
0232A:  LSR     W6,#2,W0
0232C:  ADD     W0,W5,W5
0232E:  SUB     W5,#1,W0
02330:  MOV     W0,8B0
....................     
....................    // Updates from duty cycle and period buffer registers are disabled 
....................    PWM_PWMCON2_UDIS = 1; 
02332:  BSET.B  1CA.0
....................    // Set time base period value 
....................    PWM_PTPER        = pwm_period; 
02334:  PUSH    8B0
02336:  POP     1C4
....................    // Set time base duty cycle if PWM module is enabled (duty cycle > 0%) 
....................    PWM_PDC1         = pwm_period; 
02338:  PUSH    8B0
0233A:  POP     1D6
....................    // Updates from duty cycle and period buffer registers are enabled 
....................    PWM_PWMCON2_UDIS = 0; 
0233C:  BCLR.B  1CA.0
.................... } 
0233E:  MOV     [--W15],W6
02340:  MOV     [--W15],W5
02342:  RETURN  
.................... // Disable PWM module 
.................... void pwm_disable() 
.................... { 
....................    // Set duty cycle to zero 
....................    PWM_PDC1=0; 
*
02352:  CLR     1D6
....................    // Wait for the last signal 
....................    delay_us(PWM_PTPER + 1 / 30); 
02354:  MOV     1C4,W0
02356:  CALL    2344
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN = 0; 
0235A:  BCLR.B  1C1.7
....................    // Set duty cycle to its initial value 
....................    PWM_PDC1=PWM_PTPER; 
0235C:  PUSH    1C4
0235E:  POP     1D6
....................     
....................    if(debug_mode_pwm) 
02360:  BTSS.B  800.4
02362:  BRA     237E
....................       fprintf(RS232,"PWM Disabled\n\r"); 
02364:  MOV     #0,W1
02366:  MOV     W1,W0
02368:  CALL    9E2
0236C:  INC     W1,W1
0236E:  MOV     W1,[W15++]
02370:  BTSC.B  219.1
02372:  BRA     2370
02374:  MOV     W0,21A
02376:  MOV     [--W15],W1
02378:  MOV     #D,W0
0237A:  CPSGT   W1,W0
0237C:  BRA     2366
.................... } 
0237E:  RETURN  
.................... // Enable PWM module 
.................... void pwm_enable() 
.................... { 
*
023CA:  MOV     W5,[W15++]
....................    // Disable RS232 receive byte interrupt 
....................    disable_interrupts(INT_RDA2); 
023CC:  BCLR.B  8F.0
....................     
....................    // Enable PWM module 
....................    PWM_PTCON_PTEN = 1; 
023CE:  BSET.B  1C1.7
....................    // Start pwm cycle 
....................    int1 reg_md_running = 1; 
....................    unsigned int md_step_count = 0; 
023D0:  BSET.B  8A4.0
023D2:  CLR     8A6
....................     
....................    while(reg_md_running) 
....................    { 
023D4:  BTSS.B  8A4.0
023D6:  BRA     2604
....................       if(PWM_IFS2_PWMIF) 
023D8:  BTSS.B  88.7
023DA:  BRA     2600
....................       { 
....................          // Clear the flag register 
....................          PWM_IFS2_PWMIF = 0; 
023DC:  BCLR.B  88.7
....................           
....................          md_step_count++; 
023DE:  INC     08A6
....................        
....................          switch(md_run_state)  
....................          { 
023E0:  MOV.B   801,W0L
023E2:  CLR.B   1
023E4:  XOR     #0,W0
023E6:  BRA     Z,23FA
023E8:  XOR     #1,W0
023EA:  BRA     Z,24A2
023EC:  XOR     #2,W0
023EE:  BRA     Z,250C
023F0:  XOR     #1,W0
023F2:  BRA     Z,252C
023F4:  XOR     #6,W0
023F6:  BRA     Z,2576
023F8:  BRA     2600
....................             case HOME: 
....................                if(reg_md_home_return == 0) 
023FA:  BTSC.B  84C.1
023FC:  BRA     247C
....................                { 
....................                   if(reg_md_home == 0) 
023FE:  BTSC.B  84C.0
02400:  BRA     2450
....................                   { 
....................                      if(input(MD_SW)) 
02402:  BSET.B  2D3.3
02404:  BTSS.B  2D5.3
02406:  BRA     2438
....................                      { 
....................                         if(md_step_count < md_max_acc_lim) 
02408:  MOV     8A6,W0
0240A:  MOV     84E,W4
0240C:  CP      W4,W0
0240E:  BRA     LEU,2428
....................                         { 
....................                            md_decel_count = md_step_count; 
02410:  PUSH    8A6
02412:  POP     826
....................                            pwm_set_period(delays[md_step_count]); 
02414:  MOV     8A6,W0
02416:  SL      W0,#1,W0
02418:  CALL    100
0241C:  MOV     W0,W5
0241E:  MOV     W5,8AE
02420:  CALL    22FA
....................                         } 
....................                         else 
02424:  GOTO    2434
....................                         { 
....................                            md_decel_count = md_max_acc_lim; 
02428:  PUSH    84E
0242A:  POP     826
....................                            pwm_set_period(md_min_delay); 
0242C:  PUSH    820
0242E:  POP     8AE
02430:  CALL    22FA
....................                         } 
....................                      } 
....................                      else 
02434:  GOTO    244C
....................                      { 
....................                         reg_md_home = 1; 
02438:  BSET.B  84C.0
....................                         md_decel_count--; 
0243A:  DEC     0826
....................                         pwm_set_period(delays[md_decel_count]); 
0243C:  MOV     826,W0
0243E:  SL      W0,#1,W0
02440:  CALL    100
02444:  MOV     W0,W5
02446:  MOV     W5,8AE
02448:  CALL    22FA
....................                      } 
....................                   } 
....................                   else 
0244C:  GOTO    2478
....................                   { 
....................                      if(md_decel_count == 0) 
02450:  CP0     826
02452:  BRA     NZ,2466
....................                      {   
....................                         reg_md_home_return = 1; 
02454:  BSET.B  84C.1
....................                         output_low(MD_DIR); 
02456:  BCLR.B  2D8.4
02458:  BCLR.B  2DC.4
....................                         pwm_set_period(1000); 
0245A:  MOV     #3E8,W4
0245C:  MOV     W4,8AE
0245E:  CALL    22FA
....................                      } 
....................                      else 
02462:  GOTO    2478
....................                      { 
....................                         md_decel_count--; 
02466:  DEC     0826
....................                         pwm_set_period(delays[md_decel_count]); 
02468:  MOV     826,W0
0246A:  SL      W0,#1,W0
0246C:  CALL    100
02470:  MOV     W0,W5
02472:  MOV     W5,8AE
02474:  CALL    22FA
....................                      } 
....................                   } 
....................                } 
....................                else 
02478:  GOTO    249E
....................                { 
....................                   if(input(MD_SW)) 
0247C:  BSET.B  2D3.3
0247E:  BTSS.B  2D5.3
02480:  BRA     249E
....................                   { 
....................                      pwm_disable(); 
02482:  CALL    2352
....................                      reg_md_running = 0; 
02486:  BCLR.B  8A4.0
....................                       
....................                      delay_ms(50); 
02488:  MOV     #32,W0
0248A:  CALL    168A
....................                      qei_set_count(md_home_offset); 
0248E:  PUSH    816
02490:  POP     8AA
02492:  CALL    2380
....................                      md_mt_set(mt_percent_rest); 
02496:  PUSH    80A
02498:  POP     8AA
0249A:  CALL    1FB4
....................                   } 
....................                } 
....................                break; 
0249E:  GOTO    2600
....................                 
....................             case ACCEL: 
....................                // Check if we should start deceleration. 
....................                if(md_step_count >= md_accel_lim)  
024A2:  MOV     824,W0
024A4:  MOV     8A6,W4
024A6:  CP      W4,W0
024A8:  BRA     NC,24F8
....................                { 
....................                   if(md_step_count == md_decel_lim) 
024AA:  MOV     8A6,W0
024AC:  CP      822
024AE:  BRA     NZ,24CA
....................                   { 
....................                      md_decel_count--; 
024B0:  DEC     0826
....................                      pwm_set_period(delays[md_decel_count]); 
024B2:  MOV     826,W0
024B4:  SL      W0,#1,W0
024B6:  CALL    100
024BA:  MOV     W0,W5
024BC:  MOV     W5,8AE
024BE:  CALL    22FA
....................                      md_run_state = DECEL; 
024C2:  MOV.B   #2,W0L
024C4:  MOV.B   W0L,801
....................                   } 
....................                   else if(md_decel_lim - md_step_count < 2) 
024C6:  GOTO    24F4
024CA:  MOV     822,W4
024CC:  MOV     8A6,W3
024CE:  SUB     W4,W3,W5
024D0:  CP      W5,#2
024D2:  BRA     C,24E8
....................                   { 
....................                      pwm_set_period(delays[md_step_count]); 
024D4:  MOV     8A6,W0
024D6:  SL      W0,#1,W0
024D8:  CALL    100
024DC:  MOV     W0,W5
024DE:  MOV     W5,8AE
024E0:  CALL    22FA
....................                   } 
....................                   else 
024E4:  GOTO    24F4
....................                   { 
....................                      pwm_set_period(md_min_delay); 
024E8:  PUSH    820
024EA:  POP     8AE
024EC:  CALL    22FA
....................                      md_run_state = RUN; 
024F0:  MOV.B   #3,W0L
024F2:  MOV.B   W0L,801
....................                   } 
....................                } 
....................                else 
024F4:  GOTO    2508
....................                { 
....................                   pwm_set_period(delays[md_step_count]); 
024F8:  MOV     8A6,W0
024FA:  SL      W0,#1,W0
024FC:  CALL    100
02500:  MOV     W0,W5
02502:  MOV     W5,8AE
02504:  CALL    22FA
....................                } 
....................                break; 
02508:  GOTO    2600
....................        
....................             case RUN: 
....................                // Check if we should start decelration. 
....................                if(md_step_count == md_decel_lim)  
0250C:  MOV     8A6,W0
0250E:  CP      822
02510:  BRA     NZ,2528
....................                { 
....................                   md_decel_count--; 
02512:  DEC     0826
....................                   pwm_set_period(delays[md_decel_count]); 
02514:  MOV     826,W0
02516:  SL      W0,#1,W0
02518:  CALL    100
0251C:  MOV     W0,W5
0251E:  MOV     W5,8AE
02520:  CALL    22FA
....................                   md_run_state = DECEL; 
02524:  MOV.B   #2,W0L
02526:  MOV.B   W0L,801
....................                } 
....................                break; 
02528:  GOTO    2600
....................        
....................             case DECEL: 
....................                // Check if we at last step 
....................                if(md_decel_count == 0) 
0252C:  CP0     826
0252E:  BRA     NZ,2560
....................                { 
....................                   pwm_disable(); 
02530:  CALL    2352
....................                   md_pos_iter = 0; 
02534:  CLR     828
....................                   md_run_state = POS; 
02536:  MOV.B   #4,W0L
02538:  MOV.B   W0L,801
....................                    
....................                   delay_ms(50); 
0253A:  MOV     #32,W0
0253C:  CALL    168A
....................  
....................                   md_error = md_target_count - qei_get_count(); 
02540:  CALL    23C4
02544:  MOV     81A,W4
02546:  SUB     W4,W0,W0
02548:  MOV     W0,82A
....................                    
....................                   if(md_error > 1) 
0254A:  MOV     82A,W4
0254C:  CP      W4,#1
0254E:  BRA     LE,2558
....................                      output_low(MD_DIR); 
02550:  BCLR.B  2D8.4
02552:  BCLR.B  2DC.4
....................                   else 
02554:  GOTO    255C
....................                      output_high(MD_DIR); 
02558:  BCLR.B  2D8.4
0255A:  BSET.B  2DC.4
....................                } 
....................                else 
0255C:  GOTO    2572
....................                { 
....................                   md_decel_count--; 
02560:  DEC     0826
....................                   pwm_set_period(delays[md_decel_count]); 
02562:  MOV     826,W0
02564:  SL      W0,#1,W0
02566:  CALL    100
0256A:  MOV     W0,W5
0256C:  MOV     W5,8AE
0256E:  CALL    22FA
....................                } 
....................                break; 
02572:  GOTO    2600
....................                 
....................             case POS: 
....................                md_pos_iter++; 
02576:  INC     0828
....................                 
....................                delay_ms(50); 
02578:  MOV     #32,W0
0257A:  CALL    168A
....................                 
....................                if(reg_md_cc_sample) 
0257E:  BTSS.B  84C.3
02580:  BRA     2594
....................                { 
....................                   reg_md_cc_sample = 0; 
02582:  BCLR.B  84C.3
....................                   delay_ms(50); 
02584:  MOV     #32,W0
02586:  CALL    168A
....................                   md_cc_step = md_step_count; 
0258A:  PUSH    8A6
0258C:  POP     82E
....................                   md_cc_count = qei_get_count(); 
0258E:  CALL    23C4
02592:  MOV     W0,830
....................                } 
....................  
....................                int difference; 
....................                 
....................                if(md_error < 1) 
02594:  MOV     82A,W4
02596:  CP      W4,#1
02598:  BRA     GE,25AA
....................                   difference = qei_get_count() - md_target_count; 
0259A:  CALL    23C4
0259E:  MOV     W0,W5
025A0:  MOV     81A,W4
025A2:  SUB     W5,W4,W0
025A4:  MOV     W0,8A8
....................                else 
025A6:  GOTO    25B4
....................                   difference = md_target_count - qei_get_count(); 
025AA:  CALL    23C4
025AE:  MOV     81A,W4
025B0:  SUB     W4,W0,W0
025B2:  MOV     W0,8A8
....................  
....................                if((difference < 1)||(md_pos_iter > 50)) 
025B4:  MOV     8A8,W4
025B6:  CP      W4,#1
025B8:  BRA     LT,25C2
025BA:  MOV     828,W4
025BC:  MOV     #32,W3
025BE:  CP      W3,W4
025C0:  BRA     C,25D4
....................                { 
....................                   pwm_disable(); 
025C2:  CALL    2352
....................                   reg_md_running = 0; 
025C6:  BCLR.B  8A4.0
....................                   md_mt_set(mt_percent_rest); 
025C8:  PUSH    80A
025CA:  POP     8AA
025CC:  CALL    1FB4
....................                } 
....................                else 
025D0:  GOTO    25FC
....................                { 
....................                   if(md_target_count > qei_get_count()) 
025D4:  CALL    23C4
025D8:  MOV     81A,W4
025DA:  CP      W4,W0
025DC:  BRA     LEU,25E6
....................                      output_low(MD_DIR); 
025DE:  BCLR.B  2D8.4
025E0:  BCLR.B  2DC.4
....................                   else 
025E2:  GOTO    25EA
....................                      output_high(MD_DIR); 
025E6:  BCLR.B  2D8.4
025E8:  BSET.B  2DC.4
....................                          
....................                   pwm_set_period(1000); 
025EA:  MOV     #3E8,W4
025EC:  MOV     W4,8AE
025EE:  CALL    22FA
....................                   pwm_select_mode(SINGLE); 
025F2:  MOV     #1,W4
025F4:  MOV     W4,8AA
025F6:  CALL    1AC0
....................                   // Enable PWM module 
....................                   PWM_PTCON_PTEN = 1; 
025FA:  BSET.B  1C1.7
....................                } 
....................                break; 
025FC:  GOTO    2600
....................          } 
....................       } 
....................    } 
02600:  GOTO    23D4
....................  
....................    // Enable RS232 receive byte interrupt 
....................    clear_interrupt(INT_RDA2); 
....................    enable_interrupts(INT_RDA2); 
02604:  BSET.B  8F.0
....................    reg_rs232_message = 0; 
02606:  BCLR.B  84C.2
.................... } 
02608:  MOV     [--W15],W5
0260A:  RETURN  
....................  
.................... // Move to given position (encoder count) 
.................... void move_to(unsigned int count) 
.................... { 
*
02C1A:  MOV     W5,[W15++]
02C1C:  MOV     W6,[W15++]
02C1E:  CALL    23C4
02C22:  MOV     W0,8A0
....................    // Calculate the number of steps 
....................    unsigned int displ;             
....................    // Calculate the current motor step by using current encoder count 
....................    unsigned int current_count = qei_get_count(); 
....................    // Calculate the target motor step by using given encoder step 
....................    md_target_count = count;  
02C24:  PUSH    89C
02C26:  POP     81A
....................     
....................    // Set direction 
....................    if(md_target_count > current_count) 
02C28:  MOV     8A0,W0
02C2A:  MOV     81A,W4
02C2C:  CP      W4,W0
02C2E:  BRA     LEU,2C40
....................    { 
....................       output_low(MD_DIR); 
02C30:  BCLR.B  2D8.4
02C32:  BCLR.B  2DC.4
....................       displ = md_target_count - current_count; 
02C34:  MOV     81A,W4
02C36:  MOV     8A0,W3
02C38:  SUB     W4,W3,W0
02C3A:  MOV     W0,89E
....................    } 
....................    else 
02C3C:  GOTO    2C4C
....................    { 
....................       output_high(MD_DIR); 
02C40:  BCLR.B  2D8.4
02C42:  BSET.B  2DC.4
....................       displ = current_count - md_target_count; 
02C44:  MOV     8A0,W4
02C46:  MOV     81A,W3
02C48:  SUB     W4,W3,W0
02C4A:  MOV     W0,89E
....................    } 
....................     
....................    displ = (long)displ * 10000 / md_conv_const; 
02C4C:  MOV     89E,W5
02C4E:  MOV     #0,W6
02C50:  MOV     W5,W0
02C52:  MOV     W6,W1
02C54:  MOV     #2710,W2
02C56:  MOV     #0,W3
02C58:  CALL    2B4E
02C5C:  MOV     W0,W5
02C5E:  MOV     W1,W6
02C60:  BCLR.B  43.0
02C62:  MOV     W5,W0
02C64:  MOV     W6,W1
02C66:  MOV     80C,W2
02C68:  MOV     #0,W3
02C6A:  CALL    2B90
02C6E:  MOV     W0,89E
....................     
....................    if(debug_mode_pwm) 
02C70:  BTSS.B  800.4
02C72:  BRA     2CA6
....................       fprintf(RS232,"Displacement: %u\n\r", displ); 
02C74:  MOV     #0,W1
02C76:  MOV     W1,W0
02C78:  CALL    A02
02C7C:  INC     W1,W1
02C7E:  MOV     W1,[W15++]
02C80:  BTSC.B  219.1
02C82:  BRA     2C80
02C84:  MOV     W0,21A
02C86:  MOV     [--W15],W1
02C88:  MOV     #D,W0
02C8A:  CPSGT   W1,W0
02C8C:  BRA     2C76
02C8E:  MOV     89E,W0
02C90:  MOV     #0,W4
02C92:  CALL    169A
02C96:  BTSC.B  219.1
02C98:  BRA     2C96
02C9A:  MOV     #A,W4
02C9C:  MOV     W4,21A
02C9E:  BTSC.B  219.1
02CA0:  BRA     2C9E
02CA2:  MOV     #D,W4
02CA4:  MOV     W4,21A
....................     
....................    // If displacement is zero than no need to move 
....................    if(displ == 0) 
02CA6:  CP0     89E
02CA8:  BRA     NZ,2CAC
....................       return; 
02CAA:  BRA     2DE4
....................        
....................    // Find out after how many steps we must start deceleration. 
....................    md_accel_lim = ((long)displ * md_decel) / (md_accel + md_decel); 
02CAC:  MOV     89E,W5
02CAE:  MOV     #0,W6
02CB0:  MOV     W5,W0
02CB2:  MOV     W6,W1
02CB4:  MOV     81E,W2
02CB6:  MOV     #0,W3
02CB8:  CALL    2B4E
02CBC:  MOV     W0,W5
02CBE:  MOV     W1,W6
02CC0:  MOV     81C,W0
02CC2:  ADD     81E,W0
02CC4:  BCLR.B  43.0
02CC6:  MOV     W6,W1
02CC8:  MOV     W0,W2
02CCA:  MOV     #0,W3
02CCC:  MOV     W5,W0
02CCE:  CALL    2B90
02CD2:  MOV     W0,824
....................    // We must accelerate at least 1 step before we can start deceleration. 
....................    if(md_accel_lim == 0) 
02CD4:  CP0     824
02CD6:  BRA     NZ,2CDC
....................       md_accel_lim = 1; 
02CD8:  MOV     #1,W4
02CDA:  MOV     W4,824
....................     
....................    // Use the limit we hit first to calc decel. 
....................    if(md_accel_lim >= md_max_acc_lim) 
02CDC:  MOV     84E,W0
02CDE:  MOV     824,W4
02CE0:  CP      W4,W0
02CE2:  BRA     NC,2D18
....................    { 
....................       md_accel_lim = md_max_acc_lim; 
02CE4:  PUSH    84E
02CE6:  POP     824
....................        
....................       // Find step to start decleration. 
....................       md_decel_count = ((long)md_max_acc_lim * md_accel) / md_decel; 
02CE8:  MOV     84E,W5
02CEA:  MOV     #0,W6
02CEC:  MOV     W5,W0
02CEE:  MOV     W6,W1
02CF0:  MOV     81C,W2
02CF2:  MOV     #0,W3
02CF4:  CALL    2B4E
02CF8:  MOV     W0,W5
02CFA:  MOV     W1,W6
02CFC:  BCLR.B  43.0
02CFE:  MOV     W5,W0
02D00:  MOV     W6,W1
02D02:  MOV     81E,W2
02D04:  MOV     #0,W3
02D06:  CALL    2B90
02D0A:  MOV     W0,826
....................       md_decel_lim = displ - md_decel_count;  
02D0C:  MOV     89E,W4
02D0E:  MOV     826,W3
02D10:  SUB     W4,W3,W0
02D12:  MOV     W0,822
....................    } 
....................    else 
02D14:  GOTO    2D24
....................    { 
....................       md_decel_lim = displ - md_accel_lim; 
02D18:  MOV     89E,W4
02D1A:  MOV     824,W3
02D1C:  SUB     W4,W3,W0
02D1E:  MOV     W0,822
....................       md_decel_count = md_accel_lim; 
02D20:  PUSH    824
02D22:  POP     826
....................    } 
....................     
....................    // We must decelerate at least 1 step to stop. 
....................    if(md_decel_lim == 0) 
02D24:  CP0     822
02D26:  BRA     NZ,2D2C
....................       md_decel_lim = 1; 
02D28:  MOV     #1,W4
02D2A:  MOV     W4,822
....................  
....................    if(debug_mode_pwm) 
02D2C:  BTSS.B  800.4
02D2E:  BRA     2DC6
....................    { 
....................       fprintf(RS232,"Acceleration Limit: %u\n\r", md_accel_lim); 
02D30:  MOV     #0,W1
02D32:  MOV     W1,W0
02D34:  CALL    A26
02D38:  INC     W1,W1
02D3A:  MOV     W1,[W15++]
02D3C:  BTSC.B  219.1
02D3E:  BRA     2D3C
02D40:  MOV     W0,21A
02D42:  MOV     [--W15],W1
02D44:  MOV     #13,W0
02D46:  CPSGT   W1,W0
02D48:  BRA     2D32
02D4A:  MOV     824,W0
02D4C:  MOV     #0,W4
02D4E:  CALL    169A
02D52:  BTSC.B  219.1
02D54:  BRA     2D52
02D56:  MOV     #A,W4
02D58:  MOV     W4,21A
02D5A:  BTSC.B  219.1
02D5C:  BRA     2D5A
02D5E:  MOV     #D,W4
02D60:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Limit: %u\n\r", md_decel_lim); 
02D62:  MOV     #0,W1
02D64:  MOV     W1,W0
02D66:  CALL    A50
02D6A:  INC     W1,W1
02D6C:  MOV     W1,[W15++]
02D6E:  BTSC.B  219.1
02D70:  BRA     2D6E
02D72:  MOV     W0,21A
02D74:  MOV     [--W15],W1
02D76:  MOV     #13,W0
02D78:  CPSGT   W1,W0
02D7A:  BRA     2D64
02D7C:  MOV     822,W0
02D7E:  MOV     #0,W4
02D80:  CALL    169A
02D84:  BTSC.B  219.1
02D86:  BRA     2D84
02D88:  MOV     #A,W4
02D8A:  MOV     W4,21A
02D8C:  BTSC.B  219.1
02D8E:  BRA     2D8C
02D90:  MOV     #D,W4
02D92:  MOV     W4,21A
....................       fprintf(RS232,"Deceleration Count: %u\n\r", md_decel_count); 
02D94:  MOV     #0,W1
02D96:  MOV     W1,W0
02D98:  CALL    A7A
02D9C:  INC     W1,W1
02D9E:  MOV     W1,[W15++]
02DA0:  BTSC.B  219.1
02DA2:  BRA     2DA0
02DA4:  MOV     W0,21A
02DA6:  MOV     [--W15],W1
02DA8:  MOV     #13,W0
02DAA:  CPSGT   W1,W0
02DAC:  BRA     2D96
02DAE:  MOV     826,W0
02DB0:  MOV     #0,W4
02DB2:  CALL    169A
02DB6:  BTSC.B  219.1
02DB8:  BRA     2DB6
02DBA:  MOV     #A,W4
02DBC:  MOV     W4,21A
02DBE:  BTSC.B  219.1
02DC0:  BRA     2DBE
02DC2:  MOV     #D,W4
02DC4:  MOV     W4,21A
....................    } 
....................  
....................    md_run_state = ACCEL; 
02DC6:  MOV.B   #1,W0L
02DC8:  MOV.B   W0L,801
....................    md_mt_set(mt_percent_trip); 
02DCA:  PUSH    808
02DCC:  POP     8AA
02DCE:  CALL    1FB4
....................  
....................    pwm_set_period(delays[0]); 
02DD2:  MOV     #7D0,W4
02DD4:  MOV     W4,8AE
02DD6:  CALL    22FA
....................    pwm_select_mode(FREE); 
02DDA:  CLR     8AA
02DDC:  CALL    1AC0
....................    pwm_enable(); 
02DE0:  CALL    23CA
.................... } 
02DE4:  MOV     [--W15],W6
02DE6:  MOV     [--W15],W5
02DE8:  RETURN  
.................... // Move to given position (mm) 
.................... void move_pos(unsigned int16 position) 
.................... { 
*
02EE4:  MOV     W5,[W15++]
02EE6:  MOV     #C,W5
02EE8:  REPEAT  #4
02EEA:  MOV     [W5++],[W15++]
....................    if(position>md_move_range) 
02EEC:  MOV     80E,W0
02EEE:  MOV     896,W4
02EF0:  CP      W4,W0
02EF2:  BRA     LEU,2F1A
....................    { 
....................       position=md_move_range; 
02EF4:  PUSH    80E
02EF6:  POP     896
....................       if(debug_mode_md) 
02EF8:  BTSS.B  800.3
02EFA:  BRA     2F16
....................          fprintf(RS232, "Invalid entry: System cannot move to a position beyond the movement range. System will move to maximum possible distance."); 
02EFC:  MOV     #0,W1
02EFE:  MOV     W1,W0
02F00:  CALL    AA4
02F04:  INC     W1,W1
02F06:  MOV     W1,[W15++]
02F08:  BTSC.B  219.1
02F0A:  BRA     2F08
02F0C:  MOV     W0,21A
02F0E:  MOV     [--W15],W1
02F10:  MOV     #78,W0
02F12:  CPSGT   W1,W0
02F14:  BRA     2EFE
....................    } 
....................    else if(position<md_min_distance) 
02F16:  GOTO    2F66
02F1A:  MOV     896,W0
02F1C:  MOV     818,W4
02F1E:  CP      W4,W0
02F20:  BRA     LEU,2F66
....................    { 
....................       position=md_min_distance; 
02F22:  PUSH    818
02F24:  POP     896
....................       if(debug_mode_md) 
02F26:  BTSS.B  800.3
02F28:  BRA     2F66
....................          fprintf(RS232, "Invalid entry: System cannot move to a position smaller than %u mm. System will move to minimum possible distance.", md_min_distance); 
02F2A:  MOV     #0,W1
02F2C:  MOV     W1,W0
02F2E:  CALL    B16
02F32:  INC     W1,W1
02F34:  MOV     W1,[W15++]
02F36:  BTSC.B  219.1
02F38:  BRA     2F36
02F3A:  MOV     W0,21A
02F3C:  MOV     [--W15],W1
02F3E:  MOV     #3C,W0
02F40:  CPSGT   W1,W0
02F42:  BRA     2F2C
02F44:  MOV     818,W0
02F46:  MOV     #0,W4
02F48:  CALL    169A
02F4C:  MOV     #3F,W1
02F4E:  MOV     W1,W0
02F50:  CALL    B16
02F54:  INC     W1,W1
02F56:  MOV     W1,[W15++]
02F58:  BTSC.B  219.1
02F5A:  BRA     2F58
02F5C:  MOV     W0,21A
02F5E:  MOV     [--W15],W1
02F60:  MOV     #71,W0
02F62:  CPSGT   W1,W0
02F64:  BRA     2F4E
....................    } 
....................     
....................    fprintf(RS232,"\n\rTarget Position: %u mm\n\r", position); 
02F66:  MOV     #0,W1
02F68:  MOV     W1,W0
02F6A:  CALL    B84
02F6E:  INC     W1,W1
02F70:  MOV     W1,[W15++]
02F72:  BTSC.B  219.1
02F74:  BRA     2F72
02F76:  MOV     W0,21A
02F78:  MOV     [--W15],W1
02F7A:  MOV     #12,W0
02F7C:  CPSGT   W1,W0
02F7E:  BRA     2F68
02F80:  MOV     896,W0
02F82:  MOV     #0,W4
02F84:  CALL    169A
02F88:  MOV     #15,W1
02F8A:  MOV     W1,W0
02F8C:  CALL    B84
02F90:  INC     W1,W1
02F92:  MOV     W1,[W15++]
02F94:  BTSC.B  219.1
02F96:  BRA     2F94
02F98:  MOV     W0,21A
02F9A:  MOV     [--W15],W1
02F9C:  MOV     #19,W0
02F9E:  CPSGT   W1,W0
02FA0:  BRA     2F8A
....................  
....................    data_set_last_pos(position); 
02FA2:  PUSH    896
02FA4:  POP     89C
02FA6:  CALL    27AC
....................     
....................    unsigned int16 count = md_end_pos-((float)(position-md_min_distance)/2.0f)*((float)(md_end_pos-md_home_pos)/((float)(md_move_range-md_min_distance)/2.0f)); 
02FAA:  MOV     896,W4
02FAC:  MOV     818,W3
02FAE:  SUB     W4,W3,W0
02FB0:  CALL    27BA
*
03020:  MOV     W0,898
....................     
....................    if(qei_get_count() < count) 
03022:  CALL    23C4
03026:  MOV     W0,W5
03028:  MOV     898,W4
0302A:  CP      W4,W5
0302C:  BRA     LEU,3036
....................       count-=md_backlash; 
0302E:  MOV     898,W4
03030:  MOV     82C,W3
03032:  SUB     W4,W3,W0
03034:  MOV     W0,898
....................     
....................    move_to(count); 
03036:  PUSH    898
03038:  POP     89C
0303A:  CALL    2C1A
....................     
....................    delay_ms(100); 
0303E:  MOV     #64,W0
03040:  CALL    168A
....................     
....................    if(debug_mode_md) 
03044:  BTSS.B  800.3
03046:  BRA     3148
....................    { 
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
03048:  MOV     #0,W1
0304A:  MOV     W1,W0
0304C:  CALL    BB0
03050:  INC     W1,W1
03052:  MOV     W1,[W15++]
03054:  BTSC.B  219.1
03056:  BRA     3054
03058:  MOV     W0,21A
0305A:  MOV     [--W15],W1
0305C:  MOV     #E,W0
0305E:  CPSGT   W1,W0
03060:  BRA     304A
03062:  MOV     82A,W0
03064:  MOV     #0,W4
03066:  CALL    2DEA
0306A:  BTSC.B  219.1
0306C:  BRA     306A
0306E:  MOV     #A,W4
03070:  MOV     W4,21A
03072:  BTSC.B  219.1
03074:  BRA     3072
03076:  MOV     #D,W4
03078:  MOV     W4,21A
....................       fprintf(RS232,"Target Encoder count: %u\n\r",md_target_count); 
0307A:  MOV     #0,W1
0307C:  MOV     W1,W0
0307E:  CALL    BD4
03082:  INC     W1,W1
03084:  MOV     W1,[W15++]
03086:  BTSC.B  219.1
03088:  BRA     3086
0308A:  MOV     W0,21A
0308C:  MOV     [--W15],W1
0308E:  MOV     #15,W0
03090:  CPSGT   W1,W0
03092:  BRA     307C
03094:  MOV     81A,W0
03096:  MOV     #0,W4
03098:  CALL    169A
0309C:  BTSC.B  219.1
0309E:  BRA     309C
030A0:  MOV     #A,W4
030A2:  MOV     W4,21A
030A4:  BTSC.B  219.1
030A6:  BRA     30A4
030A8:  MOV     #D,W4
030AA:  MOV     W4,21A
....................       fprintf(RS232,"Current Encoder count: %u\n\r",qei_get_count()); 
030AC:  CALL    23C4
030B0:  MOV     W0,W5
030B2:  MOV     #0,W1
030B4:  MOV     W1,W0
030B6:  CALL    C00
030BA:  INC     W1,W1
030BC:  MOV     W1,[W15++]
030BE:  BTSC.B  219.1
030C0:  BRA     30BE
030C2:  MOV     W0,21A
030C4:  MOV     [--W15],W1
030C6:  MOV     #16,W0
030C8:  CPSGT   W1,W0
030CA:  BRA     30B4
030CC:  MOV     W5,W0
030CE:  MOV     #0,W4
030D0:  CALL    169A
030D4:  BTSC.B  219.1
030D6:  BRA     30D4
030D8:  MOV     #A,W4
030DA:  MOV     W4,21A
030DC:  BTSC.B  219.1
030DE:  BRA     30DC
030E0:  MOV     #D,W4
030E2:  MOV     W4,21A
....................       fprintf(RS232,"Number of Iterations: %u\n\r",md_pos_iter); 
030E4:  MOV     #0,W1
030E6:  MOV     W1,W0
030E8:  CALL    C2C
030EC:  INC     W1,W1
030EE:  MOV     W1,[W15++]
030F0:  BTSC.B  219.1
030F2:  BRA     30F0
030F4:  MOV     W0,21A
030F6:  MOV     [--W15],W1
030F8:  MOV     #15,W0
030FA:  CPSGT   W1,W0
030FC:  BRA     30E6
030FE:  MOV     828,W0
03100:  MOV     #0,W4
03102:  CALL    169A
03106:  BTSC.B  219.1
03108:  BRA     3106
0310A:  MOV     #A,W4
0310C:  MOV     W4,21A
0310E:  BTSC.B  219.1
03110:  BRA     310E
03112:  MOV     #D,W4
03114:  MOV     W4,21A
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
03116:  MOV     #0,W1
03118:  MOV     W1,W0
0311A:  CALL    BB0
0311E:  INC     W1,W1
03120:  MOV     W1,[W15++]
03122:  BTSC.B  219.1
03124:  BRA     3122
03126:  MOV     W0,21A
03128:  MOV     [--W15],W1
0312A:  MOV     #E,W0
0312C:  CPSGT   W1,W0
0312E:  BRA     3118
03130:  MOV     82A,W0
03132:  MOV     #0,W4
03134:  CALL    2DEA
03138:  BTSC.B  219.1
0313A:  BRA     3138
0313C:  MOV     #A,W4
0313E:  MOV     W4,21A
03140:  BTSC.B  219.1
03142:  BRA     3140
03144:  MOV     #D,W4
03146:  MOV     W4,21A
....................    } 
....................     
....................    fprintf(RS232,"Error: %d\n\r",(int)qei_get_count()-(int)md_target_count); 
03148:  CALL    23C4
0314C:  MOV     W0,W5
0314E:  MOV     81A,W4
03150:  SUB     W5,W4,W5
03152:  MOV     #0,W1
03154:  MOV     W1,W0
03156:  CALL    C58
0315A:  INC     W1,W1
0315C:  MOV     W1,[W15++]
0315E:  BTSC.B  219.1
03160:  BRA     315E
03162:  MOV     W0,21A
03164:  MOV     [--W15],W1
03166:  MOV     #6,W0
03168:  CPSGT   W1,W0
0316A:  BRA     3154
0316C:  MOV     W5,W0
0316E:  MOV     #0,W4
03170:  CALL    2DEA
03174:  BTSC.B  219.1
03176:  BRA     3174
03178:  MOV     #A,W4
0317A:  MOV     W4,21A
0317C:  BTSC.B  219.1
0317E:  BRA     317C
03180:  MOV     #D,W4
03182:  MOV     W4,21A
.................... } 
03184:  MOV     #14,W5
03186:  REPEAT  #4
03188:  MOV     [--W15],[W5--]
0318A:  MOV     [--W15],W5
0318C:  RETURN  
.................... // Homing Function 
.................... void move_home() 
.................... { 
....................    fprintf(RS232,"Homing...\n\r");    
*
0260C:  MOV     #0,W1
0260E:  MOV     W1,W0
02610:  CALL    C74
02614:  INC     W1,W1
02616:  MOV     W1,[W15++]
02618:  BTSC.B  219.1
0261A:  BRA     2618
0261C:  MOV     W0,21A
0261E:  MOV     [--W15],W1
02620:  MOV     #A,W0
02622:  CPSGT   W1,W0
02624:  BRA     260E
....................     
....................    md_run_state = HOME; 
02626:  CLR.B   801
....................    md_decel_count = 0; 
02628:  CLR     826
....................    reg_md_home = 0; 
0262A:  BCLR.B  84C.0
....................    reg_md_home_return = 0; 
0262C:  BCLR.B  84C.1
....................     
....................    output_high(MD_DIR); 
0262E:  BCLR.B  2D8.4
02630:  BSET.B  2DC.4
....................    md_mt_set(mt_percent_trip); 
02632:  PUSH    808
02634:  POP     8AA
02636:  CALL    1FB4
....................  
....................    pwm_set_period(delays[0]); 
0263A:  MOV     #7D0,W4
0263C:  MOV     W4,8AE
0263E:  CALL    22FA
....................    pwm_select_mode(FREE); 
02642:  CLR     8AA
02644:  CALL    1AC0
....................    pwm_enable(); 
02648:  CALL    23CA
.................... } 
0264C:  RETURN  
.................... // Initializes the system for movement 
.................... void move_init() 
.................... { 
*
0318E:  MOV     W5,[W15++]
....................    md_move_range = data_get_move_range(); 
03190:  CALL    2114
03194:  MOV     W0,80E
....................    md_move_range = data_get_move_range(); 
03196:  CALL    2114
0319A:  MOV     W0,80E
....................    md_home_pos = data_get_home_pos(); 
0319C:  CALL    2164
031A0:  MOV     W0,810
....................    md_end_pos = data_get_end_pos(); 
031A2:  CALL    21B4
031A6:  MOV     W0,812
....................    md_backlash = data_get_backlash(); 
031A8:  CALL    2204
031AC:  MOV     W0,82C
....................    qei_set_max_count(md_end_pos+md_end_offset); 
031AE:  MOV     812,W0
031B0:  ADD     814,W0
031B2:  MOV     W0,W5
031B4:  MOV     W5,858
031B6:  CALL    2254
....................    md_conv_const = data_get_conv_const(); 
031BA:  CALL    2298
031BE:  MOV     W0,80C
....................     
....................    if(md_move_range==2000) 
031C0:  MOV     80E,W4
031C2:  MOV     #7D0,W3
031C4:  CP      W3,W4
031C6:  BRA     NZ,31CC
....................       md_min_distance=120; 
031C8:  MOV     #78,W4
031CA:  MOV     W4,818
....................           
....................    move_home();                        // Move to home position 
031CC:  CALL    260C
....................     
....................    delay_ms(500); 
031D0:  MOV     #1F4,W0
031D2:  CALL    168A
....................        
....................    if(debug_mode_md) 
031D6:  BTSS.B  800.3
031D8:  BRA     321C
....................       fprintf(RS232,"Moving Last Position: %u mm\n\r", data_get_last_pos()); 
031DA:  CALL    264E
031DE:  MOV     W0,W5
031E0:  MOV     #0,W1
031E2:  MOV     W1,W0
031E4:  CALL    C90
031E8:  INC     W1,W1
031EA:  MOV     W1,[W15++]
031EC:  BTSC.B  219.1
031EE:  BRA     31EC
031F0:  MOV     W0,21A
031F2:  MOV     [--W15],W1
031F4:  MOV     #15,W0
031F6:  CPSGT   W1,W0
031F8:  BRA     31E2
031FA:  MOV     W5,W0
031FC:  MOV     #0,W4
031FE:  CALL    169A
03202:  MOV     #18,W1
03204:  MOV     W1,W0
03206:  CALL    C90
0320A:  INC     W1,W1
0320C:  MOV     W1,[W15++]
0320E:  BTSC.B  219.1
03210:  BRA     320E
03212:  MOV     W0,21A
03214:  MOV     [--W15],W1
03216:  MOV     #1C,W0
03218:  CPSGT   W1,W0
0321A:  BRA     3204
....................  
....................    move_pos(data_get_last_pos()); 
0321C:  CALL    264E
03220:  MOV     W0,W5
03222:  MOV     W5,896
03224:  CALL    2EE4
.................... } 
03228:  MOV     [--W15],W5
0322A:  RETURN  
....................  
.................... void pp_str_low_check() 
.................... { 
*
03484:  MOV     W5,[W15++]
03486:  BSET.B  85C.0
03488:  CLR     85E
....................    int1 check = 1; 
....................    int sum = 0; 
....................     
....................    while(check) 
....................    { 
0348A:  BTSS.B  85C.0
0348C:  BRA     34C6
....................       sum = 0; 
0348E:  CLR     85E
....................       if(input(PP_STR) == 1) 
03490:  BSET.B  2D3.2
03492:  BTSS.B  2D5.2
03494:  BRA     34C2
....................       { 
....................          unsigned int i; 
....................          for(i=0; i<100; i++) 
03496:  CLR     860
03498:  MOV     860,W4
0349A:  MOV     #64,W3
0349C:  CP      W3,W4
0349E:  BRA     LEU,34B8
....................          { 
....................             delay_us(pp_str_delay); 
034A0:  MOV     846,W0
034A2:  CALL    2344
....................             if(input(PP_STR) == 1) 
034A6:  BSET.B  2D3.2
034A8:  BTSS.B  2D5.2
034AA:  BRA     34B2
....................                sum += 1; 
034AC:  MOV     85E,W4
034AE:  ADD     W4,#1,W4
034B0:  MOV     W4,85E
....................          } 
034B2:  INC     0860
034B4:  GOTO    3498
....................          if(sum > 70) 
034B8:  MOV     85E,W4
034BA:  MOV     #46,W3
034BC:  CP      W3,W4
034BE:  BRA     GE,34C2
....................          { 
....................             check = 0; 
034C0:  BCLR.B  85C.0
....................          } 
....................       } 
....................    } 
034C2:  GOTO    348A
.................... } 
034C6:  MOV     [--W15],W5
034C8:  RETURN  
.................... void pp_str_high_check() 
.................... { 
034CA:  MOV     W5,[W15++]
034CC:  BSET.B  85C.0
034CE:  CLR     85E
....................    int1 check = 1; 
....................    int sum = 0; 
....................     
....................    while(check) 
....................    { 
034D0:  BTSS.B  85C.0
034D2:  BRA     350C
....................       sum = 0; 
034D4:  CLR     85E
....................       if(input(PP_STR) == 0) 
034D6:  BSET.B  2D3.2
034D8:  BTSC.B  2D5.2
034DA:  BRA     3508
....................       { 
....................          unsigned int i; 
....................          for(i=0; i<100; i++) 
034DC:  CLR     860
034DE:  MOV     860,W4
034E0:  MOV     #64,W3
034E2:  CP      W3,W4
034E4:  BRA     LEU,34FE
....................          { 
....................             delay_us(pp_str_delay); 
034E6:  MOV     846,W0
034E8:  CALL    2344
....................             if(input(PP_STR) == 0) 
034EC:  BSET.B  2D3.2
034EE:  BTSC.B  2D5.2
034F0:  BRA     34F8
....................                sum += 1; 
034F2:  MOV     85E,W4
034F4:  ADD     W4,#1,W4
034F6:  MOV     W4,85E
....................          } 
034F8:  INC     0860
034FA:  GOTO    34DE
....................          if(sum > 70) 
034FE:  MOV     85E,W4
03500:  MOV     #46,W3
03502:  CP      W3,W4
03504:  BRA     GE,3508
....................          { 
....................             check = 0; 
03506:  BCLR.B  85C.0
....................          } 
....................       } 
....................    } 
03508:  GOTO    34D0
.................... } 
0350C:  MOV     [--W15],W5
0350E:  RETURN  
.................... // Checks strobe signal state change 
.................... void pp_str_check() 
.................... { 
....................    pp_str_low_check(); 
03510:  CALL    3484
....................    pp_str_high_check(); 
03514:  CALL    34CA
.................... } 
03518:  RETURN  
.................... //Gets byte via parallel port 
.................... unsigned int pp_get_byte() 
.................... { 
*
032A8:  MOV     W5,[W15++]
032AA:  CLR     856
032AC:  CLR     858
032AE:  CLR     85A
032B0:  CLR     85C
032B2:  CLR     85E
032B4:  CLR     860
032B6:  CLR     862
032B8:  CLR     864
032BA:  CLR     866
032BC:  BSET.B  86A.0
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................     
....................    unsigned int i; 
....................    int1 check = 1; 
....................     
....................    while(check) 
....................    { 
032BE:  BTSS.B  86A.0
032C0:  BRA     344E
....................       int sum7 = 0; 
....................       int sum6 = 0; 
....................       int sum5 = 0; 
....................       int sum4 = 0; 
....................       int sum3 = 0; 
....................       int sum2 = 0; 
....................       int sum1 = 0; 
....................       int sum0 = 0; 
032C2:  CLR     86C
032C4:  CLR     86E
032C6:  CLR     870
032C8:  CLR     872
032CA:  CLR     874
032CC:  CLR     876
032CE:  CLR     878
032D0:  CLR     87A
....................              
....................       for(i=0; i<100; i++) 
032D2:  CLR     868
032D4:  MOV     868,W4
032D6:  MOV     #64,W3
032D8:  CP      W3,W4
032DA:  BRA     LEU,3348
....................       { 
....................          delay_us(pp_str_delay); 
032DC:  MOV     846,W0
032DE:  CALL    2344
....................          if(input(PP_D7) == 0) 
032E2:  BSET.B  2D2.3
032E4:  BTSC.B  2D4.3
032E6:  BRA     32EE
....................             sum7 += 1; 
032E8:  MOV     86C,W4
032EA:  ADD     W4,#1,W4
032EC:  MOV     W4,86C
....................          if(input(PP_D6) == 0) 
032EE:  BSET.B  2D2.2
032F0:  BTSC.B  2D4.2
032F2:  BRA     32FA
....................             sum6 += 1; 
032F4:  MOV     86E,W4
032F6:  ADD     W4,#1,W4
032F8:  MOV     W4,86E
....................          if(input(PP_D5) == 0) 
032FA:  BSET.B  2D2.1
032FC:  BTSC.B  2D4.1
032FE:  BRA     3306
....................             sum5 += 1; 
03300:  MOV     870,W4
03302:  ADD     W4,#1,W4
03304:  MOV     W4,870
....................          if(input(PP_D4) == 0) 
03306:  BSET.B  2CD.6
03308:  BTSC.B  2CF.6
0330A:  BRA     3312
....................             sum4 += 1; 
0330C:  MOV     872,W4
0330E:  ADD     W4,#1,W4
03310:  MOV     W4,872
....................          if(input(PP_D3) == 0) 
03312:  BSET.B  2CD.5
03314:  BTSC.B  2CF.5
03316:  BRA     331E
....................             sum3 += 1; 
03318:  MOV     874,W4
0331A:  ADD     W4,#1,W4
0331C:  MOV     W4,874
....................          if(input(PP_D2) == 0) 
0331E:  BSET.B  2D2.0
03320:  BTSC.B  2D4.0
03322:  BRA     332A
....................             sum2 += 1; 
03324:  MOV     876,W4
03326:  ADD     W4,#1,W4
03328:  MOV     W4,876
....................          if(input(PP_D1) == 0) 
0332A:  BSET.B  2D3.1
0332C:  BTSC.B  2D5.1
0332E:  BRA     3336
....................             sum1 += 1; 
03330:  MOV     878,W4
03332:  ADD     W4,#1,W4
03334:  MOV     W4,878
....................          if(input(PP_D0) == 0) 
03336:  BSET.B  2D3.0
03338:  BTSC.B  2D5.0
0333A:  BRA     3342
....................             sum0 += 1; 
0333C:  MOV     87A,W4
0333E:  ADD     W4,#1,W4
03340:  MOV     W4,87A
....................       } 
03342:  INC     0868
03344:  GOTO    32D4
....................        
....................       if(sum7 > 70) 
03348:  MOV     86C,W4
0334A:  MOV     #46,W3
0334C:  CP      W3,W4
0334E:  BRA     GE,3358
....................          D7 = 1; 
03350:  MOV     #1,W4
03352:  MOV     W4,858
....................       else if (sum7 < 30) 
03354:  GOTO    3368
03358:  MOV     86C,W4
0335A:  CP      W4,#1E
0335C:  BRA     GE,3364
....................          D7 = 0; 
0335E:  CLR     858
....................       else 
03360:  GOTO    3368
....................          continue; 
03364:  GOTO    32BE
....................           
....................       if(sum6 > 70) 
03368:  MOV     86E,W4
0336A:  MOV     #46,W3
0336C:  CP      W3,W4
0336E:  BRA     GE,3378
....................          D6 = 1; 
03370:  MOV     #1,W4
03372:  MOV     W4,85A
....................       else if (sum6 < 30) 
03374:  GOTO    3388
03378:  MOV     86E,W4
0337A:  CP      W4,#1E
0337C:  BRA     GE,3384
....................          D6 = 0; 
0337E:  CLR     85A
....................       else 
03380:  GOTO    3388
....................          continue; 
03384:  GOTO    32BE
....................           
....................       if(sum5 > 70) 
03388:  MOV     870,W4
0338A:  MOV     #46,W3
0338C:  CP      W3,W4
0338E:  BRA     GE,3398
....................          D5 = 1; 
03390:  MOV     #1,W4
03392:  MOV     W4,85C
....................       else if (sum5 < 30) 
03394:  GOTO    33A8
03398:  MOV     870,W4
0339A:  CP      W4,#1E
0339C:  BRA     GE,33A4
....................          D5 = 0; 
0339E:  CLR     85C
....................       else 
033A0:  GOTO    33A8
....................          continue; 
033A4:  GOTO    32BE
....................           
....................       if(sum4 > 70) 
033A8:  MOV     872,W4
033AA:  MOV     #46,W3
033AC:  CP      W3,W4
033AE:  BRA     GE,33B8
....................          D4 = 1; 
033B0:  MOV     #1,W4
033B2:  MOV     W4,85E
....................       else if (sum4 < 30) 
033B4:  GOTO    33C8
033B8:  MOV     872,W4
033BA:  CP      W4,#1E
033BC:  BRA     GE,33C4
....................          D4 = 0; 
033BE:  CLR     85E
....................       else 
033C0:  GOTO    33C8
....................          continue; 
033C4:  GOTO    32BE
....................           
....................       if(sum3 > 70) 
033C8:  MOV     874,W4
033CA:  MOV     #46,W3
033CC:  CP      W3,W4
033CE:  BRA     GE,33D8
....................          D3 = 1; 
033D0:  MOV     #1,W4
033D2:  MOV     W4,860
....................       else if (sum3 < 30) 
033D4:  GOTO    33E8
033D8:  MOV     874,W4
033DA:  CP      W4,#1E
033DC:  BRA     GE,33E4
....................          D3 = 0; 
033DE:  CLR     860
....................       else 
033E0:  GOTO    33E8
....................          continue; 
033E4:  GOTO    32BE
....................           
....................       if(sum2 > 70) 
033E8:  MOV     876,W4
033EA:  MOV     #46,W3
033EC:  CP      W3,W4
033EE:  BRA     GE,33F8
....................          D2 = 1; 
033F0:  MOV     #1,W4
033F2:  MOV     W4,862
....................       else if (sum2 < 30) 
033F4:  GOTO    3408
033F8:  MOV     876,W4
033FA:  CP      W4,#1E
033FC:  BRA     GE,3404
....................          D2 = 0; 
033FE:  CLR     862
....................       else 
03400:  GOTO    3408
....................          continue; 
03404:  GOTO    32BE
....................           
....................       if(sum1 > 70) 
03408:  MOV     878,W4
0340A:  MOV     #46,W3
0340C:  CP      W3,W4
0340E:  BRA     GE,3418
....................          D1 = 1; 
03410:  MOV     #1,W4
03412:  MOV     W4,864
....................       else if (sum1 < 30) 
03414:  GOTO    3428
03418:  MOV     878,W4
0341A:  CP      W4,#1E
0341C:  BRA     GE,3424
....................          D1 = 0; 
0341E:  CLR     864
....................       else 
03420:  GOTO    3428
....................          continue; 
03424:  GOTO    32BE
....................           
....................       if(sum0 > 70) 
03428:  MOV     87A,W4
0342A:  MOV     #46,W3
0342C:  CP      W3,W4
0342E:  BRA     GE,3438
....................          D0 = 1; 
03430:  MOV     #1,W4
03432:  MOV     W4,866
....................       else if (sum0 < 30) 
03434:  GOTO    3448
03438:  MOV     87A,W4
0343A:  CP      W4,#1E
0343C:  BRA     GE,3444
....................          D0 = 0; 
0343E:  CLR     866
....................       else 
03440:  GOTO    3448
....................          continue; 
03444:  GOTO    32BE
....................           
....................       check = 0; 
03448:  BCLR.B  86A.0
....................    } 
0344A:  GOTO    32BE
....................     
....................    data=(D7<<7)+(D6<<6)+(D5<<5)+(D4<<4)+(D3<<3)+(D2<<2)+(D1<<1)+D0; 
0344E:  MOV     858,W5
03450:  SL      W5,#7,W5
03452:  MOV     85A,W0
03454:  SL      W0,#6,W0
03456:  ADD     W0,W5,W5
03458:  MOV     85C,W0
0345A:  SL      W0,#5,W0
0345C:  ADD     W0,W5,W5
0345E:  MOV     85E,W0
03460:  SL      W0,#4,W0
03462:  ADD     W0,W5,W5
03464:  MOV     860,W0
03466:  SL      W0,#3,W0
03468:  ADD     W0,W5,W5
0346A:  MOV     862,W0
0346C:  SL      W0,#2,W0
0346E:  ADD     W0,W5,W5
03470:  MOV     864,W0
03472:  SL      W0,#1,W0
03474:  ADD     W0,W5,W5
03476:  MOV     W5,W0
03478:  ADD     866,W0
0347A:  MOV     W0,856
....................  
....................    return data; 
0347C:  PUSH    856
0347E:  POP     0
.................... } 
03480:  MOV     [--W15],W5
03482:  RETURN  
.................... //Gets BCD byte via parallel port 
.................... unsigned int pp_get_BCD_byte() 
.................... { 
*
0351A:  MOV     W5,[W15++]
0351C:  CLR     85E
0351E:  CLR     860
03520:  CLR     862
03522:  CLR     864
03524:  CLR     866
03526:  CLR     868
03528:  CLR     86A
0352A:  CLR     86C
0352C:  CLR     86E
0352E:  BSET.B  872.0
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................  
....................     
....................    unsigned int i; 
....................    int1 check = 1; 
....................     
....................    while(check) 
....................    { 
03530:  BTSS.B  872.0
03532:  BRA     36C0
....................       int sum7 = 0; 
....................       int sum6 = 0; 
....................       int sum5 = 0; 
....................       int sum4 = 0; 
....................       int sum3 = 0; 
....................       int sum2 = 0; 
....................       int sum1 = 0; 
....................       int sum0 = 0; 
03534:  CLR     874
03536:  CLR     876
03538:  CLR     878
0353A:  CLR     87A
0353C:  CLR     87C
0353E:  CLR     87E
03540:  CLR     880
03542:  CLR     882
....................              
....................       for(i=0; i<100; i++) 
03544:  CLR     870
03546:  MOV     870,W4
03548:  MOV     #64,W3
0354A:  CP      W3,W4
0354C:  BRA     LEU,35BA
....................       { 
....................          delay_us(pp_str_delay); 
0354E:  MOV     846,W0
03550:  CALL    2344
....................          if(input(PP_D7) == 0) 
03554:  BSET.B  2D2.3
03556:  BTSC.B  2D4.3
03558:  BRA     3560
....................             sum7 += 1; 
0355A:  MOV     874,W4
0355C:  ADD     W4,#1,W4
0355E:  MOV     W4,874
....................          if(input(PP_D6) == 0) 
03560:  BSET.B  2D2.2
03562:  BTSC.B  2D4.2
03564:  BRA     356C
....................             sum6 += 1; 
03566:  MOV     876,W4
03568:  ADD     W4,#1,W4
0356A:  MOV     W4,876
....................          if(input(PP_D5) == 0) 
0356C:  BSET.B  2D2.1
0356E:  BTSC.B  2D4.1
03570:  BRA     3578
....................             sum5 += 1; 
03572:  MOV     878,W4
03574:  ADD     W4,#1,W4
03576:  MOV     W4,878
....................          if(input(PP_D4) == 0) 
03578:  BSET.B  2CD.6
0357A:  BTSC.B  2CF.6
0357C:  BRA     3584
....................             sum4 += 1; 
0357E:  MOV     87A,W4
03580:  ADD     W4,#1,W4
03582:  MOV     W4,87A
....................          if(input(PP_D3) == 0) 
03584:  BSET.B  2CD.5
03586:  BTSC.B  2CF.5
03588:  BRA     3590
....................             sum3 += 1; 
0358A:  MOV     87C,W4
0358C:  ADD     W4,#1,W4
0358E:  MOV     W4,87C
....................          if(input(PP_D2) == 0) 
03590:  BSET.B  2D2.0
03592:  BTSC.B  2D4.0
03594:  BRA     359C
....................             sum2 += 1; 
03596:  MOV     87E,W4
03598:  ADD     W4,#1,W4
0359A:  MOV     W4,87E
....................          if(input(PP_D1) == 0) 
0359C:  BSET.B  2D3.1
0359E:  BTSC.B  2D5.1
035A0:  BRA     35A8
....................             sum1 += 1; 
035A2:  MOV     880,W4
035A4:  ADD     W4,#1,W4
035A6:  MOV     W4,880
....................          if(input(PP_D0) == 0) 
035A8:  BSET.B  2D3.0
035AA:  BTSC.B  2D5.0
035AC:  BRA     35B4
....................             sum0 += 1; 
035AE:  MOV     882,W4
035B0:  ADD     W4,#1,W4
035B2:  MOV     W4,882
....................       } 
035B4:  INC     0870
035B6:  GOTO    3546
....................        
....................       if(sum7 > 70) 
035BA:  MOV     874,W4
035BC:  MOV     #46,W3
035BE:  CP      W3,W4
035C0:  BRA     GE,35CA
....................          D7 = 1; 
035C2:  MOV     #1,W4
035C4:  MOV     W4,860
....................       else if (sum7 < 30) 
035C6:  GOTO    35DA
035CA:  MOV     874,W4
035CC:  CP      W4,#1E
035CE:  BRA     GE,35D6
....................          D7 = 0; 
035D0:  CLR     860
....................       else 
035D2:  GOTO    35DA
....................          continue; 
035D6:  GOTO    3530
....................           
....................       if(sum6 > 70) 
035DA:  MOV     876,W4
035DC:  MOV     #46,W3
035DE:  CP      W3,W4
035E0:  BRA     GE,35EA
....................          D6 = 1; 
035E2:  MOV     #1,W4
035E4:  MOV     W4,862
....................       else if (sum6 < 30) 
035E6:  GOTO    35FA
035EA:  MOV     876,W4
035EC:  CP      W4,#1E
035EE:  BRA     GE,35F6
....................          D6 = 0; 
035F0:  CLR     862
....................       else 
035F2:  GOTO    35FA
....................          continue; 
035F6:  GOTO    3530
....................           
....................       if(sum5 > 70) 
035FA:  MOV     878,W4
035FC:  MOV     #46,W3
035FE:  CP      W3,W4
03600:  BRA     GE,360A
....................          D5 = 1; 
03602:  MOV     #1,W4
03604:  MOV     W4,864
....................       else if (sum5 < 30) 
03606:  GOTO    361A
0360A:  MOV     878,W4
0360C:  CP      W4,#1E
0360E:  BRA     GE,3616
....................          D5 = 0; 
03610:  CLR     864
....................       else 
03612:  GOTO    361A
....................          continue; 
03616:  GOTO    3530
....................           
....................       if(sum4 > 70) 
0361A:  MOV     87A,W4
0361C:  MOV     #46,W3
0361E:  CP      W3,W4
03620:  BRA     GE,362A
....................          D4 = 1; 
03622:  MOV     #1,W4
03624:  MOV     W4,866
....................       else if (sum4 < 30) 
03626:  GOTO    363A
0362A:  MOV     87A,W4
0362C:  CP      W4,#1E
0362E:  BRA     GE,3636
....................          D4 = 0; 
03630:  CLR     866
....................       else 
03632:  GOTO    363A
....................          continue; 
03636:  GOTO    3530
....................           
....................       if(sum3 > 70) 
0363A:  MOV     87C,W4
0363C:  MOV     #46,W3
0363E:  CP      W3,W4
03640:  BRA     GE,364A
....................          D3 = 1; 
03642:  MOV     #1,W4
03644:  MOV     W4,868
....................       else if (sum3 < 30) 
03646:  GOTO    365A
0364A:  MOV     87C,W4
0364C:  CP      W4,#1E
0364E:  BRA     GE,3656
....................          D3 = 0; 
03650:  CLR     868
....................       else 
03652:  GOTO    365A
....................          continue; 
03656:  GOTO    3530
....................           
....................       if(sum2 > 70) 
0365A:  MOV     87E,W4
0365C:  MOV     #46,W3
0365E:  CP      W3,W4
03660:  BRA     GE,366A
....................          D2 = 1; 
03662:  MOV     #1,W4
03664:  MOV     W4,86A
....................       else if (sum2 < 30) 
03666:  GOTO    367A
0366A:  MOV     87E,W4
0366C:  CP      W4,#1E
0366E:  BRA     GE,3676
....................          D2 = 0; 
03670:  CLR     86A
....................       else 
03672:  GOTO    367A
....................          continue; 
03676:  GOTO    3530
....................           
....................       if(sum1 > 70) 
0367A:  MOV     880,W4
0367C:  MOV     #46,W3
0367E:  CP      W3,W4
03680:  BRA     GE,368A
....................          D1 = 1; 
03682:  MOV     #1,W4
03684:  MOV     W4,86C
....................       else if (sum1 < 30) 
03686:  GOTO    369A
0368A:  MOV     880,W4
0368C:  CP      W4,#1E
0368E:  BRA     GE,3696
....................          D1 = 0; 
03690:  CLR     86C
....................       else 
03692:  GOTO    369A
....................          continue; 
03696:  GOTO    3530
....................           
....................       if(sum0 > 70) 
0369A:  MOV     882,W4
0369C:  MOV     #46,W3
0369E:  CP      W3,W4
036A0:  BRA     GE,36AA
....................          D0 = 1; 
036A2:  MOV     #1,W4
036A4:  MOV     W4,86E
....................       else if (sum0 < 30) 
036A6:  GOTO    36BA
036AA:  MOV     882,W4
036AC:  CP      W4,#1E
036AE:  BRA     GE,36B6
....................          D0 = 0; 
036B0:  CLR     86E
....................       else 
036B2:  GOTO    36BA
....................          continue; 
036B6:  GOTO    3530
....................           
....................       check = 0; 
036BA:  BCLR.B  872.0
....................    } 
036BC:  GOTO    3530
....................     
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
036C0:  CLR     884
036C2:  CLR     886
....................     
....................    byte0=8*D7+4*D6+2*D5+D4; 
036C4:  MOV     860,W5
036C6:  SL      W5,#3,W5
036C8:  MOV     862,W0
036CA:  SL      W0,#2,W0
036CC:  ADD     W0,W5,W5
036CE:  MOV     864,W0
036D0:  SL      W0,#1,W0
036D2:  ADD     W0,W5,W5
036D4:  MOV     W5,W0
036D6:  ADD     866,W0
036D8:  MOV     W0,884
....................    byte1=8*D3+4*D2+2*D1+D0; 
036DA:  MOV     868,W5
036DC:  SL      W5,#3,W5
036DE:  MOV     86A,W0
036E0:  SL      W0,#2,W0
036E2:  ADD     W0,W5,W5
036E4:  MOV     86C,W0
036E6:  SL      W0,#1,W0
036E8:  ADD     W0,W5,W5
036EA:  MOV     W5,W0
036EC:  ADD     86E,W0
036EE:  MOV     W0,886
....................    data=byte0*10+byte1; 
036F0:  MOV     884,W4
036F2:  MUL.UU  W4,#A,W0
036F4:  MOV     W0,W5
036F6:  MOV     W5,W0
036F8:  ADD     886,W0
036FA:  MOV     W0,85E
....................     
....................    return data; 
036FC:  PUSH    85E
036FE:  POP     0
.................... } 
03700:  MOV     [--W15],W5
03702:  RETURN  
.................... // Returns binary coded decimal byte of the given input 
.................... unsigned int pp_get_BCD_byte(unsigned int input) 
.................... { 
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
....................     
....................    byte0=8*bit_test(input,7)+4*bit_test(input,6)+2*bit_test(input,5)+bit_test(input,4); 
....................    byte1=8*bit_test(input,3)+4*bit_test(input,2)+2*bit_test(input,1)+bit_test(input,0); 
....................  
....................    return byte0*10+byte1; 
.................... } 
.................... // Sets position given via parallel port 
.................... void pp_set_pos() 
.................... { 
*
03720:  MOV     W5,[W15++]
....................    delay_ms(pp_rdy_delay); 
03722:  MOV     84A,W0
03724:  CALL    168A
....................    output_high(PP_RDY); 
03728:  BCLR.B  2D2.5
0372A:  BSET.B  2D6.5
....................  
....................    pp_str_check(); 
0372C:  CALL    3510
....................  
....................    output_low(PP_ACK); 
03730:  BCLR.B  2D2.4
03732:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
03734:  BCLR.B  2D2.5
03736:  BCLR.B  2D6.5
....................    delay_ms(pp_ack_delay); 
03738:  MOV     848,W0
0373A:  CALL    168A
....................    output_high(PP_ACK); 
0373E:  BCLR.B  2D2.4
03740:  BSET.B  2D6.4
....................     
....................    unsigned int index=pp_get_BCD_byte(); 
03742:  CALL    351A
03746:  MOV     W0,856
....................        
....................    delay_ms(pp_rdy_delay); 
03748:  MOV     84A,W0
0374A:  CALL    168A
....................    output_high(PP_RDY); 
0374E:  BCLR.B  2D2.5
03750:  BSET.B  2D6.5
....................     
....................    pp_str_check(); 
03752:  CALL    3510
....................     
....................    output_low(PP_ACK); 
03756:  BCLR.B  2D2.4
03758:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
0375A:  BCLR.B  2D2.5
0375C:  BCLR.B  2D6.5
....................    delay_ms(pp_ack_delay); 
0375E:  MOV     848,W0
03760:  CALL    168A
....................    output_high(PP_ACK); 
03764:  BCLR.B  2D2.4
03766:  BSET.B  2D6.4
....................     
....................    unsigned int pos0=pp_get_BCD_byte(); 
03768:  CALL    351A
0376C:  MOV     W0,858
....................     
....................    delay_ms(pp_rdy_delay); 
0376E:  MOV     84A,W0
03770:  CALL    168A
....................    output_high(PP_RDY); 
03774:  BCLR.B  2D2.5
03776:  BSET.B  2D6.5
....................     
....................    pp_str_check(); 
03778:  CALL    3510
....................  
....................    output_low(PP_ACK); 
0377C:  BCLR.B  2D2.4
0377E:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
03780:  BCLR.B  2D2.5
03782:  BCLR.B  2D6.5
....................    delay_ms(pp_ack_delay); 
03784:  MOV     848,W0
03786:  CALL    168A
....................    output_high(PP_ACK); 
0378A:  BCLR.B  2D2.4
0378C:  BSET.B  2D6.4
....................     
....................    unsigned int pos1=pp_get_BCD_byte(); 
0378E:  CALL    351A
03792:  MOV     W0,85A
....................  
....................    data_set_pos(index, pos0*100+pos1); 
03794:  MOV     858,W4
03796:  MOV     #64,W3
03798:  MUL.UU  W4,W3,W0
0379A:  MOV     W0,W5
0379C:  MOV     W5,W0
0379E:  ADD     85A,W0
037A0:  MOV     W0,W5
037A2:  MOV.B   856,W0L
037A4:  MOV.B   W0L,894
037A6:  MOV     W5,896
037A8:  CALL    3704
....................     
....................    fprintf(RS232,"Position set -> index: %u position: %u\n\r", index, pos0*100+pos1); 
037AC:  MOV     858,W4
037AE:  MOV     #64,W3
037B0:  MUL.UU  W4,W3,W0
037B2:  MOV     W0,W5
037B4:  MOV     W5,W0
037B6:  ADD     85A,W0
037B8:  MOV     W0,W5
037BA:  MOV     #0,W1
037BC:  MOV     W1,W0
037BE:  CALL    CBE
037C2:  INC     W1,W1
037C4:  MOV     W1,[W15++]
037C6:  BTSC.B  219.1
037C8:  BRA     37C6
037CA:  MOV     W0,21A
037CC:  MOV     [--W15],W1
037CE:  MOV     #16,W0
037D0:  CPSGT   W1,W0
037D2:  BRA     37BC
037D4:  MOV     856,W0
037D6:  MOV     #0,W4
037D8:  CALL    169A
037DC:  MOV     #19,W1
037DE:  MOV     W1,W0
037E0:  CALL    CBE
037E4:  INC     W1,W1
037E6:  MOV     W1,[W15++]
037E8:  BTSC.B  219.1
037EA:  BRA     37E8
037EC:  MOV     W0,21A
037EE:  MOV     [--W15],W1
037F0:  MOV     #23,W0
037F2:  CPSGT   W1,W0
037F4:  BRA     37DE
037F6:  MOV     W5,W0
037F8:  MOV     #0,W4
037FA:  CALL    169A
037FE:  BTSC.B  219.1
03800:  BRA     37FE
03802:  MOV     #A,W4
03804:  MOV     W4,21A
03806:  BTSC.B  219.1
03808:  BRA     3806
0380A:  MOV     #D,W4
0380C:  MOV     W4,21A
....................     
....................    pp_str_low_check(); 
0380E:  CALL    3484
.................... } 
03812:  MOV     [--W15],W5
03814:  RETURN  
.................... // Moves to position given via parallel port 
.................... void pp_move_pos(unsigned int input) 
.................... { 
*
03898:  CALL    351A
0389C:  MOV     W0,858
....................    unsigned int index=pp_get_BCD_byte();; 
....................    unsigned int position=data_get_pos(index); 
0389E:  MOV.B   858,W0L
038A0:  MOV.B   W0L,898
038A2:  CALL    3816
038A6:  MOV     W0,85A
....................     
....................    fprintf(RS232,"Move Position -> index: %u position: %u\n\r", index, position); 
038A8:  MOV     #0,W1
038AA:  MOV     W1,W0
038AC:  CALL    CF8
038B0:  INC     W1,W1
038B2:  MOV     W1,[W15++]
038B4:  BTSC.B  219.1
038B6:  BRA     38B4
038B8:  MOV     W0,21A
038BA:  MOV     [--W15],W1
038BC:  MOV     #17,W0
038BE:  CPSGT   W1,W0
038C0:  BRA     38AA
038C2:  MOV     858,W0
038C4:  MOV     #0,W4
038C6:  CALL    169A
038CA:  MOV     #1A,W1
038CC:  MOV     W1,W0
038CE:  CALL    CF8
038D2:  INC     W1,W1
038D4:  MOV     W1,[W15++]
038D6:  BTSC.B  219.1
038D8:  BRA     38D6
038DA:  MOV     W0,21A
038DC:  MOV     [--W15],W1
038DE:  MOV     #24,W0
038E0:  CPSGT   W1,W0
038E2:  BRA     38CC
038E4:  MOV     85A,W0
038E6:  MOV     #0,W4
038E8:  CALL    169A
038EC:  BTSC.B  219.1
038EE:  BRA     38EC
038F0:  MOV     #A,W4
038F2:  MOV     W4,21A
038F4:  BTSC.B  219.1
038F6:  BRA     38F4
038F8:  MOV     #D,W4
038FA:  MOV     W4,21A
....................        
....................    move_pos(position); 
038FC:  PUSH    85A
038FE:  POP     896
03900:  CALL    2EE4
.................... } 
03904:  RETURN  
.................... // Gets command via parallel port when system is idle 
.................... void pp_get_command() 
.................... { 
....................    output_low(PP_ACK); 
03906:  BCLR.B  2D2.4
03908:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
0390A:  BCLR.B  2D2.5
0390C:  BCLR.B  2D6.5
....................    delay_ms(pp_ack_delay); 
0390E:  MOV     848,W0
03910:  CALL    168A
....................    output_high(PP_ACK); 
03914:  BCLR.B  2D2.4
03916:  BSET.B  2D6.4
....................     
....................    unsigned int input=pp_get_byte(); 
03918:  CALL    32A8
0391C:  MOV     W0,854
....................  
....................    switch (input) 
....................    { 
0391E:  MOV     854,W0
03920:  XOR     #FE,W0
03922:  BRA     Z,3936
03924:  XOR     #3,W0
03926:  BRA     Z,3956
03928:  XOR     #1,W0
0392A:  BRA     Z,3978
0392C:  XOR     #7,W0
0392E:  BRA     Z,39A2
03930:  XOR     #4,W0
03932:  BRA     Z,39CC
03934:  BRA     39EE
....................       case 0x00FE:   fprintf(RS232,"Emergency Stop Command\n\r"); 
03936:  MOV     #0,W1
03938:  MOV     W1,W0
0393A:  CALL    D34
0393E:  INC     W1,W1
03940:  MOV     W1,[W15++]
03942:  BTSC.B  219.1
03944:  BRA     3942
03946:  MOV     W0,21A
03948:  MOV     [--W15],W1
0394A:  MOV     #17,W0
0394C:  CPSGT   W1,W0
0394E:  BRA     3938
....................                       
....................                      reg_pp_stop=1; 
03950:  BSET.B  800.7
....................                      break; 
03952:  GOTO    39FA
....................       case 0x00FD:   fprintf(RS232,"Homing Command\n\r"); 
03956:  MOV     #0,W1
03958:  MOV     W1,W0
0395A:  CALL    D5E
0395E:  INC     W1,W1
03960:  MOV     W1,[W15++]
03962:  BTSC.B  219.1
03964:  BRA     3962
03966:  MOV     W0,21A
03968:  MOV     [--W15],W1
0396A:  MOV     #F,W0
0396C:  CPSGT   W1,W0
0396E:  BRA     3958
....................        
....................                      move_home();    
03970:  CALL    260C
....................                      break; 
03974:  GOTO    39FA
....................       case 0x00FC:   fprintf(RS232,"Laser Off Command\n\r"); 
03978:  MOV     #0,W1
0397A:  MOV     W1,W0
0397C:  CALL    D80
03980:  INC     W1,W1
03982:  MOV     W1,[W15++]
03984:  BTSC.B  219.1
03986:  BRA     3984
03988:  MOV     W0,21A
0398A:  MOV     [--W15],W1
0398C:  MOV     #12,W0
0398E:  CPSGT   W1,W0
03990:  BRA     397A
....................                          
....................                      output_low(LAS_1); 
03992:  BCLR.B  2C6.0
03994:  BCLR.B  2CA.0
....................                      output_low(LAS_2); 
03996:  BCLR.B  2C6.1
03998:  BCLR.B  2CA.1
....................                      output_low(LAS_3); 
0399A:  BCLR.B  2D2.6
0399C:  BCLR.B  2D6.6
....................                      break; 
0399E:  GOTO    39FA
....................       case 0x00FB:   fprintf(RS232,"Laser On Command\n\r"); 
039A2:  MOV     #0,W1
039A4:  MOV     W1,W0
039A6:  CALL    DA4
039AA:  INC     W1,W1
039AC:  MOV     W1,[W15++]
039AE:  BTSC.B  219.1
039B0:  BRA     39AE
039B2:  MOV     W0,21A
039B4:  MOV     [--W15],W1
039B6:  MOV     #11,W0
039B8:  CPSGT   W1,W0
039BA:  BRA     39A4
....................                       
....................                      output_high(LAS_1); 
039BC:  BCLR.B  2C6.0
039BE:  BSET.B  2CA.0
....................                      output_high(LAS_2); 
039C0:  BCLR.B  2C6.1
039C2:  BSET.B  2CA.1
....................                      output_high(LAS_3); 
039C4:  BCLR.B  2D2.6
039C6:  BSET.B  2D6.6
....................                      break;  
039C8:  GOTO    39FA
....................       case 0x00FF:   fprintf(RS232,"Set Position Command\n\r"); 
039CC:  MOV     #0,W1
039CE:  MOV     W1,W0
039D0:  CALL    DC8
039D4:  INC     W1,W1
039D6:  MOV     W1,[W15++]
039D8:  BTSC.B  219.1
039DA:  BRA     39D8
039DC:  MOV     W0,21A
039DE:  MOV     [--W15],W1
039E0:  MOV     #15,W0
039E2:  CPSGT   W1,W0
039E4:  BRA     39CE
....................                       
....................                      pp_set_pos(); 
039E6:  CALL    3720
....................                      break; 
039EA:  GOTO    39FA
....................       default:       pp_move_pos(input);  
039EE:  PUSH    854
039F0:  POP     856
039F2:  CALL    3898
....................                      break; 
039F6:  GOTO    39FA
....................    } 
....................     
....................    delay_ms(pp_rdy_delay); 
039FA:  MOV     84A,W0
039FC:  CALL    168A
....................    output_high(PP_RDY); 
03A00:  BCLR.B  2D2.5
03A02:  BSET.B  2D6.5
.................... } 
03A04:  RETURN  
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
.................... { 
*
03F9C:  MOV     W5,[W15++]
03F9E:  MOV     W6,[W15++]
....................    char input; 
....................     
....................    input=fgetc(RS232); 
03FA0:  BTSS.B  218.0
03FA2:  BRA     3FA0
03FA4:  MOV     21C,W0
03FA6:  MOV.B   W0L,854
....................    switch (input){ 
03FA8:  MOV.B   854,W0L
03FAA:  CLR.B   1
03FAC:  XOR     #63,W0
03FAE:  BRA     Z,3FFA
03FB0:  XOR     #10,W0
03FB2:  BRA     Z,41EA
03FB4:  XOR     #1,W0
03FB6:  BRA     Z,4224
03FB8:  XOR     #1A,W0
03FBA:  BRA     Z,425E
03FBC:  XOR     #D,W0
03FBE:  BRA     Z,4298
03FC0:  XOR     #13,W0
03FC2:  BRA     Z,42D2
03FC4:  XOR     #14,W0
03FC6:  BRA     Z,430C
03FC8:  XOR     #16,W0
03FCA:  BRA     Z,4346
03FCC:  XOR     #1D,W0
03FCE:  BRA     Z,4380
03FD0:  XOR     #4,W0
03FD2:  BRA     Z,4388
03FD4:  XOR     #15,W0
03FD6:  BRA     Z,43AA
03FD8:  XOR     #9,W0
03FDA:  BRA     Z,4440
03FDC:  XOR     #1E,W0
03FDE:  BRA     Z,4596
03FE0:  XOR     #3,W0
03FE2:  BRA     Z,468A
03FE4:  XOR     #8,W0
03FE6:  BRA     Z,4778
03FE8:  XOR     #13,W0
03FEA:  BRA     Z,498E
03FEC:  XOR     #D,W0
03FEE:  BRA     Z,49CA
03FF0:  XOR     #1C,W0
03FF2:  BRA     Z,4A62
03FF4:  XOR     #7,W0
03FF6:  BRA     Z,4AEA
03FF8:  BRA     4AF0
....................       case 'c':   fprintf(RS232,"\n\rCOMMAND LIST\n\r"); 
03FFA:  MOV     #0,W1
03FFC:  MOV     W1,W0
03FFE:  CALL    DF0
04002:  INC     W1,W1
04004:  MOV     W1,[W15++]
04006:  BTSC.B  219.1
04008:  BRA     4006
0400A:  MOV     W0,21A
0400C:  MOV     [--W15],W1
0400E:  MOV     #F,W0
04010:  CPSGT   W1,W0
04012:  BRA     3FFC
....................                   fprintf(RS232,"\n\rSet Serial Number\t(s)"); 
04014:  MOV     #0,W1
04016:  MOV     W1,W0
04018:  CALL    E12
0401C:  INC     W1,W1
0401E:  MOV     W1,[W15++]
04020:  BTSC.B  219.1
04022:  BRA     4020
04024:  MOV     W0,21A
04026:  MOV     [--W15],W1
04028:  MOV     #16,W0
0402A:  CPSGT   W1,W0
0402C:  BRA     4016
....................                   fprintf(RS232,"\n\rSet Move Range \t\t(r)"); 
0402E:  MOV     #0,W1
04030:  MOV     W1,W0
04032:  CALL    E3A
04036:  INC     W1,W1
04038:  MOV     W1,[W15++]
0403A:  BTSC.B  219.1
0403C:  BRA     403A
0403E:  MOV     W0,21A
04040:  MOV     [--W15],W1
04042:  MOV     #15,W0
04044:  CPSGT   W1,W0
04046:  BRA     4030
....................                   fprintf(RS232,"\n\rSet Homing Distance \t(h)"); 
04048:  MOV     #0,W1
0404A:  MOV     W1,W0
0404C:  CALL    E62
04050:  INC     W1,W1
04052:  MOV     W1,[W15++]
04054:  BTSC.B  219.1
04056:  BRA     4054
04058:  MOV     W0,21A
0405A:  MOV     [--W15],W1
0405C:  MOV     #19,W0
0405E:  CPSGT   W1,W0
04060:  BRA     404A
....................                   fprintf(RS232,"\n\rSet End Distance \t(e)"); 
04062:  MOV     #0,W1
04064:  MOV     W1,W0
04066:  CALL    E8E
0406A:  INC     W1,W1
0406C:  MOV     W1,[W15++]
0406E:  BTSC.B  219.1
04070:  BRA     406E
04072:  MOV     W0,21A
04074:  MOV     [--W15],W1
04076:  MOV     #16,W0
04078:  CPSGT   W1,W0
0407A:  BRA     4064
....................                   fprintf(RS232,"\n\rSet Conversion Constant\t(v)"); 
0407C:  MOV     #0,W1
0407E:  MOV     W1,W0
04080:  CALL    EB6
04084:  INC     W1,W1
04086:  MOV     W1,[W15++]
04088:  BTSC.B  219.1
0408A:  BRA     4088
0408C:  MOV     W0,21A
0408E:  MOV     [--W15],W1
04090:  MOV     #1C,W0
04092:  CPSGT   W1,W0
04094:  BRA     407E
....................                   fprintf(RS232,"\n\rSet Backlash \t\t(b)"); 
04096:  MOV     #0,W1
04098:  MOV     W1,W0
0409A:  CALL    EE4
0409E:  INC     W1,W1
040A0:  MOV     W1,[W15++]
040A2:  BTSC.B  219.1
040A4:  BRA     40A2
040A6:  MOV     W0,21A
040A8:  MOV     [--W15],W1
040AA:  MOV     #13,W0
040AC:  CPSGT   W1,W0
040AE:  BRA     4098
....................                   fprintf(RS232,"\n\rSet Communication Type \t(t)"); 
040B0:  MOV     #0,W1
040B2:  MOV     W1,W0
040B4:  CALL    F0A
040B8:  INC     W1,W1
040BA:  MOV     W1,[W15++]
040BC:  BTSC.B  219.1
040BE:  BRA     40BC
040C0:  MOV     W0,21A
040C2:  MOV     [--W15],W1
040C4:  MOV     #1C,W0
040C6:  CPSGT   W1,W0
040C8:  BRA     40B2
....................                   fprintf(RS232,"\n\rGet System Data \t(i)"); 
040CA:  MOV     #0,W1
040CC:  MOV     W1,W0
040CE:  CALL    F38
040D2:  INC     W1,W1
040D4:  MOV     W1,[W15++]
040D6:  BTSC.B  219.1
040D8:  BRA     40D6
040DA:  MOV     W0,21A
040DC:  MOV     [--W15],W1
040DE:  MOV     #15,W0
040E0:  CPSGT   W1,W0
040E2:  BRA     40CC
....................                   fprintf(RS232,"\n\rGet Position List \t(m)"); 
040E4:  MOV     #0,W1
040E6:  MOV     W1,W0
040E8:  CALL    F60
040EC:  INC     W1,W1
040EE:  MOV     W1,[W15++]
040F0:  BTSC.B  219.1
040F2:  BRA     40F0
040F4:  MOV     W0,21A
040F6:  MOV     [--W15],W1
040F8:  MOV     #17,W0
040FA:  CPSGT   W1,W0
040FC:  BRA     40E6
....................                   fprintf(RS232,"\n\rMove To Position \t(x)"); 
040FE:  MOV     #0,W1
04100:  MOV     W1,W0
04102:  CALL    F8A
04106:  INC     W1,W1
04108:  MOV     W1,[W15++]
0410A:  BTSC.B  219.1
0410C:  BRA     410A
0410E:  MOV     W0,21A
04110:  MOV     [--W15],W1
04112:  MOV     #16,W0
04114:  CPSGT   W1,W0
04116:  BRA     4100
....................                   fprintf(RS232,"\n\rSet Table Data \t\t(q)"); 
04118:  MOV     #0,W1
0411A:  MOV     W1,W0
0411C:  CALL    FB2
04120:  INC     W1,W1
04122:  MOV     W1,[W15++]
04124:  BTSC.B  219.1
04126:  BRA     4124
04128:  MOV     W0,21A
0412A:  MOV     [--W15],W1
0412C:  MOV     #15,W0
0412E:  CPSGT   W1,W0
04130:  BRA     411A
....................                   fprintf(RS232,"\n\rTest Run (low res) \t(o)"); 
04132:  MOV     #0,W1
04134:  MOV     W1,W0
04136:  CALL    FDA
0413A:  INC     W1,W1
0413C:  MOV     W1,[W15++]
0413E:  BTSC.B  219.1
04140:  BRA     413E
04142:  MOV     W0,21A
04144:  MOV     [--W15],W1
04146:  MOV     #18,W0
04148:  CPSGT   W1,W0
0414A:  BRA     4134
....................                   fprintf(RS232,"\n\rTest Run (high res) \t(l)"); 
0414C:  MOV     #0,W1
0414E:  MOV     W1,W0
04150:  CALL    1004
04154:  INC     W1,W1
04156:  MOV     W1,[W15++]
04158:  BTSC.B  219.1
0415A:  BRA     4158
0415C:  MOV     W0,21A
0415E:  MOV     [--W15],W1
04160:  MOV     #19,W0
04162:  CPSGT   W1,W0
04164:  BRA     414E
....................                   fprintf(RS232,"\n\rSet Debug State \t(d)"); 
04166:  MOV     #0,W1
04168:  MOV     W1,W0
0416A:  CALL    1030
0416E:  INC     W1,W1
04170:  MOV     W1,[W15++]
04172:  BTSC.B  219.1
04174:  BRA     4172
04176:  MOV     W0,21A
04178:  MOV     [--W15],W1
0417A:  MOV     #15,W0
0417C:  CPSGT   W1,W0
0417E:  BRA     4168
....................                   fprintf(RS232,"\n\rGet Encoder Count \t(w)"); 
04180:  MOV     #0,W1
04182:  MOV     W1,W0
04184:  CALL    1058
04188:  INC     W1,W1
0418A:  MOV     W1,[W15++]
0418C:  BTSC.B  219.1
0418E:  BRA     418C
04190:  MOV     W0,21A
04192:  MOV     [--W15],W1
04194:  MOV     #17,W0
04196:  CPSGT   W1,W0
04198:  BRA     4182
....................                   fprintf(RS232,"\n\rStart Memory Test \t(z)"); 
0419A:  MOV     #0,W1
0419C:  MOV     W1,W0
0419E:  CALL    1082
041A2:  INC     W1,W1
041A4:  MOV     W1,[W15++]
041A6:  BTSC.B  219.1
041A8:  BRA     41A6
041AA:  MOV     W0,21A
041AC:  MOV     [--W15],W1
041AE:  MOV     #17,W0
041B0:  CPSGT   W1,W0
041B2:  BRA     419C
....................                   fprintf(RS232,"\n\rClear Memory \t\t(f)"); 
041B4:  MOV     #0,W1
041B6:  MOV     W1,W0
041B8:  CALL    10AC
041BC:  INC     W1,W1
041BE:  MOV     W1,[W15++]
041C0:  BTSC.B  219.1
041C2:  BRA     41C0
041C4:  MOV     W0,21A
041C6:  MOV     [--W15],W1
041C8:  MOV     #13,W0
041CA:  CPSGT   W1,W0
041CC:  BRA     41B6
....................                   fprintf(RS232,"\n\n\r"); 
041CE:  BTSC.B  219.1
041D0:  BRA     41CE
041D2:  MOV     #A,W4
041D4:  MOV     W4,21A
041D6:  BTSC.B  219.1
041D8:  BRA     41D6
041DA:  MOV     #A,W4
041DC:  MOV     W4,21A
041DE:  BTSC.B  219.1
041E0:  BRA     41DE
041E2:  MOV     #D,W4
041E4:  MOV     W4,21A
....................                   break; 
041E6:  GOTO    4AF0
....................       case 's':   fprintf(RS232,"\n\rSet Serial Number (13 Characters): "); 
041EA:  MOV     #0,W1
041EC:  MOV     W1,W0
041EE:  CALL    10D2
041F2:  INC     W1,W1
041F4:  MOV     W1,[W15++]
041F6:  BTSC.B  219.1
041F8:  BRA     41F6
041FA:  MOV     W0,21A
041FC:  MOV     [--W15],W1
041FE:  MOV     #24,W0
04200:  CPSGT   W1,W0
04202:  BRA     41EC
....................                   data_set_serial_no(); 
04204:  CALL    3A06
....................                   fprintf(RS232,"\n\n\r"); 
04208:  BTSC.B  219.1
0420A:  BRA     4208
0420C:  MOV     #A,W4
0420E:  MOV     W4,21A
04210:  BTSC.B  219.1
04212:  BRA     4210
04214:  MOV     #A,W4
04216:  MOV     W4,21A
04218:  BTSC.B  219.1
0421A:  BRA     4218
0421C:  MOV     #D,W4
0421E:  MOV     W4,21A
....................                   break; 
04220:  GOTO    4AF0
....................       case 'r':   fprintf(RS232,"\n\rSet Move Range in mm (xxxx): "); 
04224:  MOV     #0,W1
04226:  MOV     W1,W0
04228:  CALL    1108
0422C:  INC     W1,W1
0422E:  MOV     W1,[W15++]
04230:  BTSC.B  219.1
04232:  BRA     4230
04234:  MOV     W0,21A
04236:  MOV     [--W15],W1
04238:  MOV     #1E,W0
0423A:  CPSGT   W1,W0
0423C:  BRA     4226
....................                   data_set_move_range(); 
0423E:  CALL    3A6A
....................                   fprintf(RS232,"\n\n\r"); 
04242:  BTSC.B  219.1
04244:  BRA     4242
04246:  MOV     #A,W4
04248:  MOV     W4,21A
0424A:  BTSC.B  219.1
0424C:  BRA     424A
0424E:  MOV     #A,W4
04250:  MOV     W4,21A
04252:  BTSC.B  219.1
04254:  BRA     4252
04256:  MOV     #D,W4
04258:  MOV     W4,21A
....................                   break; 
0425A:  GOTO    4AF0
....................       case 'h':   fprintf(RS232,"\n\rSet Homing Distance in counts (xxxx): "); 
0425E:  MOV     #0,W1
04260:  MOV     W1,W0
04262:  CALL    1138
04266:  INC     W1,W1
04268:  MOV     W1,[W15++]
0426A:  BTSC.B  219.1
0426C:  BRA     426A
0426E:  MOV     W0,21A
04270:  MOV     [--W15],W1
04272:  MOV     #27,W0
04274:  CPSGT   W1,W0
04276:  BRA     4260
....................                   data_set_home_pos(); 
04278:  CALL    3B42
....................                   fprintf(RS232,"\n\n\r"); 
0427C:  BTSC.B  219.1
0427E:  BRA     427C
04280:  MOV     #A,W4
04282:  MOV     W4,21A
04284:  BTSC.B  219.1
04286:  BRA     4284
04288:  MOV     #A,W4
0428A:  MOV     W4,21A
0428C:  BTSC.B  219.1
0428E:  BRA     428C
04290:  MOV     #D,W4
04292:  MOV     W4,21A
....................                   break; 
04294:  GOTO    4AF0
....................       case 'e':   fprintf(RS232,"\n\rSet End Distance in counts (xxxxx): "); 
04298:  MOV     #0,W1
0429A:  MOV     W1,W0
0429C:  CALL    1172
042A0:  INC     W1,W1
042A2:  MOV     W1,[W15++]
042A4:  BTSC.B  219.1
042A6:  BRA     42A4
042A8:  MOV     W0,21A
042AA:  MOV     [--W15],W1
042AC:  MOV     #25,W0
042AE:  CPSGT   W1,W0
042B0:  BRA     429A
....................                   data_set_end_pos(); 
042B2:  CALL    3BD8
....................                   fprintf(RS232,"\n\n\r"); 
042B6:  BTSC.B  219.1
042B8:  BRA     42B6
042BA:  MOV     #A,W4
042BC:  MOV     W4,21A
042BE:  BTSC.B  219.1
042C0:  BRA     42BE
042C2:  MOV     #A,W4
042C4:  MOV     W4,21A
042C6:  BTSC.B  219.1
042C8:  BRA     42C6
042CA:  MOV     #D,W4
042CC:  MOV     W4,21A
....................                   break; 
042CE:  GOTO    4AF0
....................       case 'v':   fprintf(RS232,"\n\rSet Conversion Constant (xxxxx): "); 
042D2:  MOV     #0,W1
042D4:  MOV     W1,W0
042D6:  CALL    11AA
042DA:  INC     W1,W1
042DC:  MOV     W1,[W15++]
042DE:  BTSC.B  219.1
042E0:  BRA     42DE
042E2:  MOV     W0,21A
042E4:  MOV     [--W15],W1
042E6:  MOV     #22,W0
042E8:  CPSGT   W1,W0
042EA:  BRA     42D4
....................                   data_set_conv_const(); 
042EC:  CALL    3C82
....................                   fprintf(RS232,"\n\n\r"); 
042F0:  BTSC.B  219.1
042F2:  BRA     42F0
042F4:  MOV     #A,W4
042F6:  MOV     W4,21A
042F8:  BTSC.B  219.1
042FA:  BRA     42F8
042FC:  MOV     #A,W4
042FE:  MOV     W4,21A
04300:  BTSC.B  219.1
04302:  BRA     4300
04304:  MOV     #D,W4
04306:  MOV     W4,21A
....................                   break; 
04308:  GOTO    4AF0
....................       case 'b':   fprintf(RS232,"\n\rSet Backlash (xx): "); 
0430C:  MOV     #0,W1
0430E:  MOV     W1,W0
04310:  CALL    11DE
04314:  INC     W1,W1
04316:  MOV     W1,[W15++]
04318:  BTSC.B  219.1
0431A:  BRA     4318
0431C:  MOV     W0,21A
0431E:  MOV     [--W15],W1
04320:  MOV     #14,W0
04322:  CPSGT   W1,W0
04324:  BRA     430E
....................                   data_set_backlash(); 
04326:  CALL    3DAC
....................                   fprintf(RS232,"\n\n\r"); 
0432A:  BTSC.B  219.1
0432C:  BRA     432A
0432E:  MOV     #A,W4
04330:  MOV     W4,21A
04332:  BTSC.B  219.1
04334:  BRA     4332
04336:  MOV     #A,W4
04338:  MOV     W4,21A
0433A:  BTSC.B  219.1
0433C:  BRA     433A
0433E:  MOV     #D,W4
04340:  MOV     W4,21A
....................                   break; 
04342:  GOTO    4AF0
....................       case 't':   fprintf(RS232,"\n\rSet Communication Type (0: Parallel, 1: RS232"); 
04346:  MOV     #0,W1
04348:  MOV     W1,W0
0434A:  CALL    1204
0434E:  INC     W1,W1
04350:  MOV     W1,[W15++]
04352:  BTSC.B  219.1
04354:  BRA     4352
04356:  MOV     W0,21A
04358:  MOV     [--W15],W1
0435A:  MOV     #2E,W0
0435C:  CPSGT   W1,W0
0435E:  BRA     4348
....................                   data_set_comm_type(); 
04360:  CALL    3E10
....................                   fprintf(RS232,"\n\n\r"); 
04364:  BTSC.B  219.1
04366:  BRA     4364
04368:  MOV     #A,W4
0436A:  MOV     W4,21A
0436C:  BTSC.B  219.1
0436E:  BRA     436C
04370:  MOV     #A,W4
04372:  MOV     W4,21A
04374:  BTSC.B  219.1
04376:  BRA     4374
04378:  MOV     #D,W4
0437A:  MOV     W4,21A
....................                   break; 
0437C:  GOTO    4AF0
....................       case 'i':   data_get_sys_data(); 
04380:  CALL    3EE8
....................                   break; 
04384:  GOTO    4AF0
....................       case 'm':   fprintf(RS232,"\n\rGet Position List(0<=X<=9): "); 
04388:  MOV     #0,W1
0438A:  MOV     W1,W0
0438C:  CALL    1244
04390:  INC     W1,W1
04392:  MOV     W1,[W15++]
04394:  BTSC.B  219.1
04396:  BRA     4394
04398:  MOV     W0,21A
0439A:  MOV     [--W15],W1
0439C:  MOV     #1D,W0
0439E:  CPSGT   W1,W0
043A0:  BRA     438A
....................                   data_get_pos_table(); 
043A2:  CALL    3F38
....................                   break; 
043A6:  GOTO    4AF0
....................       case 'x':   fprintf(RS232,"\n\rMove To(0<=X<=9999): "); 
043AA:  MOV     #0,W1
043AC:  MOV     W1,W0
043AE:  CALL    1274
043B2:  INC     W1,W1
043B4:  MOV     W1,[W15++]
043B6:  BTSC.B  219.1
043B8:  BRA     43B6
043BA:  MOV     W0,21A
043BC:  MOV     [--W15],W1
043BE:  MOV     #16,W0
043C0:  CPSGT   W1,W0
043C2:  BRA     43AC
....................                   unsigned int i=0; 
....................                   unsigned int input_step[4]; 
....................                   unsigned int step=0; 
043C4:  CLR     856
043C6:  CLR     860
....................                   for(i=0;i<4;i++){ 
043C8:  CLR     856
043CA:  MOV     856,W4
043CC:  CP      W4,#4
043CE:  BRA     C,4400
....................                      input_step[i]=(unsigned)(fgetc(RS232)-48); 
043D0:  MOV     856,W0
043D2:  SL      W0,#1,W0
043D4:  MOV     #858,W4
043D6:  ADD     W0,W4,W5
043D8:  BTSS.B  218.0
043DA:  BRA     43D8
043DC:  MOV     21C,W0
043DE:  SUB.B   #30,W0L
043E0:  CLR.B   1
043E2:  MOV     W0,[W5]
....................                      fputc(input_step[i]+48,RS232); 
043E4:  MOV     856,W0
043E6:  SL      W0,#1,W0
043E8:  MOV     #858,W4
043EA:  ADD     W0,W4,W0
043EC:  MOV     [W0],W5
043EE:  ADD     #30,W5
043F0:  MOV.B   W5L,W0L
043F2:  BTSC.B  219.1
043F4:  BRA     43F2
043F6:  MOV.B   W0L,21A
043F8:  CLR.B   21B
....................                   } 
043FA:  INC     0856
043FC:  GOTO    43CA
....................                   fprintf(RS232,"\n\n\r"); 
04400:  BTSC.B  219.1
04402:  BRA     4400
04404:  MOV     #A,W4
04406:  MOV     W4,21A
04408:  BTSC.B  219.1
0440A:  BRA     4408
0440C:  MOV     #A,W4
0440E:  MOV     W4,21A
04410:  BTSC.B  219.1
04412:  BRA     4410
04414:  MOV     #D,W4
04416:  MOV     W4,21A
....................                    
....................                   step=1000*input_step[0]+100*input_step[1]+10*input_step[2]+1*input_step[3]; 
04418:  MOV     #3E8,W4
0441A:  MOV     858,W3
0441C:  MUL.UU  W4,W3,W0
0441E:  MOV     W0,W5
04420:  MOV     #64,W4
04422:  MOV     85A,W3
04424:  MUL.UU  W4,W3,W0
04426:  ADD     W0,W5,W5
04428:  MOV     85C,W4
0442A:  MUL.UU  W4,#A,W0
0442C:  ADD     W0,W5,W5
0442E:  MOV     W5,W0
04430:  ADD     85E,W0
04432:  MOV     W0,860
....................                    
....................                   move_pos(step); 
04434:  PUSH    860
04436:  POP     896
04438:  CALL    2EE4
....................                   break; 
0443C:  GOTO    4AF0
....................       case 'q':   fprintf(RS232,"\n\rEnter Table Index (xx): "); 
04440:  MOV     #0,W1
04442:  MOV     W1,W0
04444:  CALL    129C
04448:  INC     W1,W1
0444A:  MOV     W1,[W15++]
0444C:  BTSC.B  219.1
0444E:  BRA     444C
04450:  MOV     W0,21A
04452:  MOV     [--W15],W1
04454:  MOV     #19,W0
04456:  CPSGT   W1,W0
04458:  BRA     4442
....................                   unsigned int k=0; 
....................                   unsigned int input_index[2]; 
....................                   unsigned int index=0; 
0445A:  CLR     862
0445C:  CLR     868
....................                   for(k=0;k<2;k++){ 
0445E:  CLR     862
04460:  MOV     862,W4
04462:  CP      W4,#2
04464:  BRA     C,4496
....................                      input_index[k]=(unsigned)(fgetc(RS232)-48); 
04466:  MOV     862,W0
04468:  SL      W0,#1,W0
0446A:  MOV     #864,W4
0446C:  ADD     W0,W4,W5
0446E:  BTSS.B  218.0
04470:  BRA     446E
04472:  MOV     21C,W0
04474:  SUB.B   #30,W0L
04476:  CLR.B   1
04478:  MOV     W0,[W5]
....................                      fputc(input_index[k]+48,RS232); 
0447A:  MOV     862,W0
0447C:  SL      W0,#1,W0
0447E:  MOV     #864,W4
04480:  ADD     W0,W4,W0
04482:  MOV     [W0],W5
04484:  ADD     #30,W5
04486:  MOV.B   W5L,W0L
04488:  BTSC.B  219.1
0448A:  BRA     4488
0448C:  MOV.B   W0L,21A
0448E:  CLR.B   21B
....................                   } 
04490:  INC     0862
04492:  GOTO    4460
....................                   fprintf(RS232,"\n\n\r"); 
04496:  BTSC.B  219.1
04498:  BRA     4496
0449A:  MOV     #A,W4
0449C:  MOV     W4,21A
0449E:  BTSC.B  219.1
044A0:  BRA     449E
044A2:  MOV     #A,W4
044A4:  MOV     W4,21A
044A6:  BTSC.B  219.1
044A8:  BRA     44A6
044AA:  MOV     #D,W4
044AC:  MOV     W4,21A
....................                    
....................                   index=10*input_index[0]+1*input_index[1]; 
044AE:  MOV     864,W4
044B0:  MUL.UU  W4,#A,W0
044B2:  MOV     W0,W5
044B4:  MOV     W5,W0
044B6:  ADD     866,W0
044B8:  MOV     W0,868
....................                    
....................                   fprintf(RS232,"\n\rIndex: %u", index); 
044BA:  MOV     #0,W1
044BC:  MOV     W1,W0
044BE:  CALL    12C8
044C2:  INC     W1,W1
044C4:  MOV     W1,[W15++]
044C6:  BTSC.B  219.1
044C8:  BRA     44C6
044CA:  MOV     W0,21A
044CC:  MOV     [--W15],W1
044CE:  MOV     #8,W0
044D0:  CPSGT   W1,W0
044D2:  BRA     44BC
044D4:  MOV     868,W0
044D6:  MOV     #0,W4
044D8:  CALL    169A
....................                    
....................                   fprintf(RS232,"\n\rEnter Position (xxxx): "); 
044DC:  MOV     #0,W1
044DE:  MOV     W1,W0
044E0:  CALL    12E4
044E4:  INC     W1,W1
044E6:  MOV     W1,[W15++]
044E8:  BTSC.B  219.1
044EA:  BRA     44E8
044EC:  MOV     W0,21A
044EE:  MOV     [--W15],W1
044F0:  MOV     #18,W0
044F2:  CPSGT   W1,W0
044F4:  BRA     44DE
....................                   unsigned int input_pos[2]; 
....................                   unsigned int posi=0; 
044F6:  CLR     86E
....................                   for(k=0;k<4;k++){ 
044F8:  CLR     862
044FA:  MOV     862,W4
044FC:  CP      W4,#4
044FE:  BRA     C,4530
....................                      input_pos[k]=(unsigned)(fgetc(RS232)-48); 
04500:  MOV     862,W0
04502:  SL      W0,#1,W0
04504:  MOV     #86A,W4
04506:  ADD     W0,W4,W5
04508:  BTSS.B  218.0
0450A:  BRA     4508
0450C:  MOV     21C,W0
0450E:  SUB.B   #30,W0L
04510:  CLR.B   1
04512:  MOV     W0,[W5]
....................                      fputc(input_pos[k]+48,RS232); 
04514:  MOV     862,W0
04516:  SL      W0,#1,W0
04518:  MOV     #86A,W4
0451A:  ADD     W0,W4,W0
0451C:  MOV     [W0],W5
0451E:  ADD     #30,W5
04520:  MOV.B   W5L,W0L
04522:  BTSC.B  219.1
04524:  BRA     4522
04526:  MOV.B   W0L,21A
04528:  CLR.B   21B
....................                   } 
0452A:  INC     0862
0452C:  GOTO    44FA
....................                   fprintf(RS232,"\n\n\r"); 
04530:  BTSC.B  219.1
04532:  BRA     4530
04534:  MOV     #A,W4
04536:  MOV     W4,21A
04538:  BTSC.B  219.1
0453A:  BRA     4538
0453C:  MOV     #A,W4
0453E:  MOV     W4,21A
04540:  BTSC.B  219.1
04542:  BRA     4540
04544:  MOV     #D,W4
04546:  MOV     W4,21A
....................                    
....................                   posi=1000*input_pos[0]+100*input_pos[1]+10*input_pos[2]+1*input_pos[3]; 
04548:  MOV     #3E8,W4
0454A:  MOV     86A,W3
0454C:  MUL.UU  W4,W3,W0
0454E:  MOV     W0,W5
04550:  MOV     #64,W4
04552:  MOV     86C,W3
04554:  MUL.UU  W4,W3,W0
04556:  ADD     W0,W5,W5
04558:  MOV     86E,W4
0455A:  MUL.UU  W4,#A,W0
0455C:  ADD     W0,W5,W5
0455E:  MOV     W5,W0
04560:  ADD     870,W0
04562:  MOV     W0,86E
....................                    
....................                   fprintf(RS232,"\n\rPosition: %u", posi); 
04564:  MOV     #0,W1
04566:  MOV     W1,W0
04568:  CALL    130E
0456C:  INC     W1,W1
0456E:  MOV     W1,[W15++]
04570:  BTSC.B  219.1
04572:  BRA     4570
04574:  MOV     W0,21A
04576:  MOV     [--W15],W1
04578:  MOV     #B,W0
0457A:  CPSGT   W1,W0
0457C:  BRA     4566
0457E:  MOV     86E,W0
04580:  MOV     #0,W4
04582:  CALL    169A
....................                    
....................                   data_set_pos(index, posi); 
04586:  MOV.B   868,W0L
04588:  MOV.B   W0L,894
0458A:  PUSH    86E
0458C:  POP     896
0458E:  CALL    3704
....................                   break; 
04592:  GOTO    4AF0
....................       case 'o':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
04596:  MOV     #0,W1
04598:  MOV     W1,W0
0459A:  CALL    132E
0459E:  INC     W1,W1
045A0:  MOV     W1,[W15++]
045A2:  BTSC.B  219.1
045A4:  BRA     45A2
045A6:  MOV     W0,21A
045A8:  MOV     [--W15],W1
045AA:  MOV     #F,W0
045AC:  CPSGT   W1,W0
045AE:  BRA     4598
....................                   unsigned int r=0; 
....................                   unsigned int input_speed[4]; 
....................                   unsigned int delay=0; 
045B0:  CLR     870
045B2:  CLR     87A
....................                   for(r=0;r<4;r++){ 
045B4:  CLR     870
045B6:  MOV     870,W4
045B8:  CP      W4,#4
045BA:  BRA     C,45EC
....................                      input_speed[r]=(unsigned)(fgetc(RS232)-48); 
045BC:  MOV     870,W0
045BE:  SL      W0,#1,W0
045C0:  MOV     #872,W4
045C2:  ADD     W0,W4,W5
045C4:  BTSS.B  218.0
045C6:  BRA     45C4
045C8:  MOV     21C,W0
045CA:  SUB.B   #30,W0L
045CC:  CLR.B   1
045CE:  MOV     W0,[W5]
....................                      fputc(input_speed[r]+48,RS232); 
045D0:  MOV     870,W0
045D2:  SL      W0,#1,W0
045D4:  MOV     #872,W4
045D6:  ADD     W0,W4,W0
045D8:  MOV     [W0],W5
045DA:  ADD     #30,W5
045DC:  MOV.B   W5L,W0L
045DE:  BTSC.B  219.1
045E0:  BRA     45DE
045E2:  MOV.B   W0L,21A
045E4:  CLR.B   21B
....................                   } 
045E6:  INC     0870
045E8:  GOTO    45B6
....................                   fprintf(RS232,"\n\r"); 
045EC:  BTSC.B  219.1
045EE:  BRA     45EC
045F0:  MOV     #A,W4
045F2:  MOV     W4,21A
045F4:  BTSC.B  219.1
045F6:  BRA     45F4
045F8:  MOV     #D,W4
045FA:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
045FC:  MOV     #3E8,W4
045FE:  MOV     872,W3
04600:  MUL.UU  W4,W3,W0
04602:  MOV     W0,W5
04604:  MOV     #64,W4
04606:  MOV     874,W3
04608:  MUL.UU  W4,W3,W0
0460A:  ADD     W0,W5,W5
0460C:  MOV     876,W4
0460E:  MUL.UU  W4,#A,W0
04610:  ADD     W0,W5,W5
04612:  MOV     W5,W0
04614:  ADD     878,W0
04616:  MOV     W0,87A
....................        
....................                   unsigned int m; 
....................                   unsigned int pos_cal=md_min_distance; 
....................                   unsigned int num=(md_move_range-md_min_distance)/40+1; 
04618:  PUSH    818
0461A:  POP     87E
0461C:  MOV     80E,W4
0461E:  MOV     818,W3
04620:  SUB     W4,W3,W5
04622:  MOV     W5,W4
04624:  MOV     #28,W3
04626:  REPEAT  #11
04628:  DIV.U   W4,W3
0462A:  MOV     W0,W5
0462C:  ADD     W5,#1,W5
0462E:  MOV     W5,880
....................                    
....................                   for(m=0; m<num; m++) 
04630:  CLR     87C
04632:  MOV     87C,W0
04634:  MOV     880,W4
04636:  CP      W4,W0
04638:  BRA     LEU,4656
....................                   { 
....................                      move_pos(pos_cal+m*40); 
0463A:  MOV     87C,W4
0463C:  MOV     #28,W3
0463E:  MUL.UU  W4,W3,W0
04640:  MOV     87E,W4
04642:  ADD     W0,W4,W5
04644:  MOV     W5,896
04646:  CALL    2EE4
....................                      delay_ms(delay); 
0464A:  MOV     87A,W0
0464C:  CALL    168A
....................                   } 
04650:  INC     087C
04652:  GOTO    4632
....................                    
....................                   pos_cal=pos_cal+(num-1)*40; 
04656:  MOV     880,W4
04658:  SUB     W4,#1,W5
0465A:  MOV     #28,W4
0465C:  MUL.UU  W5,W4,W0
0465E:  ADD     87E
....................                    
....................                   for(m=0; m<num; m++) 
04660:  CLR     87C
04662:  MOV     87C,W0
04664:  MOV     880,W4
04666:  CP      W4,W0
04668:  BRA     LEU,4686
....................                   { 
....................                      move_pos(pos_cal-m*40); 
0466A:  MOV     87C,W4
0466C:  MOV     #28,W3
0466E:  MUL.UU  W4,W3,W0
04670:  MOV     87E,W4
04672:  SUB     W4,W0,W5
04674:  MOV     W5,896
04676:  CALL    2EE4
....................                      delay_ms(delay); 
0467A:  MOV     87A,W0
0467C:  CALL    168A
....................                   } 
04680:  INC     087C
04682:  GOTO    4662
....................                   break; 
04686:  GOTO    4AF0
....................       case 'l':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
0468A:  MOV     #0,W1
0468C:  MOV     W1,W0
0468E:  CALL    132E
04692:  INC     W1,W1
04694:  MOV     W1,[W15++]
04696:  BTSC.B  219.1
04698:  BRA     4696
0469A:  MOV     W0,21A
0469C:  MOV     [--W15],W1
0469E:  MOV     #F,W0
046A0:  CPSGT   W1,W0
046A2:  BRA     468C
....................                   unsigned int p=0; 
046A4:  CLR     882
....................                   for(p=0;p<4;p++){ 
046A6:  CLR     882
046A8:  MOV     882,W4
046AA:  CP      W4,#4
046AC:  BRA     C,46DE
....................                      input_speed[p]=(unsigned)(fgetc(RS232)-48); 
046AE:  MOV     882,W0
046B0:  SL      W0,#1,W0
046B2:  MOV     #872,W4
046B4:  ADD     W0,W4,W5
046B6:  BTSS.B  218.0
046B8:  BRA     46B6
046BA:  MOV     21C,W0
046BC:  SUB.B   #30,W0L
046BE:  CLR.B   1
046C0:  MOV     W0,[W5]
....................                      fputc(input_speed[p]+48,RS232); 
046C2:  MOV     882,W0
046C4:  SL      W0,#1,W0
046C6:  MOV     #872,W4
046C8:  ADD     W0,W4,W0
046CA:  MOV     [W0],W5
046CC:  ADD     #30,W5
046CE:  MOV.B   W5L,W0L
046D0:  BTSC.B  219.1
046D2:  BRA     46D0
046D4:  MOV.B   W0L,21A
046D6:  CLR.B   21B
....................                   } 
046D8:  INC     0882
046DA:  GOTO    46A8
....................                   fprintf(RS232,"\n\r"); 
046DE:  BTSC.B  219.1
046E0:  BRA     46DE
046E2:  MOV     #A,W4
046E4:  MOV     W4,21A
046E6:  BTSC.B  219.1
046E8:  BRA     46E6
046EA:  MOV     #D,W4
046EC:  MOV     W4,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
046EE:  MOV     #3E8,W4
046F0:  MOV     872,W3
046F2:  MUL.UU  W4,W3,W0
046F4:  MOV     W0,W5
046F6:  MOV     #64,W4
046F8:  MOV     874,W3
046FA:  MUL.UU  W4,W3,W0
046FC:  ADD     W0,W5,W5
046FE:  MOV     876,W4
04700:  MUL.UU  W4,#A,W0
04702:  ADD     W0,W5,W5
04704:  MOV     W5,W0
04706:  ADD     878,W0
04708:  MOV     W0,87A
....................        
....................                   unsigned int l; 
....................                   unsigned int pos_cal_2=md_min_distance; 
....................                   unsigned int num_2=(md_move_range-md_min_distance)/10+1; 
0470A:  PUSH    818
0470C:  POP     886
0470E:  MOV     80E,W4
04710:  MOV     818,W3
04712:  SUB     W4,W3,W5
04714:  MOV     W5,W4
04716:  MOV     #A,W3
04718:  REPEAT  #11
0471A:  DIV.U   W4,W3
0471C:  MOV     W0,W5
0471E:  ADD     W5,#1,W5
04720:  MOV     W5,888
....................                    
....................                   for(l=0; l<num_2; l++) 
04722:  CLR     884
04724:  MOV     884,W0
04726:  MOV     888,W4
04728:  CP      W4,W0
0472A:  BRA     LEU,4746
....................                   { 
....................                      move_pos(pos_cal_2+l*10); 
0472C:  MOV     884,W4
0472E:  MUL.UU  W4,#A,W0
04730:  MOV     886,W4
04732:  ADD     W0,W4,W5
04734:  MOV     W5,896
04736:  CALL    2EE4
....................                      delay_ms(delay); 
0473A:  MOV     87A,W0
0473C:  CALL    168A
....................                   } 
04740:  INC     0884
04742:  GOTO    4724
....................                    
....................                   pos_cal_2=pos_cal_2+(num_2-1)*10; 
04746:  MOV     888,W4
04748:  SUB     W4,#1,W5
0474A:  MOV     W5,W4
0474C:  MUL.UU  W4,#A,W0
0474E:  ADD     886
....................                    
....................                   for(l=0; l<num_2; l++) 
04750:  CLR     884
04752:  MOV     884,W0
04754:  MOV     888,W4
04756:  CP      W4,W0
04758:  BRA     LEU,4774
....................                   { 
....................                      move_pos(pos_cal_2-l*10); 
0475A:  MOV     884,W4
0475C:  MUL.UU  W4,#A,W0
0475E:  MOV     886,W4
04760:  SUB     W4,W0,W5
04762:  MOV     W5,896
04764:  CALL    2EE4
....................                      delay_ms(delay); 
04768:  MOV     87A,W0
0476A:  CALL    168A
....................                   } 
0476E:  INC     0884
04770:  GOTO    4752
....................                   break; 
04774:  GOTO    4AF0
....................       case 'd':   fprintf(RS232,"\n\rSet debug state\n\r"); 
04778:  MOV     #0,W1
0477A:  MOV     W1,W0
0477C:  CALL    1350
04780:  INC     W1,W1
04782:  MOV     W1,[W15++]
04784:  BTSC.B  219.1
04786:  BRA     4784
04788:  MOV     W0,21A
0478A:  MOV     [--W15],W1
0478C:  MOV     #12,W0
0478E:  CPSGT   W1,W0
04790:  BRA     477A
....................                   fprintf(RS232,"Digital potentiometer (a)(0 or 1): \n\r"); 
04792:  MOV     #0,W1
04794:  MOV     W1,W0
04796:  CALL    1374
0479A:  INC     W1,W1
0479C:  MOV     W1,[W15++]
0479E:  BTSC.B  219.1
047A0:  BRA     479E
047A2:  MOV     W0,21A
047A4:  MOV     [--W15],W1
047A6:  MOV     #24,W0
047A8:  CPSGT   W1,W0
047AA:  BRA     4794
....................                   fprintf(RS232,"Parallel port         (b)(0 or 1): \n\r"); 
047AC:  MOV     #0,W1
047AE:  MOV     W1,W0
047B0:  CALL    13AA
047B4:  INC     W1,W1
047B6:  MOV     W1,[W15++]
047B8:  BTSC.B  219.1
047BA:  BRA     47B8
047BC:  MOV     W0,21A
047BE:  MOV     [--W15],W1
047C0:  MOV     #24,W0
047C2:  CPSGT   W1,W0
047C4:  BRA     47AE
....................                   fprintf(RS232,"FRAM                  (c)(0 or 1): \n\r"); 
047C6:  MOV     #0,W1
047C8:  MOV     W1,W0
047CA:  CALL    13E0
047CE:  INC     W1,W1
047D0:  MOV     W1,[W15++]
047D2:  BTSC.B  219.1
047D4:  BRA     47D2
047D6:  MOV     W0,21A
047D8:  MOV     [--W15],W1
047DA:  MOV     #24,W0
047DC:  CPSGT   W1,W0
047DE:  BRA     47C8
....................                   fprintf(RS232,"Motor driver          (d)(0 or 1): \n\r"); 
047E0:  MOV     #0,W1
047E2:  MOV     W1,W0
047E4:  CALL    1416
047E8:  INC     W1,W1
047EA:  MOV     W1,[W15++]
047EC:  BTSC.B  219.1
047EE:  BRA     47EC
047F0:  MOV     W0,21A
047F2:  MOV     [--W15],W1
047F4:  MOV     #24,W0
047F6:  CPSGT   W1,W0
047F8:  BRA     47E2
....................                   fprintf(RS232,"Encoder               (e)(0 or 1): \n\r"); 
047FA:  MOV     #0,W1
047FC:  MOV     W1,W0
047FE:  CALL    144C
04802:  INC     W1,W1
04804:  MOV     W1,[W15++]
04806:  BTSC.B  219.1
04808:  BRA     4806
0480A:  MOV     W0,21A
0480C:  MOV     [--W15],W1
0480E:  MOV     #24,W0
04810:  CPSGT   W1,W0
04812:  BRA     47FC
....................                   fprintf(RS232,"PWM Module            (f)(0 or 1): \n\r"); 
04814:  MOV     #0,W1
04816:  MOV     W1,W0
04818:  CALL    1482
0481C:  INC     W1,W1
0481E:  MOV     W1,[W15++]
04820:  BTSC.B  219.1
04822:  BRA     4820
04824:  MOV     W0,21A
04826:  MOV     [--W15],W1
04828:  MOV     #24,W0
0482A:  CPSGT   W1,W0
0482C:  BRA     4816
....................                   fprintf(RS232,"All Modes             (g)(0 or 1): \n\r"); 
0482E:  MOV     #0,W1
04830:  MOV     W1,W0
04832:  CALL    14B8
04836:  INC     W1,W1
04838:  MOV     W1,[W15++]
0483A:  BTSC.B  219.1
0483C:  BRA     483A
0483E:  MOV     W0,21A
04840:  MOV     [--W15],W1
04842:  MOV     #24,W0
04844:  CPSGT   W1,W0
04846:  BRA     4830
....................                   fprintf(RS232,"Selection (xx): "); 
04848:  MOV     #0,W1
0484A:  MOV     W1,W0
0484C:  CALL    14EE
04850:  INC     W1,W1
04852:  MOV     W1,[W15++]
04854:  BTSC.B  219.1
04856:  BRA     4854
04858:  MOV     W0,21A
0485A:  MOV     [--W15],W1
0485C:  MOV     #F,W0
0485E:  CPSGT   W1,W0
04860:  BRA     484A
....................                    
....................                   int1 value=0; 
....................                   unsigned int f=0; 
....................                   char input_ds[2]; 
04862:  BCLR.B  855.0
04864:  CLR     88A
....................                   for(f=0;f<2;f++){ 
04866:  CLR     88A
04868:  MOV     88A,W4
0486A:  CP      W4,#2
0486C:  BRA     C,4894
....................                      input_ds[f]=fgetc(RS232); 
0486E:  MOV     #88C,W4
04870:  MOV     88A,W3
04872:  ADD     W3,W4,W5
04874:  BTSS.B  218.0
04876:  BRA     4874
04878:  MOV     21C,W0
0487A:  MOV.B   W0L,[W5]
....................                      fputc(input_ds[f],RS232); 
0487C:  MOV     #88C,W4
0487E:  MOV     88A,W3
04880:  ADD     W3,W4,W0
04882:  MOV.B   [W0],W5L
04884:  MOV.B   W5L,W0L
04886:  BTSC.B  219.1
04888:  BRA     4886
0488A:  MOV.B   W0L,21A
0488C:  CLR.B   21B
....................                   } 
0488E:  INC     088A
04890:  GOTO    4868
....................                   fprintf(RS232,"\n\n\r"); 
04894:  BTSC.B  219.1
04896:  BRA     4894
04898:  MOV     #A,W4
0489A:  MOV     W4,21A
0489C:  BTSC.B  219.1
0489E:  BRA     489C
048A0:  MOV     #A,W4
048A2:  MOV     W4,21A
048A4:  BTSC.B  219.1
048A6:  BRA     48A4
048A8:  MOV     #D,W4
048AA:  MOV     W4,21A
....................                    
....................                   if(input_ds[1]=='0') 
048AC:  MOV     88C,W4
048AE:  LSR     W4,#8,W4
048B0:  XOR.B   #30,W4L
048B2:  BRA     NZ,48BA
....................                      value=0; 
048B4:  BCLR.B  855.0
....................                   else if(input_ds[1]=='1') 
048B6:  GOTO    48E6
048BA:  MOV     88C,W4
048BC:  LSR     W4,#8,W4
048BE:  XOR.B   #31,W4L
048C0:  BRA     NZ,48C8
....................                      value=1; 
048C2:  BSET.B  855.0
....................                   else 
048C4:  GOTO    48E6
....................                   { 
....................                      fprintf(RS232,"Invalid Entry\n\r"); 
048C8:  MOV     #0,W1
048CA:  MOV     W1,W0
048CC:  CALL    1510
048D0:  INC     W1,W1
048D2:  MOV     W1,[W15++]
048D4:  BTSC.B  219.1
048D6:  BRA     48D4
048D8:  MOV     W0,21A
048DA:  MOV     [--W15],W1
048DC:  MOV     #E,W0
048DE:  CPSGT   W1,W0
048E0:  BRA     48CA
....................                      break; 
048E2:  GOTO    4AF0
....................                   } 
....................  
....................                   switch (input_ds[0]){ 
048E6:  MOV.B   88C,W0L
048E8:  CLR.B   1
048EA:  XOR     #61,W0
048EC:  BRA     Z,4908
048EE:  XOR     #3,W0
048F0:  BRA     Z,4912
048F2:  XOR     #1,W0
048F4:  BRA     Z,491C
048F6:  XOR     #7,W0
048F8:  BRA     Z,4926
048FA:  XOR     #1,W0
048FC:  BRA     Z,4930
048FE:  XOR     #3,W0
04900:  BRA     Z,493A
04902:  XOR     #1,W0
04904:  BRA     Z,4944
04906:  BRA     496C
....................                      case 'a':   debug_mode_dp = value; 
04908:  BCLR.B  800.0
0490A:  BTSC.B  855.0
0490C:  BSET.B  800.0
....................                                  break; 
0490E:  GOTO    498A
....................                      case 'b':   debug_mode_pp = value; 
04912:  BCLR.B  800.1
04914:  BTSC.B  855.0
04916:  BSET.B  800.1
....................                                  break; 
04918:  GOTO    498A
....................                      case 'c':   debug_mode_fr = value; 
0491C:  BCLR.B  800.2
0491E:  BTSC.B  855.0
04920:  BSET.B  800.2
....................                                  break; 
04922:  GOTO    498A
....................                      case 'd':   debug_mode_md = value; 
04926:  BCLR.B  800.3
04928:  BTSC.B  855.0
0492A:  BSET.B  800.3
....................                                  break; 
0492C:  GOTO    498A
....................                      case 'e':   debug_mode_qei = value; 
04930:  BCLR.B  800.5
04932:  BTSC.B  855.0
04934:  BSET.B  800.5
....................                                  break; 
04936:  GOTO    498A
....................                      case 'f':   debug_mode_pwm = value; 
0493A:  BCLR.B  800.4
0493C:  BTSC.B  855.0
0493E:  BSET.B  800.4
....................                                  break;           
04940:  GOTO    498A
....................                      case 'g':   debug_mode_dp = value; 
04944:  BCLR.B  800.0
04946:  BTSC.B  855.0
04948:  BSET.B  800.0
....................                                  debug_mode_pp = value; 
0494A:  BCLR.B  800.1
0494C:  BTSC.B  855.0
0494E:  BSET.B  800.1
....................                                  debug_mode_fr = value; 
04950:  BCLR.B  800.2
04952:  BTSC.B  855.0
04954:  BSET.B  800.2
....................                                  debug_mode_md = value; 
04956:  BCLR.B  800.3
04958:  BTSC.B  855.0
0495A:  BSET.B  800.3
....................                                  debug_mode_qei = value; 
0495C:  BCLR.B  800.5
0495E:  BTSC.B  855.0
04960:  BSET.B  800.5
....................                                  debug_mode_pwm = value; 
04962:  BCLR.B  800.4
04964:  BTSC.B  855.0
04966:  BSET.B  800.4
....................                                  break; 
04968:  GOTO    498A
....................                      default:    fprintf(RS232,"Invalid Entry\n\r"); 
0496C:  MOV     #0,W1
0496E:  MOV     W1,W0
04970:  CALL    1510
04974:  INC     W1,W1
04976:  MOV     W1,[W15++]
04978:  BTSC.B  219.1
0497A:  BRA     4978
0497C:  MOV     W0,21A
0497E:  MOV     [--W15],W1
04980:  MOV     #E,W0
04982:  CPSGT   W1,W0
04984:  BRA     496E
....................                                  break; 
04986:  GOTO    498A
....................                   } 
....................                   break; 
0498A:  GOTO    4AF0
....................       case 'w':   fprintf(RS232,"\n\rEncoder count %4u\n\r",qei_get_count()); 
0498E:  CALL    23C4
04992:  MOV     W0,W5
04994:  MOV     #0,W1
04996:  MOV     W1,W0
04998:  CALL    1530
0499C:  INC     W1,W1
0499E:  MOV     W1,[W15++]
049A0:  BTSC.B  219.1
049A2:  BRA     49A0
049A4:  MOV     W0,21A
049A6:  MOV     [--W15],W1
049A8:  MOV     #F,W0
049AA:  CPSGT   W1,W0
049AC:  BRA     4996
049AE:  MOV     W5,W0
049B0:  MOV     #4,W4
049B2:  CALL    169A
049B6:  BTSC.B  219.1
049B8:  BRA     49B6
049BA:  MOV     #A,W4
049BC:  MOV     W4,21A
049BE:  BTSC.B  219.1
049C0:  BRA     49BE
049C2:  MOV     #D,W4
049C4:  MOV     W4,21A
....................                   break; 
049C6:  GOTO    4AF0
....................       case 'z':   fprintf(RS232,"\n\rStart Memory Test (Yes -> 1, No -> 0): "); 
049CA:  MOV     #0,W1
049CC:  MOV     W1,W0
049CE:  CALL    1556
049D2:  INC     W1,W1
049D4:  MOV     W1,[W15++]
049D6:  BTSC.B  219.1
049D8:  BRA     49D6
049DA:  MOV     W0,21A
049DC:  MOV     [--W15],W1
049DE:  MOV     #28,W0
049E0:  CPSGT   W1,W0
049E2:  BRA     49CC
....................                   unsigned int input_mem_test=(unsigned)(fgetc(RS232)-48); 
049E4:  BTSS.B  218.0
049E6:  BRA     49E4
049E8:  MOV     21C,W0
049EA:  MOV     #30,W4
049EC:  SUB.B   W0L,W4L,W0L
049EE:  MOV.B   W0L,88E
049F0:  CLR.B   88F
....................                   fputc(input_mem_test+48,RS232); 
049F2:  MOV     #30,W4
049F4:  MOV     88E,W3
049F6:  ADD     W3,W4,W5
049F8:  MOV.B   W5L,W0L
049FA:  BTSC.B  219.1
049FC:  BRA     49FA
049FE:  MOV.B   W0L,21A
04A00:  CLR.B   21B
....................                   
....................                   unsigned int8 mem=0; 
04A02:  CLR.B   890
....................                    
....................                   if(input_mem_test == 1) 
04A04:  MOV     88E,W4
04A06:  CP      W4,#1
04A08:  BRA     NZ,4A5E
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
04A0A:  CLR.B   890
04A0C:  MOV     890,W4
04A0E:  MOV     #64,W3
04A10:  CP.B    W3L,W4L
04A12:  BRA     LEU,4A32
....................                         data_set_pos(mem, mem+1); 
04A14:  MOV     890,W4
04A16:  ADD.B   W4L,#1,W4L
04A18:  MOV.B   W4L,W0L
04A1A:  MOV.B   W0L,A
04A1C:  MOV.B   890,W0L
04A1E:  MOV.B   W0L,894
04A20:  PUSH    896
04A22:  MOV.B   W5L,[W15-#2]
04A24:  POP     896
04A26:  CLR.B   897
04A28:  CALL    3704
04A2C:  INC.B   0890
04A2E:  GOTO    4A0C
....................                          
....................                      fprintf(RS232,"\n\r"); 
04A32:  BTSC.B  219.1
04A34:  BRA     4A32
04A36:  MOV     #A,W4
04A38:  MOV     W4,21A
04A3A:  BTSC.B  219.1
04A3C:  BRA     4A3A
04A3E:  MOV     #D,W4
04A40:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
04A42:  BSET.B  800.2
....................                      for(mem=0; mem<100; mem++) 
04A44:  CLR.B   890
04A46:  MOV     890,W4
04A48:  MOV     #64,W3
04A4A:  CP.B    W3L,W4L
04A4C:  BRA     LEU,4A5C
....................                         data_get_pos(mem); 
04A4E:  MOV.B   890,W0L
04A50:  MOV.B   W0L,898
04A52:  CALL    3816
04A56:  INC.B   0890
04A58:  GOTO    4A46
....................                      debug_mode_fr=0; 
04A5C:  BCLR.B  800.2
....................                   } 
....................                   break; 
04A5E:  GOTO    4AF0
....................       case 'f':   fprintf(RS232,"\n\rClear Memory (Yes -> 1, No -> 0): "); 
04A62:  MOV     #0,W1
04A64:  MOV     W1,W0
04A66:  CALL    1592
04A6A:  INC     W1,W1
04A6C:  MOV     W1,[W15++]
04A6E:  BTSC.B  219.1
04A70:  BRA     4A6E
04A72:  MOV     W0,21A
04A74:  MOV     [--W15],W1
04A76:  MOV     #23,W0
04A78:  CPSGT   W1,W0
04A7A:  BRA     4A64
....................                   input_mem_test=(unsigned)(fgetc(RS232)-48); 
04A7C:  BTSS.B  218.0
04A7E:  BRA     4A7C
04A80:  MOV     21C,W0
04A82:  MOV     #30,W4
04A84:  SUB.B   W0L,W4L,W0L
04A86:  MOV.B   W0L,88E
04A88:  CLR.B   88F
....................                   fputc(input_mem_test+48,RS232); 
04A8A:  MOV     #30,W4
04A8C:  MOV     88E,W3
04A8E:  ADD     W3,W4,W5
04A90:  MOV.B   W5L,W0L
04A92:  BTSC.B  219.1
04A94:  BRA     4A92
04A96:  MOV.B   W0L,21A
04A98:  CLR.B   21B
....................                    
....................                   if(input_mem_test == 1) 
04A9A:  MOV     88E,W4
04A9C:  CP      W4,#1
04A9E:  BRA     NZ,4AE6
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
04AA0:  CLR.B   890
04AA2:  MOV     890,W4
04AA4:  MOV     #64,W3
04AA6:  CP.B    W3L,W4L
04AA8:  BRA     LEU,4ABA
....................                         data_set_pos(mem, 0); 
04AAA:  MOV.B   890,W0L
04AAC:  MOV.B   W0L,894
04AAE:  CLR     896
04AB0:  CALL    3704
04AB4:  INC.B   0890
04AB6:  GOTO    4AA2
....................                          
....................                      fprintf(RS232,"\n\r"); 
04ABA:  BTSC.B  219.1
04ABC:  BRA     4ABA
04ABE:  MOV     #A,W4
04AC0:  MOV     W4,21A
04AC2:  BTSC.B  219.1
04AC4:  BRA     4AC2
04AC6:  MOV     #D,W4
04AC8:  MOV     W4,21A
....................                       
....................                      debug_mode_fr=1; 
04ACA:  BSET.B  800.2
....................                      for(mem=0; mem<100; mem++) 
04ACC:  CLR.B   890
04ACE:  MOV     890,W4
04AD0:  MOV     #64,W3
04AD2:  CP.B    W3L,W4L
04AD4:  BRA     LEU,4AE4
....................                         data_get_pos(mem); 
04AD6:  MOV.B   890,W0L
04AD8:  MOV.B   W0L,898
04ADA:  CALL    3816
04ADE:  INC.B   0890
04AE0:  GOTO    4ACE
....................                      debug_mode_fr=0; 
04AE4:  BCLR.B  800.2
....................                   } 
....................                   break; 
04AE6:  GOTO    4AF0
....................       case 'a':   reset_cpu(); 
04AEA:  RESET   
....................                   break; 
04AEC:  GOTO    4AF0
....................    } 
....................     
....................    return; 
.................... } 
04AF0:  MOV     [--W15],W6
04AF2:  MOV     [--W15],W5
04AF4:  RETURN  
....................  
.................... // RS232 receive byte interrupt 
.................... #INT_RDA2 
.................... void isr_rs232_message() 
.................... { 
*
0166C:  PUSH    42
0166E:  PUSH    36
01670:  MOV     W0,[W15++]
01672:  MOV     #2,W0
01674:  REPEAT  #C
01676:  MOV     [W0++],[W15++]
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1;   
01678:  BSET.B  84C.2
.................... }  
.................... // Clears RS232 interrupt flags 
0167A:  BCLR.B  87.0
0167C:  MOV     #1A,W0
0167E:  REPEAT  #C
01680:  MOV     [--W15],[W0--]
01682:  MOV     [--W15],W0
01684:  POP     36
01686:  POP     42
01688:  RETFIE  
.................... void rs232_clear() 
.................... { 
....................    UART_IFS0_U1RXIF = 0; 
....................    UART_IFS0_U1TXIF = 0; 
....................    reg_rs232_message = 0; 
.................... } 
....................  
.................... // Main method 
.................... void main() 
.................... { 
*
04AF6:  BSET.B  81.7
04AF8:  MOV     #8000,W4
04AFA:  MOV     W4,20C
04AFC:  MOV     #400,W4
04AFE:  MOV     W4,20E
04B00:  MOV     #2,W4
04B02:  MOV     W4,214
04B04:  MOV     #8000,W4
04B06:  MOV     W4,216
04B08:  MOV     #400,W4
04B0A:  MOV     W4,218
04B0C:  MOV     #2,W4
04B0E:  MOV     W4,21E
04B10:  BCLR.B  800.0
04B12:  BCLR.B  800.1
04B14:  BCLR.B  800.2
04B16:  BCLR.B  800.3
04B18:  BCLR.B  800.4
04B1A:  BCLR.B  800.5
04B1C:  MOV     #20,W4
04B1E:  MOV     W4,802
04B20:  MOV     #3FF,W4
04B22:  MOV     W4,804
04B24:  MOV     #323,W4
04B26:  MOV     W4,806
04B28:  MOV     #46,W4
04B2A:  MOV     W4,808
04B2C:  MOV     #1C,W4
04B2E:  MOV     W4,80A
04B30:  CLR     80C
04B32:  MOV     #190,W4
04B34:  MOV     W4,80E
04B36:  MOV     #2D,W4
04B38:  MOV     W4,810
04B3A:  MOV     #3E8,W4
04B3C:  MOV     W4,812
04B3E:  MOV     #32,W4
04B40:  MOV     W4,814
04B42:  MOV     #64,W4
04B44:  MOV     W4,816
04B46:  MOV     #46,W4
04B48:  MOV     W4,818
04B4A:  CLR     81A
04B4C:  MOV     #BB8,W4
04B4E:  MOV     W4,81C
04B50:  MOV     #BB8,W4
04B52:  MOV     W4,81E
04B54:  MOV     #64,W4
04B56:  MOV     W4,820
04B58:  CLR.B   801
04B5A:  CLR     822
04B5C:  CLR     824
04B5E:  CLR     826
04B60:  CLR     828
04B62:  CLR     82A
04B64:  CLR     82C
04B66:  CLR     82E
04B68:  CLR     830
04B6A:  CLR     832
04B6C:  MOV     #D,W4
04B6E:  MOV     W4,834
04B70:  MOV     #F,W4
04B72:  MOV     W4,836
04B74:  MOV     #11,W4
04B76:  MOV     W4,838
04B78:  MOV     #13,W4
04B7A:  MOV     W4,83A
04B7C:  MOV     #15,W4
04B7E:  MOV     W4,83C
04B80:  MOV     #17,W4
04B82:  MOV     W4,83E
04B84:  MOV     #18,W4
04B86:  MOV     W4,840
04B88:  MOV     #1A,W4
04B8A:  MOV     W4,842
04B8C:  MOV     #3E8,W4
04B8E:  MOV     W4,844
04B90:  MOV     #1,W4
04B92:  MOV     W4,846
04B94:  MOV     #A,W4
04B96:  MOV     W4,848
04B98:  MOV     #A,W4
04B9A:  MOV     W4,84A
04B9C:  BCLR.B  800.6
04B9E:  BCLR.B  800.7
04BA0:  BCLR.B  84C.0
04BA2:  BCLR.B  84C.1
04BA4:  BCLR.B  84C.2
04BA6:  BCLR.B  84C.3
04BA8:  MOV     #58,W4
04BAA:  MOV     W4,84E
04BAC:  SETM    2A8
04BAE:  MOV     #2780,W15
04BB0:  MOV     #27FF,W0
04BB2:  MOV     W0,20
04BB4:  NOP     
....................    // Set I/O states of the ports 
....................    //           FEDCBA9876543210 
....................    set_tris_b(0b1111111011111100); 
04BB6:  MOV     #FEFC,W4
04BB8:  MOV     W4,2C6
....................    set_tris_c(0b1111111111111111); 
04BBA:  SETM    2CC
....................    set_tris_d(0b1111111100001111); 
04BBC:  MOV     #FF0F,W4
04BBE:  MOV     W4,2D2
....................    set_tris_e(0b1111111110000000); 
04BC0:  MOV     #FF80,W4
04BC2:  MOV     W4,2D8
....................    set_tris_f(0b1111111111111100); 
04BC4:  MOV     #FFFC,W4
04BC6:  MOV     W4,2DE
....................    set_tris_g(0b1111111100111111); 
04BC8:  MOV     #FF3F,W4
04BCA:  MOV     W4,2E4
....................     
....................    // Set parallel port pins 
....................    output_low(PP_ACK); 
04BCC:  BCLR.B  2D2.4
04BCE:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04BD0:  BCLR.B  2D2.5
04BD2:  BCLR.B  2D6.5
....................     
....................    // Turn on debug led 
....................    output_high(LED); 
04BD4:  BCLR.B  2C7.0
04BD6:  BSET.B  2CB.0
....................     
....................    //Turn on lasers 
....................    output_high(LAS_1); 
04BD8:  BCLR.B  2C6.0
04BDA:  BSET.B  2CA.0
....................    output_high(LAS_2); 
04BDC:  BCLR.B  2C6.1
04BDE:  BSET.B  2CA.1
....................    output_high(LAS_3); 
04BE0:  BCLR.B  2D2.6
04BE2:  BSET.B  2D6.6
....................  
....................    // Set A/D converter to read motor torque control voltage 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
04BE4:  MOV     #80,W4
04BE6:  MOV     W4,2A4
04BE8:  MOV     #80E0,W4
04BEA:  MOV     W4,2A0
....................    setup_adc_ports(sAN2); 
04BEC:  MOV     #FFFB,W4
04BEE:  MOV     W4,2A8
04BF0:  CLR     2A2
....................    set_adc_channel(2); 
04BF2:  MOV     #2,W4
04BF4:  MOV     W4,2A6
....................     
....................    delay_ms(500); 
04BF6:  MOV     #1F4,W0
04BF8:  CALL    168A
....................    fprintf(RS232,"\n\r"); 
04BFC:  BTSC.B  219.1
04BFE:  BRA     4BFC
04C00:  MOV     #A,W4
04C02:  MOV     W4,21A
04C04:  BTSC.B  219.1
04C06:  BRA     4C04
04C08:  MOV     #D,W4
04C0A:  MOV     W4,21A
....................    fprintf(RS232,"______________________________________________________________\n\r"); 
04C0C:  MOV.B   #3E,W5L
04C0E:  MOV     #5F,W0
04C10:  BTSC.B  219.1
04C12:  BRA     4C10
04C14:  MOV.B   W0L,21A
04C16:  CLR.B   21B
04C18:  DEC.B   000A
04C1A:  BTSS.B  42.1
04C1C:  BRA     4C0E
04C1E:  BTSC.B  219.1
04C20:  BRA     4C1E
04C22:  MOV     #A,W4
04C24:  MOV     W4,21A
04C26:  BTSC.B  219.1
04C28:  BRA     4C26
04C2A:  MOV     #D,W4
04C2C:  MOV     W4,21A
....................    fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING SYSTEM\n\n\r"); 
04C2E:  MOV     #0,W1
04C30:  MOV     W1,W0
04C32:  CALL    15C8
04C36:  INC     W1,W1
04C38:  MOV     W1,[W15++]
04C3A:  BTSC.B  219.1
04C3C:  BRA     4C3A
04C3E:  MOV     W0,21A
04C40:  MOV     [--W15],W1
04C42:  MOV     #25,W0
04C44:  CPSGT   W1,W0
04C46:  BRA     4C30
....................    fprintf(RS232,"\n\n\r Code Version V2.0 Without Interrupt\n\n\r"); 
04C48:  MOV     #0,W1
04C4A:  MOV     W1,W0
04C4C:  CALL    1600
04C50:  INC     W1,W1
04C52:  MOV     W1,[W15++]
04C54:  BTSC.B  219.1
04C56:  BRA     4C54
04C58:  MOV     W0,21A
04C5A:  MOV     [--W15],W1
04C5C:  MOV     #29,W0
04C5E:  CPSGT   W1,W0
04C60:  BRA     4C4A
....................    fprintf(RS232,"Press 'c' for command list\n\n\r"); 
04C62:  MOV     #0,W1
04C64:  MOV     W1,W0
04C66:  CALL    163E
04C6A:  INC     W1,W1
04C6C:  MOV     W1,[W15++]
04C6E:  BTSC.B  219.1
04C70:  BRA     4C6E
04C72:  MOV     W0,21A
04C74:  MOV     [--W15],W1
04C76:  MOV     #1C,W0
04C78:  CPSGT   W1,W0
04C7A:  BRA     4C64
....................    data_get_reset_state(); 
04C7C:  CALL    1750
....................  
....................    // Initialize components 
....................    qei_init();                            // Initialize quadrature encoder  
04C80:  CALL    1A72
....................    pwm_init();                            // Initialize PWM module 
04C84:  CALL    1AD8
....................    dp_init();                             // Initialize digital potentiometer 
04C88:  CALL    1B18
....................    md_init();                             // Initialize motor driver 
04C8C:  CALL    2022
....................    fr_init();                             // Initialize FRAM 
04C90:  CALL    204C
....................    move_init();                           // Initializes the system for movement 
04C94:  CALL    318E
....................     
....................    // Enable RS232 receive byte interrupt 
....................    enable_interrupts(INT_RDA2); 
04C98:  BSET.B  8F.0
....................     
....................    reg_comm_type = data_get_comm_type();  // Set communication type 
04C9A:  CALL    322C
04C9E:  BCLR.B  800.6
04CA0:  BTSC.B  0.0
04CA2:  BSET.B  800.6
....................     
....................    switch (reg_comm_type) 
....................    { 
04CA4:  CLR.B   W0
04CA6:  BTSC.B  800.6
04CA8:  INC     W0,W0
04CAA:  CLR.B   1
04CAC:  XOR     #0,W0
04CAE:  BRA     Z,4CB6
04CB0:  XOR     #1,W0
04CB2:  BRA     Z,4CC2
04CB4:  BRA     4CCE
....................       case 0   :  output_high(PP_ACK); 
04CB6:  BCLR.B  2D2.4
04CB8:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04CBA:  BCLR.B  2D2.5
04CBC:  BSET.B  2D6.5
....................                   break; 
04CBE:  GOTO    4CE4
....................       case 1   :  output_low(PP_ACK); 
04CC2:  BCLR.B  2D2.4
04CC4:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
04CC6:  BCLR.B  2D2.5
04CC8:  BCLR.B  2D6.5
....................                   break; 
04CCA:  GOTO    4CE4
....................       default:    output_high(PP_ACK); 
04CCE:  BCLR.B  2D2.4
04CD0:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04CD2:  BCLR.B  2D2.5
04CD4:  BSET.B  2D6.5
....................                   fr_write_byte(fr_comm_type, 0); 
04CD6:  CLR.B   8B0
04CD8:  PUSH    83E
04CDA:  POP     8AE
04CDC:  CALL    269E
....................                   break; 
04CE0:  GOTO    4CE4
....................    } 
....................     
....................    while(true) 
....................    { 
....................       if(input(PP_STR) == 0) 
04CE4:  BSET.B  2D3.2
04CE6:  BTSC.B  2D5.2
04CE8:  BRA     4D1E
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04CEA:  BCLR.B  8F.0
....................           
....................          unsigned int i; 
....................          int sum = 0; 
04CEC:  CLR     852
....................           
....................          for(i=0; i<100; i++) 
04CEE:  CLR     850
04CF0:  MOV     850,W4
04CF2:  MOV     #64,W3
04CF4:  CP      W3,W4
04CF6:  BRA     LEU,4D10
....................          { 
....................             delay_us(pp_str_delay); 
04CF8:  MOV     846,W0
04CFA:  CALL    2344
....................             if(input(PP_STR) == 0) 
04CFE:  BSET.B  2D3.2
04D00:  BTSC.B  2D5.2
04D02:  BRA     4D0A
....................                sum += 1; 
04D04:  MOV     852,W4
04D06:  ADD     W4,#1,W4
04D08:  MOV     W4,852
....................          } 
04D0A:  INC     0850
04D0C:  GOTO    4CF0
....................          if(sum > 70){ 
04D10:  MOV     852,W4
04D12:  MOV     #46,W3
04D14:  CP      W3,W4
04D16:  BRA     GE,4D1C
....................             pp_get_command(); 
04D18:  CALL    3906
....................          } 
....................           
....................          //fprintf(RS232,"sum: %u\n\r",sum); 
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
....................          enable_interrupts(INT_RDA2); 
04D1C:  BSET.B  8F.0
....................       } 
....................       if(reg_rs232_message) 
04D1E:  BTSS.B  84C.2
04D20:  BRA     4D2C
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04D22:  BCLR.B  8F.0
....................          reg_rs232_message = 0; 
04D24:  BCLR.B  84C.2
....................          rs232_message(); 
04D26:  CALL    3F9C
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
....................          enable_interrupts(INT_RDA2); 
04D2A:  BSET.B  8F.0
....................  
....................       } 
....................    } 
04D2C:  GOTO    4CE4
.................... } 
04D30:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C11F   FRC NOCKSFSM
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 8733   PUT64 NOBROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F   WRTB NOBSS NOEBS NORBS
          H: 0000  
   Word  5L: 330F   NOWRTSS NOSSS NORSS NOESS
          H: 0000  
   Word  6L: 0005   PROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  

CCS PCD C Compiler, Version 5.008, 5967               18-Kas-14 13:27

               Filename:   E:\File Server\Modesis\Proje Dosyalarý\LPS - Lazer Projeksiyon Sistemi\Software\SLS_Software_v2.1\SLS_Software_v2.1_without_INT.lst

               ROM used:   19836 bytes (20%)
                           Largest free fragment is 45700
               RAM used:   387 (5%) at main() level
                           714 (9%) worst case
               Stack used: 200 locations
               Stack size: 128

*
00000:  GOTO    4A40
*
00034:  DATA    42,15,00
*
00044:  DATA    64,15,00
.................... #INCLUDE <30f6015.h>  
.................... //////// Standard Header file for the DSPIC30F6015 device //////////////// 
.................... #device DSPIC30F6015 
*
00100:  CLR     32
00102:  MOV     #76,W3
00104:  SUB     W0,W3,W3
00106:  BRA     C,110
00108:  MOV     #120,W3
0010A:  ADD     W3,W0,W0
0010C:  TBLRDL  [W0],W0
0010E:  RETURN  
00110:  MOV     #120,W0
00112:  ADD     W3,W3,W3
00114:  ADD     W3,W0,W3
00116:  TBLRDH  [W3++],W0
00118:  TBLRDH  [W3],W3
0011A:  SL      W3,#8,W3
0011C:  IOR      W3,  W0,W0
0011E:  RETURN  
00120:  DATA    D0,07,82
00122:  DATA    3C,03,00
00124:  DATA    7C,02,81
00126:  DATA    18,02,00
00128:  DATA    D8,01,80
0012A:  DATA    AB,01,00
0012C:  DATA    89,01,7E
0012E:  DATA    6D,01,00
00130:  DATA    57,01,7D
00132:  DATA    45,01,00
00134:  DATA    35,01,7C
00136:  DATA    27,01,00
00138:  DATA    1B,01,7B
0013A:  DATA    10,01,00
0013C:  DATA    07,01,7A
0013E:  DATA    FE,00,00
00140:  DATA    F6,00,79
00142:  DATA    EF,00,00
00144:  DATA    E9,00,78
00146:  DATA    E2,00,00
00148:  DATA    DD,00,77
0014A:  DATA    D8,00,00
0014C:  DATA    D3,00,76
0014E:  DATA    CE,00,00
00150:  DATA    CA,00,75
00152:  DATA    C6,00,00
00154:  DATA    C2,00,74
00156:  DATA    BF,00,00
00158:  DATA    BB,00,73
0015A:  DATA    B8,00,00
0015C:  DATA    B5,00,72
0015E:  DATA    B2,00,00
00160:  DATA    AF,00,71
00162:  DATA    AD,00,00
00164:  DATA    AA,00,70
00166:  DATA    A8,00,00
00168:  DATA    A6,00,6F
0016A:  DATA    A3,00,00
0016C:  DATA    A1,00,6E
0016E:  DATA    9F,00,00
00170:  DATA    9D,00,6D
00172:  DATA    9B,00,00
00174:  DATA    99,00,6C
00176:  DATA    98,00,00
00178:  DATA    96,00,6B
0017A:  DATA    94,00,00
0017C:  DATA    93,00,6A
0017E:  DATA    91,00,00
00180:  DATA    90,00,69
00182:  DATA    8E,00,00
00184:  DATA    8D,00,68
00186:  DATA    8B,00,00
00188:  DATA    8A,00,67
0018A:  DATA    89,00,00
0018C:  DATA    87,00,66
0018E:  DATA    86,00,00
00190:  DATA    85,00,65
00192:  DATA    84,00,00
00194:  DATA    83,00,00
00196:  CLR     32
00198:  MOV     #1A2,W3
0019A:  ADD     W3,W0,W0
0019C:  TBLRDL.B[W0],W0L
0019E:  CLR.B   1
001A0:  RETURN  
001A2:  DATA    0A,0D,00
001A4:  DATA    09,56,00
001A6:  DATA    6F,6C,00
001A8:  DATA    74,61,00
001AA:  DATA    67,65,00
001AC:  DATA    20,44,00
001AE:  DATA    65,73,00
001B0:  DATA    69,72,00
001B2:  DATA    65,64,00
001B4:  DATA    3A,20,00
001B6:  DATA    25,75,00
001B8:  DATA    00,00,00
001BA:  CLR     32
001BC:  MOV     #1C6,W3
001BE:  ADD     W3,W0,W0
001C0:  TBLRDL.B[W0],W0L
001C2:  CLR.B   1
001C4:  RETURN  
001C6:  DATA    0A,0D,00
001C8:  DATA    09,54,00
001CA:  DATA    61,70,00
001CC:  DATA    20,44,00
001CE:  DATA    65,73,00
001D0:  DATA    69,72,00
001D2:  DATA    65,64,00
001D4:  DATA    3A,20,00
001D6:  DATA    25,75,00
001D8:  DATA    00,00,00
001DA:  CLR     32
001DC:  MOV     #1E6,W3
001DE:  ADD     W3,W0,W0
001E0:  TBLRDL.B[W0],W0L
001E2:  CLR.B   1
001E4:  RETURN  
001E6:  DATA    0A,0D,00
001E8:  DATA    09,56,00
001EA:  DATA    6F,6C,00
001EC:  DATA    74,61,00
001EE:  DATA    67,65,00
001F0:  DATA    20,43,00
001F2:  DATA    75,72,00
001F4:  DATA    72,65,00
001F6:  DATA    6E,74,00
001F8:  DATA    3A,20,00
001FA:  DATA    25,75,00
001FC:  DATA    00,00,00
001FE:  CLR     32
00200:  MOV     #20A,W3
00202:  ADD     W3,W0,W0
00204:  TBLRDL.B[W0],W0L
00206:  CLR.B   1
00208:  RETURN  
0020A:  DATA    0A,0D,00
0020C:  DATA    09,54,00
0020E:  DATA    61,70,00
00210:  DATA    20,43,00
00212:  DATA    75,72,00
00214:  DATA    72,65,00
00216:  DATA    6E,74,00
00218:  DATA    3A,20,00
0021A:  DATA    25,75,00
0021C:  DATA    00,00,00
0021E:  CLR     32
00220:  MOV     #22A,W3
00222:  ADD     W3,W0,W0
00224:  TBLRDL.B[W0],W0L
00226:  CLR.B   1
00228:  RETURN  
0022A:  DATA    0A,0D,00
0022C:  DATA    09,56,00
0022E:  DATA    6F,6C,00
00230:  DATA    74,61,00
00232:  DATA    67,65,00
00234:  DATA    20,44,00
00236:  DATA    69,66,00
00238:  DATA    66,65,00
0023A:  DATA    72,65,00
0023C:  DATA    6E,63,00
0023E:  DATA    65,3A,00
00240:  DATA    20,25,00
00242:  DATA    75,00,00
00244:  CLR     32
00246:  MOV     #250,W3
00248:  ADD     W3,W0,W0
0024A:  TBLRDL.B[W0],W0L
0024C:  CLR.B   1
0024E:  RETURN  
00250:  DATA    0A,0D,00
00252:  DATA    49,54,00
00254:  DATA    45,52,00
00256:  DATA    41,54,00
00258:  DATA    49,4F,00
0025A:  DATA    4E,3A,00
0025C:  DATA    20,25,00
0025E:  DATA    75,00,00
00260:  CLR     32
00262:  MOV     #26C,W3
00264:  ADD     W3,W0,W0
00266:  TBLRDL.B[W0],W0L
00268:  CLR.B   1
0026A:  RETURN  
0026C:  DATA    0A,0D,00
0026E:  DATA    09,56,00
00270:  DATA    6F,6C,00
00272:  DATA    74,61,00
00274:  DATA    67,65,00
00276:  DATA    20,43,00
00278:  DATA    75,72,00
0027A:  DATA    72,65,00
0027C:  DATA    6E,74,00
0027E:  DATA    20,3A,00
00280:  DATA    20,25,00
00282:  DATA    75,00,00
00284:  CLR     32
00286:  MOV     #290,W3
00288:  ADD     W3,W0,W0
0028A:  TBLRDL.B[W0],W0L
0028C:  CLR.B   1
0028E:  RETURN  
00290:  DATA    0A,0D,00
00292:  DATA    49,74,00
00294:  DATA    65,72,00
00296:  DATA    61,74,00
00298:  DATA    69,6F,00
0029A:  DATA    6E,20,00
0029C:  DATA    6C,69,00
0029E:  DATA    6D,69,00
002A0:  DATA    74,20,00
002A2:  DATA    72,65,00
002A4:  DATA    61,63,00
002A6:  DATA    68,65,00
002A8:  DATA    64,00,00
002AA:  CLR     32
002AC:  MOV     #2B6,W3
002AE:  ADD     W3,W0,W0
002B0:  TBLRDL.B[W0],W0L
002B2:  CLR.B   1
002B4:  RETURN  
002B6:  DATA    0A,0D,00
002B8:  DATA    46,4F,00
002BA:  DATA    55,4E,00
002BC:  DATA    44,21,00
002BE:  DATA    00,00,00
002C0:  CLR     32
002C2:  MOV     #2CC,W3
002C4:  ADD     W3,W0,W0
002C6:  TBLRDL.B[W0],W0L
002C8:  CLR.B   1
002CA:  RETURN  
002CC:  DATA    0A,0D,00
002CE:  DATA    09,54,00
002D0:  DATA    61,70,00
002D2:  DATA    20,43,00
002D4:  DATA    75,72,00
002D6:  DATA    72,65,00
002D8:  DATA    6E,74,00
002DA:  DATA    20,3A,00
002DC:  DATA    20,25,00
002DE:  DATA    75,00,00
002E0:  CLR     32
002E2:  MOV     #2EC,W3
002E4:  ADD     W3,W0,W0
002E6:  TBLRDL.B[W0],W0L
002E8:  CLR.B   1
002EA:  RETURN  
002EC:  DATA    0A,0D,00
002EE:  DATA    09,50,00
002F0:  DATA    65,72,00
002F2:  DATA    63,65,00
002F4:  DATA    6E,74,00
002F6:  DATA    20,43,00
002F8:  DATA    75,72,00
002FA:  DATA    72,65,00
002FC:  DATA    6E,74,00
002FE:  DATA    3A,20,00
00300:  DATA    25,75,00
00302:  DATA    0A,0D,00
00304:  DATA    00,00,00
00306:  CLR     32
00308:  MOV     #312,W3
0030A:  ADD     W3,W0,W0
0030C:  TBLRDL.B[W0],W0L
0030E:  CLR.B   1
00310:  RETURN  
00312:  DATA    0A,0D,00
00314:  DATA    09,50,00
00316:  DATA    65,72,00
00318:  DATA    63,65,00
0031A:  DATA    6E,74,00
0031C:  DATA    20,44,00
0031E:  DATA    65,73,00
00320:  DATA    69,72,00
00322:  DATA    65,64,00
00324:  DATA    3A,00,00
00326:  CLR     32
00328:  MOV     #332,W3
0032A:  ADD     W3,W0,W0
0032C:  TBLRDL.B[W0],W0L
0032E:  CLR.B   1
00330:  RETURN  
00332:  DATA    53,65,00
00334:  DATA    72,69,00
00336:  DATA    61,6C,00
00338:  DATA    20,4E,00
0033A:  DATA    6F,3A,00
0033C:  DATA    00,00,00
0033E:  CLR     32
00340:  MOV     #34A,W3
00342:  ADD     W3,W0,W0
00344:  TBLRDL.B[W0],W0L
00346:  CLR.B   1
00348:  RETURN  
0034A:  DATA    4D,6F,00
0034C:  DATA    76,65,00
0034E:  DATA    6D,65,00
00350:  DATA    6E,74,00
00352:  DATA    20,52,00
00354:  DATA    61,6E,00
00356:  DATA    67,65,00
00358:  DATA    3A,20,00
0035A:  DATA    25,75,00
0035C:  DATA    20,6D,00
0035E:  DATA    6D,0A,00
00360:  DATA    0D,00,00
00362:  CLR     32
00364:  MOV     #36E,W3
00366:  ADD     W3,W0,W0
00368:  TBLRDL.B[W0],W0L
0036A:  CLR.B   1
0036C:  RETURN  
0036E:  DATA    48,6F,00
00370:  DATA    6D,65,00
00372:  DATA    20,44,00
00374:  DATA    69,73,00
00376:  DATA    74,61,00
00378:  DATA    6E,63,00
0037A:  DATA    65,3A,00
0037C:  DATA    20,25,00
0037E:  DATA    75,20,00
00380:  DATA    63,6F,00
00382:  DATA    75,6E,00
00384:  DATA    74,73,00
00386:  DATA    0A,0D,00
00388:  DATA    00,00,00
0038A:  CLR     32
0038C:  MOV     #396,W3
0038E:  ADD     W3,W0,W0
00390:  TBLRDL.B[W0],W0L
00392:  CLR.B   1
00394:  RETURN  
00396:  DATA    45,6E,00
00398:  DATA    64,20,00
0039A:  DATA    44,69,00
0039C:  DATA    73,74,00
0039E:  DATA    61,6E,00
003A0:  DATA    63,65,00
003A2:  DATA    3A,20,00
003A4:  DATA    25,75,00
003A6:  DATA    20,63,00
003A8:  DATA    6F,75,00
003AA:  DATA    6E,74,00
003AC:  DATA    73,0A,00
003AE:  DATA    0D,00,00
003B0:  CLR     32
003B2:  MOV     #3BC,W3
003B4:  ADD     W3,W0,W0
003B6:  TBLRDL.B[W0],W0L
003B8:  CLR.B   1
003BA:  RETURN  
003BC:  DATA    43,6F,00
003BE:  DATA    6E,76,00
003C0:  DATA    65,72,00
003C2:  DATA    73,69,00
003C4:  DATA    6F,6E,00
003C6:  DATA    20,43,00
003C8:  DATA    6F,6E,00
003CA:  DATA    73,74,00
003CC:  DATA    61,6E,00
003CE:  DATA    74,3A,00
003D0:  DATA    20,25,00
003D2:  DATA    75,20,00
003D4:  DATA    0A,0D,00
003D6:  DATA    00,00,00
003D8:  CLR     32
003DA:  MOV     #3E4,W3
003DC:  ADD     W3,W0,W0
003DE:  TBLRDL.B[W0],W0L
003E0:  CLR.B   1
003E2:  RETURN  
003E4:  DATA    42,61,00
003E6:  DATA    63,6B,00
003E8:  DATA    6C,61,00
003EA:  DATA    73,68,00
003EC:  DATA    3A,20,00
003EE:  DATA    25,75,00
003F0:  DATA    20,63,00
003F2:  DATA    6F,75,00
003F4:  DATA    6E,74,00
003F6:  DATA    73,0A,00
003F8:  DATA    0D,00,00
003FA:  CLR     32
003FC:  MOV     #406,W3
003FE:  ADD     W3,W0,W0
00400:  TBLRDL.B[W0],W0L
00402:  CLR.B   1
00404:  RETURN  
00406:  DATA    43,6F,00
00408:  DATA    6D,6D,00
0040A:  DATA    75,6E,00
0040C:  DATA    69,63,00
0040E:  DATA    61,74,00
00410:  DATA    69,6F,00
00412:  DATA    6E,20,00
00414:  DATA    54,79,00
00416:  DATA    70,65,00
00418:  DATA    3A,20,00
0041A:  DATA    50,61,00
0041C:  DATA    72,61,00
0041E:  DATA    6C,6C,00
00420:  DATA    65,6C,00
00422:  DATA    20,50,00
00424:  DATA    6F,72,00
00426:  DATA    74,0A,00
00428:  DATA    0D,00,00
0042A:  CLR     32
0042C:  MOV     #436,W3
0042E:  ADD     W3,W0,W0
00430:  TBLRDL.B[W0],W0L
00432:  CLR.B   1
00434:  RETURN  
00436:  DATA    43,6F,00
00438:  DATA    6D,6D,00
0043A:  DATA    75,6E,00
0043C:  DATA    69,63,00
0043E:  DATA    61,74,00
00440:  DATA    69,6F,00
00442:  DATA    6E,20,00
00444:  DATA    54,79,00
00446:  DATA    70,65,00
00448:  DATA    3A,20,00
0044A:  DATA    53,65,00
0044C:  DATA    72,69,00
0044E:  DATA    61,6C,00
00450:  DATA    20,50,00
00452:  DATA    6F,72,00
00454:  DATA    74,0A,00
00456:  DATA    0D,00,00
00458:  CLR     32
0045A:  MOV     #464,W3
0045C:  ADD     W3,W0,W0
0045E:  TBLRDL.B[W0],W0L
00460:  CLR.B   1
00462:  RETURN  
00464:  DATA    43,6F,00
00466:  DATA    6D,6D,00
00468:  DATA    75,6E,00
0046A:  DATA    69,63,00
0046C:  DATA    61,74,00
0046E:  DATA    69,6F,00
00470:  DATA    6E,20,00
00472:  DATA    54,79,00
00474:  DATA    70,65,00
00476:  DATA    3A,20,00
00478:  DATA    55,6E,00
0047A:  DATA    64,65,00
0047C:  DATA    66,69,00
0047E:  DATA    6E,65,00
00480:  DATA    64,0A,00
00482:  DATA    0D,00,00
00484:  CLR     32
00486:  MOV     #490,W3
00488:  ADD     W3,W0,W0
0048A:  TBLRDL.B[W0],W0L
0048C:  CLR.B   1
0048E:  RETURN  
00490:  DATA    4C,61,00
00492:  DATA    73,74,00
00494:  DATA    20,50,00
00496:  DATA    6F,73,00
00498:  DATA    69,74,00
0049A:  DATA    69,6F,00
0049C:  DATA    6E,3A,00
0049E:  DATA    20,25,00
004A0:  DATA    75,20,00
004A2:  DATA    6D,6D,00
004A4:  DATA    0A,0D,00
004A6:  DATA    00,00,00
004A8:  CLR     32
004AA:  MOV     #4B4,W3
004AC:  ADD     W3,W0,W0
004AE:  TBLRDL.B[W0],W0L
004B0:  CLR.B   1
004B2:  RETURN  
004B4:  DATA    49,6E,00
004B6:  DATA    64,65,00
004B8:  DATA    78,3A,00
004BA:  DATA    20,25,00
004BC:  DATA    75,2C,00
004BE:  DATA    20,50,00
004C0:  DATA    6F,73,00
004C2:  DATA    69,74,00
004C4:  DATA    69,6F,00
004C6:  DATA    6E,3A,00
004C8:  DATA    20,25,00
004CA:  DATA    75,20,00
004CC:  DATA    6D,6D,00
004CE:  DATA    0A,0D,00
004D0:  DATA    00,00,00
004D2:  CLR     32
004D4:  MOV     #4DE,W3
004D6:  ADD     W3,W0,W0
004D8:  TBLRDL.B[W0],W0L
004DA:  CLR.B   1
004DC:  RETURN  
004DE:  DATA    4D,4F,00
004E0:  DATA    44,45,00
004E2:  DATA    53,49,00
004E4:  DATA    53,20,00
004E6:  DATA    4C,41,00
004E8:  DATA    53,45,00
004EA:  DATA    52,20,00
004EC:  DATA    50,4F,00
004EE:  DATA    53,49,00
004F0:  DATA    54,49,00
004F2:  DATA    4F,4E,00
004F4:  DATA    49,4E,00
004F6:  DATA    47,20,00
004F8:  DATA    53,59,00
004FA:  DATA    53,54,00
004FC:  DATA    45,4D,00
004FE:  DATA    0A,0A,00
00500:  DATA    0D,00,00
00502:  CLR     32
00504:  MOV     #50E,W3
00506:  ADD     W3,W0,W0
00508:  TBLRDL.B[W0],W0L
0050A:  CLR.B   1
0050C:  RETURN  
0050E:  DATA    52,43,00
00510:  DATA    4F,4E,00
00512:  DATA    20,52,00
00514:  DATA    45,47,00
00516:  DATA    49,53,00
00518:  DATA    54,45,00
0051A:  DATA    52,20,00
0051C:  DATA    56,41,00
0051E:  DATA    4C,55,00
00520:  DATA    45,20,00
00522:  DATA    53,49,00
00524:  DATA    46,49,00
00526:  DATA    52,4C,00
00528:  DATA    41,4E,00
0052A:  DATA    49,59,00
0052C:  DATA    4F,52,00
0052E:  DATA    2E,2E,00
00530:  DATA    2E,00,00
00532:  CLR     32
00534:  MOV     #1C,W3
00536:  SUB     W0,W3,W3
00538:  BRA     C,544
0053A:  MOV     #54E,W3
0053C:  ADD     W3,W0,W0
0053E:  TBLRDL.B[W0],W0L
00540:  CLR.B   1
00542:  RETURN  
00544:  MOV     #54E,W0
00546:  ADD     W3,W3,W3
00548:  ADD     W3,W0,W3
0054A:  TBLRDH  [W3],W0
0054C:  RETURN  
0054E:  DATA    59,45,6C
00550:  DATA    4E,49,75
00552:  DATA    20,52,6B
00554:  DATA    43,4F,20
00556:  DATA    4E,20,54
00558:  DATA    52,45,61
0055A:  DATA    47,49,62
0055C:  DATA    53,54,61
0055E:  DATA    45,52,6E
00560:  DATA    20,56,64
00562:  DATA    41,4C,61
00564:  DATA    55,45,29
00566:  DATA    28,31,3A
00568:  DATA    30,27,00
0056A:  CLR     32
0056C:  MOV     #576,W3
0056E:  ADD     W3,W0,W0
00570:  TBLRDL.B[W0],W0L
00572:  CLR.B   1
00574:  RETURN  
00576:  DATA    52,43,00
00578:  DATA    4F,4E,00
0057A:  DATA    20,52,00
0057C:  DATA    45,47,00
0057E:  DATA    49,53,00
00580:  DATA    54,45,00
00582:  DATA    52,20,00
00584:  DATA    56,41,00
00586:  DATA    4C,55,00
00588:  DATA    45,28,00
0058A:  DATA    31,30,00
0058C:  DATA    27,6C,00
0058E:  DATA    75,6B,00
00590:  DATA    20,54,00
00592:  DATA    61,62,00
00594:  DATA    61,6E,00
00596:  DATA    64,61,00
00598:  DATA    29,3A,00
0059A:  DATA    20,20,00
0059C:  DATA    00,00,00
0059E:  CLR     32
005A0:  MOV     #5AA,W3
005A2:  ADD     W3,W0,W0
005A4:  TBLRDL.B[W0],W0L
005A6:  CLR.B   1
005A8:  RETURN  
005AA:  DATA    52,43,00
005AC:  DATA    4F,4E,00
005AE:  DATA    20,52,00
005B0:  DATA    45,47,00
005B2:  DATA    49,53,00
005B4:  DATA    54,45,00
005B6:  DATA    52,20,00
005B8:  DATA    42,49,00
005BA:  DATA    54,4C,00
005BC:  DATA    45,52,00
005BE:  DATA    49,3A,00
005C0:  DATA    00,00,00
005C2:  CLR     32
005C4:  MOV     #5CE,W3
005C6:  ADD     W3,W0,W0
005C8:  TBLRDL.B[W0],W0L
005CA:  CLR.B   1
005CC:  RETURN  
005CE:  DATA    50,4F,00
005D0:  DATA    52,3A,00
005D2:  DATA    20,20,00
005D4:  DATA    20,20,00
005D6:  DATA    00,00,00
005D8:  CLR     32
005DA:  MOV     #5E4,W3
005DC:  ADD     W3,W0,W0
005DE:  TBLRDL.B[W0],W0L
005E0:  CLR.B   1
005E2:  RETURN  
005E4:  DATA    42,4F,00
005E6:  DATA    52,3A,00
005E8:  DATA    20,20,00
005EA:  DATA    20,20,00
005EC:  DATA    00,00,00
005EE:  CLR     32
005F0:  MOV     #5FA,W3
005F2:  ADD     W3,W0,W0
005F4:  TBLRDL.B[W0],W0L
005F6:  CLR.B   1
005F8:  RETURN  
005FA:  DATA    49,44,00
005FC:  DATA    4C,45,00
005FE:  DATA    3A,20,00
00600:  DATA    20,20,00
00602:  DATA    00,00,00
00604:  CLR     32
00606:  MOV     #610,W3
00608:  ADD     W3,W0,W0
0060A:  TBLRDL.B[W0],W0L
0060C:  CLR.B   1
0060E:  RETURN  
00610:  DATA    53,4C,00
00612:  DATA    45,45,00
00614:  DATA    50,3A,00
00616:  DATA    20,20,00
00618:  DATA    00,00,00
0061A:  CLR     32
0061C:  MOV     #626,W3
0061E:  ADD     W3,W0,W0
00620:  TBLRDL.B[W0],W0L
00622:  CLR.B   1
00624:  RETURN  
00626:  DATA    57,44,00
00628:  DATA    54,4F,00
0062A:  DATA    3A,20,00
0062C:  DATA    20,20,00
0062E:  DATA    00,00,00
00630:  CLR     32
00632:  MOV     #63C,W3
00634:  ADD     W3,W0,W0
00636:  TBLRDL.B[W0],W0L
00638:  CLR.B   1
0063A:  RETURN  
0063C:  DATA    53,57,00
0063E:  DATA    44,54,00
00640:  DATA    45,4E,00
00642:  DATA    3A,20,00
00644:  DATA    00,00,00
00646:  CLR     32
00648:  MOV     #652,W3
0064A:  ADD     W3,W0,W0
0064C:  TBLRDL.B[W0],W0L
0064E:  CLR.B   1
00650:  RETURN  
00652:  DATA    53,57,00
00654:  DATA    52,3A,00
00656:  DATA    20,20,00
00658:  DATA    20,20,00
0065A:  DATA    00,00,00
0065C:  CLR     32
0065E:  MOV     #668,W3
00660:  ADD     W3,W0,W0
00662:  TBLRDL.B[W0],W0L
00664:  CLR.B   1
00666:  RETURN  
00668:  DATA    45,58,00
0066A:  DATA    54,52,00
0066C:  DATA    3A,20,00
0066E:  DATA    20,20,00
00670:  DATA    00,00,00
00672:  CLR     32
00674:  MOV     #67E,W3
00676:  ADD     W3,W0,W0
00678:  TBLRDL.B[W0],W0L
0067A:  CLR.B   1
0067C:  RETURN  
0067E:  DATA    42,47,00
00680:  DATA    53,54,00
00682:  DATA    3A,20,00
00684:  DATA    20,20,00
00686:  DATA    00,00,00
00688:  CLR     32
0068A:  MOV     #694,W3
0068C:  ADD     W3,W0,W0
0068E:  TBLRDL.B[W0],W0L
00690:  CLR.B   1
00692:  RETURN  
00694:  DATA    49,4F,00
00696:  DATA    50,55,00
00698:  DATA    57,52,00
0069A:  DATA    3A,20,00
0069C:  DATA    00,00,00
0069E:  CLR     32
006A0:  MOV     #6AA,W3
006A2:  ADD     W3,W0,W0
006A4:  TBLRDL.B[W0],W0L
006A6:  CLR.B   1
006A8:  RETURN  
006AA:  DATA    54,52,00
006AC:  DATA    41,50,00
006AE:  DATA    52,3A,00
006B0:  DATA    20,20,00
006B2:  DATA    00,00,00
006B4:  CLR     32
006B6:  MOV     #6C0,W3
006B8:  ADD     W3,W0,W0
006BA:  TBLRDL.B[W0],W0L
006BC:  CLR.B   1
006BE:  RETURN  
006C0:  DATA    52,65,00
006C2:  DATA    67,69,00
006C4:  DATA    73,74,00
006C6:  DATA    65,72,00
006C8:  DATA    20,45,00
006CA:  DATA    6B,72,00
006CC:  DATA    61,6E,00
006CE:  DATA    61,20,00
006D0:  DATA    59,61,00
006D2:  DATA    7A,64,00
006D4:  DATA    69,72,00
006D6:  DATA    69,6C,00
006D8:  DATA    69,70,00
006DA:  DATA    20,53,00
006DC:  DATA    69,66,00
006DE:  DATA    69,72,00
006E0:  DATA    6C,61,00
006E2:  DATA    6E,64,00
006E4:  DATA    69,00,00
006E6:  CLR     32
006E8:  MOV     #40,W3
006EA:  SUB     W0,W3,W3
006EC:  BRA     C,6F8
006EE:  MOV     #702,W3
006F0:  ADD     W3,W0,W0
006F2:  TBLRDL.B[W0],W0L
006F4:  CLR.B   1
006F6:  RETURN  
006F8:  MOV     #702,W0
006FA:  ADD     W3,W3,W3
006FC:  ADD     W3,W0,W3
006FE:  TBLRDH  [W3],W0
00700:  RETURN  
00702:  DATA    0A,0D,6F
00704:  DATA    49,6E,76
00706:  DATA    76,61,65
00708:  DATA    6C,69,6D
0070A:  DATA    64,20,65
0070C:  DATA    65,6E,6E
0070E:  DATA    74,72,74
00710:  DATA    79,3A,20
00712:  DATA    20,4D,72
00714:  DATA    6F,76,61
00716:  DATA    65,6D,6E
00718:  DATA    65,6E,67
0071A:  DATA    74,20,65
0071C:  DATA    72,61,20
0071E:  DATA    6E,67,69
00720:  DATA    65,20,73
00722:  DATA    63,61,20
00724:  DATA    6E,6E,73
00726:  DATA    6F,74,65
00728:  DATA    20,62,74
0072A:  DATA    65,20,20
0072C:  DATA    73,6D,74
0072E:  DATA    61,6C,6F
00730:  DATA    6C,65,20
00732:  DATA    72,20,34
00734:  DATA    74,68,30
00736:  DATA    61,6E,30
00738:  DATA    20,34,20
0073A:  DATA    30,30,6D
0073C:  DATA    20,6D,6D
0073E:  DATA    6D,2E,2E
00740:  DATA    20,4D,00
00742:  CLR     32
00744:  MOV     #42,W3
00746:  SUB     W0,W3,W3
00748:  BRA     C,754
0074A:  MOV     #75E,W3
0074C:  ADD     W3,W0,W0
0074E:  TBLRDL.B[W0],W0L
00750:  CLR.B   1
00752:  RETURN  
00754:  MOV     #75E,W0
00756:  ADD     W3,W3,W3
00758:  ADD     W3,W0,W3
0075A:  TBLRDH  [W3],W0
0075C:  RETURN  
0075E:  DATA    0A,0D,65
00760:  DATA    49,6E,6D
00762:  DATA    76,61,65
00764:  DATA    6C,69,6E
00766:  DATA    64,20,74
00768:  DATA    65,6E,20
0076A:  DATA    74,72,72
0076C:  DATA    79,3A,61
0076E:  DATA    20,4D,6E
00770:  DATA    6F,76,67
00772:  DATA    65,6D,65
00774:  DATA    65,6E,20
00776:  DATA    74,20,69
00778:  DATA    72,61,73
0077A:  DATA    6E,67,20
0077C:  DATA    65,20,73
0077E:  DATA    63,61,65
00780:  DATA    6E,6E,74
00782:  DATA    6F,74,20
00784:  DATA    20,62,74
00786:  DATA    65,20,6F
00788:  DATA    6C,61,20
0078A:  DATA    72,67,32
0078C:  DATA    65,72,30
0078E:  DATA    20,74,30
00790:  DATA    68,61,30
00792:  DATA    6E,20,20
00794:  DATA    32,30,6D
00796:  DATA    30,30,6D
00798:  DATA    20,6D,2E
0079A:  DATA    6D,2E,00
0079C:  DATA    20,4D,00
0079E:  DATA    6F,76,00
007A0:  CLR     32
007A2:  MOV     #3A,W3
007A4:  SUB     W0,W3,W3
007A6:  BRA     C,7B2
007A8:  MOV     #7BC,W3
007AA:  ADD     W3,W0,W0
007AC:  TBLRDL.B[W0],W0L
007AE:  CLR.B   1
007B0:  RETURN  
007B2:  MOV     #7BC,W0
007B4:  ADD     W3,W3,W3
007B6:  ADD     W3,W0,W3
007B8:  TBLRDH  [W3],W0
007BA:  RETURN  
007BC:  DATA    0A,0D,48
007BE:  DATA    49,6E,6F
007C0:  DATA    76,61,6D
007C2:  DATA    6C,69,65
007C4:  DATA    64,20,20
007C6:  DATA    65,6E,70
007C8:  DATA    74,72,6F
007CA:  DATA    79,3A,73
007CC:  DATA    20,48,69
007CE:  DATA    6F,6D,74
007D0:  DATA    65,20,69
007D2:  DATA    70,6F,6F
007D4:  DATA    73,69,6E
007D6:  DATA    74,69,20
007D8:  DATA    6F,6E,69
007DA:  DATA    20,63,73
007DC:  DATA    61,6E,20
007DE:  DATA    6E,6F,6E
007E0:  DATA    74,20,6F
007E2:  DATA    62,65,74
007E4:  DATA    20,73,20
007E6:  DATA    6D,61,63
007E8:  DATA    6C,6C,68
007EA:  DATA    65,72,61
007EC:  DATA    20,74,6E
007EE:  DATA    68,61,67
007F0:  DATA    6E,20,65
007F2:  DATA    31,30,64
007F4:  DATA    2E,20,00
007F6:  CLR     32
007F8:  MOV     #46,W3
007FA:  SUB     W0,W3,W3
007FC:  BRA     C,808
007FE:  MOV     #812,W3
00800:  ADD     W3,W0,W0
00802:  TBLRDL.B[W0],W0L
00804:  CLR.B   1
00806:  RETURN  
00808:  MOV     #812,W0
0080A:  ADD     W3,W3,W3
0080C:  ADD     W3,W0,W3
0080E:  TBLRDH  [W3],W0
00810:  RETURN  
00812:  DATA    0A,0D,64
00814:  DATA    49,6E,20
00816:  DATA    76,61,70
00818:  DATA    6C,69,6F
0081A:  DATA    64,20,73
0081C:  DATA    65,6E,69
0081E:  DATA    74,72,74
00820:  DATA    79,3A,69
00822:  DATA    20,45,6F
00824:  DATA    6E,64,6E
00826:  DATA    20,70,20
00828:  DATA    6F,73,69
0082A:  DATA    69,74,73
0082C:  DATA    69,6F,20
0082E:  DATA    6E,20,73
00830:  DATA    63,61,65
00832:  DATA    6E,6E,74
00834:  DATA    6F,74,20
00836:  DATA    20,62,74
00838:  DATA    65,20,6F
0083A:  DATA    73,6D,20
0083C:  DATA    61,6C,69
0083E:  DATA    6C,65,74
00840:  DATA    72,20,73
00842:  DATA    74,68,20
00844:  DATA    61,6E,64
00846:  DATA    20,68,65
00848:  DATA    6F,6D,66
0084A:  DATA    65,20,61
0084C:  DATA    70,6F,75
0084E:  DATA    73,69,6C
00850:  DATA    74,69,74
00852:  DATA    6F,6E,2E
00854:  DATA    2E,20,00
00856:  DATA    45,6E,00
00858:  CLR     32
0085A:  MOV     #864,W3
0085C:  ADD     W3,W0,W0
0085E:  TBLRDL.B[W0],W0L
00860:  CLR.B   1
00862:  RETURN  
00864:  DATA    43,6F,00
00866:  DATA    75,6E,00
00868:  DATA    74,3A,00
0086A:  DATA    20,25,00
0086C:  DATA    75,20,00
0086E:  DATA    63,6F,00
00870:  DATA    75,6E,00
00872:  DATA    74,73,00
00874:  DATA    0A,0D,00
00876:  DATA    00,00,00
00878:  CLR     32
0087A:  MOV     #884,W3
0087C:  ADD     W3,W0,W0
0087E:  TBLRDL.B[W0],W0L
00880:  CLR.B   1
00882:  RETURN  
00884:  DATA    53,74,00
00886:  DATA    65,70,00
00888:  DATA    3A,20,00
0088A:  DATA    25,75,00
0088C:  DATA    20,73,00
0088E:  DATA    74,65,00
00890:  DATA    70,73,00
00892:  DATA    0A,0D,00
00894:  DATA    00,00,00
00896:  CLR     32
00898:  MOV     #8A2,W3
0089A:  ADD     W3,W0,W0
0089C:  TBLRDL.B[W0],W0L
0089E:  CLR.B   1
008A0:  RETURN  
008A2:  DATA    43,6F,00
008A4:  DATA    6E,76,00
008A6:  DATA    65,72,00
008A8:  DATA    73,69,00
008AA:  DATA    6F,6E,00
008AC:  DATA    20,43,00
008AE:  DATA    6F,6E,00
008B0:  DATA    73,74,00
008B2:  DATA    61,6E,00
008B4:  DATA    74,3A,00
008B6:  DATA    20,25,00
008B8:  DATA    75,20,00
008BA:  DATA    63,6F,00
008BC:  DATA    75,6E,00
008BE:  DATA    74,73,00
008C0:  DATA    0A,0D,00
008C2:  DATA    00,00,00
008C4:  CLR     32
008C6:  MOV     #8D0,W3
008C8:  ADD     W3,W0,W0
008CA:  TBLRDL.B[W0],W0L
008CC:  CLR.B   1
008CE:  RETURN  
008D0:  DATA    51,75,00
008D2:  DATA    61,64,00
008D4:  DATA    72,61,00
008D6:  DATA    74,75,00
008D8:  DATA    72,65,00
008DA:  DATA    20,45,00
008DC:  DATA    6E,63,00
008DE:  DATA    6F,64,00
008E0:  DATA    65,72,00
008E2:  DATA    20,49,00
008E4:  DATA    6E,69,00
008E6:  DATA    74,69,00
008E8:  DATA    61,6C,00
008EA:  DATA    69,7A,00
008EC:  DATA    65,64,00
008EE:  DATA    0A,0A,00
008F0:  DATA    0D,00,00
008F2:  CLR     32
008F4:  MOV     #8FE,W3
008F6:  ADD     W3,W0,W0
008F8:  TBLRDL.B[W0],W0L
008FA:  CLR.B   1
008FC:  RETURN  
008FE:  DATA    51,75,00
00900:  DATA    61,64,00
00902:  DATA    72,61,00
00904:  DATA    74,75,00
00906:  DATA    72,65,00
00908:  DATA    20,45,00
0090A:  DATA    6E,63,00
0090C:  DATA    6F,64,00
0090E:  DATA    65,72,00
00910:  DATA    20,43,00
00912:  DATA    6F,75,00
00914:  DATA    6E,74,00
00916:  DATA    20,53,00
00918:  DATA    65,74,00
0091A:  DATA    3A,20,00
0091C:  DATA    25,75,00
0091E:  DATA    0A,0A,00
00920:  DATA    0D,00,00
00922:  CLR     32
00924:  MOV     #1E,W3
00926:  SUB     W0,W3,W3
00928:  BRA     C,934
0092A:  MOV     #93E,W3
0092C:  ADD     W3,W0,W0
0092E:  TBLRDL.B[W0],W0L
00930:  CLR.B   1
00932:  RETURN  
00934:  MOV     #93E,W0
00936:  ADD     W3,W3,W3
00938:  ADD     W3,W0,W3
0093A:  TBLRDH  [W3],W0
0093C:  RETURN  
0093E:  DATA    51,75,6E
00940:  DATA    61,64,74
00942:  DATA    72,61,20
00944:  DATA    74,75,53
00946:  DATA    72,65,65
00948:  DATA    20,45,74
0094A:  DATA    6E,63,3A
0094C:  DATA    6F,64,20
0094E:  DATA    65,72,25
00950:  DATA    20,4D,75
00952:  DATA    61,78,0A
00954:  DATA    69,6D,0A
00956:  DATA    75,6D,0D
00958:  DATA    20,43,00
0095A:  DATA    6F,75,00
0095C:  CLR     32
0095E:  MOV     #968,W3
00960:  ADD     W3,W0,W0
00962:  TBLRDL.B[W0],W0L
00964:  CLR.B   1
00966:  RETURN  
00968:  DATA    50,57,00
0096A:  DATA    4D,20,00
0096C:  DATA    4D,6F,00
0096E:  DATA    64,75,00
00970:  DATA    6C,65,00
00972:  DATA    20,49,00
00974:  DATA    6E,69,00
00976:  DATA    74,69,00
00978:  DATA    61,6C,00
0097A:  DATA    69,7A,00
0097C:  DATA    65,64,00
0097E:  DATA    0A,0A,00
00980:  DATA    0D,00,00
00982:  CLR     32
00984:  MOV     #98E,W3
00986:  ADD     W3,W0,W0
00988:  TBLRDL.B[W0],W0L
0098A:  CLR.B   1
0098C:  RETURN  
0098E:  DATA    50,57,00
00990:  DATA    4D,20,00
00992:  DATA    44,69,00
00994:  DATA    73,61,00
00996:  DATA    62,6C,00
00998:  DATA    65,64,00
0099A:  DATA    0A,0D,00
0099C:  DATA    00,00,00
0099E:  CLR     32
009A0:  MOV     #9AA,W3
009A2:  ADD     W3,W0,W0
009A4:  TBLRDL.B[W0],W0L
009A6:  CLR.B   1
009A8:  RETURN  
009AA:  DATA    4C,69,00
009AC:  DATA    6D,69,00
009AE:  DATA    74,20,00
009B0:  DATA    73,77,00
009B2:  DATA    69,74,00
009B4:  DATA    63,68,00
009B6:  DATA    20,74,00
009B8:  DATA    72,69,00
009BA:  DATA    67,67,00
009BC:  DATA    65,72,00
009BE:  DATA    65,64,00
009C0:  DATA    2E,0A,00
009C2:  DATA    0D,00,00
009C4:  CLR     32
009C6:  MOV     #9D0,W3
009C8:  ADD     W3,W0,W0
009CA:  TBLRDL.B[W0],W0L
009CC:  CLR.B   1
009CE:  RETURN  
009D0:  DATA    44,69,00
009D2:  DATA    73,70,00
009D4:  DATA    6C,61,00
009D6:  DATA    63,65,00
009D8:  DATA    6D,65,00
009DA:  DATA    6E,74,00
009DC:  DATA    3A,20,00
009DE:  DATA    25,75,00
009E0:  DATA    0A,0D,00
009E2:  DATA    00,00,00
009E4:  CLR     32
009E6:  MOV     #9F0,W3
009E8:  ADD     W3,W0,W0
009EA:  TBLRDL.B[W0],W0L
009EC:  CLR.B   1
009EE:  RETURN  
009F0:  DATA    41,63,00
009F2:  DATA    63,65,00
009F4:  DATA    6C,65,00
009F6:  DATA    72,61,00
009F8:  DATA    74,69,00
009FA:  DATA    6F,6E,00
009FC:  DATA    20,4C,00
009FE:  DATA    69,6D,00
00A00:  DATA    69,74,00
00A02:  DATA    3A,20,00
00A04:  DATA    25,75,00
00A06:  DATA    0A,0D,00
00A08:  DATA    00,00,00
00A0A:  CLR     32
00A0C:  MOV     #A16,W3
00A0E:  ADD     W3,W0,W0
00A10:  TBLRDL.B[W0],W0L
00A12:  CLR.B   1
00A14:  RETURN  
00A16:  DATA    44,65,00
00A18:  DATA    63,65,00
00A1A:  DATA    6C,65,00
00A1C:  DATA    72,61,00
00A1E:  DATA    74,69,00
00A20:  DATA    6F,6E,00
00A22:  DATA    20,4C,00
00A24:  DATA    69,6D,00
00A26:  DATA    69,74,00
00A28:  DATA    3A,20,00
00A2A:  DATA    25,75,00
00A2C:  DATA    0A,0D,00
00A2E:  DATA    00,00,00
00A30:  CLR     32
00A32:  MOV     #A3C,W3
00A34:  ADD     W3,W0,W0
00A36:  TBLRDL.B[W0],W0L
00A38:  CLR.B   1
00A3A:  RETURN  
00A3C:  DATA    44,65,00
00A3E:  DATA    63,65,00
00A40:  DATA    6C,65,00
00A42:  DATA    72,61,00
00A44:  DATA    74,69,00
00A46:  DATA    6F,6E,00
00A48:  DATA    20,43,00
00A4A:  DATA    6F,75,00
00A4C:  DATA    6E,74,00
00A4E:  DATA    3A,20,00
00A50:  DATA    25,75,00
00A52:  DATA    0A,0D,00
00A54:  DATA    00,00,00
00A56:  CLR     32
00A58:  MOV     #52,W3
00A5A:  SUB     W0,W3,W3
00A5C:  BRA     C,A68
00A5E:  MOV     #A72,W3
00A60:  ADD     W3,W0,W0
00A62:  TBLRDL.B[W0],W0L
00A64:  CLR.B   1
00A66:  RETURN  
00A68:  MOV     #A72,W0
00A6A:  ADD     W3,W3,W3
00A6C:  ADD     W3,W0,W3
00A6E:  TBLRDH  [W3],W0
00A70:  RETURN  
00A72:  DATA    49,6E,77
00A74:  DATA    76,61,69
00A76:  DATA    6C,69,6C
00A78:  DATA    64,20,6C
00A7A:  DATA    65,6E,20
00A7C:  DATA    74,72,6D
00A7E:  DATA    79,3A,6F
00A80:  DATA    20,53,76
00A82:  DATA    79,73,65
00A84:  DATA    74,65,20
00A86:  DATA    6D,20,74
00A88:  DATA    63,61,6F
00A8A:  DATA    6E,6E,20
00A8C:  DATA    6F,74,6D
00A8E:  DATA    20,6D,61
00A90:  DATA    6F,76,78
00A92:  DATA    65,20,69
00A94:  DATA    74,6F,6D
00A96:  DATA    20,61,75
00A98:  DATA    20,70,6D
00A9A:  DATA    6F,73,20
00A9C:  DATA    69,74,70
00A9E:  DATA    69,6F,6F
00AA0:  DATA    6E,20,73
00AA2:  DATA    62,65,73
00AA4:  DATA    79,6F,69
00AA6:  DATA    6E,64,62
00AA8:  DATA    20,74,6C
00AAA:  DATA    68,65,65
00AAC:  DATA    20,6D,20
00AAE:  DATA    6F,76,64
00AB0:  DATA    65,6D,69
00AB2:  DATA    65,6E,73
00AB4:  DATA    74,20,74
00AB6:  DATA    72,61,61
00AB8:  DATA    6E,67,6E
00ABA:  DATA    65,2E,63
00ABC:  DATA    20,53,65
00ABE:  DATA    79,73,2E
00AC0:  DATA    74,65,00
00AC2:  DATA    6D,20,00
00AC4:  CLR     32
00AC6:  MOV     #4E,W3
00AC8:  SUB     W0,W3,W3
00ACA:  BRA     C,AD6
00ACC:  MOV     #AE0,W3
00ACE:  ADD     W3,W0,W0
00AD0:  TBLRDL.B[W0],W0L
00AD2:  CLR.B   1
00AD4:  RETURN  
00AD6:  MOV     #AE0,W0
00AD8:  ADD     W3,W3,W3
00ADA:  ADD     W3,W0,W3
00ADC:  TBLRDH  [W3],W0
00ADE:  RETURN  
00AE0:  DATA    49,6E,6C
00AE2:  DATA    76,61,20
00AE4:  DATA    6C,69,6D
00AE6:  DATA    64,20,6F
00AE8:  DATA    65,6E,76
00AEA:  DATA    74,72,65
00AEC:  DATA    79,3A,20
00AEE:  DATA    20,53,74
00AF0:  DATA    79,73,6F
00AF2:  DATA    74,65,20
00AF4:  DATA    6D,20,6D
00AF6:  DATA    63,61,69
00AF8:  DATA    6E,6E,6E
00AFA:  DATA    6F,74,69
00AFC:  DATA    20,6D,6D
00AFE:  DATA    6F,76,75
00B00:  DATA    65,20,6D
00B02:  DATA    74,6F,20
00B04:  DATA    20,61,70
00B06:  DATA    20,70,6F
00B08:  DATA    6F,73,73
00B0A:  DATA    69,74,73
00B0C:  DATA    69,6F,69
00B0E:  DATA    6E,20,62
00B10:  DATA    73,6D,6C
00B12:  DATA    61,6C,65
00B14:  DATA    6C,65,20
00B16:  DATA    72,20,64
00B18:  DATA    74,68,69
00B1A:  DATA    61,6E,73
00B1C:  DATA    20,25,74
00B1E:  DATA    75,20,61
00B20:  DATA    6D,6D,6E
00B22:  DATA    2E,20,63
00B24:  DATA    53,79,65
00B26:  DATA    73,74,2E
00B28:  DATA    65,6D,00
00B2A:  DATA    20,77,00
00B2C:  DATA    69,6C,00
00B2E:  CLR     32
00B30:  MOV     #B3A,W3
00B32:  ADD     W3,W0,W0
00B34:  TBLRDL.B[W0],W0L
00B36:  CLR.B   1
00B38:  RETURN  
00B3A:  DATA    0A,0D,00
00B3C:  DATA    54,61,00
00B3E:  DATA    72,67,00
00B40:  DATA    65,74,00
00B42:  DATA    20,50,00
00B44:  DATA    6F,73,00
00B46:  DATA    69,74,00
00B48:  DATA    69,6F,00
00B4A:  DATA    6E,3A,00
00B4C:  DATA    20,25,00
00B4E:  DATA    75,20,00
00B50:  DATA    6D,6D,00
00B52:  DATA    0A,0D,00
00B54:  DATA    00,00,00
00B56:  CLR     32
00B58:  MOV     #B62,W3
00B5A:  ADD     W3,W0,W0
00B5C:  TBLRDL.B[W0],W0L
00B5E:  CLR.B   1
00B60:  RETURN  
00B62:  DATA    49,6E,00
00B64:  DATA    69,74,00
00B66:  DATA    69,61,00
00B68:  DATA    6C,20,00
00B6A:  DATA    45,72,00
00B6C:  DATA    72,6F,00
00B6E:  DATA    72,3A,00
00B70:  DATA    20,25,00
00B72:  DATA    64,0A,00
00B74:  DATA    0D,00,00
00B76:  CLR     32
00B78:  MOV     #B82,W3
00B7A:  ADD     W3,W0,W0
00B7C:  TBLRDL.B[W0],W0L
00B7E:  CLR.B   1
00B80:  RETURN  
00B82:  DATA    54,61,00
00B84:  DATA    72,67,00
00B86:  DATA    65,74,00
00B88:  DATA    20,45,00
00B8A:  DATA    6E,63,00
00B8C:  DATA    6F,64,00
00B8E:  DATA    65,72,00
00B90:  DATA    20,63,00
00B92:  DATA    6F,75,00
00B94:  DATA    6E,74,00
00B96:  DATA    3A,20,00
00B98:  DATA    25,75,00
00B9A:  DATA    0A,0D,00
00B9C:  DATA    00,00,00
00B9E:  CLR     32
00BA0:  MOV     #BAA,W3
00BA2:  ADD     W3,W0,W0
00BA4:  TBLRDL.B[W0],W0L
00BA6:  CLR.B   1
00BA8:  RETURN  
00BAA:  DATA    43,75,00
00BAC:  DATA    72,72,00
00BAE:  DATA    65,6E,00
00BB0:  DATA    74,20,00
00BB2:  DATA    45,6E,00
00BB4:  DATA    63,6F,00
00BB6:  DATA    64,65,00
00BB8:  DATA    72,20,00
00BBA:  DATA    63,6F,00
00BBC:  DATA    75,6E,00
00BBE:  DATA    74,3A,00
00BC0:  DATA    20,25,00
00BC2:  DATA    75,0A,00
00BC4:  DATA    0D,00,00
00BC6:  CLR     32
00BC8:  MOV     #BD2,W3
00BCA:  ADD     W3,W0,W0
00BCC:  TBLRDL.B[W0],W0L
00BCE:  CLR.B   1
00BD0:  RETURN  
00BD2:  DATA    4E,75,00
00BD4:  DATA    6D,62,00
00BD6:  DATA    65,72,00
00BD8:  DATA    20,6F,00
00BDA:  DATA    66,20,00
00BDC:  DATA    49,74,00
00BDE:  DATA    65,72,00
00BE0:  DATA    61,74,00
00BE2:  DATA    69,6F,00
00BE4:  DATA    6E,73,00
00BE6:  DATA    3A,20,00
00BE8:  DATA    25,75,00
00BEA:  DATA    0A,0D,00
00BEC:  DATA    00,00,00
00BEE:  CLR     32
00BF0:  MOV     #BFA,W3
00BF2:  ADD     W3,W0,W0
00BF4:  TBLRDL.B[W0],W0L
00BF6:  CLR.B   1
00BF8:  RETURN  
00BFA:  DATA    45,72,00
00BFC:  DATA    72,6F,00
00BFE:  DATA    72,3A,00
00C00:  DATA    20,25,00
00C02:  DATA    64,0A,00
00C04:  DATA    0D,00,00
00C06:  CLR     32
00C08:  MOV     #C12,W3
00C0A:  ADD     W3,W0,W0
00C0C:  TBLRDL.B[W0],W0L
00C0E:  CLR.B   1
00C10:  RETURN  
00C12:  DATA    48,6F,00
00C14:  DATA    6D,69,00
00C16:  DATA    6E,67,00
00C18:  DATA    2E,2E,00
00C1A:  DATA    2E,0A,00
00C1C:  DATA    0D,00,00
00C1E:  CLR     32
00C20:  MOV     #C2A,W3
00C22:  ADD     W3,W0,W0
00C24:  TBLRDL.B[W0],W0L
00C26:  CLR.B   1
00C28:  RETURN  
00C2A:  DATA    4D,6F,00
00C2C:  DATA    76,69,00
00C2E:  DATA    6E,67,00
00C30:  DATA    20,4C,00
00C32:  DATA    61,73,00
00C34:  DATA    74,20,00
00C36:  DATA    50,6F,00
00C38:  DATA    73,69,00
00C3A:  DATA    74,69,00
00C3C:  DATA    6F,6E,00
00C3E:  DATA    3A,20,00
00C40:  DATA    25,75,00
00C42:  DATA    20,6D,00
00C44:  DATA    6D,0A,00
00C46:  DATA    0D,00,00
00C48:  CLR     32
00C4A:  MOV     #C54,W3
00C4C:  ADD     W3,W0,W0
00C4E:  TBLRDL.B[W0],W0L
00C50:  CLR.B   1
00C52:  RETURN  
00C54:  DATA    4D,6F,00
00C56:  DATA    76,69,00
00C58:  DATA    6E,67,00
00C5A:  DATA    20,61,00
00C5C:  DATA    77,61,00
00C5E:  DATA    79,20,00
00C60:  DATA    66,72,00
00C62:  DATA    6F,6D,00
00C64:  DATA    20,74,00
00C66:  DATA    68,65,00
00C68:  DATA    20,6C,00
00C6A:  DATA    69,6D,00
00C6C:  DATA    69,74,00
00C6E:  DATA    0A,0D,00
00C70:  DATA    00,00,00
00C72:  CLR     32
00C74:  MOV     #C7E,W3
00C76:  ADD     W3,W0,W0
00C78:  TBLRDL.B[W0],W0L
00C7A:  CLR.B   1
00C7C:  RETURN  
00C7E:  DATA    50,6F,00
00C80:  DATA    73,69,00
00C82:  DATA    74,69,00
00C84:  DATA    6F,6E,00
00C86:  DATA    20,73,00
00C88:  DATA    65,74,00
00C8A:  DATA    20,2D,00
00C8C:  DATA    3E,20,00
00C8E:  DATA    69,6E,00
00C90:  DATA    64,65,00
00C92:  DATA    78,3A,00
00C94:  DATA    20,25,00
00C96:  DATA    75,20,00
00C98:  DATA    70,6F,00
00C9A:  DATA    73,69,00
00C9C:  DATA    74,69,00
00C9E:  DATA    6F,6E,00
00CA0:  DATA    3A,20,00
00CA2:  DATA    25,75,00
00CA4:  DATA    0A,0D,00
00CA6:  DATA    00,00,00
00CA8:  CLR     32
00CAA:  MOV     #1C,W3
00CAC:  SUB     W0,W3,W3
00CAE:  BRA     C,CBA
00CB0:  MOV     #CC4,W3
00CB2:  ADD     W3,W0,W0
00CB4:  TBLRDL.B[W0],W0L
00CB6:  CLR.B   1
00CB8:  RETURN  
00CBA:  MOV     #CC4,W0
00CBC:  ADD     W3,W3,W3
00CBE:  ADD     W3,W0,W3
00CC0:  TBLRDH  [W3],W0
00CC2:  RETURN  
00CC4:  DATA    4D,6F,6F
00CC6:  DATA    76,65,73
00CC8:  DATA    20,50,69
00CCA:  DATA    6F,73,74
00CCC:  DATA    69,74,69
00CCE:  DATA    69,6F,6F
00CD0:  DATA    6E,20,6E
00CD2:  DATA    2D,3E,3A
00CD4:  DATA    20,69,20
00CD6:  DATA    6E,64,25
00CD8:  DATA    65,78,75
00CDA:  DATA    3A,20,0A
00CDC:  DATA    25,75,0D
00CDE:  DATA    20,70,00
00CE0:  CLR     32
00CE2:  MOV     #CEC,W3
00CE4:  ADD     W3,W0,W0
00CE6:  TBLRDL.B[W0],W0L
00CE8:  CLR.B   1
00CEA:  RETURN  
00CEC:  DATA    45,6D,00
00CEE:  DATA    65,72,00
00CF0:  DATA    67,65,00
00CF2:  DATA    6E,63,00
00CF4:  DATA    79,20,00
00CF6:  DATA    53,74,00
00CF8:  DATA    6F,70,00
00CFA:  DATA    20,43,00
00CFC:  DATA    6F,6D,00
00CFE:  DATA    6D,61,00
00D00:  DATA    6E,64,00
00D02:  DATA    0A,0D,00
00D04:  DATA    00,00,00
00D06:  CLR     32
00D08:  MOV     #D12,W3
00D0A:  ADD     W3,W0,W0
00D0C:  TBLRDL.B[W0],W0L
00D0E:  CLR.B   1
00D10:  RETURN  
00D12:  DATA    48,6F,00
00D14:  DATA    6D,69,00
00D16:  DATA    6E,67,00
00D18:  DATA    20,43,00
00D1A:  DATA    6F,6D,00
00D1C:  DATA    6D,61,00
00D1E:  DATA    6E,64,00
00D20:  DATA    0A,0D,00
00D22:  DATA    00,00,00
00D24:  CLR     32
00D26:  MOV     #D30,W3
00D28:  ADD     W3,W0,W0
00D2A:  TBLRDL.B[W0],W0L
00D2C:  CLR.B   1
00D2E:  RETURN  
00D30:  DATA    4C,61,00
00D32:  DATA    73,65,00
00D34:  DATA    72,20,00
00D36:  DATA    4F,66,00
00D38:  DATA    66,20,00
00D3A:  DATA    43,6F,00
00D3C:  DATA    6D,6D,00
00D3E:  DATA    61,6E,00
00D40:  DATA    64,0A,00
00D42:  DATA    0D,00,00
00D44:  CLR     32
00D46:  MOV     #D50,W3
00D48:  ADD     W3,W0,W0
00D4A:  TBLRDL.B[W0],W0L
00D4C:  CLR.B   1
00D4E:  RETURN  
00D50:  DATA    4C,61,00
00D52:  DATA    73,65,00
00D54:  DATA    72,20,00
00D56:  DATA    4F,6E,00
00D58:  DATA    20,43,00
00D5A:  DATA    6F,6D,00
00D5C:  DATA    6D,61,00
00D5E:  DATA    6E,64,00
00D60:  DATA    0A,0D,00
00D62:  DATA    00,00,00
00D64:  CLR     32
00D66:  MOV     #D70,W3
00D68:  ADD     W3,W0,W0
00D6A:  TBLRDL.B[W0],W0L
00D6C:  CLR.B   1
00D6E:  RETURN  
00D70:  DATA    53,65,00
00D72:  DATA    74,20,00
00D74:  DATA    50,6F,00
00D76:  DATA    73,69,00
00D78:  DATA    74,69,00
00D7A:  DATA    6F,6E,00
00D7C:  DATA    20,43,00
00D7E:  DATA    6F,6D,00
00D80:  DATA    6D,61,00
00D82:  DATA    6E,64,00
00D84:  DATA    0A,0D,00
00D86:  DATA    00,00,00
00D88:  CLR     32
00D8A:  MOV     #D94,W3
00D8C:  ADD     W3,W0,W0
00D8E:  TBLRDL.B[W0],W0L
00D90:  CLR.B   1
00D92:  RETURN  
00D94:  DATA    0A,0D,00
00D96:  DATA    43,4F,00
00D98:  DATA    4D,4D,00
00D9A:  DATA    41,4E,00
00D9C:  DATA    44,20,00
00D9E:  DATA    4C,49,00
00DA0:  DATA    53,54,00
00DA2:  DATA    0A,0D,00
00DA4:  DATA    00,00,00
00DA6:  CLR     32
00DA8:  MOV     #DB2,W3
00DAA:  ADD     W3,W0,W0
00DAC:  TBLRDL.B[W0],W0L
00DAE:  CLR.B   1
00DB0:  RETURN  
00DB2:  DATA    0A,0D,00
00DB4:  DATA    53,65,00
00DB6:  DATA    74,20,00
00DB8:  DATA    53,65,00
00DBA:  DATA    72,69,00
00DBC:  DATA    61,6C,00
00DBE:  DATA    20,4E,00
00DC0:  DATA    75,6D,00
00DC2:  DATA    62,65,00
00DC4:  DATA    72,09,00
00DC6:  DATA    28,73,00
00DC8:  DATA    29,00,00
00DCA:  CLR     32
00DCC:  MOV     #DD6,W3
00DCE:  ADD     W3,W0,W0
00DD0:  TBLRDL.B[W0],W0L
00DD2:  CLR.B   1
00DD4:  RETURN  
00DD6:  DATA    0A,0D,00
00DD8:  DATA    53,65,00
00DDA:  DATA    74,20,00
00DDC:  DATA    4D,6F,00
00DDE:  DATA    76,65,00
00DE0:  DATA    20,52,00
00DE2:  DATA    61,6E,00
00DE4:  DATA    67,65,00
00DE6:  DATA    20,09,00
00DE8:  DATA    09,28,00
00DEA:  DATA    72,29,00
00DEC:  DATA    00,00,00
00DEE:  CLR     32
00DF0:  MOV     #DFA,W3
00DF2:  ADD     W3,W0,W0
00DF4:  TBLRDL.B[W0],W0L
00DF6:  CLR.B   1
00DF8:  RETURN  
00DFA:  DATA    0A,0D,00
00DFC:  DATA    53,65,00
00DFE:  DATA    74,20,00
00E00:  DATA    48,6F,00
00E02:  DATA    6D,69,00
00E04:  DATA    6E,67,00
00E06:  DATA    20,44,00
00E08:  DATA    69,73,00
00E0A:  DATA    74,61,00
00E0C:  DATA    6E,63,00
00E0E:  DATA    65,20,00
00E10:  DATA    09,28,00
00E12:  DATA    68,29,00
00E14:  DATA    00,00,00
00E16:  CLR     32
00E18:  MOV     #E22,W3
00E1A:  ADD     W3,W0,W0
00E1C:  TBLRDL.B[W0],W0L
00E1E:  CLR.B   1
00E20:  RETURN  
00E22:  DATA    0A,0D,00
00E24:  DATA    53,65,00
00E26:  DATA    74,20,00
00E28:  DATA    45,6E,00
00E2A:  DATA    64,20,00
00E2C:  DATA    44,69,00
00E2E:  DATA    73,74,00
00E30:  DATA    61,6E,00
00E32:  DATA    63,65,00
00E34:  DATA    20,09,00
00E36:  DATA    28,65,00
00E38:  DATA    29,00,00
00E3A:  CLR     32
00E3C:  MOV     #E46,W3
00E3E:  ADD     W3,W0,W0
00E40:  TBLRDL.B[W0],W0L
00E42:  CLR.B   1
00E44:  RETURN  
00E46:  DATA    0A,0D,00
00E48:  DATA    53,65,00
00E4A:  DATA    74,20,00
00E4C:  DATA    43,6F,00
00E4E:  DATA    6E,76,00
00E50:  DATA    65,72,00
00E52:  DATA    73,69,00
00E54:  DATA    6F,6E,00
00E56:  DATA    20,43,00
00E58:  DATA    6F,6E,00
00E5A:  DATA    73,74,00
00E5C:  DATA    61,6E,00
00E5E:  DATA    74,09,00
00E60:  DATA    28,76,00
00E62:  DATA    29,00,00
00E64:  CLR     32
00E66:  MOV     #E70,W3
00E68:  ADD     W3,W0,W0
00E6A:  TBLRDL.B[W0],W0L
00E6C:  CLR.B   1
00E6E:  RETURN  
00E70:  DATA    0A,0D,00
00E72:  DATA    53,65,00
00E74:  DATA    74,20,00
00E76:  DATA    42,61,00
00E78:  DATA    63,6B,00
00E7A:  DATA    6C,61,00
00E7C:  DATA    73,68,00
00E7E:  DATA    20,09,00
00E80:  DATA    09,28,00
00E82:  DATA    62,29,00
00E84:  DATA    00,00,00
00E86:  CLR     32
00E88:  MOV     #E92,W3
00E8A:  ADD     W3,W0,W0
00E8C:  TBLRDL.B[W0],W0L
00E8E:  CLR.B   1
00E90:  RETURN  
00E92:  DATA    0A,0D,00
00E94:  DATA    53,65,00
00E96:  DATA    74,20,00
00E98:  DATA    43,6F,00
00E9A:  DATA    6D,6D,00
00E9C:  DATA    75,6E,00
00E9E:  DATA    69,63,00
00EA0:  DATA    61,74,00
00EA2:  DATA    69,6F,00
00EA4:  DATA    6E,20,00
00EA6:  DATA    54,79,00
00EA8:  DATA    70,65,00
00EAA:  DATA    20,09,00
00EAC:  DATA    28,74,00
00EAE:  DATA    29,00,00
00EB0:  CLR     32
00EB2:  MOV     #EBC,W3
00EB4:  ADD     W3,W0,W0
00EB6:  TBLRDL.B[W0],W0L
00EB8:  CLR.B   1
00EBA:  RETURN  
00EBC:  DATA    0A,0D,00
00EBE:  DATA    47,65,00
00EC0:  DATA    74,20,00
00EC2:  DATA    53,79,00
00EC4:  DATA    73,74,00
00EC6:  DATA    65,6D,00
00EC8:  DATA    20,44,00
00ECA:  DATA    61,74,00
00ECC:  DATA    61,20,00
00ECE:  DATA    09,28,00
00ED0:  DATA    69,29,00
00ED2:  DATA    00,00,00
00ED4:  CLR     32
00ED6:  MOV     #EE0,W3
00ED8:  ADD     W3,W0,W0
00EDA:  TBLRDL.B[W0],W0L
00EDC:  CLR.B   1
00EDE:  RETURN  
00EE0:  DATA    0A,0D,00
00EE2:  DATA    47,65,00
00EE4:  DATA    74,20,00
00EE6:  DATA    50,6F,00
00EE8:  DATA    73,69,00
00EEA:  DATA    74,69,00
00EEC:  DATA    6F,6E,00
00EEE:  DATA    20,4C,00
00EF0:  DATA    69,73,00
00EF2:  DATA    74,20,00
00EF4:  DATA    09,28,00
00EF6:  DATA    6D,29,00
00EF8:  DATA    00,00,00
00EFA:  CLR     32
00EFC:  MOV     #F06,W3
00EFE:  ADD     W3,W0,W0
00F00:  TBLRDL.B[W0],W0L
00F02:  CLR.B   1
00F04:  RETURN  
00F06:  DATA    0A,0D,00
00F08:  DATA    4D,6F,00
00F0A:  DATA    76,65,00
00F0C:  DATA    20,54,00
00F0E:  DATA    6F,20,00
00F10:  DATA    50,6F,00
00F12:  DATA    73,69,00
00F14:  DATA    74,69,00
00F16:  DATA    6F,6E,00
00F18:  DATA    20,09,00
00F1A:  DATA    28,78,00
00F1C:  DATA    29,00,00
00F1E:  CLR     32
00F20:  MOV     #F2A,W3
00F22:  ADD     W3,W0,W0
00F24:  TBLRDL.B[W0],W0L
00F26:  CLR.B   1
00F28:  RETURN  
00F2A:  DATA    0A,0D,00
00F2C:  DATA    53,65,00
00F2E:  DATA    74,20,00
00F30:  DATA    54,61,00
00F32:  DATA    62,6C,00
00F34:  DATA    65,20,00
00F36:  DATA    44,61,00
00F38:  DATA    74,61,00
00F3A:  DATA    20,09,00
00F3C:  DATA    09,28,00
00F3E:  DATA    71,29,00
00F40:  DATA    00,00,00
00F42:  CLR     32
00F44:  MOV     #F4E,W3
00F46:  ADD     W3,W0,W0
00F48:  TBLRDL.B[W0],W0L
00F4A:  CLR.B   1
00F4C:  RETURN  
00F4E:  DATA    0A,0D,00
00F50:  DATA    54,65,00
00F52:  DATA    73,74,00
00F54:  DATA    20,52,00
00F56:  DATA    75,6E,00
00F58:  DATA    20,28,00
00F5A:  DATA    6C,6F,00
00F5C:  DATA    77,20,00
00F5E:  DATA    72,65,00
00F60:  DATA    73,29,00
00F62:  DATA    20,09,00
00F64:  DATA    28,6F,00
00F66:  DATA    29,00,00
00F68:  CLR     32
00F6A:  MOV     #F74,W3
00F6C:  ADD     W3,W0,W0
00F6E:  TBLRDL.B[W0],W0L
00F70:  CLR.B   1
00F72:  RETURN  
00F74:  DATA    0A,0D,00
00F76:  DATA    54,65,00
00F78:  DATA    73,74,00
00F7A:  DATA    20,52,00
00F7C:  DATA    75,6E,00
00F7E:  DATA    20,28,00
00F80:  DATA    68,69,00
00F82:  DATA    67,68,00
00F84:  DATA    20,72,00
00F86:  DATA    65,73,00
00F88:  DATA    29,20,00
00F8A:  DATA    09,28,00
00F8C:  DATA    6C,29,00
00F8E:  DATA    00,00,00
00F90:  CLR     32
00F92:  MOV     #F9C,W3
00F94:  ADD     W3,W0,W0
00F96:  TBLRDL.B[W0],W0L
00F98:  CLR.B   1
00F9A:  RETURN  
00F9C:  DATA    0A,0D,00
00F9E:  DATA    53,65,00
00FA0:  DATA    74,20,00
00FA2:  DATA    44,65,00
00FA4:  DATA    62,75,00
00FA6:  DATA    67,20,00
00FA8:  DATA    53,74,00
00FAA:  DATA    61,74,00
00FAC:  DATA    65,20,00
00FAE:  DATA    09,28,00
00FB0:  DATA    64,29,00
00FB2:  DATA    00,00,00
00FB4:  CLR     32
00FB6:  MOV     #FC0,W3
00FB8:  ADD     W3,W0,W0
00FBA:  TBLRDL.B[W0],W0L
00FBC:  CLR.B   1
00FBE:  RETURN  
00FC0:  DATA    0A,0D,00
00FC2:  DATA    47,65,00
00FC4:  DATA    74,20,00
00FC6:  DATA    45,6E,00
00FC8:  DATA    63,6F,00
00FCA:  DATA    64,65,00
00FCC:  DATA    72,20,00
00FCE:  DATA    43,6F,00
00FD0:  DATA    75,6E,00
00FD2:  DATA    74,20,00
00FD4:  DATA    09,28,00
00FD6:  DATA    77,29,00
00FD8:  DATA    00,00,00
00FDA:  CLR     32
00FDC:  MOV     #FE6,W3
00FDE:  ADD     W3,W0,W0
00FE0:  TBLRDL.B[W0],W0L
00FE2:  CLR.B   1
00FE4:  RETURN  
00FE6:  DATA    0A,0D,00
00FE8:  DATA    53,74,00
00FEA:  DATA    61,72,00
00FEC:  DATA    74,20,00
00FEE:  DATA    4D,65,00
00FF0:  DATA    6D,6F,00
00FF2:  DATA    72,79,00
00FF4:  DATA    20,54,00
00FF6:  DATA    65,73,00
00FF8:  DATA    74,20,00
00FFA:  DATA    09,28,00
00FFC:  DATA    7A,29,00
00FFE:  DATA    00,00,00
01000:  CLR     32
01002:  MOV     #100C,W3
01004:  ADD     W3,W0,W0
01006:  TBLRDL.B[W0],W0L
01008:  CLR.B   1
0100A:  RETURN  
0100C:  DATA    0A,0D,00
0100E:  DATA    43,6C,00
01010:  DATA    65,61,00
01012:  DATA    72,20,00
01014:  DATA    4D,65,00
01016:  DATA    6D,6F,00
01018:  DATA    72,79,00
0101A:  DATA    20,09,00
0101C:  DATA    09,28,00
0101E:  DATA    66,29,00
01020:  DATA    00,00,00
01022:  CLR     32
01024:  MOV     #102E,W3
01026:  ADD     W3,W0,W0
01028:  TBLRDL.B[W0],W0L
0102A:  CLR.B   1
0102C:  RETURN  
0102E:  DATA    0A,0D,00
01030:  DATA    53,65,00
01032:  DATA    74,20,00
01034:  DATA    53,65,00
01036:  DATA    72,69,00
01038:  DATA    61,6C,00
0103A:  DATA    20,4E,00
0103C:  DATA    75,6D,00
0103E:  DATA    62,65,00
01040:  DATA    72,20,00
01042:  DATA    28,31,00
01044:  DATA    33,20,00
01046:  DATA    43,68,00
01048:  DATA    61,72,00
0104A:  DATA    61,63,00
0104C:  DATA    74,65,00
0104E:  DATA    72,73,00
01050:  DATA    29,3A,00
01052:  DATA    20,00,00
01054:  CLR     32
01056:  MOV     #1060,W3
01058:  ADD     W3,W0,W0
0105A:  TBLRDL.B[W0],W0L
0105C:  CLR.B   1
0105E:  RETURN  
01060:  DATA    0A,0D,00
01062:  DATA    53,65,00
01064:  DATA    74,20,00
01066:  DATA    4D,6F,00
01068:  DATA    76,65,00
0106A:  DATA    20,52,00
0106C:  DATA    61,6E,00
0106E:  DATA    67,65,00
01070:  DATA    20,69,00
01072:  DATA    6E,20,00
01074:  DATA    6D,6D,00
01076:  DATA    20,28,00
01078:  DATA    78,78,00
0107A:  DATA    78,78,00
0107C:  DATA    29,3A,00
0107E:  DATA    20,00,00
01080:  CLR     32
01082:  MOV     #108C,W3
01084:  ADD     W3,W0,W0
01086:  TBLRDL.B[W0],W0L
01088:  CLR.B   1
0108A:  RETURN  
0108C:  DATA    0A,0D,00
0108E:  DATA    53,65,00
01090:  DATA    74,20,00
01092:  DATA    48,6F,00
01094:  DATA    6D,69,00
01096:  DATA    6E,67,00
01098:  DATA    20,44,00
0109A:  DATA    69,73,00
0109C:  DATA    74,61,00
0109E:  DATA    6E,63,00
010A0:  DATA    65,20,00
010A2:  DATA    69,6E,00
010A4:  DATA    20,63,00
010A6:  DATA    6F,75,00
010A8:  DATA    6E,74,00
010AA:  DATA    73,20,00
010AC:  DATA    28,78,00
010AE:  DATA    78,78,00
010B0:  DATA    78,29,00
010B2:  DATA    3A,20,00
010B4:  DATA    00,00,00
010B6:  CLR     32
010B8:  MOV     #10C2,W3
010BA:  ADD     W3,W0,W0
010BC:  TBLRDL.B[W0],W0L
010BE:  CLR.B   1
010C0:  RETURN  
010C2:  DATA    0A,0D,00
010C4:  DATA    53,65,00
010C6:  DATA    74,20,00
010C8:  DATA    45,6E,00
010CA:  DATA    64,20,00
010CC:  DATA    44,69,00
010CE:  DATA    73,74,00
010D0:  DATA    61,6E,00
010D2:  DATA    63,65,00
010D4:  DATA    20,69,00
010D6:  DATA    6E,20,00
010D8:  DATA    63,6F,00
010DA:  DATA    75,6E,00
010DC:  DATA    74,73,00
010DE:  DATA    20,28,00
010E0:  DATA    78,78,00
010E2:  DATA    78,78,00
010E4:  DATA    78,29,00
010E6:  DATA    3A,20,00
010E8:  DATA    00,00,00
010EA:  CLR     32
010EC:  MOV     #10F6,W3
010EE:  ADD     W3,W0,W0
010F0:  TBLRDL.B[W0],W0L
010F2:  CLR.B   1
010F4:  RETURN  
010F6:  DATA    0A,0D,00
010F8:  DATA    53,65,00
010FA:  DATA    74,20,00
010FC:  DATA    43,6F,00
010FE:  DATA    6E,76,00
01100:  DATA    65,72,00
01102:  DATA    73,69,00
01104:  DATA    6F,6E,00
01106:  DATA    20,43,00
01108:  DATA    6F,6E,00
0110A:  DATA    73,74,00
0110C:  DATA    61,6E,00
0110E:  DATA    74,20,00
01110:  DATA    28,78,00
01112:  DATA    78,78,00
01114:  DATA    78,78,00
01116:  DATA    29,3A,00
01118:  DATA    20,00,00
0111A:  CLR     32
0111C:  MOV     #1126,W3
0111E:  ADD     W3,W0,W0
01120:  TBLRDL.B[W0],W0L
01122:  CLR.B   1
01124:  RETURN  
01126:  DATA    0A,0D,00
01128:  DATA    53,65,00
0112A:  DATA    74,20,00
0112C:  DATA    42,61,00
0112E:  DATA    63,6B,00
01130:  DATA    6C,61,00
01132:  DATA    73,68,00
01134:  DATA    20,28,00
01136:  DATA    78,78,00
01138:  DATA    29,3A,00
0113A:  DATA    20,00,00
0113C:  CLR     32
0113E:  MOV     #20,W3
01140:  SUB     W0,W3,W3
01142:  BRA     C,114E
01144:  MOV     #1158,W3
01146:  ADD     W3,W0,W0
01148:  TBLRDL.B[W0],W0L
0114A:  CLR.B   1
0114C:  RETURN  
0114E:  MOV     #1158,W0
01150:  ADD     W3,W3,W3
01152:  ADD     W3,W0,W3
01154:  TBLRDH  [W3],W0
01156:  RETURN  
01158:  DATA    0A,0D,61
0115A:  DATA    53,65,6C
0115C:  DATA    74,20,6C
0115E:  DATA    43,6F,65
01160:  DATA    6D,6D,6C
01162:  DATA    75,6E,2C
01164:  DATA    69,63,20
01166:  DATA    61,74,31
01168:  DATA    69,6F,3A
0116A:  DATA    6E,20,20
0116C:  DATA    54,79,52
0116E:  DATA    70,65,53
01170:  DATA    20,28,32
01172:  DATA    30,3A,33
01174:  DATA    20,50,32
01176:  DATA    61,72,00
01178:  CLR     32
0117A:  MOV     #1184,W3
0117C:  ADD     W3,W0,W0
0117E:  TBLRDL.B[W0],W0L
01180:  CLR.B   1
01182:  RETURN  
01184:  DATA    0A,0D,00
01186:  DATA    47,65,00
01188:  DATA    74,20,00
0118A:  DATA    50,6F,00
0118C:  DATA    73,69,00
0118E:  DATA    74,69,00
01190:  DATA    6F,6E,00
01192:  DATA    20,4C,00
01194:  DATA    69,73,00
01196:  DATA    74,28,00
01198:  DATA    30,3C,00
0119A:  DATA    3D,58,00
0119C:  DATA    3C,3D,00
0119E:  DATA    39,29,00
011A0:  DATA    3A,20,00
011A2:  DATA    00,00,00
011A4:  CLR     32
011A6:  MOV     #11B0,W3
011A8:  ADD     W3,W0,W0
011AA:  TBLRDL.B[W0],W0L
011AC:  CLR.B   1
011AE:  RETURN  
011B0:  DATA    0A,0D,00
011B2:  DATA    4D,6F,00
011B4:  DATA    76,65,00
011B6:  DATA    20,54,00
011B8:  DATA    6F,28,00
011BA:  DATA    30,3C,00
011BC:  DATA    3D,58,00
011BE:  DATA    3C,3D,00
011C0:  DATA    39,39,00
011C2:  DATA    39,39,00
011C4:  DATA    29,3A,00
011C6:  DATA    20,00,00
011C8:  CLR     32
011CA:  MOV     #11D4,W3
011CC:  ADD     W3,W0,W0
011CE:  TBLRDL.B[W0],W0L
011D0:  CLR.B   1
011D2:  RETURN  
011D4:  DATA    0A,0D,00
011D6:  DATA    45,6E,00
011D8:  DATA    74,65,00
011DA:  DATA    72,20,00
011DC:  DATA    54,61,00
011DE:  DATA    62,6C,00
011E0:  DATA    65,20,00
011E2:  DATA    49,6E,00
011E4:  DATA    64,65,00
011E6:  DATA    78,20,00
011E8:  DATA    28,78,00
011EA:  DATA    78,29,00
011EC:  DATA    3A,20,00
011EE:  DATA    00,00,00
011F0:  CLR     32
011F2:  MOV     #11FC,W3
011F4:  ADD     W3,W0,W0
011F6:  TBLRDL.B[W0],W0L
011F8:  CLR.B   1
011FA:  RETURN  
011FC:  DATA    0A,0D,00
011FE:  DATA    49,6E,00
01200:  DATA    64,65,00
01202:  DATA    78,3A,00
01204:  DATA    20,25,00
01206:  DATA    75,00,00
01208:  CLR     32
0120A:  MOV     #1214,W3
0120C:  ADD     W3,W0,W0
0120E:  TBLRDL.B[W0],W0L
01210:  CLR.B   1
01212:  RETURN  
01214:  DATA    0A,0D,00
01216:  DATA    45,6E,00
01218:  DATA    74,65,00
0121A:  DATA    72,20,00
0121C:  DATA    50,6F,00
0121E:  DATA    73,69,00
01220:  DATA    74,69,00
01222:  DATA    6F,6E,00
01224:  DATA    20,28,00
01226:  DATA    78,78,00
01228:  DATA    78,78,00
0122A:  DATA    29,3A,00
0122C:  DATA    20,00,00
0122E:  CLR     32
01230:  MOV     #123A,W3
01232:  ADD     W3,W0,W0
01234:  TBLRDL.B[W0],W0L
01236:  CLR.B   1
01238:  RETURN  
0123A:  DATA    0A,0D,00
0123C:  DATA    50,6F,00
0123E:  DATA    73,69,00
01240:  DATA    74,69,00
01242:  DATA    6F,6E,00
01244:  DATA    3A,20,00
01246:  DATA    25,75,00
01248:  DATA    00,00,00
0124A:  CLR     32
0124C:  MOV     #1256,W3
0124E:  ADD     W3,W0,W0
01250:  TBLRDL.B[W0],W0L
01252:  CLR.B   1
01254:  RETURN  
01256:  DATA    0A,0D,00
01258:  DATA    53,70,00
0125A:  DATA    65,65,00
0125C:  DATA    64,20,00
0125E:  DATA    28,78,00
01260:  DATA    78,78,00
01262:  DATA    78,29,00
01264:  DATA    3A,20,00
01266:  DATA    00,00,00
01268:  CLR     32
0126A:  MOV     #1274,W3
0126C:  ADD     W3,W0,W0
0126E:  TBLRDL.B[W0],W0L
01270:  CLR.B   1
01272:  RETURN  
01274:  DATA    0A,0D,00
01276:  DATA    53,65,00
01278:  DATA    74,20,00
0127A:  DATA    64,65,00
0127C:  DATA    62,75,00
0127E:  DATA    67,20,00
01280:  DATA    73,74,00
01282:  DATA    61,74,00
01284:  DATA    65,0A,00
01286:  DATA    0D,00,00
01288:  CLR     32
0128A:  MOV     #1294,W3
0128C:  ADD     W3,W0,W0
0128E:  TBLRDL.B[W0],W0L
01290:  CLR.B   1
01292:  RETURN  
01294:  DATA    44,69,00
01296:  DATA    67,69,00
01298:  DATA    74,61,00
0129A:  DATA    6C,20,00
0129C:  DATA    70,6F,00
0129E:  DATA    74,65,00
012A0:  DATA    6E,74,00
012A2:  DATA    69,6F,00
012A4:  DATA    6D,65,00
012A6:  DATA    74,65,00
012A8:  DATA    72,20,00
012AA:  DATA    28,61,00
012AC:  DATA    29,28,00
012AE:  DATA    30,20,00
012B0:  DATA    6F,72,00
012B2:  DATA    20,31,00
012B4:  DATA    29,3A,00
012B6:  DATA    20,0A,00
012B8:  DATA    0D,00,00
012BA:  CLR     32
012BC:  MOV     #12C6,W3
012BE:  ADD     W3,W0,W0
012C0:  TBLRDL.B[W0],W0L
012C2:  CLR.B   1
012C4:  RETURN  
012C6:  DATA    50,61,00
012C8:  DATA    72,61,00
012CA:  DATA    6C,6C,00
012CC:  DATA    65,6C,00
012CE:  DATA    20,70,00
012D0:  DATA    6F,72,00
012D2:  DATA    74,20,00
012D4:  DATA    20,20,00
012D6:  DATA    20,20,00
012D8:  DATA    20,20,00
012DA:  DATA    20,20,00
012DC:  DATA    28,62,00
012DE:  DATA    29,28,00
012E0:  DATA    30,20,00
012E2:  DATA    6F,72,00
012E4:  DATA    20,31,00
012E6:  DATA    29,3A,00
012E8:  DATA    20,0A,00
012EA:  DATA    0D,00,00
012EC:  CLR     32
012EE:  MOV     #12F8,W3
012F0:  ADD     W3,W0,W0
012F2:  TBLRDL.B[W0],W0L
012F4:  CLR.B   1
012F6:  RETURN  
012F8:  DATA    46,52,00
012FA:  DATA    41,4D,00
012FC:  DATA    20,20,00
012FE:  DATA    20,20,00
01300:  DATA    20,20,00
01302:  DATA    20,20,00
01304:  DATA    20,20,00
01306:  DATA    20,20,00
01308:  DATA    20,20,00
0130A:  DATA    20,20,00
0130C:  DATA    20,20,00
0130E:  DATA    28,63,00
01310:  DATA    29,28,00
01312:  DATA    30,20,00
01314:  DATA    6F,72,00
01316:  DATA    20,31,00
01318:  DATA    29,3A,00
0131A:  DATA    20,0A,00
0131C:  DATA    0D,00,00
0131E:  CLR     32
01320:  MOV     #132A,W3
01322:  ADD     W3,W0,W0
01324:  TBLRDL.B[W0],W0L
01326:  CLR.B   1
01328:  RETURN  
0132A:  DATA    4D,6F,00
0132C:  DATA    74,6F,00
0132E:  DATA    72,20,00
01330:  DATA    64,72,00
01332:  DATA    69,76,00
01334:  DATA    65,72,00
01336:  DATA    20,20,00
01338:  DATA    20,20,00
0133A:  DATA    20,20,00
0133C:  DATA    20,20,00
0133E:  DATA    20,20,00
01340:  DATA    28,64,00
01342:  DATA    29,28,00
01344:  DATA    30,20,00
01346:  DATA    6F,72,00
01348:  DATA    20,31,00
0134A:  DATA    29,3A,00
0134C:  DATA    20,0A,00
0134E:  DATA    0D,00,00
01350:  CLR     32
01352:  MOV     #135C,W3
01354:  ADD     W3,W0,W0
01356:  TBLRDL.B[W0],W0L
01358:  CLR.B   1
0135A:  RETURN  
0135C:  DATA    45,6E,00
0135E:  DATA    63,6F,00
01360:  DATA    64,65,00
01362:  DATA    72,20,00
01364:  DATA    20,20,00
01366:  DATA    20,20,00
01368:  DATA    20,20,00
0136A:  DATA    20,20,00
0136C:  DATA    20,20,00
0136E:  DATA    20,20,00
01370:  DATA    20,20,00
01372:  DATA    28,65,00
01374:  DATA    29,28,00
01376:  DATA    30,20,00
01378:  DATA    6F,72,00
0137A:  DATA    20,31,00
0137C:  DATA    29,3A,00
0137E:  DATA    20,0A,00
01380:  DATA    0D,00,00
01382:  CLR     32
01384:  MOV     #138E,W3
01386:  ADD     W3,W0,W0
01388:  TBLRDL.B[W0],W0L
0138A:  CLR.B   1
0138C:  RETURN  
0138E:  DATA    50,57,00
01390:  DATA    4D,20,00
01392:  DATA    4D,6F,00
01394:  DATA    64,75,00
01396:  DATA    6C,65,00
01398:  DATA    20,20,00
0139A:  DATA    20,20,00
0139C:  DATA    20,20,00
0139E:  DATA    20,20,00
013A0:  DATA    20,20,00
013A2:  DATA    20,20,00
013A4:  DATA    28,66,00
013A6:  DATA    29,28,00
013A8:  DATA    30,20,00
013AA:  DATA    6F,72,00
013AC:  DATA    20,31,00
013AE:  DATA    29,3A,00
013B0:  DATA    20,0A,00
013B2:  DATA    0D,00,00
013B4:  CLR     32
013B6:  MOV     #13C0,W3
013B8:  ADD     W3,W0,W0
013BA:  TBLRDL.B[W0],W0L
013BC:  CLR.B   1
013BE:  RETURN  
013C0:  DATA    41,6C,00
013C2:  DATA    6C,20,00
013C4:  DATA    4D,6F,00
013C6:  DATA    64,65,00
013C8:  DATA    73,20,00
013CA:  DATA    20,20,00
013CC:  DATA    20,20,00
013CE:  DATA    20,20,00
013D0:  DATA    20,20,00
013D2:  DATA    20,20,00
013D4:  DATA    20,20,00
013D6:  DATA    28,67,00
013D8:  DATA    29,28,00
013DA:  DATA    30,20,00
013DC:  DATA    6F,72,00
013DE:  DATA    20,31,00
013E0:  DATA    29,3A,00
013E2:  DATA    20,0A,00
013E4:  DATA    0D,00,00
013E6:  CLR     32
013E8:  MOV     #13F2,W3
013EA:  ADD     W3,W0,W0
013EC:  TBLRDL.B[W0],W0L
013EE:  CLR.B   1
013F0:  RETURN  
013F2:  DATA    53,65,00
013F4:  DATA    6C,65,00
013F6:  DATA    63,74,00
013F8:  DATA    69,6F,00
013FA:  DATA    6E,20,00
013FC:  DATA    28,78,00
013FE:  DATA    78,29,00
01400:  DATA    3A,20,00
01402:  DATA    00,00,00
01404:  CLR     32
01406:  MOV     #1410,W3
01408:  ADD     W3,W0,W0
0140A:  TBLRDL.B[W0],W0L
0140C:  CLR.B   1
0140E:  RETURN  
01410:  DATA    49,6E,00
01412:  DATA    76,61,00
01414:  DATA    6C,69,00
01416:  DATA    64,20,00
01418:  DATA    45,6E,00
0141A:  DATA    74,72,00
0141C:  DATA    79,0A,00
0141E:  DATA    0D,00,00
01420:  CLR     32
01422:  MOV     #142C,W3
01424:  ADD     W3,W0,W0
01426:  TBLRDL.B[W0],W0L
01428:  CLR.B   1
0142A:  RETURN  
0142C:  DATA    0A,0D,00
0142E:  DATA    45,6E,00
01430:  DATA    63,6F,00
01432:  DATA    64,65,00
01434:  DATA    72,20,00
01436:  DATA    63,6F,00
01438:  DATA    75,6E,00
0143A:  DATA    74,20,00
0143C:  DATA    25,34,00
0143E:  DATA    75,0A,00
01440:  DATA    0D,00,00
01442:  CLR     32
01444:  MOV     #1C,W3
01446:  SUB     W0,W3,W3
01448:  BRA     C,1454
0144A:  MOV     #145E,W3
0144C:  ADD     W3,W0,W0
0144E:  TBLRDL.B[W0],W0L
01450:  CLR.B   1
01452:  RETURN  
01454:  MOV     #145E,W0
01456:  ADD     W3,W3,W3
01458:  ADD     W3,W0,W3
0145A:  TBLRDH  [W3],W0
0145C:  RETURN  
0145E:  DATA    0A,0D,31
01460:  DATA    53,74,2C
01462:  DATA    61,72,20
01464:  DATA    74,20,4E
01466:  DATA    4D,65,6F
01468:  DATA    6D,6F,20
0146A:  DATA    72,79,2D
0146C:  DATA    20,54,3E
0146E:  DATA    65,73,20
01470:  DATA    74,20,30
01472:  DATA    28,59,29
01474:  DATA    65,73,3A
01476:  DATA    20,2D,20
01478:  DATA    3E,20,00
0147A:  CLR     32
0147C:  MOV     #1486,W3
0147E:  ADD     W3,W0,W0
01480:  TBLRDL.B[W0],W0L
01482:  CLR.B   1
01484:  RETURN  
01486:  DATA    0A,0D,00
01488:  DATA    43,6C,00
0148A:  DATA    65,61,00
0148C:  DATA    72,20,00
0148E:  DATA    4D,65,00
01490:  DATA    6D,6F,00
01492:  DATA    72,79,00
01494:  DATA    20,28,00
01496:  DATA    59,65,00
01498:  DATA    73,20,00
0149A:  DATA    2D,3E,00
0149C:  DATA    20,31,00
0149E:  DATA    2C,20,00
014A0:  DATA    4E,6F,00
014A2:  DATA    20,2D,00
014A4:  DATA    3E,20,00
014A6:  DATA    30,29,00
014A8:  DATA    3A,20,00
014AA:  DATA    00,00,00
014AC:  CLR     32
014AE:  MOV     #14B8,W3
014B0:  ADD     W3,W0,W0
014B2:  TBLRDL.B[W0],W0L
014B4:  CLR.B   1
014B6:  RETURN  
014B8:  DATA    0A,0A,00
014BA:  DATA    0D,4D,00
014BC:  DATA    4F,44,00
014BE:  DATA    45,53,00
014C0:  DATA    49,53,00
014C2:  DATA    20,4C,00
014C4:  DATA    41,53,00
014C6:  DATA    45,52,00
014C8:  DATA    20,50,00
014CA:  DATA    4F,53,00
014CC:  DATA    49,54,00
014CE:  DATA    49,4F,00
014D0:  DATA    4E,49,00
014D2:  DATA    4E,47,00
014D4:  DATA    20,53,00
014D6:  DATA    59,53,00
014D8:  DATA    54,45,00
014DA:  DATA    4D,0A,00
014DC:  DATA    0A,0D,00
014DE:  DATA    00,00,00
014E0:  CLR     32
014E2:  MOV     #1C,W3
014E4:  SUB     W0,W3,W3
014E6:  BRA     C,14F2
014E8:  MOV     #14FC,W3
014EA:  ADD     W3,W0,W0
014EC:  TBLRDL.B[W0],W0L
014EE:  CLR.B   1
014F0:  RETURN  
014F2:  MOV     #14FC,W0
014F4:  ADD     W3,W3,W3
014F6:  ADD     W3,W0,W3
014F8:  TBLRDH  [W3],W0
014FA:  RETURN  
014FC:  DATA    0A,0A,20
014FE:  DATA    0D,43,49
01500:  DATA    6F,64,6E
01502:  DATA    65,20,74
01504:  DATA    56,65,65
01506:  DATA    72,73,72
01508:  DATA    69,6F,72
0150A:  DATA    6E,20,75
0150C:  DATA    56,32,70
0150E:  DATA    2E,31,74
01510:  DATA    20,57,0A
01512:  DATA    69,74,0A
01514:  DATA    68,6F,0D
01516:  DATA    75,74,00
01518:  CLR     32
0151A:  MOV     #1524,W3
0151C:  ADD     W3,W0,W0
0151E:  TBLRDL.B[W0],W0L
01520:  CLR.B   1
01522:  RETURN  
01524:  DATA    50,72,00
01526:  DATA    65,73,00
01528:  DATA    73,20,00
0152A:  DATA    27,63,00
0152C:  DATA    27,20,00
0152E:  DATA    66,6F,00
01530:  DATA    72,20,00
01532:  DATA    63,6F,00
01534:  DATA    6D,6D,00
01536:  DATA    61,6E,00
01538:  DATA    64,20,00
0153A:  DATA    6C,69,00
0153C:  DATA    73,74,00
0153E:  DATA    0A,0A,00
01540:  DATA    0D,00,00
*
01596:  MOV     W5,[W15++]
01598:  MOV     #C,W5
0159A:  REPEAT  #3
0159C:  MOV     [W5++],[W15++]
0159E:  MOV     W0,W7
015A0:  MOV     W4,W9
015A2:  BCLR    W4.F
015A4:  CP0     W4
015A6:  BRA     NZ,15B4
015A8:  BTSC    W9.F
015AA:  BRA     15B0
015AC:  MOV     #0,W5
015AE:  BRA     15CE
015B0:  MOV     #0,W5
015B2:  BRA     15CE
015B4:  SUB.B   W4L,#6,W5L
015B6:  BRA     NC,15CC
015B8:  MOV     #30,W0
015BA:  BTSS    W9.F
015BC:  MOV     #20,W0
015BE:  BTSC.B  219.1
015C0:  BRA     15BE
015C2:  MOV.B   W0L,21A
015C4:  DEC     W5,W5
015C6:  BRA     NN,15BE
015C8:  MOV     #5,W5
015CA:  BRA     15CE
015CC:  MOV     W4,W5
015CE:  MOV     #6,W4
015D0:  BSET    W5.E
015D2:  BTSC    W9.F
015D4:  BSET    W5.F
015D6:  MOV     #2710,W8
015D8:  REPEAT  #11
015DA:  DIV.U   W7,W8
015DC:  CALL    1610
015E0:  MOV     W1,W7
015E2:  MOV     #3E8,W8
015E4:  REPEAT  #11
015E6:  DIV.U   W7,W8
015E8:  CALL    1610
015EC:  MOV     W1,W7
015EE:  MOV     #64,W8
015F0:  REPEAT  #11
015F2:  DIV.U   W7,W8
015F4:  CALL    1610
015F8:  MOV     W1,W7
015FA:  MOV     #A,W8
015FC:  REPEAT  #11
015FE:  DIV.U   W7,W8
01600:  CALL    1610
01604:  MOV     #30,W0
01606:  ADD.B   W1L,W0L,W0L
01608:  BTSC.B  219.1
0160A:  BRA     1608
0160C:  MOV.B   W0L,21A
0160E:  BRA     163E
01610:  MOV     #30,W6
01612:  CP0     W0
01614:  BRA     NZ,1632
01616:  BTSS    W5.E
01618:  BRA     1634
0161A:  DEC     W4,W4
0161C:  CP.B    W4L,W5L
0161E:  BRA     Z,1624
01620:  BTSC.B  42.0
01622:  RETURN  
01624:  CP0     W0
01626:  BRA     NZ,1632
01628:  BTSS    W5.E
0162A:  BRA     1634
0162C:  BTSS    W5.F
0162E:  MOV     #20,W6
01630:  BRA     1634
01632:  BCLR    W5.E
01634:  ADD.B   W6L,W0L,W0L
01636:  BTSC.B  219.1
01638:  BRA     1636
0163A:  MOV.B   W0L,21A
0163C:  RETURN  
0163E:  MOV     #12,W5
01640:  REPEAT  #3
01642:  MOV     [--W15],[W5--]
01644:  MOV     [--W15],W5
01646:  RETURN  
*
019FA:  MOV     W5,[W15++]
019FC:  MOV     #C,W5
019FE:  REPEAT  #3
01A00:  MOV     [W5++],[W15++]
01A02:  MUL.UU  W0,W2,W4
01A04:  MUL.UU  W0,W3,W6
01A06:  BCLR.B  42.0
01A08:  ADD     W6,W5,W5
01A0A:  ADDC    W7,#0,W8
01A0C:  MUL.UU  W1,W2,W6
01A0E:  ADDC    W6,W5,W5
01A10:  ADDC    W7,W8,W8
01A12:  MUL.UU  W1,W3,W6
01A14:  ADD     W6,W8,W8
01A16:  ADDC    #0,W7
01A18:  MOV     W7,W3
01A1A:  MOV     W8,W2
01A1C:  MOV     W5,W1
01A1E:  MOV     W4,W0
01A20:  MOV     #12,W5
01A22:  REPEAT  #3
01A24:  MOV     [--W15],[W5--]
01A26:  MOV     [--W15],W5
01A28:  RETURN  
01A2A:  MOV     W5,[W15++]
01A2C:  MOV     #C,W5
01A2E:  REPEAT  #3
01A30:  MOV     [W5++],[W15++]
01A32:  MOV     #0,W9
01A34:  BTSC.B  43.0
01A36:  MOV     #1,W9
01A38:  MOV     W9,[W15++]
01A3A:  CLR     W4
01A3C:  CLR     W5
01A3E:  CLR     W6
01A40:  CLR     W7
01A42:  XOR     W2,W3,W8
01A44:  BRA     Z,1A68
01A46:  MOV     #20,W8
01A48:  BCLR.B  42.0
01A4A:  RLC     W0,W0
01A4C:  RLC     W1,W1
01A4E:  RLC     W4,W4
01A50:  RLC     W5,W5
01A52:  CP      W5,W3
01A54:  BRA     NZ,1A58
01A56:  CPB     W4,W2
01A58:  BRA     NC,1A60
01A5A:  SUB     W4,W2,W4
01A5C:  SUBB    W5,W3,W5
01A5E:  BSET.B  42.0
01A60:  RLC     W6,W6
01A62:  RLC     W7,W7
01A64:  DEC     W8,W8
01A66:  BRA     NZ,1A48
01A68:  MOV     W7,W1
01A6A:  MOV     W6,W0
01A6C:  MOV     [--W15],W9
01A6E:  CP0     W9
01A70:  BRA     Z,1A74
01A72:  MOV.D   W4,W0
01A74:  MOV     #12,W5
01A76:  REPEAT  #3
01A78:  MOV     [--W15],[W5--]
01A7A:  MOV     [--W15],W5
01A7C:  RETURN  
*
026AC:  MOV     W5,[W15++]
026AE:  MOV     W6,[W15++]
026B0:  MOV     #8E,W1
026B2:  CP0     W0
026B4:  BRA     Z,26DA
026B6:  BTSC    W0.F
026B8:  BRA     26C2
026BA:  BCLR.B  42.0
026BC:  RLC     W0,W0
026BE:  DEC     W1,W1
026C0:  BRA     26B6
026C2:  SWAP    W1
026C4:  BCLR.B  42.0
026C6:  RRC     W1,W1
026C8:  BCLR    W0.F
026CA:  SWAP    W0
026CC:  XOR.B   W0L,W1L,W1L
026CE:  AND.B   #0,W0L
026D0:  BRA     26E0
026D2:  MOV.B   W1L,W0L
026D4:  BSET    W1.7
026D6:  AND.B   #0,W1L
026D8:  BRA     26E0
026DA:  CLR     W0
026DC:  CLR     W1
026DE:  BRA     26E0
026E0:  MOV     [--W15],W6
026E2:  MOV     [--W15],W5
026E4:  RETURN  
026E6:  MOV     W5,[W15++]
026E8:  MOV     #C,W5
026EA:  REPEAT  #4
026EC:  MOV     [W5++],[W15++]
026EE:  CLR     W9
026F0:  XOR     W1,W3,W9
026F2:  MOV     W1,W6
026F4:  MOV     W0,W5
026F6:  MOV     W3,W8
026F8:  MOV     W2,W7
026FA:  RLC     W1,W1
026FC:  SWAP    W1
026FE:  ZE      W1,W1
02700:  CP0     W1
02702:  BRA     Z,27A0
02704:  RLC     W3,W3
02706:  SWAP    W3
02708:  ZE      W3,W3
0270A:  CP0     W3
0270C:  BRA     Z,27A0
0270E:  CLR     W0
02710:  SUB.B   W1L,W3L,W0L
02712:  BRA     NC,271A
02714:  ADD.B   #7F,W0L
02716:  BRA     C,27A0
02718:  BRA     2720
0271A:  SUB.B   #81,W0L
0271C:  BRA     NC,27A0
0271E:  BRA     Z,27A0
02720:  MOV     W5,W1
02722:  MOV     W6,W2
02724:  BSET    W2.7
02726:  AND     #FF,W2
02728:  AND     #FF,W8
0272A:  BSET    W8.7
0272C:  MOV     #19,W10
0272E:  CLR     W3
02730:  CLR     W4
02732:  SUB     W1,W7,W1
02734:  SUBB    W2,W8,W2
02736:  BRA     N,273C
02738:  BRA     C,2742
0273A:  BRA     NZ,2744
0273C:  ADD     W1,W7,W1
0273E:  ADDC    W2,W8,W2
02740:  BRA     2744
02742:  BSET    W4.0
02744:  DEC     W10,W10
02746:  BRA     Z,2756
02748:  BCLR.B  42.0
0274A:  RLC     W1,W1
0274C:  RLC     W2,W2
0274E:  BCLR.B  42.0
02750:  RLC     W4,W4
02752:  RLC     W3,W3
02754:  BRA     2732
02756:  CLR     W10
02758:  BTSC    W3.8
0275A:  BRA     275E
0275C:  BRA     276A
0275E:  BCLR.B  42.0
02760:  RRC     W3,W3
02762:  BCLR    W3.7
02764:  RRC     W4,W4
02766:  RLC     W10,W10
02768:  BRA     276E
0276A:  DEC     W0,W0
0276C:  BRA     Z,27A0
0276E:  BTSC    W10.F
02770:  BRA     NC,277C
02772:  RLC     W1,W1
02774:  RLC     W2,W2
02776:  SUB     W1,W7,W1
02778:  SUBB    W2,W8,W2
0277A:  BRA     NC,278E
0277C:  INC     W4,W4
0277E:  BRA     NZ,278E
02780:  INC     W3,W3
02782:  BRA     NZ,278E
02784:  INC     W0,W0
02786:  BRA     Z,27A0
02788:  BRA     278E
0278A:  DEC     W0,W0
0278C:  BRA     Z,27A0
0278E:  SWAP    W0
02790:  RRC     W0,W1
02792:  BSET    W1.F
02794:  BTSS    W9.F
02796:  BCLR    W1.F
02798:  BCLR    W3.7
0279A:  XOR.B   W3L,W1L,W1L
0279C:  MOV     W4,W0
0279E:  BRA     27A6
027A0:  MOV     #0,W0
027A2:  MOV     #0,W1
027A4:  BRA     27A6
027A6:  MOV     #14,W5
027A8:  REPEAT  #4
027AA:  MOV     [--W15],[W5--]
027AC:  MOV     [--W15],W5
027AE:  RETURN  
027B0:  MOV     W5,[W15++]
027B2:  MOV     #C,W5
027B4:  REPEAT  #4
027B6:  MOV     [W5++],[W15++]
027B8:  MOV     W0,W4
027BA:  MOV     W1,W5
027BC:  MOV     W3,W7
027BE:  MOV     W2,W6
027C0:  BCLR.B  42.0
027C2:  BCLR.B  42.1
027C4:  RLC     W1,W1
027C6:  SWAP    W1
027C8:  AND     #FF,W1
027CA:  CP0     W1
027CC:  BRA     Z,2864
027CE:  BCLR.B  42.0
027D0:  BCLR.B  42.1
027D2:  RLC     W3,W3
027D4:  SWAP    W3
027D6:  AND     #FF,W3
027D8:  CP0     W3
027DA:  BRA     Z,2864
027DC:  ZE      W0,W0
027DE:  ADD.B   W3L,W1L,W0L
027E0:  BRA     C,27EA
027E2:  SUB     #7F,W0
027E4:  BRA     Z,2864
027E6:  BRA     NC,2864
027E8:  BRA     27EE
027EA:  ADD.B   #81,W0L
027EC:  BRA     C,2864
027EE:  XOR     W5,W7,W10
027F0:  BCLR.B  42.0
027F2:  BCLR.B  42.1
027F4:  AND     #FF,W5
027F6:  BSET    W5.7
027F8:  BCLR.B  42.0
027FA:  AND     #FF,W7
027FC:  BSET    W7.7
027FE:  MUL.UU  W4,W6,W2
02800:  MUL.UU  W5,W6,W8
02802:  ADDC    W8,W3,W3
02804:  MOV     W9,W1
02806:  BTSC.B  42.0
02808:  INC     W1,W1
0280A:  BCLR.B  42.0
0280C:  MUL.UU  W7,W4,W8
0280E:  ADDC    W8,W3,W3
02810:  ADDC    W9,W1,W1
02812:  MUL.UU  W5,W7,W8
02814:  ADDC    W8,W1,W1
02816:  INC     W0,W0
02818:  CP0     W1
0281A:  BTSC.B  42.1
0281C:  BRA     2820
0281E:  BRA     2826
02820:  CP0     W3
02822:  BTSC.B  42.1
02824:  BRA     2830
02826:  BTSC    W1.F
02828:  BRA     2830
0282A:  RLC     W3,W3
0282C:  RLC     W1,W1
0282E:  DEC     W0,W0
02830:  MOV     W1,W2
02832:  BCLR.B  42.0
02834:  BTSS    W3.7
02836:  BRA     284A
02838:  MOV     #FF00,W7
0283A:  AND     W3,W7,W3
0283C:  ADD     #100,W3
0283E:  ADDC    W2,#0,W2
02840:  CP0     W2
02842:  BRA     NZ,284A
02844:  CP0     W3
02846:  BRA     NZ,284A
02848:  INC     W0,W0
0284A:  SWAP    W0
0284C:  BCLR.B  42.0
0284E:  BCLR.B  42.1
02850:  RRC     W0,W1
02852:  BTSC    W10.F
02854:  BSET    W1.F
02856:  BCLR    W2.F
02858:  SWAP    W2
0285A:  XOR.B   W2L,W1L,W1L
0285C:  SWAP    W3
0285E:  MOV.B   W3L,W2L
02860:  MOV     W2,W0
02862:  BRA     286A
02864:  MOV     #0,W0
02866:  MOV     #0,W1
02868:  BRA     286A
0286A:  MOV     #14,W5
0286C:  REPEAT  #4
0286E:  MOV     [--W15],[W5--]
02870:  MOV     [--W15],W5
02872:  RETURN  
02874:  MOV     W5,[W15++]
02876:  MOV     #C,W5
02878:  REPEAT  #3
0287A:  MOV     [W5++],[W15++]
0287C:  CLR     W9
0287E:  MOV     #8000,W8
02880:  BTSC.B  43.0
02882:  XOR     W8,W3,W3
02884:  CP0     W0
02886:  BRA     NZ,288E
02888:  MOV     #7FFF,W10
0288A:  AND     W1,W10,W10
0288C:  BTSS.B  42.1
0288E:  MOV     W1,W10
02890:  XOR     W3,W10,W11
02892:  MOV     W1,W6
02894:  MOV     W3,W7
02896:  MOV     W3,W12
02898:  BCLR.B  42.1
0289A:  BCLR.B  42.0
0289C:  RLC     W6,W6
0289E:  SWAP    W6
028A0:  AND     #FF,W6
028A2:  CP0     W6
028A4:  BRA     Z,29E8
028A6:  BCLR.B  42.1
028A8:  BCLR.B  42.0
028AA:  RLC     W7,W7
028AC:  SWAP    W7
028AE:  AND     #FF,W7
028B0:  CP0     W7
028B2:  BRA     Z,29F2
028B4:  BCLR.B  42.1
028B6:  BCLR.B  42.0
028B8:  CP      W7,W6
028BA:  BRA     Z,29F4
028BC:  BRA     N,2A04
028BE:  BCLR    W9.0
028C0:  BSET    W9.1
028C2:  SUB     W7,W6,W8
028C4:  MOV     W7,W6
028C6:  AND     #FF,W1
028C8:  BSET    W1.7
028CA:  AND     #FF,W3
028CC:  BSET    W3.7
028CE:  MOV     #28,W7
028D0:  CP      W7,W8
028D2:  BRA     N,28F6
028D4:  BCLR.B  42.1
028D6:  BCLR.B  42.0
028D8:  RRC     W1,W1
028DA:  RRC     W0,W0
028DC:  DEC     W8,W8
028DE:  BRA     NZ,28D4
028E0:  BRA     28FC
028E2:  MOV     #28,W7
028E4:  CP      W7,W8
028E6:  BRA     N,28FA
028E8:  BCLR.B  42.1
028EA:  BCLR.B  42.0
028EC:  RRC     W3,W3
028EE:  RRC     W2,W2
028F0:  DEC     W8,W8
028F2:  BRA     NZ,28E8
028F4:  BRA     2914
028F6:  MOV     W2,W0
028F8:  MOV     W3,W1
028FA:  BRA     2982
028FC:  BTSS    W11.F
028FE:  BRA     2922
02900:  BTSC    W9.4
02902:  MOV     W12,W11
02904:  NEG     W0,W0
02906:  BRA     Z,290C
02908:  COM.B   W1L,W1L
0290A:  BRA     290E
0290C:  NEG     W1,W1
0290E:  BTSC    W9.4
02910:  BRA     2968
02912:  BRA     2922
02914:  BTSS    W11.F
02916:  BRA     2922
02918:  NEG     W2,W2
0291A:  BRA     Z,2920
0291C:  COM.B   W3L,W3L
0291E:  BRA     2922
02920:  NEG     W3,W3
02922:  AND     #FF,W5
02924:  BCLR.B  42.1
02926:  BCLR.B  42.0
02928:  ADD     W0,W2,W0
0292A:  ADDC.B  W1L,W3L,W1L
0292C:  BTSC.B  42.0
0292E:  BSET    W9.3
02930:  BTSC    W9.0
02932:  BRA     2946
02934:  BTSC    W9.1
02936:  BRA     293A
02938:  BRA     2950
0293A:  BTSC    W11.F
0293C:  BRA     2968
0293E:  BTSC    W9.3
02940:  BRA     2994
02942:  BSET    W9.6
02944:  BRA     2982
02946:  BTSC    W11.F
02948:  BRA     2968
0294A:  BTSC    W9.3
0294C:  BRA     2994
0294E:  BRA     2982
02950:  BCLR    W9.2
02952:  BTSC    W11.F
02954:  BRA     295E
02956:  MOV     W10,W11
02958:  BTSC    W9.3
0295A:  BRA     2994
0295C:  BRA     29CA
0295E:  BSET    W9.4
02960:  XOR.B   #80,W1L
02962:  BTSC    W1.7
02964:  BRA     2900
02966:  MOV     W10,W11
02968:  AND     #FF,W1
0296A:  IOR      W0,  W1,W7
0296C:  BRA     Z,2982
0296E:  BTSC    W1.7
02970:  BRA     2982
02972:  BCLR.B  42.1
02974:  BCLR.B  42.0
02976:  RLC     W0,W0
02978:  RLC     W1,W1
0297A:  DEC     W6,W6
0297C:  BTSC.B  42.1
0297E:  BRA     29E2
02980:  BRA     296E
02982:  BTSC    W9.0
02984:  MOV     W10,W11
02986:  BTSC    W9.1
02988:  MOV     W12,W11
0298A:  BTSS    W9.5
0298C:  BRA     29C2
0298E:  BTSC    W10.F
02990:  BSET    W0.8
02992:  BRA     29CA
02994:  BSET.B  42.0
02996:  RRC.B   W1L,W1L
02998:  RRC     W0,W0
0299A:  BTSC.B  42.0
0299C:  BSET    W9.5
0299E:  INC     W6,W6
029A0:  BRA     Z,29E2
029A2:  BTSS    W9.5
029A4:  BRA     29B6
029A6:  INC     W0,W0
029A8:  BRA     NZ,29B6
029AA:  INC.B   W1L,W1L
029AC:  BRA     NZ,29B6
029AE:  RRC.B   W1L,W1L
029B0:  RRC     W0,W0
029B2:  INC     W6,W6
029B4:  BRA     Z,29E2
029B6:  BTSC    W9.0
029B8:  MOV     W10,W11
029BA:  BTSC    W9.1
029BC:  MOV     W12,W11
029BE:  BTSC.B  42.1
029C0:  BRA     29E2
029C2:  BTSC    W9.6
029C4:  MOV     W10,W11
029C6:  BTSC    W9.7
029C8:  MOV     W12,W11
029CA:  IOR      W0,  W1,W2
029CC:  BRA     Z,2A14
029CE:  BCLR    W1.7
029D0:  SWAP    W6
029D2:  BCLR.B  42.1
029D4:  BCLR.B  42.0
029D6:  RRC     W6,W6
029D8:  XOR     W6,W1,W1
029DA:  BSET    W1.F
029DC:  BTSS    W11.F
029DE:  BCLR    W1.F
029E0:  BRA     2A14
029E2:  MOV     #0,W0
029E4:  MOV     #0,W1
029E6:  BRA     2A14
029E8:  BTSC    W10.F
029EA:  XOR     W8,W3,W3
029EC:  MOV     W2,W0
029EE:  MOV     W3,W1
029F0:  BRA     2A14
029F2:  BRA     2A14
029F4:  AND     #FF,W3
029F6:  BSET    W3.7
029F8:  AND     #FF,W1
029FA:  BSET    W1.7
029FC:  BTSC    W11.F
029FE:  BCLR    W3.7
02A00:  BSET    W9.2
02A02:  BRA     2914
02A04:  SUB     W6,W7,W8
02A06:  AND     #FF,W1
02A08:  BSET    W1.7
02A0A:  AND     #FF,W3
02A0C:  BSET    W3.7
02A0E:  BCLR    W9.1
02A10:  BSET    W9.0
02A12:  BRA     28E2
02A14:  MOV     #12,W5
02A16:  REPEAT  #3
02A18:  MOV     [--W15],[W5--]
02A1A:  MOV     [--W15],W5
02A1C:  RETURN  
02A1E:  MOV     W0,W2
02A20:  MOV     W1,W3
02A22:  MOV.B   W1L,W0L
02A24:  SWAP    W0
02A26:  BSET    W0.F
02A28:  RLC     W1,W1
02A2A:  SWAP    W1
02A2C:  ZE      W1,W1
02A2E:  MOV     #8E,W4
02A30:  SUB.B   W4L,W1L,W1L
02A32:  BRA     Z,2A40
02A34:  CP0     W0
02A36:  BRA     Z,2A40
02A38:  BCLR.B  42.0
02A3A:  RRC     W0,W0
02A3C:  DEC     W1,W1
02A3E:  BRA     NZ,2A34
02A40:  BTSS    W3.F
02A42:  BRA     2A48
02A44:  NEG     W0,W0
02A46:  BRA     2A48
02A48:  RETURN  
02A4A:  MOV     W5,[W15++]
02A4C:  MOV     #C,W5
02A4E:  REPEAT  #3
02A50:  MOV     [W5++],[W15++]
02A52:  MUL.UU  W0,W2,W4
02A54:  BTSS    W3.F
02A56:  BRA     2A5C
02A58:  MUL.SS  W0,W3,W6
02A5A:  BRA     2A5E
02A5C:  MUL.UU  W0,W3,W6
02A5E:  BCLR.B  42.0
02A60:  ADD     W6,W5,W5
02A62:  ADDC    W7,#0,W8
02A64:  BTSS    W1.F
02A66:  BRA     2A6C
02A68:  MUL.SS  W1,W2,W6
02A6A:  BRA     2A6E
02A6C:  MUL.UU  W1,W2,W6
02A6E:  ADDC    W6,W5,W5
02A70:  ADDC    W7,W8,W8
02A72:  ADDC    #0,W9
02A74:  MUL.SS  W1,W3,W6
02A76:  ADDC    W6,W8,W8
02A78:  ADDC    W9,W7,W7
02A7A:  MOV     W7,W3
02A7C:  MOV     W8,W2
02A7E:  MOV     W5,W1
02A80:  MOV     W4,W0
02A82:  MOV     #12,W5
02A84:  REPEAT  #3
02A86:  MOV     [--W15],[W5--]
02A88:  MOV     [--W15],W5
02A8A:  RETURN  
02A8C:  MOV     W5,[W15++]
02A8E:  MOV     #C,W5
02A90:  REPEAT  #3
02A92:  MOV     [W5++],[W15++]
02A94:  MOV     #0,W9
02A96:  BTSC.B  43.0
02A98:  MOV     #1,W9
02A9A:  MOV     W9,[W15++]
02A9C:  XOR     W1,W3,W9
02A9E:  BTSS    W1.F
02AA0:  BRA     2AA8
02AA2:  COM     W1,W1
02AA4:  NEG     W0,W0
02AA6:  ADDC    W1,#0,W1
02AA8:  BTSS    W3.F
02AAA:  BRA     2AB2
02AAC:  COM     W3,W3
02AAE:  NEG     W2,W2
02AB0:  ADDC    W3,#0,W3
02AB2:  XOR     W2,W3,W4
02AB4:  BRA     Z,2AE0
02AB6:  CLR     W4
02AB8:  CLR     W5
02ABA:  CLR     W6
02ABC:  CLR     W7
02ABE:  MOV     #20,W8
02AC0:  BCLR.B  42.0
02AC2:  RLC     W0,W0
02AC4:  RLC     W1,W1
02AC6:  RLC     W4,W4
02AC8:  RLC     W5,W5
02ACA:  CP      W5,W3
02ACC:  BRA     NZ,2AD0
02ACE:  CPB     W4,W2
02AD0:  BRA     NC,2AD8
02AD2:  SUB     W4,W2,W4
02AD4:  SUBB    W5,W3,W5
02AD6:  BSET.B  42.0
02AD8:  RLC     W6,W6
02ADA:  RLC     W7,W7
02ADC:  DEC     W8,W8
02ADE:  BRA     NZ,2AC0
02AE0:  BTSS    W9.F
02AE2:  BRA     2AF2
02AE4:  NEG     W6,W0
02AE6:  BRA     Z,2AEA
02AE8:  BRA     NZ,2AEE
02AEA:  NEG     W7,W1
02AEC:  BRA     2AF8
02AEE:  COM     W7,W1
02AF0:  BRA     2AF8
02AF2:  MOV     W7,W1
02AF4:  MOV     W6,W0
02AF6:  BRA     2AF8
02AF8:  MOV     [--W15],W9
02AFA:  CP0     W9
02AFC:  BRA     Z,2B00
02AFE:  MOV.D   W4,W0
02B00:  MOV     #12,W5
02B02:  REPEAT  #3
02B04:  MOV     [--W15],[W5--]
02B06:  MOV     [--W15],W5
02B08:  RETURN  
*
02CD2:  MOV     W5,[W15++]
02CD4:  MOV     #C,W5
02CD6:  REPEAT  #3
02CD8:  MOV     [W5++],[W15++]
02CDA:  BTSS    W0.F
02CDC:  BRA     2CF6
02CDE:  NEG     W0,W0
02CE0:  BSET    W4.8
02CE2:  BTSS    W4.F
02CE4:  BRA     2CF6
02CE6:  MOV     W0,[W15++]
02CE8:  MOV     #2D,W0
02CEA:  BTSC.B  219.1
02CEC:  BRA     2CEA
02CEE:  MOV.B   W0L,21A
02CF0:  MOV     [--W15],W0
02CF2:  BCLR    W4.8
02CF4:  DEC.B   0008
02CF6:  CLR     W5
02CF8:  MOV     W0,W7
02CFA:  MOV     W4,W9
02CFC:  BCLR    W4.F
02CFE:  CP0.B   W4L
02D00:  BRA     NZ,2D0E
02D02:  BTSC    W9.F
02D04:  BRA     2D0A
02D06:  MOV     #0,W5
02D08:  BRA     2D28
02D0A:  MOV     #0,W5
02D0C:  BRA     2D28
02D0E:  SUB.B   W4L,#6,W5L
02D10:  BRA     NC,2D26
02D12:  MOV     #30,W0
02D14:  BTSS    W9.F
02D16:  MOV     #20,W0
02D18:  BTSC.B  219.1
02D1A:  BRA     2D18
02D1C:  MOV.B   W0L,21A
02D1E:  DEC     W5,W5
02D20:  BRA     NN,2D18
02D22:  MOV     #5,W5
02D24:  BRA     2D28
02D26:  MOV     W4,W5
02D28:  MOV     #6,W4
02D2A:  BTSC    W5.8
02D2C:  INC     W4,W4
02D2E:  BSET    W5.E
02D30:  BTSC    W9.F
02D32:  BSET    W5.F
02D34:  MOV     #2710,W8
02D36:  REPEAT  #11
02D38:  DIV.U   W7,W8
02D3A:  CALL    2D7E
02D3E:  MOV     W1,W7
02D40:  MOV     #3E8,W8
02D42:  REPEAT  #11
02D44:  DIV.U   W7,W8
02D46:  CALL    2D7E
02D4A:  MOV     W1,W7
02D4C:  MOV     #64,W8
02D4E:  REPEAT  #11
02D50:  DIV.U   W7,W8
02D52:  CALL    2D7E
02D56:  MOV     W1,W7
02D58:  MOV     #A,W8
02D5A:  REPEAT  #11
02D5C:  DIV.U   W7,W8
02D5E:  CALL    2D7E
02D62:  BTSS    W9.8
02D64:  BRA     2D70
02D66:  MOV     #2D,W0
02D68:  BTSC.B  219.1
02D6A:  BRA     2D68
02D6C:  MOV.B   W0L,21A
02D6E:  BCLR    W9.8
02D70:  MOV     #30,W0
02D72:  ADD.B   W1L,W0L,W0L
02D74:  MOV     W0,2A
02D76:  BTSC.B  219.1
02D78:  BRA     2D76
02D7A:  MOV.B   W0L,21A
02D7C:  BRA     2DBE
02D7E:  MOV     #30,W6
02D80:  CP0     W0
02D82:  BRA     NZ,2DA0
02D84:  BTSS    W5.E
02D86:  BRA     2DB4
02D88:  DEC     W4,W4
02D8A:  CP.B    W4L,W5L
02D8C:  BRA     Z,2D92
02D8E:  BTSC.B  42.0
02D90:  RETURN  
02D92:  CP0     W0
02D94:  BRA     NZ,2DA0
02D96:  BTSS    W5.E
02D98:  BRA     2DB4
02D9A:  BTSS    W5.F
02D9C:  MOV     #20,W6
02D9E:  BRA     2DB4
02DA0:  BCLR    W5.E
02DA2:  BTSS    W9.8
02DA4:  BRA     2DB4
02DA6:  MOV     W0,W10
02DA8:  MOV     #2D,W0
02DAA:  BTSC.B  219.1
02DAC:  BRA     2DAA
02DAE:  MOV.B   W0L,21A
02DB0:  BCLR    W9.8
02DB2:  MOV     W10,W0
02DB4:  ADD.B   W6L,W0L,W0L
02DB6:  BTSC.B  219.1
02DB8:  BRA     2DB6
02DBA:  MOV.B   W0L,21A
02DBC:  RETURN  
02DBE:  MOV     #12,W5
02DC0:  REPEAT  #3
02DC2:  MOV     [--W15],[W5--]
02DC4:  MOV     [--W15],W5
02DC6:  RETURN  
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10                                                    // Configures the read_adc return size as 10 bit 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                                                      // No Watch Dog Timer  
.................... #FUSES FRC                                                        // Internal Fast RC Oscillator 
.................... #FUSES NOCKSFSM                                                   // Clock Switching is disabled, fail Safe clock monitor is disabled  
.................... #FUSES NOBROWNOUT                                                 // Not reset when brownout detected  
.................... #FUSES PROTECT                                                    // Code is protected from reading  
.................... #FUSES NOWRT                                                      // Program memory not write protected  
.................... #FUSES NODEBUG                                                    // No Debug mode for ICD 
....................  
.................... #USE DELAY(clock=7370000)                                         // delay() func. adjusted for internal osc clock speed. 
*
01586:  CP0     W0
01588:  BTSC.B  42.1
0158A:  BRA     1594
0158C:  REPEAT  #72D
0158E:  NOP     
01590:  DEC     W0,W0
01592:  BRA     NZ,158C
01594:  RETURN  
*
021E4:  LSR     W0,#1,W0
021E6:  CP0     W0
021E8:  BTSC.B  42.1
021EA:  BRA     21F2
021EC:  NOP     
021EE:  DEC     W0,W0
021F0:  BRA     NZ,21EC
021F2:  RETURN  
.................... #USE RS232(stream=RS232,UART2,baud=38400,parity=N,bits=8,stop=1)  // Set UART2 as RS232 stream 
.................... //Register for Reset Info 
.................... #WORD RCON                 = 0x740           //Reset control register 
.................... #BIT RCON_POR              = RCON.0          //POR 
.................... #BIT RCON_BOR              = RCON.1          //BOR 
.................... #BIT RCON_IDLE             = RCON.2 
.................... #BIT RCON_SLEEP            = RCON.3 
.................... #BIT RCON_WDTO             = RCON.4 
.................... #BIT RCON_SWDTEN           = RCON.5 
.................... #BIT RCON_SWR              = RCON.6 
.................... #BIT RCON_EXTR             = RCON.7         //MCLR Reset during normal operation 
.................... #BIT RCON_BGST             = RCON.13 
.................... #BIT RCON_IOPUWR           = RCON.14 
.................... #BIT RCON_TRAPR            = RCON.15 
....................  
.................... // Registers of quadrature encoder interface module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD QEI_QEICON        = 0x122           // Control and status register QEICON allows control of the QEI operation and status flags indicating the module state. 
.................... #WORD QEI_DFLTCON       = 0x124           // Digital filter control register DFLTCON allows control of the digital input filter operation. 
.................... #WORD QEI_POSCNT        = 0x126           // Position count register POSCNT allows reading and writing of the 16-bit position counter. 
.................... #WORD QEI_MAXCNT        = 0x128           // Maximum count register MAXCNT holds a value that will be compared to the POSCNT counter in some operations. 
.................... // Bits of the QEICON register 
.................... #BIT QEI_QEICON_CNTERR  = QEI_QEICON.15   // Count error status flag bit 
.................... #BIT QEI_QEICON_QEISIDL = QEI_QEICON.13   // Stop in idle mode bit 
.................... #BIT QEI_QEICON_INDEX   = QEI_QEICON.12   // Index pin state status bit (read only) 
.................... #BIT QEI_QEICON_UPDN    = QEI_QEICON.11   // Position counter direction status bit (read only) 
.................... #BIT QEI_QEICON_QEIM2   = QEI_QEICON.10   // Quadrature encoder interface mode select bits 
.................... #BIT QEI_QEICON_QEIM1   = QEI_QEICON.9 
.................... #BIT QEI_QEICON_QEIM0   = QEI_QEICON.8 
.................... #BIT QEI_QEICON_SWPAB   = QEI_QEICON.7    // Phase A and phase B input swap select bit  
.................... #BIT QEI_QEICON_PCDOUT  = QEI_QEICON.6    // Position counter direction state output rnable bit 
.................... #BIT QEI_QEICON_TQGATE  = QEI_QEICON.5    // Timer gated time accumulation rnable bit 
.................... #BIT QEI_QEICON_TQCKPS1 = QEI_QEICON.4    // Timer input clock prescale select bits 
.................... #BIT QEI_QEICON_TQCKPS0 = QEI_QEICON.3 
.................... #BIT QEI_QEICON_POSRES  = QEI_QEICON.2    // Position counter reset enable bit 
.................... #BIT QEI_QEICON_TQCS    = QEI_QEICON.1    // Timer clock source select bit 
.................... #BIT QEI_QEICON_UDSRC   = QEI_QEICON.0    // Position counter direction selection control bit 
.................... // Bits of the DFLTCON register 
.................... #BIT QEI_DFLTCON_IMV1   = QEI_DFLTCON.10  // Index match value bits 
.................... #BIT QEI_DFLTCON_IMV0   = QEI_DFLTCON.9   // These bits allow the user to specify the state of the QEA and QEB input pins during an Index pulse when the POSCNT register is to be reset. 
.................... #BIT QEI_DFLTCON_CEID   = QEI_DFLTCON.8   // Count error interrupt disable bit 
.................... #BIT QEI_DFLTCON_QEOUT  = QEI_DFLTCON.7   // QEA/QEB/IND digital filter output enable bit  
.................... #BIT QEI_DFLTCON_QECK2  = QEI_DFLTCON.6   // QEA/QEB/IND digital filter clock divide select bits 
.................... #BIT QEI_DFLTCON_QECK1  = QEI_DFLTCON.5      
.................... #BIT QEI_DFLTCON_QECK0  = QEI_DFLTCON.4 
....................  
.................... // Registers of the motor control PWM module 
.................... // Refer to Microchip dsPIC30f Family Reference Manual for detailed information 
.................... #WORD PWM_PTCON         = 0x1C0           // PWM Time base control register 
.................... #WORD PWM_PTPER         = 0x1C4           // PWM Time base period register 
.................... #WORD PWM_PWMCON1       = 0x1C8           // PWM Control register #1 
.................... #WORD PWM_PWMCON2       = 0x1CA           // PWM Control register #2 
.................... #WORD PWM_PDC4          = 0x1DC           // PWM Duty cycle register #4 
.................... #WORD PWM_IEC2          = 0x090           // PWM Interrupt Enable Control Register 
.................... #WORD PWM_IFS2          = 0x088           // PWM Interrupt Flag Status Register 
.................... // Bits of the PTCON register 
.................... #BIT PWM_PTCON_PTEN     = PWM_PTCON.15    // PWM Time base timer enable bit 
.................... #BIT PWM_PTCON_PTOPS3   = PWM_PTCON.7     // PWM Time base output postscale select bits  
.................... #BIT PWM_PTCON_PTOPS2   = PWM_PTCON.6 
.................... #BIT PWM_PTCON_PTOPS1   = PWM_PTCON.5 
.................... #BIT PWM_PTCON_PTOPS0   = PWM_PTCON.4 
.................... #BIT PWM_PTCON_PTCKPS1  = PWM_PTCON.3     // PWM Time base input clock prescale select bits 
.................... #BIT PWM_PTCON_PTCKPS0  = PWM_PTCON.2     
.................... #BIT PWM_PTCON_PTMOD1   = PWM_PTCON.1     // PWM Time base mode select bits 
.................... #BIT PWM_PTCON_PTMOD0   = PWM_PTCON.0 
.................... // Bits of the PWMCON1 register 
.................... #BIT PWM_PWMCON1_PMOD4  = PWM_PWMCON1.11  // PWM4 I/O pin pair mode bit 
.................... #BIT PWM_PWMCON1_PEN4L  = PWM_PWMCON1.3   // PWM4L I/O pin enable bit 
.................... // Bits of the PWMCON2 register   
.................... #BIT PWM_PWMCON2_IUE    = PWM_PWMCON2.2   // Immediate update enable bit 
.................... #BIT PWM_PWMCON2_OSYNC  = PWM_PWMCON2.1   // Output override synchronization bit 
.................... #BIT PWM_PWMCON2_UDIS   = PWM_PWMCON2.0   // PWM update disable bit 
.................... // Bits of the IEC2 register 
.................... #BIT PWM_IEC2_PWMIE     = PWM_IEC2.7      // PWM Interrupt enable bit  
.................... // Bits of the IFS2 register 
.................... #BIT PWM_IFS2_PWMIF     = PWM_IFS2.7      // PWM Interrupt flag status bit     
....................  
.................... // Registers of the UART1 module 
.................... #WORD UART_IFS0          = 0x088          // UART Interrupt Flag Status Register 
.................... // Bits of the IFS0 register 
.................... #BIT UART_IFS0_U1RXIF    = UART_IFS0.9    // UART Receiver Interrupt flag status bit   
.................... #BIT UART_IFS0_U1TXIF    = UART_IFS0.10   // UART Transmiter Interrupt flag status bit   
....................  
.................... // Led pins 
.................... #DEFINE LED          PIN_B0               // Led used in debugging 
....................  
.................... // Laser pins 
.................... #DEFINE LAS_1        PIN_G6               // Control pin of the first laser 
.................... #DEFINE LAS_2        PIN_G7               // Control pin of the second laser 
.................... #DEFINE LAS_3        PIN_G8               // Control pin of the third laser 
....................  
.................... //Parallel Port Pin Assignments 
.................... #DEFINE PP_D0        PIN_D3               // Parallel port data pin first bit 
.................... #DEFINE PP_D1        PIN_D2               // Parallel port data pin second bit 
.................... #DEFINE PP_D2        PIN_D1               // Parallel port data pin third bit 
.................... #DEFINE PP_D3        PIN_C14              // Parallel port data pin fourth bit 
.................... #DEFINE PP_D4        PIN_C13              // Parallel port data pin fifth bit 
.................... #DEFINE PP_D5        PIN_D0               // Parallel port data pin sixth bit 
.................... #DEFINE PP_D6        PIN_D11              // Parallel port data pin seventh bit 
.................... #DEFINE PP_D7        PIN_D10              // Parallel port data pin eigth bit 
.................... #DEFINE PP_STR       PIN_D9               // Parallel port strobe pin 
.................... #DEFINE PP_ACK       PIN_D4               // Parallel port acknowledge pin used to  
.................... #DEFINE PP_RDY       PIN_D5               // Parallel port ready pin 
....................  
.................... // Pins used to control digital potentiometer 
.................... #DEFINE DP_CS        PIN_E0               // Digital potentiometer chip select pin assignment (active low) 
.................... #DEFINE DP_UD        PIN_F1               // Digital potentiometer up/down control pin assignment 
....................  
.................... // Pins used to control motor driver 
.................... #DEFINE MD_MS        PIN_E5               // Step resolution select pin assignment 
.................... #DEFINE MD_RESET     PIN_E7               // Reset input pin assignment (active low) 
.................... #DEFINE MD_STEP      PIN_E6               // Step input pin assignment 
.................... #DEFINE MD_ENABLE    PIN_D6               // Enable input pin assignment (active low) 
.................... #DEFINE MD_SLEEP     PIN_D7               // Sleep input pin assignment (active low) 
.................... #DEFINE MD_DIR       PIN_F0               // Direction input pin assignment 
....................  
.................... // Pins used for switches 
.................... #DEFINE MD_SW        PIN_G9               // Homing switch input pin assignment 
.................... #DEFINE MD_LIM       PIN_D8               // Limit switch input pin assignment 
....................  
.................... // Pins used to control FRAM 
.................... #DEFINE FR_CS        PIN_B2               // FRAM chip select pin assignment (active low) 
.................... #DEFINE FR_WP        PIN_G3               // FRAM write protection pin assignment (active low) 
.................... #DEFINE FR_SCK       PIN_F6               // FRAM serial clock pin assignment 
.................... #DEFINE FR_SI        PIN_F2               // FRAM serial input pin assignment 
.................... #DEFINE FR_SO        PIN_F3               // FRAM serial output pin assignment 
....................  
.................... // Speed ramp states 
.................... #DEFINE HOME         0 
.................... #DEFINE ACCEL        1 
.................... #DEFINE DECEL        2 
.................... #DEFINE RUN          3 
.................... #DEFINE POS          4 
.................... #DEFINE LIMIT        5 
....................  
.................... // PWM module operating modes 
.................... #DEFINE FREE         0 
.................... #DEFINE SINGLE       1 
....................  
.................... int1           debug_mode_dp     = 0;              // Debug state of digital potentiometer 
.................... int1           debug_mode_pp     = 0;              // Debug state of parallel port communication 
.................... int1           debug_mode_fr     = 0;              // Debug state of FRAM 
.................... int1           debug_mode_md     = 0;              // Debug state of motor driver 
.................... int1           debug_mode_pwm    = 0;              // Debug state of motor control PWM module 
.................... int1           debug_mode_qei    = 0;              // Debug state of quadrature encoder 
....................  
.................... unsigned int   dp_tap_limit      = 32;             // Digital potentiometer maximum tap level 
.................... unsigned int   dp_voltage_limit  = 1023;           // Digital potentiometer maximum voltage level 
....................  
.................... unsigned int   mt_voltage_limit  = 803;            // Motor torque control voltage is limited to 4V (which is defined in driver specs) 
.................... unsigned int   mt_percent_trip   = 56;             // Motor torque percent while system is moving 
.................... unsigned int   mt_percent_rest   = 28;             // Motor torque percent while system is stationary 
....................  
.................... unsigned int   md_conv_const     = 0;              // Constant used to convert encoder count to motor step 
.................... unsigned int   md_move_range     = 400;            // Movement range of the device 
.................... unsigned int   md_home_pos       = 45;             // Sets the number of encoder counts between the home position and homing switch position 
.................... unsigned int   md_end_pos        = 1000;           // Sets the number of encoder counts between the home position and the end of movement range 
.................... unsigned int   md_end_offset     = 50;             // Offset of the maximum count number from the end position 
.................... unsigned int   md_home_offset    = 100;            // Offset of the maximum count number from the home position 
.................... unsigned int   md_min_distance   = 70;             // Minimum distance between symmetricaly moving lasers 
.................... unsigned int   md_target_count   = 0;              // Target position count 
....................  
.................... unsigned int   md_accel          = 3000;           // Acceleration of the motor (0.01 mm/s2) 
.................... unsigned int   md_decel          = 3000;           // Deceleration of the motor (0.01 mm/s2) 
....................  
.................... unsigned int   md_min_delay      = 100;            // Minimum time delay (max speed) 
.................... unsigned char  md_run_state      = 0;              // What part of the speed ramp we are in. 
.................... unsigned int   md_decel_lim      = 0;              // What step_pos to start decelaration 
.................... unsigned int   md_accel_lim      = 0;              // What step_pos to end accelaration 
.................... unsigned int   md_decel_count    = 0;              // Counter used when decelerateing to calculate step_delay. 
.................... unsigned int   md_pos_iter       = 0;              // Number of iterations performed during positioning 
.................... int            md_error          = 0;              // Positioning error 
.................... unsigned int   md_backlash       = 0;              // Backlash of the positioning system 
....................  
.................... unsigned int   md_cc_step        = 0;              // Motor count used in conversion constant conversion 
.................... unsigned int   md_cc_count       = 0;              // Encoder count used in conversion constant conversion 
.................... unsigned int   md_lim_disp       = 500;            // The displacement (in counts) required to move away from the limit switch 
....................  
.................... unsigned int   fr_serial_no      = 0;              // External adress of product serial no 
.................... unsigned int   fr_move_range     = 13;             // External adress of movement range 
.................... unsigned int   fr_home_pos       = 15;             // External adress of home position 
.................... unsigned int   fr_end_pos        = 17;             // External addres of end position 
.................... unsigned int   fr_conv_const     = 19;             // External adress of conversion constant 
.................... unsigned int   fr_backlash       = 21;             // External adress of backlash compensation 
.................... unsigned int   fr_comm_type      = 23;             // External adress of communication type 
.................... unsigned int   fr_last_pos       = 24;             // External adress of last position 
.................... unsigned int   fr_pos_table      = 26;             // External adress of position table 
....................  
.................... unsigned int   pp_str_check      = 1000;           // Parallel port strobe signal filter iteration number 
.................... unsigned int   pp_str_delay      = 1;              // Parallel port strobe signal filter pause time (us) 
.................... unsigned int   pp_ack_delay      = 10;              // Parallel port acknowledge signal pause time (ms) 
.................... unsigned int   pp_rdy_delay      = 10;             // Parallel port ready signal pause time (ms) 
....................  
.................... int1           reg_comm_type     = 0;              // Communication type register 
.................... int1           reg_pp_stop       = 0;              // Parallel port emergency stop signal register 
.................... int1           reg_md_home       = 0;              // Homing action register 
.................... int1           reg_md_home_return= 0;              // Home correction return register 
.................... int1           reg_rs232_message = 0;              // RS232 message flag 
.................... int1           reg_md_cc_sample  = 0;              // Special case register for conversion constant calculation 
.................... int1           reg_md_limit      = 0;              // Limit switch interrupt register 
....................  
.................... #DEFINE ACC_15 
....................  
.................... #IFDEF ACC_10 
.................... unsigned int   md_max_acc_lim    = 116;             // Number of steps before we hit max speed. acc=10000 dec=10000  
.................... unsigned int const delays[116]={2449,1015,779,656,578,523,481,447,420,397,378,361,346,333,322,311,302,293,285,277,271,264,258,253,247,243,238,234,229,226,222,218,215,212,209,206,203,200,197,195,192,190,188,186,184,182,180, 
.................... 178,176,174,172,171,169,167,166,164,163,162,160,159,157,156,155,154,152,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115, 
.................... 114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_15 
.................... unsigned int   md_max_acc_lim    = 88;             // Number of steps before we hit max speed. acc=15000 dec=15000 
.................... unsigned int const delays[88]={2000,828,636,536,472,427,393,365,343,325,309,295,283,272,263,254,246,239,233,226,221,216,211,206,202,198,194,191,187,184,181,178,175,173,170,168,166,163,161,159,157,155,153,152,150,148,147, 
.................... 145,144,142,141,139,138,137,135,134,133,132,131,130,129,128,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_20 
.................... unsigned int   md_max_acc_lim    = 71;             // Number of steps before we hit max speed. acc=20000 dec=20000  
.................... unsigned int const delays[71]={1732,717,551,464,409,370,340,316,297,281,267,255,245,236,227,220,213,207,201,196,191,187,183,179,175,172,168,165,162,159,157,154,152,150,147,145,143,141,140,138,136,134,133,131,130,128,127, 
.................... 126,124,123,122,121,120,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_25 
.................... unsigned int   md_max_acc_lim    = 59;             // Number of steps before we hit max speed. acc=25000 dec=25000  
.................... unsigned int const delays[59]={1549,642,492,415,366,331,304,283,266,251,239,228,219,211,203,197,191,185,180,175,171,167,163,160,157,153,150,148,145,143,140,138,136,134,132,130,128,126,125,123,122,120,119,117,116,115,114, 
.................... 112,111,110,109,108,107,106,105,104,103,102,101}; 
.................... #ENDIF 
....................  
.................... #IFDEF ACC_30 
.................... unsigned int   md_max_acc_lim    = 50;             // Number of steps before we hit max speed. acc=30000 dec=30000  
.................... unsigned int const delays[50]={1414,586,449,379,334,302,278,258,243,229,218,209,200,192,186,180,174,169,164,160,156,153,149,146,143,140,137,135,132,130,128,126,124,122,120,119,117,115,114,113,111,110,108,107,106,105,104, 
.................... 103,102,101}; 
.................... #ENDIF 
....................  
.................... void move_pos(unsigned int16 position); 
.................... unsigned int16 qei_get_count(); 
....................  
.................... // Initializes digital potentiometer 
.................... void dp_init()  
.................... { 
....................    output_high(DP_CS);                       // Chip select is active low so keep it disabled 
*
019F0:  BCLR.B  2D8.0
019F2:  BSET.B  2DC.0
....................    output_low(DP_UD);                        // Up/down control pin can be in any state 
019F4:  BCLR.B  2DE.1
019F6:  BCLR.B  2E2.1
019F8:  RETURN  
.................... } 
.................... // Increases digital potentiometer by given tap 
.................... void dp_up(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
*
01A7E:  MOV     8B2,W0
01A80:  MOV     99E,W4
01A82:  CP      W4,W0
01A84:  BRA     LEU,1A8A
....................       tap=dp_tap_limit; 
01A86:  PUSH    8B2
01A88:  POP     99E
....................        
....................    output_high(DP_UD);        // Set U/D to high before activating digital potentiometer 
01A8A:  BCLR.B  2DE.1
01A8C:  BSET.B  2E2.1
....................    delay_us(1); 
01A8E:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
01A90:  BCLR.B  2D8.0
01A92:  BCLR.B  2DC.0
....................    delay_us(1); 
01A94:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
01A96:  CLR     9A0
01A98:  MOV     9A0,W0
01A9A:  MOV     99E,W4
01A9C:  CP      W4,W0
01A9E:  BRA     LEU,1AB8
....................    { 
....................       output_low(DP_UD);      // Low part of pulse 
01AA0:  BCLR.B  2DE.1
01AA2:  BCLR.B  2E2.1
....................       delay_us(1); 
01AA4:  NOP     
....................       output_high(DP_UD);     // High part of pulse 
01AA6:  BCLR.B  2DE.1
01AA8:  BSET.B  2E2.1
....................       delay_us(1); 
01AAA:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
01AAC:  BCLR.B  2DE.1
01AAE:  BCLR.B  2E2.1
....................       delay_us(1);  
01AB0:  NOP     
01AB2:  INC     09A0
01AB4:  GOTO    1A98
....................    } 
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer   
01AB8:  BCLR.B  2D8.0
01ABA:  BSET.B  2DC.0
01ABC:  RETURN  
.................... } 
.................... // Decreases digital potentiometer by given tap 
.................... void dp_down(unsigned int tap) 
.................... { 
....................    if(tap>dp_tap_limit)       // Tap cannot be more than tap limit    
01ABE:  MOV     8B2,W0
01AC0:  MOV     99E,W4
01AC2:  CP      W4,W0
01AC4:  BRA     LEU,1ACA
....................       tap=dp_tap_limit; 
01AC6:  PUSH    8B2
01AC8:  POP     99E
....................        
....................    output_low(DP_UD);         // Set U/D to low before activating digital potentiometer 
01ACA:  BCLR.B  2DE.1
01ACC:  BCLR.B  2E2.1
....................    delay_us(1); 
01ACE:  NOP     
....................    output_low(DP_CS);         // Activate digital potentiometer 
01AD0:  BCLR.B  2D8.0
01AD2:  BCLR.B  2DC.0
....................    delay_us(1);             
01AD4:  NOP     
....................     
....................    unsigned int i; 
....................    for(i=0;i<tap;i++) 
01AD6:  CLR     9A0
01AD8:  MOV     9A0,W0
01ADA:  MOV     99E,W4
01ADC:  CP      W4,W0
01ADE:  BRA     LEU,1AF2
....................    { 
....................       output_high(DP_UD);     // High part of pulse 
01AE0:  BCLR.B  2DE.1
01AE2:  BSET.B  2E2.1
....................       delay_us(1); 
01AE4:  NOP     
....................       output_low(DP_UD);      // End one square pulse 
01AE6:  BCLR.B  2DE.1
01AE8:  BCLR.B  2E2.1
....................       delay_us(1);   
01AEA:  NOP     
01AEC:  INC     09A0
01AEE:  GOTO    1AD8
....................    } 
....................     
....................    output_high(DP_CS);        // Deactivate digital potentiometer 
01AF2:  BCLR.B  2D8.0
01AF4:  BSET.B  2DC.0
01AF6:  RETURN  
.................... } 
.................... // Sets digital potentiometer to given voltage 
.................... void dp_set(unsigned int voltage) 
01AF8:  MOV     W5,[W15++]
01AFA:  MOV     #3,W4
01AFC:  MOV     W4,986
01AFE:  CLR     988
01B00:  MOV     #F,W4
01B02:  MOV     W4,98A
01B04:  MOV     984,W4
01B06:  MOV     8B2,W3
01B08:  MUL.UU  W4,W3,W0
01B0A:  MOV     W0,W5
01B0C:  MOV     W5,W4
01B0E:  MOV     8B4,W3
01B10:  REPEAT  #11
01B12:  DIV.U   W4,W3
01B14:  MOV     W0,98C
01B16:  BCLR.B  2A0.0
01B18:  BSET.B  2A0.1
01B1A:  BTSS.B  2A0.0
01B1C:  BRA     1B1A
01B1E:  PUSH    280
01B20:  POP     98E
01B22:  MOV     984,W4
01B24:  MOV     98E,W3
01B26:  SUB     W4,W3,W5
01B28:  MOV     W5,W0
01B2A:  MOV     W5,990
.................... { 
....................    unsigned int iteration_limit=3;                                   // Maximum number of iterations to be performed to set voltage 
....................    unsigned int iteration=0;                                         // Number of iterations performed to set voltage 
....................    unsigned int region=15;                                           // We want the voltage to be inside this region (+/-)  
....................    unsigned int tap_desired=voltage*dp_tap_limit/dp_voltage_limit;   // Find the desired potentiometer tap 
....................    unsigned int voltage_current=read_adc();                          // Read the current voltage 
....................    unsigned int voltage_diff=abs(voltage-voltage_current);           // Find the difference between the current and desired voltage  
....................    unsigned int tap_current;                                         // Current tap value 
....................     
....................    if(debug_mode_dp) 
01B2C:  BTSS.B  8B0.0
01B2E:  BRA     1BF4
....................    { 
....................       fprintf(RS232,"\n\r\tVoltage Desired: %u",voltage); 
01B30:  MOV     #0,W1
01B32:  MOV     W1,W0
01B34:  CLR.B   1
01B36:  CALL    196
01B3A:  INC     W1,W1
01B3C:  BTSC.B  219.1
01B3E:  BRA     1B3C
01B40:  MOV.B   W0L,21A
01B42:  MOV     #13,W0
01B44:  CPSGT   W1,W0
01B46:  BRA     1B32
01B48:  MOV     984,W0
01B4A:  MOV     #0,W4
01B4C:  CALL    1596
....................       fprintf(RS232,"\n\r\tTap Desired: %u",dp_tap_limit*voltage/dp_voltage_limit); 
01B50:  MOV     8B2,W4
01B52:  MOV     984,W3
01B54:  MUL.UU  W4,W3,W0
01B56:  MOV     W0,W5
01B58:  MOV     W5,W4
01B5A:  MOV     8B4,W3
01B5C:  REPEAT  #11
01B5E:  DIV.U   W4,W3
01B60:  MOV     W0,W5
01B62:  MOV     #0,W1
01B64:  MOV     W1,W0
01B66:  CLR.B   1
01B68:  CALL    1BA
01B6C:  INC     W1,W1
01B6E:  BTSC.B  219.1
01B70:  BRA     1B6E
01B72:  MOV.B   W0L,21A
01B74:  MOV     #F,W0
01B76:  CPSGT   W1,W0
01B78:  BRA     1B64
01B7A:  MOV     W5,W0
01B7C:  MOV     #0,W4
01B7E:  CALL    1596
....................       fprintf(RS232,"\n\r\tVoltage Current: %u",voltage_current); 
01B82:  MOV     #0,W1
01B84:  MOV     W1,W0
01B86:  CLR.B   1
01B88:  CALL    1DA
01B8C:  INC     W1,W1
01B8E:  BTSC.B  219.1
01B90:  BRA     1B8E
01B92:  MOV.B   W0L,21A
01B94:  MOV     #13,W0
01B96:  CPSGT   W1,W0
01B98:  BRA     1B84
01B9A:  MOV     98E,W0
01B9C:  MOV     #0,W4
01B9E:  CALL    1596
....................       fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01BA2:  MOV     8B2,W4
01BA4:  MOV     98E,W3
01BA6:  MUL.UU  W4,W3,W0
01BA8:  MOV     W0,W5
01BAA:  MOV     W5,W4
01BAC:  MOV     8B4,W3
01BAE:  REPEAT  #11
01BB0:  DIV.U   W4,W3
01BB2:  MOV     W0,W5
01BB4:  MOV     #0,W1
01BB6:  MOV     W1,W0
01BB8:  CLR.B   1
01BBA:  CALL    1FE
01BBE:  INC     W1,W1
01BC0:  BTSC.B  219.1
01BC2:  BRA     1BC0
01BC4:  MOV.B   W0L,21A
01BC6:  MOV     #F,W0
01BC8:  CPSGT   W1,W0
01BCA:  BRA     1BB6
01BCC:  MOV     W5,W0
01BCE:  MOV     #0,W4
01BD0:  CALL    1596
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",voltage_diff); 
01BD4:  MOV     #0,W1
01BD6:  MOV     W1,W0
01BD8:  CLR.B   1
01BDA:  CALL    21E
01BDE:  INC     W1,W1
01BE0:  BTSC.B  219.1
01BE2:  BRA     1BE0
01BE4:  MOV.B   W0L,21A
01BE6:  MOV     #16,W0
01BE8:  CPSGT   W1,W0
01BEA:  BRA     1BD6
01BEC:  MOV     990,W0
01BEE:  MOV     #0,W4
01BF0:  CALL    1596
....................    } 
....................     
....................    while(voltage_diff>region)                                        // Try until voltage is found 
01BF4:  MOV     98A,W0
01BF6:  MOV     990,W4
01BF8:  CP      W4,W0
01BFA:  BRA     LEU,1D54
....................    {                                                                 // or iteration limit is reached  
....................       if(iteration <iteration_limit)                      
01BFC:  MOV     988,W0
01BFE:  MOV     986,W4
01C00:  CP      W4,W0
01C02:  BRA     LEU,1D32
....................       { 
....................          iteration++;                                                // Set iteration number 
01C04:  INC     0988
....................          tap_current=dp_tap_limit*voltage_current/dp_voltage_limit;  // Convert new voltage to tap 
01C06:  MOV     8B2,W4
01C08:  MOV     98E,W3
01C0A:  MUL.UU  W4,W3,W0
01C0C:  MOV     W0,W5
01C0E:  MOV     W5,W4
01C10:  MOV     8B4,W3
01C12:  REPEAT  #11
01C14:  DIV.U   W4,W3
01C16:  MOV     W0,992
....................  
....................          if(tap_desired>tap_current)                                 // Set the digital potentiometer to desired tap 
01C18:  MOV     992,W0
01C1A:  MOV     98C,W4
01C1C:  CP      W4,W0
01C1E:  BRA     LEU,1C30
....................          { 
....................             dp_up(tap_desired-tap_current); 
01C20:  MOV     98C,W4
01C22:  MOV     992,W3
01C24:  SUB     W4,W3,W5
01C26:  MOV     W5,99E
01C28:  CALL    1A7E
....................          } 
01C2C:  GOTO    1C64
....................          else if(tap_desired<tap_current) 
01C30:  MOV     98C,W0
01C32:  MOV     992,W4
01C34:  CP      W4,W0
01C36:  BRA     LEU,1C48
....................          { 
....................             dp_down(tap_current-tap_desired); 
01C38:  MOV     992,W4
01C3A:  MOV     98C,W3
01C3C:  SUB     W4,W3,W5
01C3E:  MOV     W5,99E
01C40:  CALL    1ABE
....................          } 
01C44:  GOTO    1C64
....................          else                                                        // If tap level is same as the previous one and it still outside the region 
....................          {                                                           // then go one step up or down according to desired voltage 
....................             if(voltage>voltage_current) 
01C48:  MOV     98E,W0
01C4A:  MOV     984,W4
01C4C:  CP      W4,W0
01C4E:  BRA     LEU,1C5C
....................                dp_up(1); 
01C50:  MOV     #1,W4
01C52:  MOV     W4,99E
01C54:  CALL    1A7E
01C58:  GOTO    1C64
....................             else 
....................                dp_down(1); 
01C5C:  MOV     #1,W4
01C5E:  MOV     W4,99E
01C60:  CALL    1ABE
....................          } 
....................           
....................          delay_ms(2); 
01C64:  REPEAT  #E62
01C66:  NOP     
....................              
....................          voltage_current=read_adc();                                 // Read the new voltage 
01C68:  BCLR.B  2A0.0
01C6A:  BSET.B  2A0.1
01C6C:  BTSS.B  2A0.0
01C6E:  BRA     1C6C
01C70:  PUSH    280
01C72:  POP     98E
....................           
....................          if(voltage>voltage_current)                                 // Find the difference between the new and desired voltages for next iteration check 
01C74:  MOV     98E,W0
01C76:  MOV     984,W4
01C78:  CP      W4,W0
01C7A:  BRA     LEU,1C88
....................             voltage_diff=voltage - voltage_current; 
01C7C:  MOV     984,W4
01C7E:  MOV     98E,W3
01C80:  SUB     W4,W3,W0
01C82:  MOV     W0,990
01C84:  GOTO    1C90
....................          else 
....................             voltage_diff=voltage_current - voltage; 
01C88:  MOV     98E,W4
01C8A:  MOV     984,W3
01C8C:  SUB     W4,W3,W0
01C8E:  MOV     W0,990
....................           
....................          if(debug_mode_dp) 
01C90:  BTSS.B  8B0.0
01C92:  BRA     1D2E
....................          { 
....................             fprintf(RS232,"\n\rITERATION: %u",iteration); 
01C94:  MOV     #0,W1
01C96:  MOV     W1,W0
01C98:  CLR.B   1
01C9A:  CALL    244
01C9E:  INC     W1,W1
01CA0:  BTSC.B  219.1
01CA2:  BRA     1CA0
01CA4:  MOV.B   W0L,21A
01CA6:  MOV     #C,W0
01CA8:  CPSGT   W1,W0
01CAA:  BRA     1C96
01CAC:  MOV     988,W0
01CAE:  MOV     #0,W4
01CB0:  CALL    1596
....................             fprintf(RS232,"\n\r\tTap Current: %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01CB4:  MOV     8B2,W4
01CB6:  MOV     98E,W3
01CB8:  MUL.UU  W4,W3,W0
01CBA:  MOV     W0,W5
01CBC:  MOV     W5,W4
01CBE:  MOV     8B4,W3
01CC0:  REPEAT  #11
01CC2:  DIV.U   W4,W3
01CC4:  MOV     W0,W5
01CC6:  MOV     #0,W1
01CC8:  MOV     W1,W0
01CCA:  CLR.B   1
01CCC:  CALL    1FE
01CD0:  INC     W1,W1
01CD2:  BTSC.B  219.1
01CD4:  BRA     1CD2
01CD6:  MOV.B   W0L,21A
01CD8:  MOV     #F,W0
01CDA:  CPSGT   W1,W0
01CDC:  BRA     1CC8
01CDE:  MOV     W5,W0
01CE0:  MOV     #0,W4
01CE2:  CALL    1596
....................             fprintf(RS232,"\n\r\tVoltage Current : %u",voltage_current); 
01CE6:  MOV     #0,W1
01CE8:  MOV     W1,W0
01CEA:  CLR.B   1
01CEC:  CALL    260
01CF0:  INC     W1,W1
01CF2:  BTSC.B  219.1
01CF4:  BRA     1CF2
01CF6:  MOV.B   W0L,21A
01CF8:  MOV     #14,W0
01CFA:  CPSGT   W1,W0
01CFC:  BRA     1CE8
01CFE:  MOV     98E,W0
01D00:  MOV     #0,W4
01D02:  CALL    1596
....................             fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-voltage_current)); 
01D06:  MOV     984,W4
01D08:  MOV     98E,W3
01D0A:  SUB     W4,W3,W5
01D0C:  MOV     W5,W0
01D0E:  MOV     #0,W1
01D10:  MOV     W1,W0
01D12:  CLR.B   1
01D14:  CALL    21E
01D18:  INC     W1,W1
01D1A:  BTSC.B  219.1
01D1C:  BRA     1D1A
01D1E:  MOV.B   W0L,21A
01D20:  MOV     #16,W0
01D22:  CPSGT   W1,W0
01D24:  BRA     1D10
01D26:  MOV     W5,W0
01D28:  MOV     #0,W4
01D2A:  CALL    1596
....................          } 
....................       } 
01D2E:  GOTO    1D50
....................       else 
....................       { 
....................          if(debug_mode_dp) 
01D32:  BTSS.B  8B0.0
01D34:  BRA     1D4E
....................             fprintf(RS232,"\n\rIteration limit reached"); 
01D36:  MOV     #0,W1
01D38:  MOV     W1,W0
01D3A:  CLR.B   1
01D3C:  CALL    284
01D40:  INC     W1,W1
01D42:  BTSC.B  219.1
01D44:  BRA     1D42
01D46:  MOV.B   W0L,21A
01D48:  MOV     #18,W0
01D4A:  CPSGT   W1,W0
01D4C:  BRA     1D38
....................          return; 
01D4E:  BRA     1DFC
....................       } 
01D50:  GOTO    1BF4
....................    } 
....................     
....................    if(debug_mode_dp) 
01D54:  BTSS.B  8B0.0
01D56:  BRA     1DFC
....................    { 
....................       fprintf(RS232,"\n\rFOUND!"); 
01D58:  MOV     #0,W1
01D5A:  MOV     W1,W0
01D5C:  CLR.B   1
01D5E:  CALL    2AA
01D62:  INC     W1,W1
01D64:  BTSC.B  219.1
01D66:  BRA     1D64
01D68:  MOV.B   W0L,21A
01D6A:  MOV     #7,W0
01D6C:  CPSGT   W1,W0
01D6E:  BRA     1D5A
....................       fprintf(RS232,"\n\r\tTap Current : %u",dp_tap_limit*voltage_current/dp_voltage_limit); 
01D70:  MOV     8B2,W4
01D72:  MOV     98E,W3
01D74:  MUL.UU  W4,W3,W0
01D76:  MOV     W0,W5
01D78:  MOV     W5,W4
01D7A:  MOV     8B4,W3
01D7C:  REPEAT  #11
01D7E:  DIV.U   W4,W3
01D80:  MOV     W0,W5
01D82:  MOV     #0,W1
01D84:  MOV     W1,W0
01D86:  CLR.B   1
01D88:  CALL    2C0
01D8C:  INC     W1,W1
01D8E:  BTSC.B  219.1
01D90:  BRA     1D8E
01D92:  MOV.B   W0L,21A
01D94:  MOV     #10,W0
01D96:  CPSGT   W1,W0
01D98:  BRA     1D84
01D9A:  MOV     W5,W0
01D9C:  MOV     #0,W4
01D9E:  CALL    1596
....................       fprintf(RS232,"\n\r\tVoltage Current : %u",read_adc()); 
01DA2:  BCLR.B  2A0.0
01DA4:  BSET.B  2A0.1
01DA6:  BTSS.B  2A0.0
01DA8:  BRA     1DA6
01DAA:  MOV     280,W5
01DAC:  MOV     #0,W1
01DAE:  MOV     W1,W0
01DB0:  CLR.B   1
01DB2:  CALL    260
01DB6:  INC     W1,W1
01DB8:  BTSC.B  219.1
01DBA:  BRA     1DB8
01DBC:  MOV.B   W0L,21A
01DBE:  MOV     #14,W0
01DC0:  CPSGT   W1,W0
01DC2:  BRA     1DAE
01DC4:  MOV     W5,W0
01DC6:  MOV     #0,W4
01DC8:  CALL    1596
....................       fprintf(RS232,"\n\r\tVoltage Difference: %u",abs(voltage-read_adc())); 
01DCC:  BCLR.B  2A0.0
01DCE:  BSET.B  2A0.1
01DD0:  BTSS.B  2A0.0
01DD2:  BRA     1DD0
01DD4:  MOV     280,W0
01DD6:  MOV     984,W4
01DD8:  SUB     W4,W0,W5
01DDA:  MOV     W5,W0
01DDC:  MOV     #0,W1
01DDE:  MOV     W1,W0
01DE0:  CLR.B   1
01DE2:  CALL    21E
01DE6:  INC     W1,W1
01DE8:  BTSC.B  219.1
01DEA:  BRA     1DE8
01DEC:  MOV.B   W0L,21A
01DEE:  MOV     #16,W0
01DF0:  CPSGT   W1,W0
01DF2:  BRA     1DDE
01DF4:  MOV     W5,W0
01DF6:  MOV     #0,W4
01DF8:  CALL    1596
....................    } 
01DFC:  MOV     [--W15],W5
01DFE:  RETURN  
.................... } 
....................  
.................... // Returns current motor torque in percent (%0-100) 
.................... unsigned int md_mt_get() 
01E00:  MOV     W5,[W15++]
01E02:  MOV     W6,[W15++]
01E04:  BCLR.B  2A0.0
01E06:  BSET.B  2A0.1
01E08:  BTSS.B  2A0.0
01E0A:  BRA     1E08
01E0C:  PUSH    280
01E0E:  POP     984
01E10:  MOV     984,W0
01E12:  MOV     #0,W1
01E14:  MOV     W0,W2
01E16:  MOV     W1,W3
01E18:  MOV     #64,W0
01E1A:  MOV     #0,W1
01E1C:  CALL    19FA
01E20:  MOV     W0,W5
01E22:  MOV     W1,W6
01E24:  BCLR.B  43.0
01E26:  MOV     W5,W0
01E28:  MOV     W6,W1
01E2A:  MOV     8B6,W2
01E2C:  MOV     #0,W3
01E2E:  CALL    1A2A
01E32:  MOV     W0,986
.................... { 
....................    unsigned int analog=read_adc();                                         // Read the voltage level 
....................    unsigned int percent=100*(unsigned int32)analog/mt_voltage_limit;       // Convert voltage to percent 
....................     
....................    if(debug_mode_dp) 
01E34:  BTSS.B  8B0.0
01E36:  BRA     1E68
....................       fprintf(RS232,"\n\r\tPercent Current: %u\n\r",percent); 
01E38:  MOV     #0,W1
01E3A:  MOV     W1,W0
01E3C:  CLR.B   1
01E3E:  CALL    2E0
01E42:  INC     W1,W1
01E44:  BTSC.B  219.1
01E46:  BRA     1E44
01E48:  MOV.B   W0L,21A
01E4A:  MOV     #13,W0
01E4C:  CPSGT   W1,W0
01E4E:  BRA     1E3A
01E50:  MOV     986,W0
01E52:  MOV     #0,W4
01E54:  CALL    1596
01E58:  BTSC.B  219.1
01E5A:  BRA     1E58
01E5C:  MOV.B   #A,W0L
01E5E:  MOV.B   W0L,21A
01E60:  BTSC.B  219.1
01E62:  BRA     1E60
01E64:  MOV.B   #D,W0L
01E66:  MOV.B   W0L,21A
....................        
....................    return percent;   
01E68:  PUSH    986
01E6A:  POP     0
01E6C:  MOV     [--W15],W6
01E6E:  MOV     [--W15],W5
01E70:  RETURN  
.................... } 
.................... // Sets motor torque approximate to desired percent and returns the actual percent (%0-100) 
.................... unsigned int md_mt_set(unsigned int percent) 
01E72:  MOV     W5,[W15++]
01E74:  MOV     W6,[W15++]
.................... { 
....................    // percent must be between 0 and 100 
....................    if(percent>100) 
01E76:  MOV     97E,W4
01E78:  MOV     #64,W3
01E7A:  CP      W3,W4
01E7C:  BRA     C,1E82
....................       percent=100; 
01E7E:  MOV     #64,W4
01E80:  MOV     W4,97E
....................        
....................    if(debug_mode_dp) 
01E82:  BTSS.B  8B0.0
01E84:  BRA     1EA6
....................    { 
....................       fprintf(RS232,"\n\r\tPercent Desired:"); 
01E86:  MOV     #0,W1
01E88:  MOV     W1,W0
01E8A:  CLR.B   1
01E8C:  CALL    306
01E90:  INC     W1,W1
01E92:  BTSC.B  219.1
01E94:  BRA     1E92
01E96:  MOV.B   W0L,21A
01E98:  MOV     #12,W0
01E9A:  CPSGT   W1,W0
01E9C:  BRA     1E88
....................       fprintf(RS232,"%u",percent); 
01E9E:  MOV     97E,W0
01EA0:  MOV     #0,W4
01EA2:  CALL    1596
....................    } 
....................     
....................    unsigned int voltage=(unsigned int32)percent*mt_voltage_limit/100;      // convert percent to voltage 
01EA6:  MOV     97E,W5
01EA8:  MOV     #0,W6
01EAA:  MOV     W5,W0
01EAC:  MOV     W6,W1
01EAE:  MOV     8B6,W2
01EB0:  MOV     #0,W3
01EB2:  CALL    19FA
01EB6:  MOV     W0,W5
01EB8:  MOV     W1,W6
01EBA:  BCLR.B  43.0
01EBC:  MOV     W5,W0
01EBE:  MOV     W6,W1
01EC0:  MOV     #64,W2
01EC2:  MOV     #0,W3
01EC4:  CALL    1A2A
01EC8:  MOV     W0,980
....................    dp_set(voltage);                                      // set digital potentiometer 
01ECA:  PUSH    980
01ECC:  POP     984
01ECE:  CALL    1AF8
....................     
....................    return md_mt_get(); 
01ED2:  CALL    1E00
01ED6:  MOV     W0,0
01ED8:  MOV     [--W15],W6
01EDA:  MOV     [--W15],W5
01EDC:  RETURN  
.................... } 
.................... // Initializes motor driver 
.................... void md_init() 
.................... { 
....................    md_mt_set(mt_percent_rest);               // Set motor torque before initialization of motor driver 
01EDE:  PUSH    8BA
01EE0:  POP     97E
01EE2:  CALL    1E72
....................  
....................    output_high(MD_RESET);                    // Reset is active low so keep it disabled 
01EE6:  BCLR.B  2D8.7
01EE8:  BSET.B  2DC.7
....................    output_high(MD_SLEEP);                    // Sleep is active low so keep it disabled 
01EEA:  BCLR.B  2D2.7
01EEC:  BSET.B  2D6.7
....................    output_high(MD_DIR);                      // Direction control pin can be in any state 
01EEE:  BCLR.B  2DE.0
01EF0:  BSET.B  2E2.0
....................    output_high(MD_MS);                       // MS1 and MS2 high enables 8x microstepping mode 
01EF2:  BCLR.B  2D8.5
01EF4:  BSET.B  2DC.5
....................    output_low(MD_ENABLE);                    // Enable is active so keep it high 
01EF6:  BCLR.B  2D2.6
01EF8:  BCLR.B  2D6.6
....................    output_low(MD_STEP);                      // A low-to-high transition advances the motor one increment so keep step input low 
01EFA:  BCLR.B  2D8.6
01EFC:  BCLR.B  2DC.6
01EFE:  RETURN  
.................... } 
....................  
.................... // Initializes external EEPROM (FRAM) 
.................... void fr_init()  
.................... { 
....................    output_high(FR_CS);     // Chip select is active low when it is high the device enters low-power standby mode so initialy keep it high 
01F00:  BCLR.B  2C6.2
01F02:  BSET.B  2CA.2
....................    output_low(FR_WP);      // Write protection pin is active low and prevents write operations to the status register so initially keep it low 
01F04:  BCLR.B  2E4.3
01F06:  BCLR.B  2E8.3
....................    output_low(FR_SI);      // Serial input pin is driven to high logic state during communication so initially keep it low 
01F08:  BCLR.B  2DE.2
01F0A:  BCLR.B  2E2.2
....................    output_low(FR_SCK);     // Inputs are latched on the rising edge and outputs occur on the falling edge so initially serial clock can be in any state  
01F0C:  BCLR.B  2DE.6
01F0E:  BCLR.B  2E2.6
01F10:  RETURN  
.................... } 
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... void fr_write_byte(unsigned int16 address, unsigned int8 data)  
.................... { 
....................    unsigned int8 cmd[4]; 
....................    unsigned int8 i; 
....................    unsigned int8 wren; 
....................    unsigned int8 write; 
....................    unsigned int8 wrdi; 
....................     
....................    //     76543210     
....................    wren=0b00000110; 
*
02590:  MOV.B   #6,W0L
02592:  MOV.B   W0L,98A
....................    //      76543210  
....................    write=0b00000010; 
02594:  MOV.B   #2,W0L
02596:  MOV.B   W0L,98B
....................    //     76543210 
....................    wrdi=0b00000100; 
02598:  MOV.B   #4,W0L
0259A:  MOV.B   W0L,98C
....................     
....................    cmd[0]=data; 
0259C:  MOV.B   984,W0L
0259E:  MOV.B   W0L,986
....................    cmd[1]=address; 
025A0:  MOV.B   982,W0L
025A2:  MOV.B   W0L,987
....................    cmd[2]=address/256; 
025A4:  MOV.B   983,W0L
025A6:  MOV.B   W0L,988
....................    cmd[3]=write; 
025A8:  MOV.B   98B,W0L
025AA:  MOV.B   W0L,989
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    output_low(FR_CS); 
025AC:  BCLR.B  2C6.2
025AE:  BCLR.B  2CA.2
....................    delay_us(1); 
025B0:  NOP     
....................    for(i=0; i<8; ++i) 
025B2:  CLR.B   985
025B4:  MOV     984,W4
025B6:  LSR     W4,#8,W4
025B8:  CP.B    W4L,#8
025BA:  BRA     C,25E4
....................    { 
....................       output_bit(FR_SI, shift_left(&wren,1,0)); 
025BC:  BCLR.B  42.0
025BE:  RLC.B   98A
025C0:  BRA     C,25C6
025C2:  BCLR.B  2E2.2
025C4:  BRA     25C8
025C6:  BSET.B  2E2.2
025C8:  BCLR.B  2DE.2
....................       delay_us(1); 
025CA:  NOP     
....................       output_high(FR_SCK); 
025CC:  BCLR.B  2DE.6
025CE:  BSET.B  2E2.6
....................       delay_us(1); 
025D0:  NOP     
....................       output_low(FR_SI); 
025D2:  BCLR.B  2DE.2
025D4:  BCLR.B  2E2.2
....................       delay_us(1); 
025D6:  NOP     
....................       output_low(FR_SCK); 
025D8:  BCLR.B  2DE.6
025DA:  BCLR.B  2E2.6
....................       delay_us(1); 
025DC:  NOP     
025DE:  INC.B   0985
025E0:  GOTO    25B4
....................    } 
....................    delay_us(1); 
025E4:  NOP     
....................    output_high(FR_CS); 
025E6:  BCLR.B  2C6.2
025E8:  BSET.B  2CA.2
....................    delay_us(1); 
025EA:  NOP     
....................     
....................    output_low(FR_CS); 
025EC:  BCLR.B  2C6.2
025EE:  BCLR.B  2CA.2
....................    delay_us(1); 
025F0:  NOP     
....................    for(i=0; i<32; ++i) 
025F2:  CLR.B   985
025F4:  MOV     984,W4
025F6:  LSR     W4,#8,W4
025F8:  MOV     #20,W3
025FA:  CP.B    W3L,W4L
025FC:  BRA     LEU,2628
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,4,0)); 
025FE:  BCLR.B  42.0
02600:  RLC     986
02602:  RLC     988
02604:  BRA     C,260A
02606:  BCLR.B  2E2.2
02608:  BRA     260C
0260A:  BSET.B  2E2.2
0260C:  BCLR.B  2DE.2
....................       delay_us(1); 
0260E:  NOP     
....................       output_high(FR_SCK); 
02610:  BCLR.B  2DE.6
02612:  BSET.B  2E2.6
....................       delay_us(1); 
02614:  NOP     
....................       output_low(FR_SI); 
02616:  BCLR.B  2DE.2
02618:  BCLR.B  2E2.2
....................       delay_us(1); 
0261A:  NOP     
....................       output_low(FR_SCK); 
0261C:  BCLR.B  2DE.6
0261E:  BCLR.B  2E2.6
....................       delay_us(1); 
02620:  NOP     
02622:  INC.B   0985
02624:  GOTO    25F4
....................    } 
....................    delay_us(1); 
02628:  NOP     
....................    output_high(FR_CS); 
0262A:  BCLR.B  2C6.2
0262C:  BSET.B  2CA.2
....................    delay_us(1); 
0262E:  NOP     
....................     
....................    output_low(FR_CS); 
02630:  BCLR.B  2C6.2
02632:  BCLR.B  2CA.2
....................    delay_us(1); 
02634:  NOP     
....................    for(i=0; i<8; ++i) 
02636:  CLR.B   985
02638:  MOV     984,W4
0263A:  LSR     W4,#8,W4
0263C:  CP.B    W4L,#8
0263E:  BRA     C,2668
....................    { 
....................       output_bit(FR_SI, shift_left(&wrdi,1,0)); 
02640:  BCLR.B  42.0
02642:  RLC.B   98C
02644:  BRA     C,264A
02646:  BCLR.B  2E2.2
02648:  BRA     264C
0264A:  BSET.B  2E2.2
0264C:  BCLR.B  2DE.2
....................       delay_us(1); 
0264E:  NOP     
....................       output_high(FR_SCK); 
02650:  BCLR.B  2DE.6
02652:  BSET.B  2E2.6
....................       delay_us(1); 
02654:  NOP     
....................       output_low(FR_SI); 
02656:  BCLR.B  2DE.2
02658:  BCLR.B  2E2.2
....................       delay_us(1); 
0265A:  NOP     
....................       output_low(FR_SCK); 
0265C:  BCLR.B  2DE.6
0265E:  BCLR.B  2E2.6
....................       delay_us(1); 
02660:  NOP     
02662:  INC.B   0985
02664:  GOTO    2638
....................    } 
....................    delay_us(1); 
02668:  NOP     
....................    output_high(FR_CS); 
0266A:  BCLR.B  2C6.2
0266C:  BSET.B  2CA.2
....................    delay_us(1); 
0266E:  NOP     
02670:  RETURN  
.................... } 
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 8 bit data as parameters 
.................... unsigned int8 fr_read_byte(unsigned int16 address)  
.................... { 
....................    unsigned int8 cmd[3]; 
....................    unsigned int8 i,data; 
....................    unsigned int8 read; 
....................     
....................    //     76543210  
....................    read=0b00000011; 
*
01F12:  MOV.B   #3,W0L
01F14:  MOV.B   W0L,98D
....................     
....................    //Sample on Rising Edge of EEPROM_CLK 
....................    //Read on Rising Edge of EEPROM_CLK 
....................    //Clock Period=4usec(2usec high, 2usec low) 
....................    cmd[0]=address; 
01F16:  MOV.B   986,W0L
01F18:  MOV.B   W0L,988
....................    cmd[1]=address/256; 
01F1A:  MOV.B   987,W0L
01F1C:  MOV.B   W0L,989
....................    cmd[2]=read; 
01F1E:  MOV.B   98D,W0L
01F20:  MOV.B   W0L,98A
....................  
....................    output_low(FR_CS); 
01F22:  BCLR.B  2C6.2
01F24:  BCLR.B  2CA.2
....................    delay_us(1); 
01F26:  NOP     
....................    for(i=0; i<24; ++i) 
01F28:  CLR.B   98B
01F2A:  MOV     98A,W4
01F2C:  LSR     W4,#8,W4
01F2E:  CP.B    W4L,#18
01F30:  BRA     C,1F5C
....................    { 
....................       output_bit(FR_SI, shift_left(cmd,3,0)); 
01F32:  BCLR.B  42.0
01F34:  RLC     988
01F36:  RLC.B   98A
01F38:  BRA     C,1F3E
01F3A:  BCLR.B  2E2.2
01F3C:  BRA     1F40
01F3E:  BSET.B  2E2.2
01F40:  BCLR.B  2DE.2
....................       delay_us(1); 
01F42:  NOP     
....................       output_high(FR_SCK); 
01F44:  BCLR.B  2DE.6
01F46:  BSET.B  2E2.6
....................       delay_us(1); 
01F48:  NOP     
....................       output_low(FR_SI); 
01F4A:  BCLR.B  2DE.2
01F4C:  BCLR.B  2E2.2
....................       delay_us(1); 
01F4E:  NOP     
....................       output_low(FR_SCK); 
01F50:  BCLR.B  2DE.6
01F52:  BCLR.B  2E2.6
....................       delay_us(1); 
01F54:  NOP     
01F56:  INC.B   098B
01F58:  GOTO    1F2A
....................    } 
....................    for(i=0; i<8; ++i) 
01F5C:  CLR.B   98B
01F5E:  MOV     98A,W4
01F60:  LSR     W4,#8,W4
01F62:  CP.B    W4L,#8
01F64:  BRA     C,1F8A
....................    { 
....................       delay_us(1); 
01F66:  NOP     
....................       shift_left(&data,1,input(FR_SO)); 
01F68:  BSET.B  2DE.3
01F6A:  BTSC.B  2E0.3
01F6C:  BRA     1F72
01F6E:  BCLR.B  42.0
01F70:  BRA     1F74
01F72:  BSET.B  42.0
01F74:  RLC.B   98C
....................       output_high(FR_SCK); 
01F76:  BCLR.B  2DE.6
01F78:  BSET.B  2E2.6
....................       delay_us(1); 
01F7A:  NOP     
....................       delay_us(1); 
01F7C:  NOP     
....................       output_low(FR_SCK); 
01F7E:  BCLR.B  2DE.6
01F80:  BCLR.B  2E2.6
....................       delay_us(1); 
01F82:  NOP     
01F84:  INC.B   098B
01F86:  GOTO    1F5E
....................    } 
....................    output_high(FR_CS); 
01F8A:  BCLR.B  2C6.2
01F8C:  BSET.B  2CA.2
....................    delay_us(1); 
01F8E:  NOP     
....................     
....................    return(data); 
01F90:  MOV.B   98C,W0L
01F92:  MOV.B   W0L,0
01F94:  RETURN  
.................... } 
.................... // Writes to external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... void fr_write(unsigned int16 address,unsigned int16 data) 
*
02672:  MOV     W5,[W15++]
.................... { 
....................    unsigned int8 data_high; 
....................    unsigned int8 data_low; 
....................    data_low=(unsigned int8)data; 
02674:  MOV.B   978,W0L
02676:  MOV.B   W0L,97B
....................    data_high=(unsigned int8)(data>>8); 
02678:  CLR.B   1
0267A:  MOV.B   979,W0L
0267C:  MOV.B   W0L,97A
....................     
....................    fr_write_byte(address,data_low); 
0267E:  MOV.B   97B,W0L
02680:  MOV.B   W0L,984
02682:  PUSH    976
02684:  POP     982
02686:  CALL    2590
....................    fr_write_byte(address+1,data_high); 
0268A:  MOV     976,W4
0268C:  ADD     W4,#1,W4
0268E:  MOV     W4,W5
02690:  MOV.B   97A,W0L
02692:  MOV.B   W0L,984
02694:  MOV     W5,982
02696:  CALL    2590
....................     
....................    return; 
0269A:  MOV     [--W15],W5
0269C:  RETURN  
.................... } 
.................... // Reads from external EEPROM (FRAM) and takes 16 bit address and 16 bit data as parameters 
.................... unsigned int16 fr_read(unsigned int16 address) 
*
01F96:  MOV     W5,[W15++]
.................... { 
....................    unsigned int16 data_buffer; 
....................    unsigned int16 data_low; 
....................    unsigned int16 data_high; 
....................     
....................    data_low=fr_read_byte(address); 
01F98:  PUSH    978
01F9A:  POP     986
01F9C:  CALL    1F12
01FA0:  MOV.B   W0L,97C
01FA2:  CLR.B   97D
....................    data_high=fr_read_byte(address+1); 
01FA4:  MOV     978,W4
01FA6:  ADD     W4,#1,W4
01FA8:  MOV     W4,W5
01FAA:  MOV     W5,986
01FAC:  CALL    1F12
01FB0:  MOV.B   W0L,97E
01FB2:  CLR.B   97F
....................     
....................    data_buffer=(data_high<<8)+data_low; 
01FB4:  MOV.B   97E,W0L
01FB6:  MOV.B   W0L,B
01FB8:  CLR.B   W5
01FBA:  MOV     W5,W0
01FBC:  ADD     97C,W0
01FBE:  MOV     W0,97A
....................     
....................    return data_buffer; 
01FC0:  PUSH    97A
01FC2:  POP     0
01FC4:  MOV     [--W15],W5
01FC6:  RETURN  
.................... } 
....................  
.................... // Returns serial number of the device via RS232 
.................... void data_get_serial_no() 
*
03D78:  MOV     W5,[W15++]
03D7A:  MOV     W6,[W15++]
.................... { 
....................    if(!debug_mode_fr)  
03D7C:  BTSC.B  8B0.2
03D7E:  BRA     3D82
....................       return; 
03D80:  BRA     3DEC
....................        
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
03D82:  CLR.B   962
....................     
....................    fprintf(RS232, "Serial No:"); 
03D84:  MOV     #0,W1
03D86:  MOV     W1,W0
03D88:  CLR.B   1
03D8A:  CALL    326
03D8E:  INC     W1,W1
03D90:  BTSC.B  219.1
03D92:  BRA     3D90
03D94:  MOV.B   W0L,21A
03D96:  MOV     #9,W0
03D98:  CPSGT   W1,W0
03D9A:  BRA     3D86
....................    for(i=0; i<13; i++) 
03D9C:  CLR.B   962
03D9E:  MOV     962,W4
03DA0:  CP.B    W4L,#D
03DA2:  BRA     C,3DDC
....................    { 
....................       input[i]=fr_read_byte(fr_serial_no+i); 
03DA4:  MOV     962,W4
03DA6:  CLR.B   9
03DA8:  MOV     #964,W3
03DAA:  ADD     W4,W3,W5
03DAC:  MOV     962,W4
03DAE:  CLR.B   9
03DB0:  MOV     8E4,W3
03DB2:  ADD     W3,W4,W6
03DB4:  MOV     W6,986
03DB6:  CALL    1F12
03DBA:  MOV.B   W0L,[W5]
....................       fputc(input[i]+48,RS232); 
03DBC:  MOV     962,W4
03DBE:  CLR.B   9
03DC0:  MOV     #964,W3
03DC2:  ADD     W4,W3,W0
03DC4:  MOV.B   [W0],W4L
03DC6:  CLR.B   9
03DC8:  MOV     #30,W3
03DCA:  ADD     W4,W3,W5
03DCC:  MOV.B   W5L,W0L
03DCE:  BTSC.B  219.1
03DD0:  BRA     3DCE
03DD2:  MOV.B   W0L,21A
03DD4:  CLR.B   21B
03DD6:  INC.B   0962
03DD8:  GOTO    3D9E
....................    } 
....................    fprintf(RS232, "\n\r"); 
03DDC:  BTSC.B  219.1
03DDE:  BRA     3DDC
03DE0:  MOV.B   #A,W0L
03DE2:  MOV.B   W0L,21A
03DE4:  BTSC.B  219.1
03DE6:  BRA     3DE4
03DE8:  MOV.B   #D,W0L
03DEA:  MOV.B   W0L,21A
03DEC:  MOV     [--W15],W6
03DEE:  MOV     [--W15],W5
03DF0:  RETURN  
.................... } 
.................... // Returns movement range of the device 
.................... unsigned int16 data_get_move_range() 
*
01FC8:  PUSH    8E6
01FCA:  POP     978
01FCC:  CALL    1F96
01FD0:  MOV     W0,962
.................... { 
....................    unsigned int16 range = fr_read(fr_move_range); 
....................     
....................    if(debug_mode_fr)  
01FD2:  BTSS.B  8B0.2
01FD4:  BRA     200E
....................       fprintf(RS232, "Movement Range: %u mm\n\r", range); 
01FD6:  MOV     #0,W1
01FD8:  MOV     W1,W0
01FDA:  CLR.B   1
01FDC:  CALL    33E
01FE0:  INC     W1,W1
01FE2:  BTSC.B  219.1
01FE4:  BRA     1FE2
01FE6:  MOV.B   W0L,21A
01FE8:  MOV     #F,W0
01FEA:  CPSGT   W1,W0
01FEC:  BRA     1FD8
01FEE:  MOV     962,W0
01FF0:  MOV     #0,W4
01FF2:  CALL    1596
01FF6:  MOV     #12,W1
01FF8:  MOV     W1,W0
01FFA:  CLR.B   1
01FFC:  CALL    33E
02000:  INC     W1,W1
02002:  BTSC.B  219.1
02004:  BRA     2002
02006:  MOV.B   W0L,21A
02008:  MOV     #16,W0
0200A:  CPSGT   W1,W0
0200C:  BRA     1FF8
....................     
....................    return range; 
0200E:  PUSH    962
02010:  POP     0
02012:  RETURN  
.................... } 
.................... // Returns home position 
.................... unsigned int16 data_get_home_pos() 
02014:  PUSH    8E8
02016:  POP     978
02018:  CALL    1F96
0201C:  MOV     W0,976
.................... { 
....................    unsigned int16 home_pos = fr_read(fr_home_pos); 
....................     
....................    if(debug_mode_fr)  
0201E:  BTSS.B  8B0.2
02020:  BRA     205A
....................       fprintf(RS232, "Home Distance: %u counts\n\r", home_pos); 
02022:  MOV     #0,W1
02024:  MOV     W1,W0
02026:  CLR.B   1
02028:  CALL    362
0202C:  INC     W1,W1
0202E:  BTSC.B  219.1
02030:  BRA     202E
02032:  MOV.B   W0L,21A
02034:  MOV     #E,W0
02036:  CPSGT   W1,W0
02038:  BRA     2024
0203A:  MOV     976,W0
0203C:  MOV     #0,W4
0203E:  CALL    1596
02042:  MOV     #11,W1
02044:  MOV     W1,W0
02046:  CLR.B   1
02048:  CALL    362
0204C:  INC     W1,W1
0204E:  BTSC.B  219.1
02050:  BRA     204E
02052:  MOV.B   W0L,21A
02054:  MOV     #19,W0
02056:  CPSGT   W1,W0
02058:  BRA     2044
....................        
....................    return home_pos; 
0205A:  PUSH    976
0205C:  POP     0
0205E:  RETURN  
.................... } 
.................... // Returns end position 
.................... unsigned int16 data_get_end_pos() 
02060:  PUSH    8EA
02062:  POP     978
02064:  CALL    1F96
02068:  MOV     W0,962
.................... { 
....................    unsigned int16 end = fr_read(fr_end_pos); 
....................     
....................    if(debug_mode_fr) 
0206A:  BTSS.B  8B0.2
0206C:  BRA     20A6
....................       fprintf(RS232, "End Distance: %u counts\n\r", end); 
0206E:  MOV     #0,W1
02070:  MOV     W1,W0
02072:  CLR.B   1
02074:  CALL    38A
02078:  INC     W1,W1
0207A:  BTSC.B  219.1
0207C:  BRA     207A
0207E:  MOV.B   W0L,21A
02080:  MOV     #D,W0
02082:  CPSGT   W1,W0
02084:  BRA     2070
02086:  MOV     962,W0
02088:  MOV     #0,W4
0208A:  CALL    1596
0208E:  MOV     #10,W1
02090:  MOV     W1,W0
02092:  CLR.B   1
02094:  CALL    38A
02098:  INC     W1,W1
0209A:  BTSC.B  219.1
0209C:  BRA     209A
0209E:  MOV.B   W0L,21A
020A0:  MOV     #18,W0
020A2:  CPSGT   W1,W0
020A4:  BRA     2090
....................     
....................    return end; 
020A6:  PUSH    962
020A8:  POP     0
020AA:  RETURN  
.................... } 
.................... // Returns positioning velocity 
.................... unsigned int16 data_get_conv_const() 
*
0213A:  PUSH    8EC
0213C:  POP     978
0213E:  CALL    1F96
02142:  MOV     W0,962
.................... { 
....................    unsigned int16 conv_const = fr_read(fr_conv_const); 
....................     
....................    if((conv_const < 12000)||(conv_const > 13000)) 
02144:  MOV     962,W4
02146:  MOV     #2EE0,W3
02148:  CP      W3,W4
0214A:  BRA     GTU,2154
0214C:  MOV     962,W4
0214E:  MOV     #32C8,W3
02150:  CP      W3,W4
02152:  BRA     C,2158
....................       conv_const = 12500; 
02154:  MOV     #30D4,W4
02156:  MOV     W4,962
....................     
....................    if(debug_mode_fr)  
02158:  BTSS.B  8B0.2
0215A:  BRA     2194
....................       fprintf(RS232, "Conversion Constant: %u \n\r", conv_const); 
0215C:  MOV     #0,W1
0215E:  MOV     W1,W0
02160:  CLR.B   1
02162:  CALL    3B0
02166:  INC     W1,W1
02168:  BTSC.B  219.1
0216A:  BRA     2168
0216C:  MOV.B   W0L,21A
0216E:  MOV     #14,W0
02170:  CPSGT   W1,W0
02172:  BRA     215E
02174:  MOV     962,W0
02176:  MOV     #0,W4
02178:  CALL    1596
0217C:  BTSC.B  219.1
0217E:  BRA     217C
02180:  MOV.B   #20,W0L
02182:  MOV.B   W0L,21A
02184:  BTSC.B  219.1
02186:  BRA     2184
02188:  MOV.B   #A,W0L
0218A:  MOV.B   W0L,21A
0218C:  BTSC.B  219.1
0218E:  BRA     218C
02190:  MOV.B   #D,W0L
02192:  MOV.B   W0L,21A
....................     
....................    return conv_const; 
02194:  PUSH    962
02196:  POP     0
02198:  RETURN  
.................... } 
.................... // Returns the backlash of the system 
.................... unsigned int16 data_get_backlash() 
*
020AC:  PUSH    8EE
020AE:  POP     978
020B0:  CALL    1F96
020B4:  MOV     W0,962
.................... { 
....................    unsigned int16 backlash = fr_read(fr_backlash); 
....................  
....................    if(debug_mode_fr)  
020B6:  BTSS.B  8B0.2
020B8:  BRA     20F2
....................       fprintf(RS232, "Backlash: %u counts\n\r", backlash); 
020BA:  MOV     #0,W1
020BC:  MOV     W1,W0
020BE:  CLR.B   1
020C0:  CALL    3D8
020C4:  INC     W1,W1
020C6:  BTSC.B  219.1
020C8:  BRA     20C6
020CA:  MOV.B   W0L,21A
020CC:  MOV     #9,W0
020CE:  CPSGT   W1,W0
020D0:  BRA     20BC
020D2:  MOV     962,W0
020D4:  MOV     #0,W4
020D6:  CALL    1596
020DA:  MOV     #C,W1
020DC:  MOV     W1,W0
020DE:  CLR.B   1
020E0:  CALL    3D8
020E4:  INC     W1,W1
020E6:  BTSC.B  219.1
020E8:  BRA     20E6
020EA:  MOV.B   W0L,21A
020EC:  MOV     #14,W0
020EE:  CPSGT   W1,W0
020F0:  BRA     20DC
....................     
....................    return backlash; 
020F2:  PUSH    962
020F4:  POP     0
020F6:  RETURN  
.................... } 
.................... // Returns communication type 
.................... unsigned int8 data_get_comm_type() 
*
030F6:  PUSH    8F0
030F8:  POP     986
030FA:  CALL    1F12
030FE:  MOV.B   W0L,962
.................... { 
....................    unsigned int8 comm_type=fr_read_byte(fr_comm_type); 
....................     
....................    if(debug_mode_fr) 
03100:  BTSS.B  8B0.2
03102:  BRA     3166
....................       switch (comm_type) 
03104:  MOV.B   962,W0L
03106:  CLR.B   1
03108:  XOR     #0,W0
0310A:  BRA     Z,3112
0310C:  XOR     #1,W0
0310E:  BRA     Z,312E
03110:  BRA     314A
....................       { 
....................          case 0   :  fprintf(RS232,"Communication Type: Parallel Port\n\r"); 
03112:  MOV     #0,W1
03114:  MOV     W1,W0
03116:  CLR.B   1
03118:  CALL    3FA
0311C:  INC     W1,W1
0311E:  BTSC.B  219.1
03120:  BRA     311E
03122:  MOV.B   W0L,21A
03124:  MOV     #22,W0
03126:  CPSGT   W1,W0
03128:  BRA     3114
....................                      break; 
0312A:  GOTO    3166
....................          case 1   :  fprintf(RS232,"Communication Type: Serial Port\n\r"); 
0312E:  MOV     #0,W1
03130:  MOV     W1,W0
03132:  CLR.B   1
03134:  CALL    42A
03138:  INC     W1,W1
0313A:  BTSC.B  219.1
0313C:  BRA     313A
0313E:  MOV.B   W0L,21A
03140:  MOV     #20,W0
03142:  CPSGT   W1,W0
03144:  BRA     3130
....................                      break; 
03146:  GOTO    3166
....................          default  :  fprintf(RS232,"Communication Type: Undefined\n\r"); 
0314A:  MOV     #0,W1
0314C:  MOV     W1,W0
0314E:  CLR.B   1
03150:  CALL    458
03154:  INC     W1,W1
03156:  BTSC.B  219.1
03158:  BRA     3156
0315A:  MOV.B   W0L,21A
0315C:  MOV     #1E,W0
0315E:  CPSGT   W1,W0
03160:  BRA     314C
....................                      break; 
03162:  GOTO    3166
....................       } 
....................        
....................    return comm_type; 
03166:  MOV.B   962,W0L
03168:  MOV.B   W0L,0
0316A:  RETURN  
.................... } 
.................... // Returns last position 
.................... unsigned int16 data_get_last_pos() 
*
02544:  PUSH    8F2
02546:  POP     978
02548:  CALL    1F96
0254C:  MOV     W0,962
.................... { 
....................    unsigned int16 position=fr_read(fr_last_pos); 
....................     
....................    if(debug_mode_fr)  
0254E:  BTSS.B  8B0.2
02550:  BRA     258A
....................       fprintf(RS232, "Last Position: %u mm\n\r", position); 
02552:  MOV     #0,W1
02554:  MOV     W1,W0
02556:  CLR.B   1
02558:  CALL    484
0255C:  INC     W1,W1
0255E:  BTSC.B  219.1
02560:  BRA     255E
02562:  MOV.B   W0L,21A
02564:  MOV     #E,W0
02566:  CPSGT   W1,W0
02568:  BRA     2554
0256A:  MOV     962,W0
0256C:  MOV     #0,W4
0256E:  CALL    1596
02572:  MOV     #11,W1
02574:  MOV     W1,W0
02576:  CLR.B   1
02578:  CALL    484
0257C:  INC     W1,W1
0257E:  BTSC.B  219.1
02580:  BRA     257E
02582:  MOV.B   W0L,21A
02584:  MOV     #15,W0
02586:  CPSGT   W1,W0
02588:  BRA     2574
....................     
....................    return position; 
0258A:  PUSH    962
0258C:  POP     0
0258E:  RETURN  
.................... } 
.................... // Returns the position in the given index 
.................... unsigned int16 data_get_pos(unsigned int8 index) 
*
03742:  MOV     W5,[W15++]
03744:  MOV.B   96A,W0L
03746:  CLR.B   1
03748:  SL      W0,#1,W0
0374A:  MOV     8F4,W4
0374C:  ADD     W0,W4,W5
0374E:  MOV     W5,978
03750:  CALL    1F96
03754:  MOV     W0,96C
.................... { 
....................    unsigned int16 position=fr_read(fr_pos_table+index*2); 
....................     
....................    if(debug_mode_fr) 
03756:  BTSS.B  8B0.2
03758:  BRA     37B4
....................       fprintf(RS232,"Index: %u, Position: %u mm\n\r", index, position); 
0375A:  MOV     #0,W1
0375C:  MOV     W1,W0
0375E:  CLR.B   1
03760:  CALL    4A8
03764:  INC     W1,W1
03766:  BTSC.B  219.1
03768:  BRA     3766
0376A:  MOV.B   W0L,21A
0376C:  MOV     #6,W0
0376E:  CPSGT   W1,W0
03770:  BRA     375C
03772:  MOV.B   96A,W0L
03774:  CLR.B   1
03776:  MOV     #0,W4
03778:  CALL    1596
0377C:  MOV     #9,W1
0377E:  MOV     W1,W0
03780:  CLR.B   1
03782:  CALL    4A8
03786:  INC     W1,W1
03788:  BTSC.B  219.1
0378A:  BRA     3788
0378C:  MOV.B   W0L,21A
0378E:  MOV     #14,W0
03790:  CPSGT   W1,W0
03792:  BRA     377E
03794:  MOV     96C,W0
03796:  MOV     #0,W4
03798:  CALL    1596
0379C:  MOV     #17,W1
0379E:  MOV     W1,W0
037A0:  CLR.B   1
037A2:  CALL    4A8
037A6:  INC     W1,W1
037A8:  BTSC.B  219.1
037AA:  BRA     37A8
037AC:  MOV.B   W0L,21A
037AE:  MOV     #1B,W0
037B0:  CPSGT   W1,W0
037B2:  BRA     379E
....................     
....................    return position; 
037B4:  PUSH    96C
037B6:  POP     0
037B8:  MOV     [--W15],W5
037BA:  RETURN  
.................... } 
.................... // Returns position table via RS232 
.................... void data_get_pos_table() 
*
03EDC:  MOV     W5,[W15++]
.................... { 
....................    debug_mode_fr=1; 
03EDE:  BSET.B  8B0.2
....................     
....................    unsigned int input; 
....................    unsigned int i; 
....................    unsigned int index; 
....................     
....................    input=(unsigned)(fgetc(RS232)-48); 
03EE0:  BTSS.B  218.0
03EE2:  BRA     3EE0
03EE4:  MOV     21C,W0
03EE6:  ZE      W0,W0
03EE8:  CLR.B   1
03EEA:  SUB     #30,W0
03EEC:  MOV     W0,962
....................    fputc(input+48,RS232); 
03EEE:  MOV     #30,W4
03EF0:  MOV     962,W3
03EF2:  ADD     W3,W4,W5
03EF4:  MOV.B   W5L,W0L
03EF6:  BTSC.B  219.1
03EF8:  BRA     3EF6
03EFA:  MOV.B   W0L,21A
03EFC:  CLR.B   21B
....................  
....................    if(input>9) 
03EFE:  MOV     962,W4
03F00:  CP      W4,#9
03F02:  BRA     LEU,3F08
....................       input=9; 
03F04:  MOV     #9,W4
03F06:  MOV     W4,962
....................  
....................    fprintf(RS232,"\n\r"); 
03F08:  BTSC.B  219.1
03F0A:  BRA     3F08
03F0C:  MOV.B   #A,W0L
03F0E:  MOV.B   W0L,21A
03F10:  BTSC.B  219.1
03F12:  BRA     3F10
03F14:  MOV.B   #D,W0L
03F16:  MOV.B   W0L,21A
....................     
....................    for(i=0; i<10; i++) 
03F18:  CLR     964
03F1A:  MOV     964,W4
03F1C:  CP      W4,#A
03F1E:  BRA     C,3F3A
....................    { 
....................       index=input*10+i; 
03F20:  MOV     962,W4
03F22:  MUL.UU  W4,#A,W0
03F24:  MOV     W0,W5
03F26:  MOV     W5,W0
03F28:  ADD     964,W0
03F2A:  MOV     W0,966
....................       data_get_pos(index); 
03F2C:  MOV.B   966,W0L
03F2E:  MOV.B   W0L,96A
03F30:  CALL    3742
03F34:  INC     0964
03F36:  GOTO    3F1A
....................    } 
....................     
....................    debug_mode_fr=0; 
03F3A:  BCLR.B  8B0.2
03F3C:  MOV     [--W15],W5
03F3E:  RETURN  
.................... } 
.................... // Returns all system data via RS232 
.................... void data_get_sys_data() 
*
03DF2:  MOV     W5,[W15++]
.................... { 
....................    fprintf(RS232,"\n\r"); 
03DF4:  BTSC.B  219.1
03DF6:  BRA     3DF4
03DF8:  MOV.B   #A,W0L
03DFA:  MOV.B   W0L,21A
03DFC:  BTSC.B  219.1
03DFE:  BRA     3DFC
03E00:  MOV.B   #D,W0L
03E02:  MOV.B   W0L,21A
....................    fprintf(RS232,"______________________________________________________________\n\r"); 
03E04:  MOV.B   #3E,W5L
03E06:  MOV     #5F,W0
03E08:  BTSC.B  219.1
03E0A:  BRA     3E08
03E0C:  MOV.B   W0L,21A
03E0E:  DEC.B   000A
03E10:  BTSS.B  42.1
03E12:  BRA     3E06
03E14:  BTSC.B  219.1
03E16:  BRA     3E14
03E18:  MOV.B   #A,W0L
03E1A:  MOV.B   W0L,21A
03E1C:  BTSC.B  219.1
03E1E:  BRA     3E1C
03E20:  MOV.B   #D,W0L
03E22:  MOV.B   W0L,21A
....................    fprintf(RS232,"MODESIS LASER POSITIONING SYSTEM\n\n\r"); 
03E24:  MOV     #0,W1
03E26:  MOV     W1,W0
03E28:  CLR.B   1
03E2A:  CALL    4D2
03E2E:  INC     W1,W1
03E30:  BTSC.B  219.1
03E32:  BRA     3E30
03E34:  MOV.B   W0L,21A
03E36:  MOV     #22,W0
03E38:  CPSGT   W1,W0
03E3A:  BRA     3E26
....................    debug_mode_fr=1; 
03E3C:  BSET.B  8B0.2
....................    data_get_serial_no(); 
03E3E:  CALL    3D78
....................    data_get_move_range(); 
03E42:  CALL    1FC8
....................    data_get_home_pos(); 
03E46:  CALL    2014
....................    data_get_end_pos(); 
03E4A:  CALL    2060
....................    data_get_conv_const(); 
03E4E:  CALL    213A
....................    data_get_backlash(); 
03E52:  CALL    20AC
....................    data_get_comm_type(); 
03E56:  CALL    30F6
....................    data_get_last_pos(); 
03E5A:  CALL    2544
....................    debug_mode_fr=0; 
03E5E:  BCLR.B  8B0.2
....................    fprintf(RS232,"\n\r"); 
03E60:  BTSC.B  219.1
03E62:  BRA     3E60
03E64:  MOV.B   #A,W0L
03E66:  MOV.B   W0L,21A
03E68:  BTSC.B  219.1
03E6A:  BRA     3E68
03E6C:  MOV.B   #D,W0L
03E6E:  MOV.B   W0L,21A
....................    fprintf(RS232,"RCON REGISTER VALUE SIFIRLANIYOR..."); 
03E70:  MOV     #0,W1
03E72:  MOV     W1,W0
03E74:  CLR.B   1
03E76:  CALL    502
03E7A:  INC     W1,W1
03E7C:  BTSC.B  219.1
03E7E:  BRA     3E7C
03E80:  MOV.B   W0L,21A
03E82:  MOV     #22,W0
03E84:  CPSGT   W1,W0
03E86:  BRA     3E72
....................    fprintf(RS232,"\n\r"); 
03E88:  BTSC.B  219.1
03E8A:  BRA     3E88
03E8C:  MOV.B   #A,W0L
03E8E:  MOV.B   W0L,21A
03E90:  BTSC.B  219.1
03E92:  BRA     3E90
03E94:  MOV.B   #D,W0L
03E96:  MOV.B   W0L,21A
....................    fprintf(RS232,"YENI RCON REGISTER VALUE(10'luk Tabanda):"); 
03E98:  MOV     #0,W1
03E9A:  MOV     W1,W0
03E9C:  CLR.B   1
03E9E:  CALL    532
03EA2:  INC     W1,W1
03EA4:  BTSC.B  219.1
03EA6:  BRA     3EA4
03EA8:  MOV.B   W0L,21A
03EAA:  MOV     #28,W0
03EAC:  CPSGT   W1,W0
03EAE:  BRA     3E9A
....................    fprintf(RS232,"%u",RCON); 
03EB0:  MOV     740,W0
03EB2:  MOV     #0,W4
03EB4:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
03EB8:  BTSC.B  219.1
03EBA:  BRA     3EB8
03EBC:  MOV.B   #A,W0L
03EBE:  MOV.B   W0L,21A
03EC0:  BTSC.B  219.1
03EC2:  BRA     3EC0
03EC4:  MOV.B   #D,W0L
03EC6:  MOV.B   W0L,21A
....................    fprintf(RS232,"\n\r"); 
03EC8:  BTSC.B  219.1
03ECA:  BRA     3EC8
03ECC:  MOV.B   #A,W0L
03ECE:  MOV.B   W0L,21A
03ED0:  BTSC.B  219.1
03ED2:  BRA     3ED0
03ED4:  MOV.B   #D,W0L
03ED6:  MOV.B   W0L,21A
03ED8:  MOV     [--W15],W5
03EDA:  RETURN  
.................... } 
.................... // Returns the reset register state of he microcontroller 
.................... void data_get_reset_state() 
*
01648:  MOV     W5,[W15++]
.................... { 
....................    fprintf(RS232,"RCON REGISTER VALUE(10'luk Tabanda):  "); 
0164A:  MOV     #0,W1
0164C:  MOV     W1,W0
0164E:  CLR.B   1
01650:  CALL    56A
01654:  INC     W1,W1
01656:  BTSC.B  219.1
01658:  BRA     1656
0165A:  MOV.B   W0L,21A
0165C:  MOV     #25,W0
0165E:  CPSGT   W1,W0
01660:  BRA     164C
....................    fprintf(RS232,"%u",RCON); 
01662:  MOV     740,W0
01664:  MOV     #0,W4
01666:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
0166A:  BTSC.B  219.1
0166C:  BRA     166A
0166E:  MOV.B   #A,W0L
01670:  MOV.B   W0L,21A
01672:  BTSC.B  219.1
01674:  BRA     1672
01676:  MOV.B   #D,W0L
01678:  MOV.B   W0L,21A
....................    fprintf(RS232,"RCON REGISTER BITLERI:"); 
0167A:  MOV     #0,W1
0167C:  MOV     W1,W0
0167E:  CLR.B   1
01680:  CALL    59E
01684:  INC     W1,W1
01686:  BTSC.B  219.1
01688:  BRA     1686
0168A:  MOV.B   W0L,21A
0168C:  MOV     #15,W0
0168E:  CPSGT   W1,W0
01690:  BRA     167C
....................    fprintf(RS232,"\n\r"); 
01692:  BTSC.B  219.1
01694:  BRA     1692
01696:  MOV.B   #A,W0L
01698:  MOV.B   W0L,21A
0169A:  BTSC.B  219.1
0169C:  BRA     169A
0169E:  MOV.B   #D,W0L
016A0:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"POR:    "); 
016A2:  MOV     #0,W1
016A4:  MOV     W1,W0
016A6:  CLR.B   1
016A8:  CALL    5C2
016AC:  INC     W1,W1
016AE:  BTSC.B  219.1
016B0:  BRA     16AE
016B2:  MOV.B   W0L,21A
016B4:  MOV     #7,W0
016B6:  CPSGT   W1,W0
016B8:  BRA     16A4
....................    fprintf(RS232,"%u",RCON_POR); 
016BA:  CLR.B   W0
016BC:  BTSC.B  740.0
016BE:  INC     W0,W0
016C0:  MOV.B   W0L,W5L
016C2:  MOV.B   W5L,W0L
016C4:  CLR.B   1
016C6:  MOV     #0,W4
016C8:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
016CC:  BTSC.B  219.1
016CE:  BRA     16CC
016D0:  MOV.B   #A,W0L
016D2:  MOV.B   W0L,21A
016D4:  BTSC.B  219.1
016D6:  BRA     16D4
016D8:  MOV.B   #D,W0L
016DA:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"BOR:    "); 
016DC:  MOV     #0,W1
016DE:  MOV     W1,W0
016E0:  CLR.B   1
016E2:  CALL    5D8
016E6:  INC     W1,W1
016E8:  BTSC.B  219.1
016EA:  BRA     16E8
016EC:  MOV.B   W0L,21A
016EE:  MOV     #7,W0
016F0:  CPSGT   W1,W0
016F2:  BRA     16DE
....................    fprintf(RS232,"%u",RCON_BOR); 
016F4:  CLR.B   W0
016F6:  BTSC.B  740.1
016F8:  INC     W0,W0
016FA:  MOV.B   W0L,W5L
016FC:  MOV.B   W5L,W0L
016FE:  CLR.B   1
01700:  MOV     #0,W4
01702:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
01706:  BTSC.B  219.1
01708:  BRA     1706
0170A:  MOV.B   #A,W0L
0170C:  MOV.B   W0L,21A
0170E:  BTSC.B  219.1
01710:  BRA     170E
01712:  MOV.B   #D,W0L
01714:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"IDLE:   "); 
01716:  MOV     #0,W1
01718:  MOV     W1,W0
0171A:  CLR.B   1
0171C:  CALL    5EE
01720:  INC     W1,W1
01722:  BTSC.B  219.1
01724:  BRA     1722
01726:  MOV.B   W0L,21A
01728:  MOV     #7,W0
0172A:  CPSGT   W1,W0
0172C:  BRA     1718
....................    fprintf(RS232,"%u",RCON_IDLE); 
0172E:  CLR.B   W0
01730:  BTSC.B  740.2
01732:  INC     W0,W0
01734:  MOV.B   W0L,W5L
01736:  MOV.B   W5L,W0L
01738:  CLR.B   1
0173A:  MOV     #0,W4
0173C:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
01740:  BTSC.B  219.1
01742:  BRA     1740
01744:  MOV.B   #A,W0L
01746:  MOV.B   W0L,21A
01748:  BTSC.B  219.1
0174A:  BRA     1748
0174C:  MOV.B   #D,W0L
0174E:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"SLEEP:  "); 
01750:  MOV     #0,W1
01752:  MOV     W1,W0
01754:  CLR.B   1
01756:  CALL    604
0175A:  INC     W1,W1
0175C:  BTSC.B  219.1
0175E:  BRA     175C
01760:  MOV.B   W0L,21A
01762:  MOV     #7,W0
01764:  CPSGT   W1,W0
01766:  BRA     1752
....................    fprintf(RS232,"%u",RCON_SLEEP); 
01768:  CLR.B   W0
0176A:  BTSC.B  740.3
0176C:  INC     W0,W0
0176E:  MOV.B   W0L,W5L
01770:  MOV.B   W5L,W0L
01772:  CLR.B   1
01774:  MOV     #0,W4
01776:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
0177A:  BTSC.B  219.1
0177C:  BRA     177A
0177E:  MOV.B   #A,W0L
01780:  MOV.B   W0L,21A
01782:  BTSC.B  219.1
01784:  BRA     1782
01786:  MOV.B   #D,W0L
01788:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"WDTO:   "); 
0178A:  MOV     #0,W1
0178C:  MOV     W1,W0
0178E:  CLR.B   1
01790:  CALL    61A
01794:  INC     W1,W1
01796:  BTSC.B  219.1
01798:  BRA     1796
0179A:  MOV.B   W0L,21A
0179C:  MOV     #7,W0
0179E:  CPSGT   W1,W0
017A0:  BRA     178C
....................    fprintf(RS232,"%u",RCON_WDTO); 
017A2:  CLR.B   W0
017A4:  BTSC.B  740.4
017A6:  INC     W0,W0
017A8:  MOV.B   W0L,W5L
017AA:  MOV.B   W5L,W0L
017AC:  CLR.B   1
017AE:  MOV     #0,W4
017B0:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
017B4:  BTSC.B  219.1
017B6:  BRA     17B4
017B8:  MOV.B   #A,W0L
017BA:  MOV.B   W0L,21A
017BC:  BTSC.B  219.1
017BE:  BRA     17BC
017C0:  MOV.B   #D,W0L
017C2:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"SWDTEN: "); 
017C4:  MOV     #0,W1
017C6:  MOV     W1,W0
017C8:  CLR.B   1
017CA:  CALL    630
017CE:  INC     W1,W1
017D0:  BTSC.B  219.1
017D2:  BRA     17D0
017D4:  MOV.B   W0L,21A
017D6:  MOV     #7,W0
017D8:  CPSGT   W1,W0
017DA:  BRA     17C6
....................    fprintf(RS232,"%u",RCON_SWDTEN); 
017DC:  CLR.B   W0
017DE:  BTSC.B  740.5
017E0:  INC     W0,W0
017E2:  MOV.B   W0L,W5L
017E4:  MOV.B   W5L,W0L
017E6:  CLR.B   1
017E8:  MOV     #0,W4
017EA:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
017EE:  BTSC.B  219.1
017F0:  BRA     17EE
017F2:  MOV.B   #A,W0L
017F4:  MOV.B   W0L,21A
017F6:  BTSC.B  219.1
017F8:  BRA     17F6
017FA:  MOV.B   #D,W0L
017FC:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"SWR:    "); 
017FE:  MOV     #0,W1
01800:  MOV     W1,W0
01802:  CLR.B   1
01804:  CALL    646
01808:  INC     W1,W1
0180A:  BTSC.B  219.1
0180C:  BRA     180A
0180E:  MOV.B   W0L,21A
01810:  MOV     #7,W0
01812:  CPSGT   W1,W0
01814:  BRA     1800
....................    fprintf(RS232,"%u",RCON_SWR); 
01816:  CLR.B   W0
01818:  BTSC.B  740.6
0181A:  INC     W0,W0
0181C:  MOV.B   W0L,W5L
0181E:  MOV.B   W5L,W0L
01820:  CLR.B   1
01822:  MOV     #0,W4
01824:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
01828:  BTSC.B  219.1
0182A:  BRA     1828
0182C:  MOV.B   #A,W0L
0182E:  MOV.B   W0L,21A
01830:  BTSC.B  219.1
01832:  BRA     1830
01834:  MOV.B   #D,W0L
01836:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"EXTR:   "); 
01838:  MOV     #0,W1
0183A:  MOV     W1,W0
0183C:  CLR.B   1
0183E:  CALL    65C
01842:  INC     W1,W1
01844:  BTSC.B  219.1
01846:  BRA     1844
01848:  MOV.B   W0L,21A
0184A:  MOV     #7,W0
0184C:  CPSGT   W1,W0
0184E:  BRA     183A
....................    fprintf(RS232,"%u",RCON_EXTR); 
01850:  CLR.B   W0
01852:  BTSC.B  740.7
01854:  INC     W0,W0
01856:  MOV.B   W0L,W5L
01858:  MOV.B   W5L,W0L
0185A:  CLR.B   1
0185C:  MOV     #0,W4
0185E:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
01862:  BTSC.B  219.1
01864:  BRA     1862
01866:  MOV.B   #A,W0L
01868:  MOV.B   W0L,21A
0186A:  BTSC.B  219.1
0186C:  BRA     186A
0186E:  MOV.B   #D,W0L
01870:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"BGST:   "); 
01872:  MOV     #0,W1
01874:  MOV     W1,W0
01876:  CLR.B   1
01878:  CALL    672
0187C:  INC     W1,W1
0187E:  BTSC.B  219.1
01880:  BRA     187E
01882:  MOV.B   W0L,21A
01884:  MOV     #7,W0
01886:  CPSGT   W1,W0
01888:  BRA     1874
....................    fprintf(RS232,"%u",RCON_BGST); 
0188A:  CLR.B   W0
0188C:  BTSC.B  741.5
0188E:  INC     W0,W0
01890:  MOV.B   W0L,W5L
01892:  MOV.B   W5L,W0L
01894:  CLR.B   1
01896:  MOV     #0,W4
01898:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
0189C:  BTSC.B  219.1
0189E:  BRA     189C
018A0:  MOV.B   #A,W0L
018A2:  MOV.B   W0L,21A
018A4:  BTSC.B  219.1
018A6:  BRA     18A4
018A8:  MOV.B   #D,W0L
018AA:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"IOPUWR: "); 
018AC:  MOV     #0,W1
018AE:  MOV     W1,W0
018B0:  CLR.B   1
018B2:  CALL    688
018B6:  INC     W1,W1
018B8:  BTSC.B  219.1
018BA:  BRA     18B8
018BC:  MOV.B   W0L,21A
018BE:  MOV     #7,W0
018C0:  CPSGT   W1,W0
018C2:  BRA     18AE
....................    fprintf(RS232,"%u",RCON_IOPUWR); 
018C4:  CLR.B   W0
018C6:  BTSC.B  741.6
018C8:  INC     W0,W0
018CA:  MOV.B   W0L,W5L
018CC:  MOV.B   W5L,W0L
018CE:  CLR.B   1
018D0:  MOV     #0,W4
018D2:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
018D6:  BTSC.B  219.1
018D8:  BRA     18D6
018DA:  MOV.B   #A,W0L
018DC:  MOV.B   W0L,21A
018DE:  BTSC.B  219.1
018E0:  BRA     18DE
018E2:  MOV.B   #D,W0L
018E4:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"TRAPR:  "); 
018E6:  MOV     #0,W1
018E8:  MOV     W1,W0
018EA:  CLR.B   1
018EC:  CALL    69E
018F0:  INC     W1,W1
018F2:  BTSC.B  219.1
018F4:  BRA     18F2
018F6:  MOV.B   W0L,21A
018F8:  MOV     #7,W0
018FA:  CPSGT   W1,W0
018FC:  BRA     18E8
....................    fprintf(RS232,"%u",RCON_TRAPR); 
018FE:  CLR.B   W0
01900:  BTSC.B  741.7
01902:  INC     W0,W0
01904:  MOV.B   W0L,W5L
01906:  MOV.B   W5L,W0L
01908:  CLR.B   1
0190A:  MOV     #0,W4
0190C:  CALL    1596
....................    fprintf(RS232,"\n\r"); 
01910:  BTSC.B  219.1
01912:  BRA     1910
01914:  MOV.B   #A,W0L
01916:  MOV.B   W0L,21A
01918:  BTSC.B  219.1
0191A:  BRA     1918
0191C:  MOV.B   #D,W0L
0191E:  MOV.B   W0L,21A
....................     
....................    fprintf(RS232,"Register Ekrana Yazdirilip Sifirlandi"); 
01920:  MOV     #0,W1
01922:  MOV     W1,W0
01924:  CLR.B   1
01926:  CALL    6B4
0192A:  INC     W1,W1
0192C:  BTSC.B  219.1
0192E:  BRA     192C
01930:  MOV.B   W0L,21A
01932:  MOV     #24,W0
01934:  CPSGT   W1,W0
01936:  BRA     1922
....................    fprintf(RS232,"\n\r"); 
01938:  BTSC.B  219.1
0193A:  BRA     1938
0193C:  MOV.B   #A,W0L
0193E:  MOV.B   W0L,21A
01940:  BTSC.B  219.1
01942:  BRA     1940
01944:  MOV.B   #D,W0L
01946:  MOV.B   W0L,21A
....................    RCON = 0x0000; 
01948:  CLR     740
0194A:  MOV     [--W15],W5
0194C:  RETURN  
.................... } 
....................  
.................... // Sets serial nuber of the device 
.................... void data_set_serial_no() 
*
0391C:  MOV     W5,[W15++]
0391E:  MOV     W6,[W15++]
03920:  CLR.B   962
.................... { 
....................    unsigned int8 i=0; 
....................    unsigned int8 input[13]; 
....................    for(i=0; i<13; i++) 
03922:  CLR.B   962
03924:  MOV     962,W4
03926:  CP.B    W4L,#D
03928:  BRA     C,397A
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
0392A:  MOV     962,W4
0392C:  CLR.B   9
0392E:  MOV     #964,W3
03930:  ADD     W4,W3,W5
03932:  BTSS.B  218.0
03934:  BRA     3932
03936:  MOV     21C,W0
03938:  SUB.B   #30,W0L
0393A:  MOV.B   W0L,[W5+#0]
....................       fr_write_byte(fr_serial_no+i, input[i]); 
0393C:  MOV     962,W4
0393E:  CLR.B   9
03940:  MOV     8E4,W3
03942:  ADD     W3,W4,W5
03944:  MOV     962,W4
03946:  CLR.B   9
03948:  MOV     #964,W3
0394A:  ADD     W4,W3,W0
0394C:  MOV.B   [W0],W6L
0394E:  PUSH    984
03950:  MOV.B   W6L,[W15-#2]
03952:  POP     984
03954:  MOV     W5,982
03956:  CALL    2590
....................       fputc(input[i]+48,RS232); 
0395A:  MOV     962,W4
0395C:  CLR.B   9
0395E:  MOV     #964,W3
03960:  ADD     W4,W3,W0
03962:  MOV.B   [W0],W4L
03964:  CLR.B   9
03966:  MOV     #30,W3
03968:  ADD     W4,W3,W5
0396A:  MOV.B   W5L,W0L
0396C:  BTSC.B  219.1
0396E:  BRA     396C
03970:  MOV.B   W0L,21A
03972:  CLR.B   21B
03974:  INC.B   0962
03976:  GOTO    3924
....................    } 
0397A:  MOV     [--W15],W6
0397C:  MOV     [--W15],W5
0397E:  RETURN  
.................... } 
.................... // Sets movement range of the device 
.................... void data_set_move_range() 
03980:  MOV     W5,[W15++]
03982:  MOV     W6,[W15++]
03984:  CLR.B   962
.................... { 
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0;i<4;i++) 
03986:  CLR.B   962
03988:  MOV     962,W4
0398A:  CP.B    W4L,#4
0398C:  BRA     C,39C4
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
0398E:  MOV.B   962,W0L
03990:  CLR.B   1
03992:  SL      W0,#1,W0
03994:  MOV     #964,W4
03996:  ADD     W0,W4,W5
03998:  BTSS.B  218.0
0399A:  BRA     3998
0399C:  MOV     21C,W0
0399E:  ZE      W0,W0
039A0:  CLR.B   1
039A2:  SUB     #30,W0
039A4:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
039A6:  MOV.B   962,W0L
039A8:  CLR.B   1
039AA:  SL      W0,#1,W0
039AC:  MOV     #964,W4
039AE:  ADD     W0,W4,W0
039B0:  MOV     [W0],W5
039B2:  ADD     #30,W5
039B4:  MOV.B   W5L,W0L
039B6:  BTSC.B  219.1
039B8:  BRA     39B6
039BA:  MOV.B   W0L,21A
039BC:  CLR.B   21B
039BE:  INC.B   0962
039C0:  GOTO    3988
....................    } 
....................    unsigned int range=1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
039C4:  MOV     #3E8,W4
039C6:  MOV     964,W3
039C8:  MUL.UU  W4,W3,W0
039CA:  MOV     W0,W5
039CC:  MOV     #64,W4
039CE:  MOV     966,W3
039D0:  MUL.UU  W4,W3,W0
039D2:  ADD     W0,W5,W5
039D4:  MOV     968,W4
039D6:  MUL.UU  W4,#A,W0
039D8:  ADD     W0,W5,W5
039DA:  MOV     W5,W0
039DC:  ADD     96A,W0
039DE:  MOV     W0,96C
....................     
....................    if(range<400) 
039E0:  MOV     96C,W4
039E2:  MOV     #190,W3
039E4:  CP      W3,W4
039E6:  BRA     LEU,3A08
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be smaller than 400 mm. Movement range is set to 400 mm."); 
039E8:  MOV     #0,W1
039EA:  MOV     W1,W0
039EC:  CLR.B   1
039EE:  CALL    6E6
039F2:  INC     W1,W1
039F4:  BTSC.B  219.1
039F6:  BRA     39F4
039F8:  MOV.B   W0L,21A
039FA:  MOV     #5E,W0
039FC:  CPSGT   W1,W0
039FE:  BRA     39EA
....................       range=400; 
03A00:  MOV     #190,W4
03A02:  MOV     W4,96C
....................    } 
03A04:  GOTO    3A2C
....................    else if(range>2000) 
03A08:  MOV     96C,W4
03A0A:  MOV     #7D0,W3
03A0C:  CP      W3,W4
03A0E:  BRA     C,3A2C
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Movement range cannot be larger than 2000 mm. Movement range is set to 2000 mm."); 
03A10:  MOV     #0,W1
03A12:  MOV     W1,W0
03A14:  CLR.B   1
03A16:  CALL    742
03A1A:  INC     W1,W1
03A1C:  BTSC.B  219.1
03A1E:  BRA     3A1C
03A20:  MOV.B   W0L,21A
03A22:  MOV     #5F,W0
03A24:  CPSGT   W1,W0
03A26:  BRA     3A12
....................       range=2000; 
03A28:  MOV     #7D0,W4
03A2A:  MOV     W4,96C
....................    } 
....................     
....................    if(range==2000) 
03A2C:  MOV     96C,W4
03A2E:  MOV     #7D0,W3
03A30:  CP      W3,W4
03A32:  BRA     NZ,3A3C
....................       md_min_distance=120; 
03A34:  MOV     #78,W4
03A36:  MOV     W4,8C8
03A38:  GOTO    3A40
....................    else 
....................       md_min_distance=70; 
03A3C:  MOV     #46,W4
03A3E:  MOV     W4,8C8
....................        
....................    fr_write(fr_move_range, range); 
03A40:  PUSH    8E6
03A42:  POP     976
03A44:  PUSH    96C
03A46:  POP     978
03A48:  CALL    2672
....................    md_move_range=range; 
03A4C:  PUSH    96C
03A4E:  POP     8BE
03A50:  MOV     [--W15],W6
03A52:  MOV     [--W15],W5
03A54:  RETURN  
.................... } 
.................... // Sets home position 
.................... void data_set_home_pos() 
03A56:  MOV     W5,[W15++]
03A58:  MOV     W6,[W15++]
03A5A:  CLR.B   962
.................... { 
....................    unsigned int8 i=0; 
....................    unsigned int input[4]; 
....................    for(i=0; i<4; i++) 
03A5C:  CLR.B   962
03A5E:  MOV     962,W4
03A60:  CP.B    W4L,#4
03A62:  BRA     C,3A9A
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03A64:  MOV.B   962,W0L
03A66:  CLR.B   1
03A68:  SL      W0,#1,W0
03A6A:  MOV     #964,W4
03A6C:  ADD     W0,W4,W5
03A6E:  BTSS.B  218.0
03A70:  BRA     3A6E
03A72:  MOV     21C,W0
03A74:  ZE      W0,W0
03A76:  CLR.B   1
03A78:  SUB     #30,W0
03A7A:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03A7C:  MOV.B   962,W0L
03A7E:  CLR.B   1
03A80:  SL      W0,#1,W0
03A82:  MOV     #964,W4
03A84:  ADD     W0,W4,W0
03A86:  MOV     [W0],W5
03A88:  ADD     #30,W5
03A8A:  MOV.B   W5L,W0L
03A8C:  BTSC.B  219.1
03A8E:  BRA     3A8C
03A90:  MOV.B   W0L,21A
03A92:  CLR.B   21B
03A94:  INC.B   0962
03A96:  GOTO    3A5E
....................    } 
....................    unsigned int home_pos = 1000*input[0]+100*input[1]+10*input[2]+1*input[3]; 
03A9A:  MOV     #3E8,W4
03A9C:  MOV     964,W3
03A9E:  MUL.UU  W4,W3,W0
03AA0:  MOV     W0,W5
03AA2:  MOV     #64,W4
03AA4:  MOV     966,W3
03AA6:  MUL.UU  W4,W3,W0
03AA8:  ADD     W0,W5,W5
03AAA:  MOV     968,W4
03AAC:  MUL.UU  W4,#A,W0
03AAE:  ADD     W0,W5,W5
03AB0:  MOV     W5,W0
03AB2:  ADD     96A,W0
03AB4:  MOV     W0,96C
....................     
....................    if(home_pos<10) 
03AB6:  MOV     96C,W4
03AB8:  CP      W4,#A
03ABA:  BRA     C,3AD6
....................    { 
....................       fprintf(RS232, "\n\rInvalid entry: Home position cannot be smaller than 10. Home position is not changed"); 
03ABC:  MOV     #0,W1
03ABE:  MOV     W1,W0
03AC0:  CLR.B   1
03AC2:  CALL    7A0
03AC6:  INC     W1,W1
03AC8:  BTSC.B  219.1
03ACA:  BRA     3AC8
03ACC:  MOV.B   W0L,21A
03ACE:  MOV     #55,W0
03AD0:  CPSGT   W1,W0
03AD2:  BRA     3ABE
....................       return; 
03AD4:  BRA     3AE6
....................    } 
....................     
....................    fr_write(fr_home_pos,home_pos); 
03AD6:  PUSH    8E8
03AD8:  POP     976
03ADA:  PUSH    96C
03ADC:  POP     978
03ADE:  CALL    2672
....................    md_home_pos=home_pos; 
03AE2:  PUSH    96C
03AE4:  POP     8C0
03AE6:  MOV     [--W15],W6
03AE8:  MOV     [--W15],W5
03AEA:  RETURN  
.................... } 
.................... // Sets end position 
.................... void data_set_end_pos() 
03AEC:  MOV     W5,[W15++]
03AEE:  MOV     W6,[W15++]
03AF0:  CLR.B   962
.................... { 
....................    unsigned int8 i=0; 
....................    unsigned int input[5]; 
....................    for(i=0; i<5; i++) 
03AF2:  CLR.B   962
03AF4:  MOV     962,W4
03AF6:  CP.B    W4L,#5
03AF8:  BRA     C,3B30
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03AFA:  MOV.B   962,W0L
03AFC:  CLR.B   1
03AFE:  SL      W0,#1,W0
03B00:  MOV     #964,W4
03B02:  ADD     W0,W4,W5
03B04:  BTSS.B  218.0
03B06:  BRA     3B04
03B08:  MOV     21C,W0
03B0A:  ZE      W0,W0
03B0C:  CLR.B   1
03B0E:  SUB     #30,W0
03B10:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03B12:  MOV.B   962,W0L
03B14:  CLR.B   1
03B16:  SL      W0,#1,W0
03B18:  MOV     #964,W4
03B1A:  ADD     W0,W4,W0
03B1C:  MOV     [W0],W5
03B1E:  ADD     #30,W5
03B20:  MOV.B   W5L,W0L
03B22:  BTSC.B  219.1
03B24:  BRA     3B22
03B26:  MOV.B   W0L,21A
03B28:  CLR.B   21B
03B2A:  INC.B   0962
03B2C:  GOTO    3AF4
....................    } 
....................    unsigned int end=10000*input[0]+1000*input[1]+100*input[2]+10*input[3]+1*input[4]; 
03B30:  MOV     #2710,W4
03B32:  MOV     964,W3
03B34:  MUL.UU  W4,W3,W0
03B36:  MOV     W0,W5
03B38:  MOV     #3E8,W4
03B3A:  MOV     966,W3
03B3C:  MUL.UU  W4,W3,W0
03B3E:  ADD     W0,W5,W5
03B40:  MOV     #64,W4
03B42:  MOV     968,W3
03B44:  MUL.UU  W4,W3,W0
03B46:  ADD     W0,W5,W5
03B48:  MOV     96A,W4
03B4A:  MUL.UU  W4,#A,W0
03B4C:  ADD     W0,W5,W5
03B4E:  MOV     W5,W0
03B50:  ADD     96C,W0
03B52:  MOV     W0,96E
....................     
....................    if(end<md_home_pos) 
03B54:  MOV     96E,W0
03B56:  MOV     8C0,W4
03B58:  CP      W4,W0
03B5A:  BRA     LEU,3B80
....................    { 
....................       end=data_get_home_pos()+50; 
03B5C:  CALL    2014
03B60:  MOV     W0,W5
03B62:  MOV     #32,W4
03B64:  ADD     W5,W4,W0
03B66:  MOV     W0,96E
....................       fprintf(RS232, "\n\rInvalid entry: End position cannot be smaller than home position. End position is set to its default."); 
03B68:  MOV     #0,W1
03B6A:  MOV     W1,W0
03B6C:  CLR.B   1
03B6E:  CALL    7F6
03B72:  INC     W1,W1
03B74:  BTSC.B  219.1
03B76:  BRA     3B74
03B78:  MOV.B   W0L,21A
03B7A:  MOV     #66,W0
03B7C:  CPSGT   W1,W0
03B7E:  BRA     3B6A
....................    } 
....................     
....................    fr_write(fr_end_pos,end); 
03B80:  PUSH    8EA
03B82:  POP     976
03B84:  PUSH    96E
03B86:  POP     978
03B88:  CALL    2672
....................    md_end_pos=end; 
03B8C:  PUSH    96E
03B8E:  POP     8C2
03B90:  MOV     [--W15],W6
03B92:  MOV     [--W15],W5
03B94:  RETURN  
.................... } 
.................... // Sets positioning velocity 
.................... void data_set_conv_const() 
03B96:  MOV     W5,[W15++]
03B98:  MOV     W6,[W15++]
.................... { 
....................    md_conv_const = 12500; 
03B9A:  MOV     #30D4,W4
03B9C:  MOV     W4,8BC
....................    md_cc_step = 0; 
03B9E:  CLR     8DE
....................    md_cc_count = 0; 
03BA0:  CLR     8E0
....................     
....................    move_pos(md_min_distance); 
03BA2:  PUSH    8C8
03BA4:  POP     968
03BA6:  CALL    2DC8
....................  
....................    unsigned int cc_first_count = qei_get_count(); 
03BAA:  CALL    2262
03BAE:  MOV     W0,962
....................     
....................    reg_md_cc_sample =1; 
03BB0:  BSET.B  8FE.3
....................    move_pos(md_move_range); 
03BB2:  PUSH    8BE
03BB4:  POP     968
03BB6:  CALL    2DC8
....................     
....................    unsigned int conv_const = ((float)(cc_first_count - md_cc_count)/(float)md_cc_step)*10000; 
03BBA:  MOV     962,W4
03BBC:  MOV     8E0,W3
03BBE:  SUB     W4,W3,W0
03BC0:  CALL    26AC
03BC4:  MOV     W0,W5
03BC6:  MOV     W1,W6
03BC8:  MOV     8DE,W0
03BCA:  CALL    26AC
03BCE:  MOV     W0,W2
03BD0:  MOV     W1,W3
03BD2:  MOV     W5,W0
03BD4:  MOV     W6,W1
03BD6:  CALL    26E6
03BDA:  MOV     W0,W5
03BDC:  MOV     W1,W6
03BDE:  MOV     W5,W0
03BE0:  MOV     W6,W1
03BE2:  MOV     #4000,W2
03BE4:  MOV     #461C,W3
03BE6:  CALL    27B0
03BEA:  CALL    2A1E
03BEE:  MOV     W0,964
....................  
....................    fprintf(RS232, "Count: %u counts\n\r", cc_first_count-md_cc_count); 
03BF0:  MOV     962,W4
03BF2:  MOV     8E0,W3
03BF4:  SUB     W4,W3,W5
03BF6:  MOV     #0,W1
03BF8:  MOV     W1,W0
03BFA:  CLR.B   1
03BFC:  CALL    858
03C00:  INC     W1,W1
03C02:  BTSC.B  219.1
03C04:  BRA     3C02
03C06:  MOV.B   W0L,21A
03C08:  MOV     #6,W0
03C0A:  CPSGT   W1,W0
03C0C:  BRA     3BF8
03C0E:  MOV     W5,W0
03C10:  MOV     #0,W4
03C12:  CALL    1596
03C16:  MOV     #9,W1
03C18:  MOV     W1,W0
03C1A:  CLR.B   1
03C1C:  CALL    858
03C20:  INC     W1,W1
03C22:  BTSC.B  219.1
03C24:  BRA     3C22
03C26:  MOV.B   W0L,21A
03C28:  MOV     #11,W0
03C2A:  CPSGT   W1,W0
03C2C:  BRA     3C18
....................    fprintf(RS232, "Step: %u steps\n\r", md_cc_step); 
03C2E:  MOV     #0,W1
03C30:  MOV     W1,W0
03C32:  CLR.B   1
03C34:  CALL    878
03C38:  INC     W1,W1
03C3A:  BTSC.B  219.1
03C3C:  BRA     3C3A
03C3E:  MOV.B   W0L,21A
03C40:  MOV     #5,W0
03C42:  CPSGT   W1,W0
03C44:  BRA     3C30
03C46:  MOV     8DE,W0
03C48:  MOV     #0,W4
03C4A:  CALL    1596
03C4E:  MOV     #8,W1
03C50:  MOV     W1,W0
03C52:  CLR.B   1
03C54:  CALL    878
03C58:  INC     W1,W1
03C5A:  BTSC.B  219.1
03C5C:  BRA     3C5A
03C5E:  MOV.B   W0L,21A
03C60:  MOV     #F,W0
03C62:  CPSGT   W1,W0
03C64:  BRA     3C50
....................    fprintf(RS232, "Conversion Constant: %u counts\n\r", conv_const); 
03C66:  MOV     #0,W1
03C68:  MOV     W1,W0
03C6A:  CLR.B   1
03C6C:  CALL    896
03C70:  INC     W1,W1
03C72:  BTSC.B  219.1
03C74:  BRA     3C72
03C76:  MOV.B   W0L,21A
03C78:  MOV     #14,W0
03C7A:  CPSGT   W1,W0
03C7C:  BRA     3C68
03C7E:  MOV     964,W0
03C80:  MOV     #0,W4
03C82:  CALL    1596
03C86:  MOV     #17,W1
03C88:  MOV     W1,W0
03C8A:  CLR.B   1
03C8C:  CALL    896
03C90:  INC     W1,W1
03C92:  BTSC.B  219.1
03C94:  BRA     3C92
03C96:  MOV.B   W0L,21A
03C98:  MOV     #1F,W0
03C9A:  CPSGT   W1,W0
03C9C:  BRA     3C88
....................    
....................    fr_write(fr_conv_const,conv_const); 
03C9E:  PUSH    8EC
03CA0:  POP     976
03CA2:  PUSH    964
03CA4:  POP     978
03CA6:  CALL    2672
....................    md_conv_const = conv_const; 
03CAA:  PUSH    964
03CAC:  POP     8BC
03CAE:  MOV     [--W15],W6
03CB0:  MOV     [--W15],W5
03CB2:  RETURN  
.................... } 
.................... // Sets backlash 
.................... void data_set_backlash() 
03CB4:  MOV     W5,[W15++]
03CB6:  MOV     W6,[W15++]
03CB8:  CLR.B   962
.................... { 
....................    unsigned int8 i=0; 
....................    unsigned int input[2]; 
....................    for(i=0; i<2; i++) 
03CBA:  CLR.B   962
03CBC:  MOV     962,W4
03CBE:  CP.B    W4L,#2
03CC0:  BRA     C,3CF8
....................    { 
....................       input[i]=(unsigned)(fgetc(RS232)-48); 
03CC2:  MOV.B   962,W0L
03CC4:  CLR.B   1
03CC6:  SL      W0,#1,W0
03CC8:  MOV     #964,W4
03CCA:  ADD     W0,W4,W5
03CCC:  BTSS.B  218.0
03CCE:  BRA     3CCC
03CD0:  MOV     21C,W0
03CD2:  ZE      W0,W0
03CD4:  CLR.B   1
03CD6:  SUB     #30,W0
03CD8:  MOV     W0,[W5]
....................       fputc(input[i]+48,RS232); 
03CDA:  MOV.B   962,W0L
03CDC:  CLR.B   1
03CDE:  SL      W0,#1,W0
03CE0:  MOV     #964,W4
03CE2:  ADD     W0,W4,W0
03CE4:  MOV     [W0],W5
03CE6:  ADD     #30,W5
03CE8:  MOV.B   W5L,W0L
03CEA:  BTSC.B  219.1
03CEC:  BRA     3CEA
03CEE:  MOV.B   W0L,21A
03CF0:  CLR.B   21B
03CF2:  INC.B   0962
03CF4:  GOTO    3CBC
....................    } 
....................    unsigned int backlash = 10*input[0]+1*input[1]; 
03CF8:  MOV     964,W4
03CFA:  MUL.UU  W4,#A,W0
03CFC:  MOV     W0,W5
03CFE:  MOV     W5,W0
03D00:  ADD     966,W0
03D02:  MOV     W0,968
....................     
....................    fr_write(fr_backlash,backlash); 
03D04:  PUSH    8EE
03D06:  POP     976
03D08:  PUSH    968
03D0A:  POP     978
03D0C:  CALL    2672
....................    md_backlash = backlash; 
03D10:  PUSH    968
03D12:  POP     8DC
03D14:  MOV     [--W15],W6
03D16:  MOV     [--W15],W5
03D18:  RETURN  
.................... } 
.................... // Sets communication type 
.................... void data_set_comm_type() 
03D1A:  MOV     W5,[W15++]
03D1C:  BTSS.B  218.0
03D1E:  BRA     3D1C
03D20:  MOV     21C,W0
03D22:  SUB.B   #30,W0L
03D24:  MOV.B   W0L,962
.................... { 
....................    unsigned int8 input=(unsigned)(fgetc(RS232)-48); 
....................    fputc(input+48,RS232); 
03D26:  MOV     962,W4
03D28:  CLR.B   9
03D2A:  MOV     #30,W3
03D2C:  ADD     W4,W3,W5
03D2E:  MOV.B   W5L,W0L
03D30:  BTSC.B  219.1
03D32:  BRA     3D30
03D34:  MOV.B   W0L,21A
03D36:  CLR.B   21B
....................    switch (input) 
03D38:  MOV.B   962,W0L
03D3A:  CLR.B   1
03D3C:  XOR     #1,W0
03D3E:  BRA     Z,3D46
03D40:  XOR     #1,W0
03D42:  BRA     Z,3D5E
03D44:  BRA     3D5E
....................    { 
....................       case 1   :  output_low(PP_ACK); 
03D46:  BCLR.B  2D2.4
03D48:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
03D4A:  BCLR.B  2D2.5
03D4C:  BCLR.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 1); 
03D4E:  MOV.B   #1,W0L
03D50:  MOV.B   W0L,984
03D52:  PUSH    8F0
03D54:  POP     982
03D56:  CALL    2590
....................                   break; 
03D5A:  GOTO    3D74
....................       case 0   :     
....................       default  :  output_high(PP_ACK); 
03D5E:  BCLR.B  2D2.4
03D60:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
03D62:  BCLR.B  2D2.5
03D64:  BSET.B  2D6.5
....................                    
....................                   fr_write_byte(fr_comm_type, 0); 
03D66:  CLR.B   984
03D68:  PUSH    8F0
03D6A:  POP     982
03D6C:  CALL    2590
....................                   break; 
03D70:  GOTO    3D74
....................    } 
03D74:  MOV     [--W15],W5
03D76:  RETURN  
.................... } 
.................... // Sets last position 
.................... void data_set_last_pos(unsigned int16 position) 
.................... { 
....................    fr_write(fr_last_pos, position); 
*
0269E:  PUSH    8F2
026A0:  POP     976
026A2:  PUSH    96E
026A4:  POP     978
026A6:  CALL    2672
026AA:  RETURN  
.................... } 
.................... // Sets position to given index 
.................... void data_set_pos(unsigned int8 index, unsigned int16 position) 
*
03636:  MOV     W5,[W15++]
.................... { 
....................    fr_write(fr_pos_table+index*2, position); 
03638:  MOV.B   966,W0L
0363A:  CLR.B   1
0363C:  SL      W0,#1,W0
0363E:  MOV     8F4,W4
03640:  ADD     W0,W4,W5
03642:  MOV     W5,976
03644:  PUSH    968
03646:  POP     978
03648:  CALL    2672
0364C:  MOV     [--W15],W5
0364E:  RETURN  
.................... } 
....................  
.................... // Initializes the quadrature encoder interface module by using default values 
.................... void qei_init() 
.................... { 
....................    // Disable QEI module  
....................    QEI_QEICON_QEIM0=0; 
*
0194E:  BCLR.B  123.0
....................    QEI_QEICON_QEIM1=0; 
01950:  BCLR.B  123.1
....................    QEI_QEICON_QEIM2=0; 
01952:  BCLR.B  123.2
....................    // Clear any count errors 
....................    QEI_QEICON_CNTERR=0; 
01954:  BCLR.B  123.7
....................    // Continue module operation during sleep 
....................    QEI_QEICON_QEISIDL=0; 
01956:  BCLR.B  123.5
....................    // QEA and QEB not swapped 
....................    QEI_QEICON_SWPAB=0; 
01958:  BCLR.B  122.7
....................    // Normal I/O pin operation 
....................    QEI_QEICON_PCDOUT=0; 
0195A:  BCLR.B  122.6
....................    // Timer gated time accumulation disabled 
....................    QEI_QEICON_TQGATE=0; 
0195C:  BCLR.B  122.5
....................    // 1:1 timer input clock prescale 
....................    QEI_QEICON_TQCKPS0=0; 
0195E:  BCLR.B  122.3
....................    QEI_QEICON_TQCKPS1=0; 
01960:  BCLR.B  122.4
....................    // Index pulse does not reset the position counter 
....................    QEI_QEICON_POSRES = 0; 
01962:  BCLR.B  122.2
....................    // Internal clock as timer clock source 
....................    QEI_QEICON_TQCS = 0; 
01964:  BCLR.B  122.1
....................    // QEI_QEICON_UPDN defines timer counter (QEI_POSCNT) direction 
....................    QEI_QEICON_UDSRC = 0; 
01966:  BCLR.B  122.0
....................     
....................    // Count error interrupts enabled 
....................    QEI_DFLTCON_CEID = 0;  
01968:  BCLR.B  125.0
....................    // Digital filter outputs enabled 
....................    QEI_DFLTCON_QEOUT = 0;  
0196A:  BCLR.B  124.7
....................    // 1:256 clock divide for digital filter 
....................    QEI_DFLTCON_QECK2 = 1; 
0196C:  BSET.B  124.6
....................    QEI_DFLTCON_QECK1 = 1; 
0196E:  BSET.B  124.5
....................    QEI_DFLTCON_QECK0 = 0; 
01970:  BCLR.B  124.4
....................     
....................    // Reset position counter 
....................    QEI_POSCNT = 0x0000; 
01972:  CLR     126
....................     
....................    // Set maximum count 
....................    QEI_MAXCNT = 0xFFFF; 
01974:  SETM    128
....................     
....................    // QEI module enabled in x4 mode with position counter reset by QEI_MAXCNT match 
....................    QEI_QEICON_QEIM2 = 1; 
01976:  BSET.B  123.2
....................    QEI_QEICON_QEIM1 = 1; 
01978:  BSET.B  123.1
....................    QEI_QEICON_QEIM0 = 1; 
0197A:  BSET.B  123.0
....................     
....................    if(debug_mode_qei) 
0197C:  BTSS.B  8B0.5
0197E:  BRA     1998
....................       fprintf(RS232,"Quadrature Encoder Initialized\n\n\r"); 
01980:  MOV     #0,W1
01982:  MOV     W1,W0
01984:  CLR.B   1
01986:  CALL    8C4
0198A:  INC     W1,W1
0198C:  BTSC.B  219.1
0198E:  BRA     198C
01990:  MOV.B   W0L,21A
01992:  MOV     #20,W0
01994:  CPSGT   W1,W0
01996:  BRA     1982
01998:  RETURN  
.................... } 
.................... // Sets the position counter to given value 
.................... void qei_set_count(unsigned int16 value) 
.................... {  
....................    QEI_POSCNT = value; 
*
02220:  PUSH    97E
02222:  POP     126
....................     
....................    if(debug_mode_qei) 
02224:  BTSS.B  8B0.5
02226:  BRA     2260
....................       fprintf(RS232,"Quadrature Encoder Count Set: %u\n\n\r", value); 
02228:  MOV     #0,W1
0222A:  MOV     W1,W0
0222C:  CLR.B   1
0222E:  CALL    8F2
02232:  INC     W1,W1
02234:  BTSC.B  219.1
02236:  BRA     2234
02238:  MOV.B   W0L,21A
0223A:  MOV     #1D,W0
0223C:  CPSGT   W1,W0
0223E:  BRA     222A
02240:  MOV     97E,W0
02242:  MOV     #0,W4
02244:  CALL    1596
02248:  BTSC.B  219.1
0224A:  BRA     2248
0224C:  MOV.B   #A,W0L
0224E:  MOV.B   W0L,21A
02250:  BTSC.B  219.1
02252:  BRA     2250
02254:  MOV.B   #A,W0L
02256:  MOV.B   W0L,21A
02258:  BTSC.B  219.1
0225A:  BRA     2258
0225C:  MOV.B   #D,W0L
0225E:  MOV.B   W0L,21A
02260:  RETURN  
.................... } 
.................... // Sets the maximum count to given value 
.................... void qei_set_max_count(unsigned int16 value) 
.................... {  
....................    QEI_MAXCNT = value; 
*
020F8:  PUSH    90C
020FA:  POP     128
....................     
....................    if(debug_mode_qei) 
020FC:  BTSS.B  8B0.5
020FE:  BRA     2138
....................       fprintf(RS232,"Quadrature Encoder Maximum Count Set: %u\n\n\r", value); 
02100:  MOV     #0,W1
02102:  MOV     W1,W0
02104:  CLR.B   1
02106:  CALL    922
0210A:  INC     W1,W1
0210C:  BTSC.B  219.1
0210E:  BRA     210C
02110:  MOV.B   W0L,21A
02112:  MOV     #25,W0
02114:  CPSGT   W1,W0
02116:  BRA     2102
02118:  MOV     90C,W0
0211A:  MOV     #0,W4
0211C:  CALL    1596
02120:  BTSC.B  219.1
02122:  BRA     2120
02124:  MOV.B   #A,W0L
02126:  MOV.B   W0L,21A
02128:  BTSC.B  219.1
0212A:  BRA     2128
0212C:  MOV.B   #A,W0L
0212E:  MOV.B   W0L,21A
02130:  BTSC.B  219.1
02132:  BRA     2130
02134:  MOV.B   #D,W0L
02136:  MOV.B   W0L,21A
02138:  RETURN  
.................... } 
.................... // Returns the value of the position counter 
.................... unsigned int16 qei_get_count(){ return QEI_POSCNT;} 
*
02262:  PUSH    126
02264:  POP     0
02266:  RETURN  
....................  
.................... // Sets the operating mode of the PWM module 
.................... void pwm_select_mode(unsigned int mode) 
.................... { 
....................    if(mode == FREE) 
*
0199A:  CP0     97E
0199C:  BRA     NZ,19A6
....................    { 
....................       // Select free running PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
0199E:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 0; 
019A0:  BCLR.B  1C0.0
....................    } 
019A2:  GOTO    19B0
....................    else if(mode == SINGLE) 
019A6:  MOV     97E,W4
019A8:  CP      W4,#1
019AA:  BRA     NZ,19B0
....................    { 
....................       // Select single event PWM time base mode 
....................       PWM_PTCON_PTMOD1     = 0; 
019AC:  BCLR.B  1C0.1
....................       PWM_PTCON_PTMOD0     = 1; 
019AE:  BSET.B  1C0.0
....................    } 
019B0:  RETURN  
.................... } 
.................... // Initializes the PWM module by using default values 
.................... void pwm_init() 
.................... { 
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN       = 0; 
019B2:  BCLR.B  1C1.7
....................     
....................    // Select 1:1 output postscale 
....................    PWM_PTCON_PTOPS3     = 0; 
019B4:  BCLR.B  1C0.7
....................    PWM_PTCON_PTOPS2     = 0; 
019B6:  BCLR.B  1C0.6
....................    PWM_PTCON_PTOPS1     = 0; 
019B8:  BCLR.B  1C0.5
....................    PWM_PTCON_PTOPS0     = 0; 
019BA:  BCLR.B  1C0.4
....................    // Select 1:1 input prescale 
....................    PWM_PTCON_PTCKPS1    = 0; 
019BC:  BCLR.B  1C0.3
....................    PWM_PTCON_PTCKPS0    = 0; 
019BE:  BCLR.B  1C0.2
....................     
....................    // Set the operating mode of PWM module 
....................    pwm_select_mode(FREE); 
019C0:  CLR     97E
019C2:  CALL    199A
....................  
....................    // Select independent output mode for PWM4 I/O pair 
....................    PWM_PWMCON1_PMOD4    = 1; 
019C6:  BSET.B  1C9.3
....................    // Set PWM4L pin as PWM output 
....................    PWM_PWMCON1_PEN4L    = 1; 
019C8:  BSET.B  1C8.3
....................     
....................    // Synchronize PDC registers to the PWM time base 
....................    PWM_PWMCON2_IUE      = 0; 
019CA:  BCLR.B  1CA.2
....................    // Enable PWM interrupt 
....................    PWM_IEC2_PWMIE       = 0; 
019CC:  BCLR.B  90.7
....................     
....................    // Set time base period value 
....................    PWM_PTPER            = 0; 
019CE:  CLR     1C4
....................    // Set time base duty cycle 
....................    PWM_PDC4             = 0; 
019D0:  CLR     1DC
....................  
....................    if(debug_mode_md) 
019D2:  BTSS.B  8B0.3
019D4:  BRA     19EE
....................       fprintf(RS232,"PWM Module Initialized\n\n\r"); 
019D6:  MOV     #0,W1
019D8:  MOV     W1,W0
019DA:  CLR.B   1
019DC:  CALL    95C
019E0:  INC     W1,W1
019E2:  BTSC.B  219.1
019E4:  BRA     19E2
019E6:  MOV.B   W0L,21A
019E8:  MOV     #18,W0
019EA:  CPSGT   W1,W0
019EC:  BRA     19D8
019EE:  RETURN  
.................... } 
.................... // Set PWM period time (us) 
.................... void pwm_set_period(unsigned int16 period) 
*
0219A:  MOV     W5,[W15++]
0219C:  MOV     W6,[W15++]
.................... { 
....................    // PWM period 
....................    unsigned int16 pwm_period;  
....................     
....................    // Set the PWM period 
....................    if(period==0) 
0219E:  CP0     980
021A0:  BRA     NZ,21A8
....................       pwm_period = 0; 
021A2:  CLR     982
021A4:  GOTO    21D2
....................    else 
....................       pwm_period =  (7 * period / 400) + (3 * period / 40) + ( 7 * period / 4) - 1; 
021A8:  MOV     980,W4
021AA:  MUL.UU  W4,#7,W0
021AC:  MOV     W0,W5
021AE:  MOV     W5,W4
021B0:  MOV     #190,W3
021B2:  REPEAT  #11
021B4:  DIV.U   W4,W3
021B6:  MOV     W0,W5
021B8:  MOV     980,W4
021BA:  MUL.UU  W4,#3,W6
021BC:  MOV     W6,W4
021BE:  MOV     #28,W3
021C0:  REPEAT  #11
021C2:  DIV.U   W4,W3
021C4:  ADD     W0,W5,W5
021C6:  MOV     980,W4
021C8:  MUL.UU  W4,#7,W6
021CA:  LSR     W6,#2,W0
021CC:  ADD     W0,W5,W5
021CE:  SUB     W5,#1,W0
021D0:  MOV     W0,982
....................     
....................    // Updates from duty cycle and period buffer registers are disabled 
....................    PWM_PWMCON2_UDIS = 1; 
021D2:  BSET.B  1CA.0
....................    // Set time base period value 
....................    PWM_PTPER        = pwm_period; 
021D4:  PUSH    982
021D6:  POP     1C4
....................    // Set time base duty cycle if PWM module is enabled (duty cycle > 0%) 
....................    PWM_PDC4         = pwm_period; 
021D8:  PUSH    982
021DA:  POP     1DC
....................    // Updates from duty cycle and period buffer registers are enabled 
....................    PWM_PWMCON2_UDIS = 0; 
021DC:  BCLR.B  1CA.0
021DE:  MOV     [--W15],W6
021E0:  MOV     [--W15],W5
021E2:  RETURN  
.................... } 
.................... // Disable PWM module 
.................... void pwm_disable() 
.................... { 
....................    // Set duty cycle to zero 
....................    PWM_PDC4=0; 
*
021F4:  CLR     1DC
....................    // Wait for the last signal 
....................    delay_us(PWM_PTPER + 1 / 30); 
021F6:  MOV     1C4,W0
021F8:  CALL    21E4
....................    // Disable PWM module 
....................    PWM_PTCON_PTEN = 0; 
021FC:  BCLR.B  1C1.7
....................    // Set duty cycle to its initial value 
....................    PWM_PDC4=PWM_PTPER; 
021FE:  PUSH    1C4
02200:  POP     1DC
....................     
....................    if(debug_mode_pwm) 
02202:  BTSS.B  8B0.4
02204:  BRA     221E
....................       fprintf(RS232,"PWM Disabled\n\r"); 
02206:  MOV     #0,W1
02208:  MOV     W1,W0
0220A:  CLR.B   1
0220C:  CALL    982
02210:  INC     W1,W1
02212:  BTSC.B  219.1
02214:  BRA     2212
02216:  MOV.B   W0L,21A
02218:  MOV     #D,W0
0221A:  CPSGT   W1,W0
0221C:  BRA     2208
0221E:  RETURN  
.................... } 
.................... // Enable PWM module 
.................... void pwm_enable() 
*
02268:  MOV     W5,[W15++]
.................... { 
....................    // Disable RS232 receive byte interrupt 
....................    disable_interrupts(INT_RDA2); 
0226A:  BCLR.B  8F.0
....................     
....................    // Enable PWM module 
....................    PWM_PTCON_PTEN = 1; 
0226C:  BSET.B  1C1.7
....................    // Start pwm cycle 
....................    int1 reg_md_running = 1; 
....................    unsigned int md_step_count = 0; 
0226E:  BSET.B  976.0
02270:  CLR     978
....................     
....................    while(reg_md_running) 
02272:  BTSS.B  976.0
02274:  BRA     24F6
....................    { 
....................       if(PWM_IFS2_PWMIF) 
02276:  BTSS.B  88.7
02278:  BRA     24F2
....................       { 
....................          // Clear the flag register 
....................          PWM_IFS2_PWMIF = 0; 
0227A:  BCLR.B  88.7
....................           
....................          md_step_count++; 
0227C:  INC     0978
....................  
....................          if(reg_md_limit) 
0227E:  BTSS.B  8FE.4
02280:  BRA     22B4
....................          { 
....................             pwm_disable(); 
02282:  CALL    21F4
....................             reg_md_running = 0; 
02286:  BCLR.B  976.0
....................             md_mt_set(mt_percent_rest); 
02288:  PUSH    8BA
0228A:  POP     97E
0228C:  CALL    1E72
....................              
....................             // Enable RS232 receive byte interrupt 
....................             clear_interrupt(INT_RDA2); 
02290:  REPEAT  #3
02292:  MOV     21C,W0
02294:  BCLR.B  87.0
....................             enable_interrupts(INT_RDA2); 
02296:  BSET.B  8F.0
....................             reg_rs232_message = 0; 
02298:  BCLR.B  8FE.2
....................              
....................             fprintf(RS232,"Limit switch triggered.\n\r"); 
0229A:  MOV     #0,W1
0229C:  MOV     W1,W0
0229E:  CLR.B   1
022A0:  CALL    99E
022A4:  INC     W1,W1
022A6:  BTSC.B  219.1
022A8:  BRA     22A6
022AA:  MOV.B   W0L,21A
022AC:  MOV     #18,W0
022AE:  CPSGT   W1,W0
022B0:  BRA     229C
....................     
....................             return; 
022B2:  BRA     2500
....................          } 
....................           
....................          switch(md_run_state)  
022B4:  MOV.B   8B1,W0L
022B6:  CLR.B   1
022B8:  XOR     #0,W0
022BA:  BRA     Z,22D2
022BC:  XOR     #1,W0
022BE:  BRA     Z,237A
022C0:  XOR     #2,W0
022C2:  BRA     Z,23E4
022C4:  XOR     #1,W0
022C6:  BRA     Z,2404
022C8:  XOR     #6,W0
022CA:  BRA     Z,244E
022CC:  XOR     #1,W0
022CE:  BRA     Z,24D8
022D0:  BRA     24F2
....................          { 
....................             case HOME: 
....................                if(reg_md_home_return == 0) 
022D2:  BTSC.B  8FE.1
022D4:  BRA     2354
....................                { 
....................                   if(reg_md_home == 0) 
022D6:  BTSC.B  8FE.0
022D8:  BRA     2328
....................                   { 
....................                      if(input(MD_SW)) 
022DA:  BSET.B  2E5.1
022DC:  BTSS.B  2E7.1
022DE:  BRA     2310
....................                      { 
....................                         if(md_step_count < md_max_acc_lim) 
022E0:  MOV     978,W0
022E2:  MOV     900,W4
022E4:  CP      W4,W0
022E6:  BRA     LEU,2300
....................                         { 
....................                            md_decel_count = md_step_count; 
022E8:  PUSH    978
022EA:  POP     8D6
....................                            pwm_set_period(delays[md_step_count]); 
022EC:  MOV     978,W0
022EE:  SL      W0,#1,W0
022F0:  CALL    100
022F4:  MOV     W0,W5
022F6:  MOV     W5,980
022F8:  CALL    219A
....................                         } 
022FC:  GOTO    230C
....................                         else 
....................                         { 
....................                            md_decel_count = md_max_acc_lim; 
02300:  PUSH    900
02302:  POP     8D6
....................                            pwm_set_period(md_min_delay); 
02304:  PUSH    8D0
02306:  POP     980
02308:  CALL    219A
....................                         } 
....................                      } 
0230C:  GOTO    2324
....................                      else 
....................                      { 
....................                         reg_md_home = 1; 
02310:  BSET.B  8FE.0
....................                         md_decel_count--; 
02312:  DEC     08D6
....................                         pwm_set_period(delays[md_decel_count]); 
02314:  MOV     8D6,W0
02316:  SL      W0,#1,W0
02318:  CALL    100
0231C:  MOV     W0,W5
0231E:  MOV     W5,980
02320:  CALL    219A
....................                      } 
....................                   } 
02324:  GOTO    2350
....................                   else 
....................                   { 
....................                      if(md_decel_count == 0) 
02328:  CP0     8D6
0232A:  BRA     NZ,233E
....................                      {   
....................                         reg_md_home_return = 1; 
0232C:  BSET.B  8FE.1
....................                         output_low(MD_DIR); 
0232E:  BCLR.B  2DE.0
02330:  BCLR.B  2E2.0
....................                         pwm_set_period(1000); 
02332:  MOV     #3E8,W4
02334:  MOV     W4,980
02336:  CALL    219A
....................                      } 
0233A:  GOTO    2350
....................                      else 
....................                      { 
....................                         md_decel_count--; 
0233E:  DEC     08D6
....................                         pwm_set_period(delays[md_decel_count]); 
02340:  MOV     8D6,W0
02342:  SL      W0,#1,W0
02344:  CALL    100
02348:  MOV     W0,W5
0234A:  MOV     W5,980
0234C:  CALL    219A
....................                      } 
....................                   } 
....................                } 
02350:  GOTO    2376
....................                else 
....................                { 
....................                   if(input(MD_SW)) 
02354:  BSET.B  2E5.1
02356:  BTSS.B  2E7.1
02358:  BRA     2376
....................                   { 
....................                      pwm_disable(); 
0235A:  CALL    21F4
....................                      reg_md_running = 0; 
0235E:  BCLR.B  976.0
....................                       
....................                      delay_ms(50); 
02360:  MOV     #32,W0
02362:  CALL    1586
....................                      qei_set_count(md_home_offset); 
02366:  PUSH    8C6
02368:  POP     97E
0236A:  CALL    2220
....................                      md_mt_set(mt_percent_rest); 
0236E:  PUSH    8BA
02370:  POP     97E
02372:  CALL    1E72
....................                   } 
....................                } 
....................                break; 
02376:  GOTO    24F2
....................                 
....................             case ACCEL: 
....................                // Check if we should start deceleration. 
....................                if(md_step_count >= md_accel_lim)  
0237A:  MOV     8D4,W0
0237C:  MOV     978,W4
0237E:  CP      W4,W0
02380:  BRA     NC,23D0
....................                { 
....................                   if(md_step_count == md_decel_lim) 
02382:  MOV     978,W0
02384:  CP      8D2
02386:  BRA     NZ,23A2
....................                   { 
....................                      md_decel_count--; 
02388:  DEC     08D6
....................                      pwm_set_period(delays[md_decel_count]); 
0238A:  MOV     8D6,W0
0238C:  SL      W0,#1,W0
0238E:  CALL    100
02392:  MOV     W0,W5
02394:  MOV     W5,980
02396:  CALL    219A
....................                      md_run_state = DECEL; 
0239A:  MOV.B   #2,W0L
0239C:  MOV.B   W0L,8B1
....................                   } 
0239E:  GOTO    23CC
....................                   else if(md_decel_lim - md_step_count < 2) 
023A2:  MOV     8D2,W4
023A4:  MOV     978,W3
023A6:  SUB     W4,W3,W5
023A8:  CP      W5,#2
023AA:  BRA     C,23C0
....................                   { 
....................                      pwm_set_period(delays[md_step_count]); 
023AC:  MOV     978,W0
023AE:  SL      W0,#1,W0
023B0:  CALL    100
023B4:  MOV     W0,W5
023B6:  MOV     W5,980
023B8:  CALL    219A
....................                   } 
023BC:  GOTO    23CC
....................                   else 
....................                   { 
....................                      pwm_set_period(md_min_delay); 
023C0:  PUSH    8D0
023C2:  POP     980
023C4:  CALL    219A
....................                      md_run_state = RUN; 
023C8:  MOV.B   #3,W0L
023CA:  MOV.B   W0L,8B1
....................                   } 
....................                } 
023CC:  GOTO    23E0
....................                else 
....................                { 
....................                   pwm_set_period(delays[md_step_count]); 
023D0:  MOV     978,W0
023D2:  SL      W0,#1,W0
023D4:  CALL    100
023D8:  MOV     W0,W5
023DA:  MOV     W5,980
023DC:  CALL    219A
....................                } 
....................                break; 
023E0:  GOTO    24F2
....................        
....................             case RUN: 
....................                // Check if we should start decelration. 
....................                if(md_step_count == md_decel_lim)  
023E4:  MOV     978,W0
023E6:  CP      8D2
023E8:  BRA     NZ,2400
....................                { 
....................                   md_decel_count--; 
023EA:  DEC     08D6
....................                   pwm_set_period(delays[md_decel_count]); 
023EC:  MOV     8D6,W0
023EE:  SL      W0,#1,W0
023F0:  CALL    100
023F4:  MOV     W0,W5
023F6:  MOV     W5,980
023F8:  CALL    219A
....................                   md_run_state = DECEL; 
023FC:  MOV.B   #2,W0L
023FE:  MOV.B   W0L,8B1
....................                } 
....................                break; 
02400:  GOTO    24F2
....................        
....................             case DECEL: 
....................                // Check if we at last step 
....................                if(md_decel_count == 0) 
02404:  CP0     8D6
02406:  BRA     NZ,2438
....................                { 
....................                   pwm_disable(); 
02408:  CALL    21F4
....................                   md_pos_iter = 0; 
0240C:  CLR     8D8
....................                   md_run_state = POS; 
0240E:  MOV.B   #4,W0L
02410:  MOV.B   W0L,8B1
....................                    
....................                   delay_ms(50); 
02412:  MOV     #32,W0
02414:  CALL    1586
....................  
....................                   md_error = md_target_count - qei_get_count(); 
02418:  CALL    2262
0241C:  MOV     8CA,W4
0241E:  SUB     W4,W0,W0
02420:  MOV     W0,8DA
....................                    
....................                   if(md_error > 1) 
02422:  MOV     8DA,W4
02424:  CP      W4,#1
02426:  BRA     LE,2430
....................                      output_low(MD_DIR); 
02428:  BCLR.B  2DE.0
0242A:  BCLR.B  2E2.0
0242C:  GOTO    2434
....................                   else 
....................                      output_high(MD_DIR); 
02430:  BCLR.B  2DE.0
02432:  BSET.B  2E2.0
....................                } 
02434:  GOTO    244A
....................                else 
....................                { 
....................                   md_decel_count--; 
02438:  DEC     08D6
....................                   pwm_set_period(delays[md_decel_count]); 
0243A:  MOV     8D6,W0
0243C:  SL      W0,#1,W0
0243E:  CALL    100
02442:  MOV     W0,W5
02444:  MOV     W5,980
02446:  CALL    219A
....................                } 
....................                break; 
0244A:  GOTO    24F2
....................                 
....................             case POS: 
....................                md_pos_iter++; 
0244E:  INC     08D8
....................                 
....................                delay_ms(50); 
02450:  MOV     #32,W0
02452:  CALL    1586
....................                 
....................                if(reg_md_cc_sample) 
02456:  BTSS.B  8FE.3
02458:  BRA     246C
....................                { 
....................                   reg_md_cc_sample = 0; 
0245A:  BCLR.B  8FE.3
....................                   delay_ms(50); 
0245C:  MOV     #32,W0
0245E:  CALL    1586
....................                   md_cc_step = md_step_count; 
02462:  PUSH    978
02464:  POP     8DE
....................                   md_cc_count = qei_get_count(); 
02466:  CALL    2262
0246A:  MOV     W0,8E0
....................                } 
....................  
....................                int difference; 
....................                 
....................                if(md_error < 1) 
0246C:  MOV     8DA,W4
0246E:  CP      W4,#1
02470:  BRA     GE,2482
....................                   difference = qei_get_count() - md_target_count; 
02472:  CALL    2262
02476:  MOV     W0,W5
02478:  MOV     8CA,W4
0247A:  SUB     W5,W4,W0
0247C:  MOV     W0,97A
0247E:  GOTO    248C
....................                else 
....................                   difference = md_target_count - qei_get_count(); 
02482:  CALL    2262
02486:  MOV     8CA,W4
02488:  SUB     W4,W0,W0
0248A:  MOV     W0,97A
....................  
....................                if((difference < 1)||(md_pos_iter > 50)) 
0248C:  MOV     97A,W4
0248E:  CP      W4,#1
02490:  BRA     LT,249A
02492:  MOV     8D8,W4
02494:  MOV     #32,W3
02496:  CP      W3,W4
02498:  BRA     C,24AC
....................                { 
....................                   pwm_disable(); 
0249A:  CALL    21F4
....................                   reg_md_running = 0; 
0249E:  BCLR.B  976.0
....................                   md_mt_set(mt_percent_rest); 
024A0:  PUSH    8BA
024A2:  POP     97E
024A4:  CALL    1E72
....................                } 
024A8:  GOTO    24D4
....................                else 
....................                { 
....................                   if(md_target_count > qei_get_count()) 
024AC:  CALL    2262
024B0:  MOV     8CA,W4
024B2:  CP      W4,W0
024B4:  BRA     LEU,24BE
....................                      output_low(MD_DIR); 
024B6:  BCLR.B  2DE.0
024B8:  BCLR.B  2E2.0
024BA:  GOTO    24C2
....................                   else 
....................                      output_high(MD_DIR); 
024BE:  BCLR.B  2DE.0
024C0:  BSET.B  2E2.0
....................                          
....................                   pwm_set_period(1000); 
024C2:  MOV     #3E8,W4
024C4:  MOV     W4,980
024C6:  CALL    219A
....................                   pwm_select_mode(SINGLE); 
024CA:  MOV     #1,W4
024CC:  MOV     W4,97E
024CE:  CALL    199A
....................                   // Enable PWM module 
....................                   PWM_PTCON_PTEN = 1; 
024D2:  BSET.B  1C1.7
....................                } 
....................                break; 
024D4:  GOTO    24F2
....................  
....................             case LIMIT: 
....................                if(md_step_count > md_lim_disp) 
024D8:  MOV     8E2,W0
024DA:  MOV     978,W4
024DC:  CP      W4,W0
024DE:  BRA     LEU,24EE
....................                { 
....................                   pwm_disable(); 
024E0:  CALL    21F4
....................                   reg_md_running = 0; 
024E4:  BCLR.B  976.0
....................                   md_mt_set(mt_percent_rest); 
024E6:  PUSH    8BA
024E8:  POP     97E
024EA:  CALL    1E72
....................                } 
....................                break; 
024EE:  GOTO    24F2
....................          } 
....................       } 
024F2:  GOTO    2272
....................    } 
....................  
....................    // Enable RS232 receive byte interrupt 
....................    clear_interrupt(INT_RDA2); 
024F6:  REPEAT  #3
024F8:  MOV     21C,W0
024FA:  BCLR.B  87.0
....................    enable_interrupts(INT_RDA2); 
024FC:  BSET.B  8F.0
....................    reg_rs232_message = 0; 
024FE:  BCLR.B  8FE.2
02500:  MOV     [--W15],W5
02502:  RETURN  
.................... } 
....................  
.................... // Move to given position (encoder count) 
.................... void move_to(unsigned int count) 
*
02B0A:  MOV     W5,[W15++]
02B0C:  MOV     W6,[W15++]
02B0E:  CALL    2262
02B12:  MOV     W0,972
.................... { 
....................    // Calculate the number of steps 
....................    unsigned int displ;             
....................    // Calculate the current motor step by using current encoder count 
....................    unsigned int current_count = qei_get_count(); 
....................    // Calculate the target motor step by using given encoder step 
....................    md_target_count = count;  
02B14:  PUSH    96E
02B16:  POP     8CA
....................     
....................    // Set direction 
....................    if(md_target_count > current_count) 
02B18:  MOV     972,W0
02B1A:  MOV     8CA,W4
02B1C:  CP      W4,W0
02B1E:  BRA     LEU,2B30
....................    { 
....................       output_low(MD_DIR); 
02B20:  BCLR.B  2DE.0
02B22:  BCLR.B  2E2.0
....................       displ = md_target_count - current_count; 
02B24:  MOV     8CA,W4
02B26:  MOV     972,W3
02B28:  SUB     W4,W3,W0
02B2A:  MOV     W0,970
....................    } 
02B2C:  GOTO    2B3C
....................    else 
....................    { 
....................       output_high(MD_DIR); 
02B30:  BCLR.B  2DE.0
02B32:  BSET.B  2E2.0
....................       displ = current_count - md_target_count; 
02B34:  MOV     972,W4
02B36:  MOV     8CA,W3
02B38:  SUB     W4,W3,W0
02B3A:  MOV     W0,970
....................    } 
....................     
....................    displ = (long)displ * 10000 / md_conv_const; 
02B3C:  MOV     970,W5
02B3E:  MOV     #0,W6
02B40:  MOV     W5,W0
02B42:  MOV     W6,W1
02B44:  MOV     #2710,W2
02B46:  MOV     #0,W3
02B48:  CALL    2A4A
02B4C:  MOV     W0,W5
02B4E:  MOV     W1,W6
02B50:  BCLR.B  43.0
02B52:  MOV     W5,W0
02B54:  MOV     W6,W1
02B56:  MOV     8BC,W2
02B58:  MOV     #0,W3
02B5A:  CALL    2A8C
02B5E:  MOV     W0,970
....................     
....................    if(debug_mode_pwm) 
02B60:  BTSS.B  8B0.4
02B62:  BRA     2B94
....................       fprintf(RS232,"Displacement: %u\n\r", displ); 
02B64:  MOV     #0,W1
02B66:  MOV     W1,W0
02B68:  CLR.B   1
02B6A:  CALL    9C4
02B6E:  INC     W1,W1
02B70:  BTSC.B  219.1
02B72:  BRA     2B70
02B74:  MOV.B   W0L,21A
02B76:  MOV     #D,W0
02B78:  CPSGT   W1,W0
02B7A:  BRA     2B66
02B7C:  MOV     970,W0
02B7E:  MOV     #0,W4
02B80:  CALL    1596
02B84:  BTSC.B  219.1
02B86:  BRA     2B84
02B88:  MOV.B   #A,W0L
02B8A:  MOV.B   W0L,21A
02B8C:  BTSC.B  219.1
02B8E:  BRA     2B8C
02B90:  MOV.B   #D,W0L
02B92:  MOV.B   W0L,21A
....................     
....................    // If displacement is zero than no need to move 
....................    if(displ == 0) 
02B94:  CP0     970
02B96:  BRA     NZ,2B9A
....................       return; 
02B98:  BRA     2CCC
....................        
....................    // Find out after how many steps we must start deceleration. 
....................    md_accel_lim = ((long)displ * md_decel) / (md_accel + md_decel); 
02B9A:  MOV     970,W5
02B9C:  MOV     #0,W6
02B9E:  MOV     W5,W0
02BA0:  MOV     W6,W1
02BA2:  MOV     8CE,W2
02BA4:  MOV     #0,W3
02BA6:  CALL    2A4A
02BAA:  MOV     W0,W5
02BAC:  MOV     W1,W6
02BAE:  MOV     8CC,W0
02BB0:  ADD     8CE,W0
02BB2:  BCLR.B  43.0
02BB4:  MOV     W6,W1
02BB6:  MOV     W0,W2
02BB8:  MOV     #0,W3
02BBA:  MOV     W5,W0
02BBC:  CALL    2A8C
02BC0:  MOV     W0,8D4
....................    // We must accelerate at least 1 step before we can start deceleration. 
....................    if(md_accel_lim == 0) 
02BC2:  CP0     8D4
02BC4:  BRA     NZ,2BCA
....................       md_accel_lim = 1; 
02BC6:  MOV     #1,W4
02BC8:  MOV     W4,8D4
....................     
....................    // Use the limit we hit first to calc decel. 
....................    if(md_accel_lim >= md_max_acc_lim) 
02BCA:  MOV     900,W0
02BCC:  MOV     8D4,W4
02BCE:  CP      W4,W0
02BD0:  BRA     NC,2C06
....................    { 
....................       md_accel_lim = md_max_acc_lim; 
02BD2:  PUSH    900
02BD4:  POP     8D4
....................        
....................       // Find step to start decleration. 
....................       md_decel_count = ((long)md_max_acc_lim * md_accel) / md_decel; 
02BD6:  MOV     900,W5
02BD8:  MOV     #0,W6
02BDA:  MOV     W5,W0
02BDC:  MOV     W6,W1
02BDE:  MOV     8CC,W2
02BE0:  MOV     #0,W3
02BE2:  CALL    2A4A
02BE6:  MOV     W0,W5
02BE8:  MOV     W1,W6
02BEA:  BCLR.B  43.0
02BEC:  MOV     W5,W0
02BEE:  MOV     W6,W1
02BF0:  MOV     8CE,W2
02BF2:  MOV     #0,W3
02BF4:  CALL    2A8C
02BF8:  MOV     W0,8D6
....................       md_decel_lim = displ - md_decel_count;  
02BFA:  MOV     970,W4
02BFC:  MOV     8D6,W3
02BFE:  SUB     W4,W3,W0
02C00:  MOV     W0,8D2
....................    } 
02C02:  GOTO    2C12
....................    else 
....................    { 
....................       md_decel_lim = displ - md_accel_lim; 
02C06:  MOV     970,W4
02C08:  MOV     8D4,W3
02C0A:  SUB     W4,W3,W0
02C0C:  MOV     W0,8D2
....................       md_decel_count = md_accel_lim; 
02C0E:  PUSH    8D4
02C10:  POP     8D6
....................    } 
....................     
....................    // We must decelerate at least 1 step to stop. 
....................    if(md_decel_lim == 0) 
02C12:  CP0     8D2
02C14:  BRA     NZ,2C1A
....................       md_decel_lim = 1; 
02C16:  MOV     #1,W4
02C18:  MOV     W4,8D2
....................  
....................    if(debug_mode_pwm) 
02C1A:  BTSS.B  8B0.4
02C1C:  BRA     2CAE
....................    { 
....................       fprintf(RS232,"Acceleration Limit: %u\n\r", md_accel_lim); 
02C1E:  MOV     #0,W1
02C20:  MOV     W1,W0
02C22:  CLR.B   1
02C24:  CALL    9E4
02C28:  INC     W1,W1
02C2A:  BTSC.B  219.1
02C2C:  BRA     2C2A
02C2E:  MOV.B   W0L,21A
02C30:  MOV     #13,W0
02C32:  CPSGT   W1,W0
02C34:  BRA     2C20
02C36:  MOV     8D4,W0
02C38:  MOV     #0,W4
02C3A:  CALL    1596
02C3E:  BTSC.B  219.1
02C40:  BRA     2C3E
02C42:  MOV.B   #A,W0L
02C44:  MOV.B   W0L,21A
02C46:  BTSC.B  219.1
02C48:  BRA     2C46
02C4A:  MOV.B   #D,W0L
02C4C:  MOV.B   W0L,21A
....................       fprintf(RS232,"Deceleration Limit: %u\n\r", md_decel_lim); 
02C4E:  MOV     #0,W1
02C50:  MOV     W1,W0
02C52:  CLR.B   1
02C54:  CALL    A0A
02C58:  INC     W1,W1
02C5A:  BTSC.B  219.1
02C5C:  BRA     2C5A
02C5E:  MOV.B   W0L,21A
02C60:  MOV     #13,W0
02C62:  CPSGT   W1,W0
02C64:  BRA     2C50
02C66:  MOV     8D2,W0
02C68:  MOV     #0,W4
02C6A:  CALL    1596
02C6E:  BTSC.B  219.1
02C70:  BRA     2C6E
02C72:  MOV.B   #A,W0L
02C74:  MOV.B   W0L,21A
02C76:  BTSC.B  219.1
02C78:  BRA     2C76
02C7A:  MOV.B   #D,W0L
02C7C:  MOV.B   W0L,21A
....................       fprintf(RS232,"Deceleration Count: %u\n\r", md_decel_count); 
02C7E:  MOV     #0,W1
02C80:  MOV     W1,W0
02C82:  CLR.B   1
02C84:  CALL    A30
02C88:  INC     W1,W1
02C8A:  BTSC.B  219.1
02C8C:  BRA     2C8A
02C8E:  MOV.B   W0L,21A
02C90:  MOV     #13,W0
02C92:  CPSGT   W1,W0
02C94:  BRA     2C80
02C96:  MOV     8D6,W0
02C98:  MOV     #0,W4
02C9A:  CALL    1596
02C9E:  BTSC.B  219.1
02CA0:  BRA     2C9E
02CA2:  MOV.B   #A,W0L
02CA4:  MOV.B   W0L,21A
02CA6:  BTSC.B  219.1
02CA8:  BRA     2CA6
02CAA:  MOV.B   #D,W0L
02CAC:  MOV.B   W0L,21A
....................    } 
....................  
....................    md_run_state = ACCEL; 
02CAE:  MOV.B   #1,W0L
02CB0:  MOV.B   W0L,8B1
....................    md_mt_set(mt_percent_trip); 
02CB2:  PUSH    8B8
02CB4:  POP     97E
02CB6:  CALL    1E72
....................  
....................    pwm_set_period(delays[0]); 
02CBA:  MOV     #7D0,W4
02CBC:  MOV     W4,980
02CBE:  CALL    219A
....................    pwm_select_mode(FREE); 
02CC2:  CLR     97E
02CC4:  CALL    199A
....................    pwm_enable(); 
02CC8:  CALL    2268
02CCC:  MOV     [--W15],W6
02CCE:  MOV     [--W15],W5
02CD0:  RETURN  
.................... } 
.................... // Move to given position (mm) 
.................... void move_pos(unsigned int16 position) 
*
02DC8:  MOV     W5,[W15++]
02DCA:  MOV     #C,W5
02DCC:  REPEAT  #4
02DCE:  MOV     [W5++],[W15++]
.................... { 
....................    if(position>md_move_range) 
02DD0:  MOV     8BE,W0
02DD2:  MOV     968,W4
02DD4:  CP      W4,W0
02DD6:  BRA     LEU,2DFC
....................    { 
....................       position=md_move_range; 
02DD8:  PUSH    8BE
02DDA:  POP     968
....................       if(debug_mode_md) 
02DDC:  BTSS.B  8B0.3
02DDE:  BRA     2DF8
....................          fprintf(RS232, "Invalid entry: System cannot move to a position beyond the movement range. System will move to maximum possible distance."); 
02DE0:  MOV     #0,W1
02DE2:  MOV     W1,W0
02DE4:  CLR.B   1
02DE6:  CALL    A56
02DEA:  INC     W1,W1
02DEC:  BTSC.B  219.1
02DEE:  BRA     2DEC
02DF0:  MOV.B   W0L,21A
02DF2:  MOV     #78,W0
02DF4:  CPSGT   W1,W0
02DF6:  BRA     2DE2
....................    } 
02DF8:  GOTO    2E44
....................    else if(position<md_min_distance) 
02DFC:  MOV     968,W0
02DFE:  MOV     8C8,W4
02E00:  CP      W4,W0
02E02:  BRA     LEU,2E44
....................    { 
....................       position=md_min_distance; 
02E04:  PUSH    8C8
02E06:  POP     968
....................       if(debug_mode_md) 
02E08:  BTSS.B  8B0.3
02E0A:  BRA     2E44
....................          fprintf(RS232, "Invalid entry: System cannot move to a position smaller than %u mm. System will move to minimum possible distance.", md_min_distance); 
02E0C:  MOV     #0,W1
02E0E:  MOV     W1,W0
02E10:  CLR.B   1
02E12:  CALL    AC4
02E16:  INC     W1,W1
02E18:  BTSC.B  219.1
02E1A:  BRA     2E18
02E1C:  MOV.B   W0L,21A
02E1E:  MOV     #3C,W0
02E20:  CPSGT   W1,W0
02E22:  BRA     2E0E
02E24:  MOV     8C8,W0
02E26:  MOV     #0,W4
02E28:  CALL    1596
02E2C:  MOV     #3F,W1
02E2E:  MOV     W1,W0
02E30:  CLR.B   1
02E32:  CALL    AC4
02E36:  INC     W1,W1
02E38:  BTSC.B  219.1
02E3A:  BRA     2E38
02E3C:  MOV.B   W0L,21A
02E3E:  MOV     #71,W0
02E40:  CPSGT   W1,W0
02E42:  BRA     2E2E
....................    } 
....................     
....................    fprintf(RS232,"\n\rTarget Position: %u mm\n\r", position); 
02E44:  MOV     #0,W1
02E46:  MOV     W1,W0
02E48:  CLR.B   1
02E4A:  CALL    B2E
02E4E:  INC     W1,W1
02E50:  BTSC.B  219.1
02E52:  BRA     2E50
02E54:  MOV.B   W0L,21A
02E56:  MOV     #12,W0
02E58:  CPSGT   W1,W0
02E5A:  BRA     2E46
02E5C:  MOV     968,W0
02E5E:  MOV     #0,W4
02E60:  CALL    1596
02E64:  MOV     #15,W1
02E66:  MOV     W1,W0
02E68:  CLR.B   1
02E6A:  CALL    B2E
02E6E:  INC     W1,W1
02E70:  BTSC.B  219.1
02E72:  BRA     2E70
02E74:  MOV.B   W0L,21A
02E76:  MOV     #19,W0
02E78:  CPSGT   W1,W0
02E7A:  BRA     2E66
....................  
....................    data_set_last_pos(position); 
02E7C:  PUSH    968
02E7E:  POP     96E
02E80:  CALL    269E
....................     
....................    unsigned int16 count = md_end_pos-((float)(position-md_min_distance)/2.0f)*((float)(md_end_pos-md_home_pos)/((float)(md_move_range-md_min_distance)/2.0f)); 
02E84:  MOV     968,W4
02E86:  MOV     8C8,W3
02E88:  SUB     W4,W3,W0
02E8A:  CALL    26AC
02E8E:  MOV     W0,W5
02E90:  MOV     W1,W6
02E92:  MOV     W5,W0
02E94:  MOV     W6,W1
02E96:  MOV     #0,W2
02E98:  MOV     #4000,W3
02E9A:  CALL    26E6
02E9E:  MOV     W0,W5
02EA0:  MOV     W1,W6
02EA2:  MOV     8C2,W4
02EA4:  MOV     8C0,W3
02EA6:  SUB     W4,W3,W0
02EA8:  CALL    26AC
02EAC:  MOV     W0,W7
02EAE:  MOV     W1,W8
02EB0:  MOV     8BE,W4
02EB2:  MOV     8C8,W3
02EB4:  SUB     W4,W3,W0
02EB6:  CALL    26AC
02EBA:  MOV     W0,W9
02EBC:  MOV     W1,W10
02EBE:  MOV     W9,W0
02EC0:  MOV     W10,W1
02EC2:  MOV     #0,W2
02EC4:  MOV     #4000,W3
02EC6:  CALL    26E6
02ECA:  MOV     W0,W2
02ECC:  MOV     W1,W3
02ECE:  MOV     W7,W0
02ED0:  MOV     W8,W1
02ED2:  CALL    26E6
02ED6:  MOV     W0,W2
02ED8:  MOV     W1,W3
02EDA:  MOV     W5,W0
02EDC:  MOV     W6,W1
02EDE:  CALL    27B0
02EE2:  MOV     W0,W5
02EE4:  MOV     W1,W6
02EE6:  MOV     8C2,W0
02EE8:  CALL    26AC
02EEC:  BSET.B  43.0
02EEE:  MOV     W5,W2
02EF0:  MOV     W6,W3
02EF2:  CALL    2874
02EF6:  CALL    2A1E
02EFA:  MOV     W0,96A
....................     
....................    if(qei_get_count() < count) 
02EFC:  CALL    2262
02F00:  MOV     W0,W5
02F02:  MOV     96A,W4
02F04:  CP      W4,W5
02F06:  BRA     LEU,2F10
....................       count-=md_backlash; 
02F08:  MOV     96A,W4
02F0A:  MOV     8DC,W3
02F0C:  SUB     W4,W3,W0
02F0E:  MOV     W0,96A
....................     
....................    move_to(count); 
02F10:  PUSH    96A
02F12:  POP     96E
02F14:  CALL    2B0A
....................     
....................    delay_ms(100); 
02F18:  MOV     #64,W0
02F1A:  CALL    1586
....................     
....................    if(debug_mode_md) 
02F1E:  BTSS.B  8B0.3
02F20:  BRA     3018
....................    { 
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02F22:  MOV     #0,W1
02F24:  MOV     W1,W0
02F26:  CLR.B   1
02F28:  CALL    B56
02F2C:  INC     W1,W1
02F2E:  BTSC.B  219.1
02F30:  BRA     2F2E
02F32:  MOV.B   W0L,21A
02F34:  MOV     #E,W0
02F36:  CPSGT   W1,W0
02F38:  BRA     2F24
02F3A:  MOV     8DA,W0
02F3C:  MOV     #0,W4
02F3E:  CALL    2CD2
02F42:  BTSC.B  219.1
02F44:  BRA     2F42
02F46:  MOV.B   #A,W0L
02F48:  MOV.B   W0L,21A
02F4A:  BTSC.B  219.1
02F4C:  BRA     2F4A
02F4E:  MOV.B   #D,W0L
02F50:  MOV.B   W0L,21A
....................       fprintf(RS232,"Target Encoder count: %u\n\r",md_target_count); 
02F52:  MOV     #0,W1
02F54:  MOV     W1,W0
02F56:  CLR.B   1
02F58:  CALL    B76
02F5C:  INC     W1,W1
02F5E:  BTSC.B  219.1
02F60:  BRA     2F5E
02F62:  MOV.B   W0L,21A
02F64:  MOV     #15,W0
02F66:  CPSGT   W1,W0
02F68:  BRA     2F54
02F6A:  MOV     8CA,W0
02F6C:  MOV     #0,W4
02F6E:  CALL    1596
02F72:  BTSC.B  219.1
02F74:  BRA     2F72
02F76:  MOV.B   #A,W0L
02F78:  MOV.B   W0L,21A
02F7A:  BTSC.B  219.1
02F7C:  BRA     2F7A
02F7E:  MOV.B   #D,W0L
02F80:  MOV.B   W0L,21A
....................       fprintf(RS232,"Current Encoder count: %u\n\r",qei_get_count()); 
02F82:  CALL    2262
02F86:  MOV     W0,W5
02F88:  MOV     #0,W1
02F8A:  MOV     W1,W0
02F8C:  CLR.B   1
02F8E:  CALL    B9E
02F92:  INC     W1,W1
02F94:  BTSC.B  219.1
02F96:  BRA     2F94
02F98:  MOV.B   W0L,21A
02F9A:  MOV     #16,W0
02F9C:  CPSGT   W1,W0
02F9E:  BRA     2F8A
02FA0:  MOV     W5,W0
02FA2:  MOV     #0,W4
02FA4:  CALL    1596
02FA8:  BTSC.B  219.1
02FAA:  BRA     2FA8
02FAC:  MOV.B   #A,W0L
02FAE:  MOV.B   W0L,21A
02FB0:  BTSC.B  219.1
02FB2:  BRA     2FB0
02FB4:  MOV.B   #D,W0L
02FB6:  MOV.B   W0L,21A
....................       fprintf(RS232,"Number of Iterations: %u\n\r",md_pos_iter); 
02FB8:  MOV     #0,W1
02FBA:  MOV     W1,W0
02FBC:  CLR.B   1
02FBE:  CALL    BC6
02FC2:  INC     W1,W1
02FC4:  BTSC.B  219.1
02FC6:  BRA     2FC4
02FC8:  MOV.B   W0L,21A
02FCA:  MOV     #15,W0
02FCC:  CPSGT   W1,W0
02FCE:  BRA     2FBA
02FD0:  MOV     8D8,W0
02FD2:  MOV     #0,W4
02FD4:  CALL    1596
02FD8:  BTSC.B  219.1
02FDA:  BRA     2FD8
02FDC:  MOV.B   #A,W0L
02FDE:  MOV.B   W0L,21A
02FE0:  BTSC.B  219.1
02FE2:  BRA     2FE0
02FE4:  MOV.B   #D,W0L
02FE6:  MOV.B   W0L,21A
....................       fprintf(RS232,"Initial Error: %d\n\r",md_error); 
02FE8:  MOV     #0,W1
02FEA:  MOV     W1,W0
02FEC:  CLR.B   1
02FEE:  CALL    B56
02FF2:  INC     W1,W1
02FF4:  BTSC.B  219.1
02FF6:  BRA     2FF4
02FF8:  MOV.B   W0L,21A
02FFA:  MOV     #E,W0
02FFC:  CPSGT   W1,W0
02FFE:  BRA     2FEA
03000:  MOV     8DA,W0
03002:  MOV     #0,W4
03004:  CALL    2CD2
03008:  BTSC.B  219.1
0300A:  BRA     3008
0300C:  MOV.B   #A,W0L
0300E:  MOV.B   W0L,21A
03010:  BTSC.B  219.1
03012:  BRA     3010
03014:  MOV.B   #D,W0L
03016:  MOV.B   W0L,21A
....................    } 
....................     
....................    fprintf(RS232,"Error: %d\n\r",(int)qei_get_count()-(int)md_target_count); 
03018:  CALL    2262
0301C:  MOV     W0,W5
0301E:  MOV     8CA,W4
03020:  SUB     W5,W4,W5
03022:  MOV     #0,W1
03024:  MOV     W1,W0
03026:  CLR.B   1
03028:  CALL    BEE
0302C:  INC     W1,W1
0302E:  BTSC.B  219.1
03030:  BRA     302E
03032:  MOV.B   W0L,21A
03034:  MOV     #6,W0
03036:  CPSGT   W1,W0
03038:  BRA     3024
0303A:  MOV     W5,W0
0303C:  MOV     #0,W4
0303E:  CALL    2CD2
03042:  BTSC.B  219.1
03044:  BRA     3042
03046:  MOV.B   #A,W0L
03048:  MOV.B   W0L,21A
0304A:  BTSC.B  219.1
0304C:  BRA     304A
0304E:  MOV.B   #D,W0L
03050:  MOV.B   W0L,21A
03052:  MOV     #14,W5
03054:  REPEAT  #4
03056:  MOV     [--W15],[W5--]
03058:  MOV     [--W15],W5
0305A:  RETURN  
.................... } 
.................... // Homing Function 
.................... void move_home() 
.................... { 
....................    fprintf(RS232,"Homing...\n\r");    
*
02504:  MOV     #0,W1
02506:  MOV     W1,W0
02508:  CLR.B   1
0250A:  CALL    C06
0250E:  INC     W1,W1
02510:  BTSC.B  219.1
02512:  BRA     2510
02514:  MOV.B   W0L,21A
02516:  MOV     #A,W0
02518:  CPSGT   W1,W0
0251A:  BRA     2506
....................     
....................    md_run_state = HOME; 
0251C:  CLR.B   8B1
....................    md_decel_count = 0; 
0251E:  CLR     8D6
....................    reg_md_home = 0; 
02520:  BCLR.B  8FE.0
....................    reg_md_home_return = 0; 
02522:  BCLR.B  8FE.1
....................     
....................    output_high(MD_DIR); 
02524:  BCLR.B  2DE.0
02526:  BSET.B  2E2.0
....................    md_mt_set(mt_percent_trip); 
02528:  PUSH    8B8
0252A:  POP     97E
0252C:  CALL    1E72
....................  
....................    pwm_set_period(delays[0]); 
02530:  MOV     #7D0,W4
02532:  MOV     W4,980
02534:  CALL    219A
....................    pwm_select_mode(FREE); 
02538:  CLR     97E
0253A:  CALL    199A
....................    pwm_enable(); 
0253E:  CALL    2268
02542:  RETURN  
.................... } 
.................... // Initializes the system for movement 
.................... void move_init() 
*
0305C:  MOV     W5,[W15++]
.................... { 
....................    md_move_range = data_get_move_range(); 
0305E:  CALL    1FC8
03062:  MOV     W0,8BE
....................    md_move_range = data_get_move_range(); 
03064:  CALL    1FC8
03068:  MOV     W0,8BE
....................    md_home_pos = data_get_home_pos(); 
0306A:  CALL    2014
0306E:  MOV     W0,8C0
....................    md_end_pos = data_get_end_pos(); 
03070:  CALL    2060
03074:  MOV     W0,8C2
....................    md_backlash = data_get_backlash(); 
03076:  CALL    20AC
0307A:  MOV     W0,8DC
....................    qei_set_max_count(md_end_pos+md_end_offset); 
0307C:  MOV     8C2,W0
0307E:  ADD     8C4,W0
03080:  MOV     W0,W5
03082:  MOV     W5,90C
03084:  CALL    20F8
....................    md_conv_const = data_get_conv_const(); 
03088:  CALL    213A
0308C:  MOV     W0,8BC
....................     
....................    if(md_move_range==2000) 
0308E:  MOV     8BE,W4
03090:  MOV     #7D0,W3
03092:  CP      W3,W4
03094:  BRA     NZ,309A
....................       md_min_distance=120; 
03096:  MOV     #78,W4
03098:  MOV     W4,8C8
....................           
....................    move_home();                        // Move to home position 
0309A:  CALL    2504
....................     
....................    delay_ms(500); 
0309E:  MOV     #1F4,W0
030A0:  CALL    1586
....................        
....................    if(debug_mode_md) 
030A4:  BTSS.B  8B0.3
030A6:  BRA     30E6
....................       fprintf(RS232,"Moving Last Position: %u mm\n\r", data_get_last_pos()); 
030A8:  CALL    2544
030AC:  MOV     W0,W5
030AE:  MOV     #0,W1
030B0:  MOV     W1,W0
030B2:  CLR.B   1
030B4:  CALL    C1E
030B8:  INC     W1,W1
030BA:  BTSC.B  219.1
030BC:  BRA     30BA
030BE:  MOV.B   W0L,21A
030C0:  MOV     #15,W0
030C2:  CPSGT   W1,W0
030C4:  BRA     30B0
030C6:  MOV     W5,W0
030C8:  MOV     #0,W4
030CA:  CALL    1596
030CE:  MOV     #18,W1
030D0:  MOV     W1,W0
030D2:  CLR.B   1
030D4:  CALL    C1E
030D8:  INC     W1,W1
030DA:  BTSC.B  219.1
030DC:  BRA     30DA
030DE:  MOV.B   W0L,21A
030E0:  MOV     #1C,W0
030E2:  CPSGT   W1,W0
030E4:  BRA     30D0
....................  
....................    move_pos(data_get_last_pos()); 
030E6:  CALL    2544
030EA:  MOV     W0,W5
030EC:  MOV     W5,968
030EE:  CALL    2DC8
030F2:  MOV     [--W15],W5
030F4:  RETURN  
.................... } 
.................... // Moves system to a predefined position when a limit switch is triggered 
.................... void move_from_limit() 
.................... { 
....................    fprintf(RS232,"Moving away from the limit\n\r"); 
*
0316C:  MOV     #0,W1
0316E:  MOV     W1,W0
03170:  CLR.B   1
03172:  CALL    C48
03176:  INC     W1,W1
03178:  BTSC.B  219.1
0317A:  BRA     3178
0317C:  MOV.B   W0L,21A
0317E:  MOV     #1B,W0
03180:  CPSGT   W1,W0
03182:  BRA     316E
....................     
....................    int i; 
....................     
....................    for(i=0; i<3; i++) 
03184:  CLR     908
03186:  MOV     908,W4
03188:  CP      W4,#3
0318A:  BRA     GE,31B6
....................    { 
....................       //Turn on lasers 
....................       output_low(LAS_1); 
0318C:  BCLR.B  2E4.6
0318E:  BCLR.B  2E8.6
....................       output_low(LAS_2); 
03190:  BCLR.B  2E4.7
03192:  BCLR.B  2E8.7
....................       output_low(LAS_3); 
03194:  BCLR.B  2E5.0
03196:  BCLR.B  2E9.0
....................       delay_ms(500); 
03198:  MOV     #1F4,W0
0319A:  CALL    1586
....................       output_high(LAS_1); 
0319E:  BCLR.B  2E4.6
031A0:  BSET.B  2E8.6
....................       output_high(LAS_2); 
031A2:  BCLR.B  2E4.7
031A4:  BSET.B  2E8.7
....................       output_high(LAS_3); 
031A6:  BCLR.B  2E5.0
031A8:  BSET.B  2E9.0
....................       delay_ms(500); 
031AA:  MOV     #1F4,W0
031AC:  CALL    1586
031B0:  INC     0908
031B2:  GOTO    3186
....................    } 
....................     
....................    md_run_state = LIMIT; 
031B6:  MOV.B   #5,W0L
031B8:  MOV.B   W0L,8B1
....................    output_toggle(MD_DIR); 
031BA:  BCLR.B  2DE.0
031BC:  BTG.B   2E2.0
....................    md_mt_set(mt_percent_trip); 
031BE:  PUSH    8B8
031C0:  POP     97E
031C2:  CALL    1E72
....................  
....................    pwm_set_period(delays[0]); 
031C6:  MOV     #7D0,W4
031C8:  MOV     W4,980
031CA:  CALL    219A
....................    pwm_select_mode(FREE); 
031CE:  CLR     97E
031D0:  CALL    199A
....................    pwm_enable(); 
031D4:  CALL    2268
031D8:  RETURN  
.................... } 
....................  
.................... void pp_str_low_check() 
*
033B6:  MOV     W5,[W15++]
033B8:  BSET.B  912.0
033BA:  CLR     914
.................... { 
....................    int1 check = 1; 
....................    int sum = 0; 
....................     
....................    while(check) 
033BC:  BTSS.B  912.0
033BE:  BRA     33F8
....................    { 
....................       sum = 0; 
033C0:  CLR     914
....................       if(input(PP_STR) == 1) 
033C2:  BSET.B  2D3.1
033C4:  BTSS.B  2D5.1
033C6:  BRA     33F4
....................       { 
....................          unsigned int i; 
....................          for(i=0; i<1000; i++) 
033C8:  CLR     916
033CA:  MOV     916,W4
033CC:  MOV     #3E8,W3
033CE:  CP      W3,W4
033D0:  BRA     LEU,33EA
....................          { 
....................             delay_us(pp_str_delay); 
033D2:  MOV     8F8,W0
033D4:  CALL    21E4
....................             if(input(PP_STR) == 1) 
033D8:  BSET.B  2D3.1
033DA:  BTSS.B  2D5.1
033DC:  BRA     33E4
....................                sum += 1; 
033DE:  MOV     914,W4
033E0:  ADD     W4,#1,W4
033E2:  MOV     W4,914
033E4:  INC     0916
033E6:  GOTO    33CA
....................          } 
....................          if(sum > 700) 
033EA:  MOV     914,W4
033EC:  MOV     #2BC,W3
033EE:  CP      W3,W4
033F0:  BRA     GE,33F4
....................          { 
....................             check = 0; 
033F2:  BCLR.B  912.0
....................          } 
....................       } 
033F4:  GOTO    33BC
....................    } 
033F8:  MOV     [--W15],W5
033FA:  RETURN  
.................... } 
.................... void pp_str_high_check() 
033FC:  MOV     W5,[W15++]
033FE:  BSET.B  912.0
03400:  CLR     914
.................... { 
....................    int1 check = 1; 
....................    int sum = 0; 
....................     
....................    while(check) 
03402:  BTSS.B  912.0
03404:  BRA     343E
....................    { 
....................       sum = 0; 
03406:  CLR     914
....................       if(input(PP_STR) == 0) 
03408:  BSET.B  2D3.1
0340A:  BTSC.B  2D5.1
0340C:  BRA     343A
....................       { 
....................          unsigned int i; 
....................          for(i=0; i<1000; i++) 
0340E:  CLR     916
03410:  MOV     916,W4
03412:  MOV     #3E8,W3
03414:  CP      W3,W4
03416:  BRA     LEU,3430
....................          { 
....................             delay_us(pp_str_delay); 
03418:  MOV     8F8,W0
0341A:  CALL    21E4
....................             if(input(PP_STR) == 0) 
0341E:  BSET.B  2D3.1
03420:  BTSC.B  2D5.1
03422:  BRA     342A
....................                sum += 1; 
03424:  MOV     914,W4
03426:  ADD     W4,#1,W4
03428:  MOV     W4,914
0342A:  INC     0916
0342C:  GOTO    3410
....................          } 
....................          if(sum > 700) 
03430:  MOV     914,W4
03432:  MOV     #2BC,W3
03434:  CP      W3,W4
03436:  BRA     GE,343A
....................          { 
....................             check = 0; 
03438:  BCLR.B  912.0
....................          } 
....................       } 
0343A:  GOTO    3402
....................    } 
0343E:  MOV     [--W15],W5
03440:  RETURN  
.................... } 
.................... // Checks strobe signal state change 
.................... void pp_str_check() 
.................... { 
....................    pp_str_low_check(); 
03442:  CALL    33B6
....................    pp_str_high_check(); 
03446:  CALL    33FC
0344A:  RETURN  
.................... } 
.................... //Gets byte via parallel port 
.................... unsigned int pp_get_byte() 
*
031DA:  MOV     W5,[W15++]
031DC:  CLR     90A
031DE:  CLR     90C
031E0:  CLR     90E
031E2:  CLR     910
031E4:  CLR     912
031E6:  CLR     914
031E8:  CLR     916
031EA:  CLR     918
031EC:  CLR     91A
031EE:  BSET.B  91E.0
.................... { 
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................     
....................    unsigned int i; 
....................    int1 check = 1; 
....................     
....................    while(check) 
031F0:  BTSS.B  91E.0
031F2:  BRA     3380
....................    { 
....................       int sum7 = 0; 
....................       int sum6 = 0; 
....................       int sum5 = 0; 
....................       int sum4 = 0; 
....................       int sum3 = 0; 
....................       int sum2 = 0; 
....................       int sum1 = 0; 
....................       int sum0 = 0; 
031F4:  CLR     920
031F6:  CLR     922
031F8:  CLR     924
031FA:  CLR     926
031FC:  CLR     928
031FE:  CLR     92A
03200:  CLR     92C
03202:  CLR     92E
....................              
....................       for(i=0; i<100; i++) 
03204:  CLR     91C
03206:  MOV     91C,W4
03208:  MOV     #64,W3
0320A:  CP      W3,W4
0320C:  BRA     LEU,327A
....................       { 
....................          delay_us(pp_str_delay); 
0320E:  MOV     8F8,W0
03210:  CALL    21E4
....................          if(input(PP_D7) == 0) 
03214:  BSET.B  2D3.2
03216:  BTSC.B  2D5.2
03218:  BRA     3220
....................             sum7 += 1; 
0321A:  MOV     920,W4
0321C:  ADD     W4,#1,W4
0321E:  MOV     W4,920
....................          if(input(PP_D6) == 0) 
03220:  BSET.B  2D3.3
03222:  BTSC.B  2D5.3
03224:  BRA     322C
....................             sum6 += 1; 
03226:  MOV     922,W4
03228:  ADD     W4,#1,W4
0322A:  MOV     W4,922
....................          if(input(PP_D5) == 0) 
0322C:  BSET.B  2D2.0
0322E:  BTSC.B  2D4.0
03230:  BRA     3238
....................             sum5 += 1; 
03232:  MOV     924,W4
03234:  ADD     W4,#1,W4
03236:  MOV     W4,924
....................          if(input(PP_D4) == 0) 
03238:  BSET.B  2CD.5
0323A:  BTSC.B  2CF.5
0323C:  BRA     3244
....................             sum4 += 1; 
0323E:  MOV     926,W4
03240:  ADD     W4,#1,W4
03242:  MOV     W4,926
....................          if(input(PP_D3) == 0) 
03244:  BSET.B  2CD.6
03246:  BTSC.B  2CF.6
03248:  BRA     3250
....................             sum3 += 1; 
0324A:  MOV     928,W4
0324C:  ADD     W4,#1,W4
0324E:  MOV     W4,928
....................          if(input(PP_D2) == 0) 
03250:  BSET.B  2D2.1
03252:  BTSC.B  2D4.1
03254:  BRA     325C
....................             sum2 += 1; 
03256:  MOV     92A,W4
03258:  ADD     W4,#1,W4
0325A:  MOV     W4,92A
....................          if(input(PP_D1) == 0) 
0325C:  BSET.B  2D2.2
0325E:  BTSC.B  2D4.2
03260:  BRA     3268
....................             sum1 += 1; 
03262:  MOV     92C,W4
03264:  ADD     W4,#1,W4
03266:  MOV     W4,92C
....................          if(input(PP_D0) == 0) 
03268:  BSET.B  2D2.3
0326A:  BTSC.B  2D4.3
0326C:  BRA     3274
....................             sum0 += 1; 
0326E:  MOV     92E,W4
03270:  ADD     W4,#1,W4
03272:  MOV     W4,92E
03274:  INC     091C
03276:  GOTO    3206
....................       } 
....................        
....................       if(sum7 > 70) 
0327A:  MOV     920,W4
0327C:  MOV     #46,W3
0327E:  CP      W3,W4
03280:  BRA     GE,328A
....................          D7 = 1; 
03282:  MOV     #1,W4
03284:  MOV     W4,90C
03286:  GOTO    329A
....................       else if (sum7 < 30) 
0328A:  MOV     920,W4
0328C:  CP      W4,#1E
0328E:  BRA     GE,3296
....................          D7 = 0; 
03290:  CLR     90C
03292:  GOTO    329A
....................       else 
....................          continue; 
03296:  GOTO    31F0
....................           
....................       if(sum6 > 70) 
0329A:  MOV     922,W4
0329C:  MOV     #46,W3
0329E:  CP      W3,W4
032A0:  BRA     GE,32AA
....................          D6 = 1; 
032A2:  MOV     #1,W4
032A4:  MOV     W4,90E
032A6:  GOTO    32BA
....................       else if (sum6 < 30) 
032AA:  MOV     922,W4
032AC:  CP      W4,#1E
032AE:  BRA     GE,32B6
....................          D6 = 0; 
032B0:  CLR     90E
032B2:  GOTO    32BA
....................       else 
....................          continue; 
032B6:  GOTO    31F0
....................           
....................       if(sum5 > 70) 
032BA:  MOV     924,W4
032BC:  MOV     #46,W3
032BE:  CP      W3,W4
032C0:  BRA     GE,32CA
....................          D5 = 1; 
032C2:  MOV     #1,W4
032C4:  MOV     W4,910
032C6:  GOTO    32DA
....................       else if (sum5 < 30) 
032CA:  MOV     924,W4
032CC:  CP      W4,#1E
032CE:  BRA     GE,32D6
....................          D5 = 0; 
032D0:  CLR     910
032D2:  GOTO    32DA
....................       else 
....................          continue; 
032D6:  GOTO    31F0
....................           
....................       if(sum4 > 70) 
032DA:  MOV     926,W4
032DC:  MOV     #46,W3
032DE:  CP      W3,W4
032E0:  BRA     GE,32EA
....................          D4 = 1; 
032E2:  MOV     #1,W4
032E4:  MOV     W4,912
032E6:  GOTO    32FA
....................       else if (sum4 < 30) 
032EA:  MOV     926,W4
032EC:  CP      W4,#1E
032EE:  BRA     GE,32F6
....................          D4 = 0; 
032F0:  CLR     912
032F2:  GOTO    32FA
....................       else 
....................          continue; 
032F6:  GOTO    31F0
....................           
....................       if(sum3 > 70) 
032FA:  MOV     928,W4
032FC:  MOV     #46,W3
032FE:  CP      W3,W4
03300:  BRA     GE,330A
....................          D3 = 1; 
03302:  MOV     #1,W4
03304:  MOV     W4,914
03306:  GOTO    331A
....................       else if (sum3 < 30) 
0330A:  MOV     928,W4
0330C:  CP      W4,#1E
0330E:  BRA     GE,3316
....................          D3 = 0; 
03310:  CLR     914
03312:  GOTO    331A
....................       else 
....................          continue; 
03316:  GOTO    31F0
....................           
....................       if(sum2 > 70) 
0331A:  MOV     92A,W4
0331C:  MOV     #46,W3
0331E:  CP      W3,W4
03320:  BRA     GE,332A
....................          D2 = 1; 
03322:  MOV     #1,W4
03324:  MOV     W4,916
03326:  GOTO    333A
....................       else if (sum2 < 30) 
0332A:  MOV     92A,W4
0332C:  CP      W4,#1E
0332E:  BRA     GE,3336
....................          D2 = 0; 
03330:  CLR     916
03332:  GOTO    333A
....................       else 
....................          continue; 
03336:  GOTO    31F0
....................           
....................       if(sum1 > 70) 
0333A:  MOV     92C,W4
0333C:  MOV     #46,W3
0333E:  CP      W3,W4
03340:  BRA     GE,334A
....................          D1 = 1; 
03342:  MOV     #1,W4
03344:  MOV     W4,918
03346:  GOTO    335A
....................       else if (sum1 < 30) 
0334A:  MOV     92C,W4
0334C:  CP      W4,#1E
0334E:  BRA     GE,3356
....................          D1 = 0; 
03350:  CLR     918
03352:  GOTO    335A
....................       else 
....................          continue; 
03356:  GOTO    31F0
....................           
....................       if(sum0 > 70) 
0335A:  MOV     92E,W4
0335C:  MOV     #46,W3
0335E:  CP      W3,W4
03360:  BRA     GE,336A
....................          D0 = 1; 
03362:  MOV     #1,W4
03364:  MOV     W4,91A
03366:  GOTO    337A
....................       else if (sum0 < 30) 
0336A:  MOV     92E,W4
0336C:  CP      W4,#1E
0336E:  BRA     GE,3376
....................          D0 = 0; 
03370:  CLR     91A
03372:  GOTO    337A
....................       else 
....................          continue; 
03376:  GOTO    31F0
....................           
....................       check = 0; 
0337A:  BCLR.B  91E.0
0337C:  GOTO    31F0
....................    } 
....................     
....................    data=(D7<<7)+(D6<<6)+(D5<<5)+(D4<<4)+(D3<<3)+(D2<<2)+(D1<<1)+D0; 
03380:  MOV     90C,W5
03382:  SL      W5,#7,W5
03384:  MOV     90E,W0
03386:  SL      W0,#6,W0
03388:  ADD     W0,W5,W5
0338A:  MOV     910,W0
0338C:  SL      W0,#5,W0
0338E:  ADD     W0,W5,W5
03390:  MOV     912,W0
03392:  SL      W0,#4,W0
03394:  ADD     W0,W5,W5
03396:  MOV     914,W0
03398:  SL      W0,#3,W0
0339A:  ADD     W0,W5,W5
0339C:  MOV     916,W0
0339E:  SL      W0,#2,W0
033A0:  ADD     W0,W5,W5
033A2:  MOV     918,W0
033A4:  SL      W0,#1,W0
033A6:  ADD     W0,W5,W5
033A8:  MOV     W5,W0
033AA:  ADD     91A,W0
033AC:  MOV     W0,90A
....................    return data; 
033AE:  PUSH    90A
033B0:  POP     0
033B2:  MOV     [--W15],W5
033B4:  RETURN  
.................... } 
.................... //Gets BCD byte via parallel port 
.................... unsigned int pp_get_BCD_byte() 
*
0344C:  MOV     W5,[W15++]
0344E:  CLR     912
03450:  CLR     914
03452:  CLR     916
03454:  CLR     918
03456:  CLR     91A
03458:  CLR     91C
0345A:  CLR     91E
0345C:  CLR     920
0345E:  CLR     922
03460:  BSET.B  926.0
.................... { 
....................    unsigned int data=0; 
....................    unsigned int D7=0; 
....................    unsigned int D6=0; 
....................    unsigned int D5=0; 
....................    unsigned int D4=0; 
....................    unsigned int D3=0; 
....................    unsigned int D2=0; 
....................    unsigned int D1=0; 
....................    unsigned int D0=0; 
....................     
....................    unsigned int i; 
....................    int1 check = 1; 
....................     
....................    while(check) 
03462:  BTSS.B  926.0
03464:  BRA     35F2
....................    { 
....................       int sum7 = 0; 
....................       int sum6 = 0; 
....................       int sum5 = 0; 
....................       int sum4 = 0; 
....................       int sum3 = 0; 
....................       int sum2 = 0; 
....................       int sum1 = 0; 
....................       int sum0 = 0; 
03466:  CLR     928
03468:  CLR     92A
0346A:  CLR     92C
0346C:  CLR     92E
0346E:  CLR     930
03470:  CLR     932
03472:  CLR     934
03474:  CLR     936
....................              
....................       for(i=0; i<100; i++) 
03476:  CLR     924
03478:  MOV     924,W4
0347A:  MOV     #64,W3
0347C:  CP      W3,W4
0347E:  BRA     LEU,34EC
....................       { 
....................          delay_us(pp_str_delay); 
03480:  MOV     8F8,W0
03482:  CALL    21E4
....................          if(input(PP_D7) == 0) 
03486:  BSET.B  2D3.2
03488:  BTSC.B  2D5.2
0348A:  BRA     3492
....................             sum7 += 1; 
0348C:  MOV     928,W4
0348E:  ADD     W4,#1,W4
03490:  MOV     W4,928
....................          if(input(PP_D6) == 0) 
03492:  BSET.B  2D3.3
03494:  BTSC.B  2D5.3
03496:  BRA     349E
....................             sum6 += 1; 
03498:  MOV     92A,W4
0349A:  ADD     W4,#1,W4
0349C:  MOV     W4,92A
....................          if(input(PP_D5) == 0) 
0349E:  BSET.B  2D2.0
034A0:  BTSC.B  2D4.0
034A2:  BRA     34AA
....................             sum5 += 1; 
034A4:  MOV     92C,W4
034A6:  ADD     W4,#1,W4
034A8:  MOV     W4,92C
....................          if(input(PP_D4) == 0) 
034AA:  BSET.B  2CD.5
034AC:  BTSC.B  2CF.5
034AE:  BRA     34B6
....................             sum4 += 1; 
034B0:  MOV     92E,W4
034B2:  ADD     W4,#1,W4
034B4:  MOV     W4,92E
....................          if(input(PP_D3) == 0) 
034B6:  BSET.B  2CD.6
034B8:  BTSC.B  2CF.6
034BA:  BRA     34C2
....................             sum3 += 1; 
034BC:  MOV     930,W4
034BE:  ADD     W4,#1,W4
034C0:  MOV     W4,930
....................          if(input(PP_D2) == 0) 
034C2:  BSET.B  2D2.1
034C4:  BTSC.B  2D4.1
034C6:  BRA     34CE
....................             sum2 += 1; 
034C8:  MOV     932,W4
034CA:  ADD     W4,#1,W4
034CC:  MOV     W4,932
....................          if(input(PP_D1) == 0) 
034CE:  BSET.B  2D2.2
034D0:  BTSC.B  2D4.2
034D2:  BRA     34DA
....................             sum1 += 1; 
034D4:  MOV     934,W4
034D6:  ADD     W4,#1,W4
034D8:  MOV     W4,934
....................          if(input(PP_D0) == 0) 
034DA:  BSET.B  2D2.3
034DC:  BTSC.B  2D4.3
034DE:  BRA     34E6
....................             sum0 += 1; 
034E0:  MOV     936,W4
034E2:  ADD     W4,#1,W4
034E4:  MOV     W4,936
034E6:  INC     0924
034E8:  GOTO    3478
....................       } 
....................        
....................       if(sum7 > 70) 
034EC:  MOV     928,W4
034EE:  MOV     #46,W3
034F0:  CP      W3,W4
034F2:  BRA     GE,34FC
....................          D7 = 1; 
034F4:  MOV     #1,W4
034F6:  MOV     W4,914
034F8:  GOTO    350C
....................       else if (sum7 < 30) 
034FC:  MOV     928,W4
034FE:  CP      W4,#1E
03500:  BRA     GE,3508
....................          D7 = 0; 
03502:  CLR     914
03504:  GOTO    350C
....................       else 
....................          continue; 
03508:  GOTO    3462
....................           
....................       if(sum6 > 70) 
0350C:  MOV     92A,W4
0350E:  MOV     #46,W3
03510:  CP      W3,W4
03512:  BRA     GE,351C
....................          D6 = 1; 
03514:  MOV     #1,W4
03516:  MOV     W4,916
03518:  GOTO    352C
....................       else if (sum6 < 30) 
0351C:  MOV     92A,W4
0351E:  CP      W4,#1E
03520:  BRA     GE,3528
....................          D6 = 0; 
03522:  CLR     916
03524:  GOTO    352C
....................       else 
....................          continue; 
03528:  GOTO    3462
....................           
....................       if(sum5 > 70) 
0352C:  MOV     92C,W4
0352E:  MOV     #46,W3
03530:  CP      W3,W4
03532:  BRA     GE,353C
....................          D5 = 1; 
03534:  MOV     #1,W4
03536:  MOV     W4,918
03538:  GOTO    354C
....................       else if (sum5 < 30) 
0353C:  MOV     92C,W4
0353E:  CP      W4,#1E
03540:  BRA     GE,3548
....................          D5 = 0; 
03542:  CLR     918
03544:  GOTO    354C
....................       else 
....................          continue; 
03548:  GOTO    3462
....................           
....................       if(sum4 > 70) 
0354C:  MOV     92E,W4
0354E:  MOV     #46,W3
03550:  CP      W3,W4
03552:  BRA     GE,355C
....................          D4 = 1; 
03554:  MOV     #1,W4
03556:  MOV     W4,91A
03558:  GOTO    356C
....................       else if (sum4 < 30) 
0355C:  MOV     92E,W4
0355E:  CP      W4,#1E
03560:  BRA     GE,3568
....................          D4 = 0; 
03562:  CLR     91A
03564:  GOTO    356C
....................       else 
....................          continue; 
03568:  GOTO    3462
....................           
....................       if(sum3 > 70) 
0356C:  MOV     930,W4
0356E:  MOV     #46,W3
03570:  CP      W3,W4
03572:  BRA     GE,357C
....................          D3 = 1; 
03574:  MOV     #1,W4
03576:  MOV     W4,91C
03578:  GOTO    358C
....................       else if (sum3 < 30) 
0357C:  MOV     930,W4
0357E:  CP      W4,#1E
03580:  BRA     GE,3588
....................          D3 = 0; 
03582:  CLR     91C
03584:  GOTO    358C
....................       else 
....................          continue; 
03588:  GOTO    3462
....................           
....................       if(sum2 > 70) 
0358C:  MOV     932,W4
0358E:  MOV     #46,W3
03590:  CP      W3,W4
03592:  BRA     GE,359C
....................          D2 = 1; 
03594:  MOV     #1,W4
03596:  MOV     W4,91E
03598:  GOTO    35AC
....................       else if (sum2 < 30) 
0359C:  MOV     932,W4
0359E:  CP      W4,#1E
035A0:  BRA     GE,35A8
....................          D2 = 0; 
035A2:  CLR     91E
035A4:  GOTO    35AC
....................       else 
....................          continue; 
035A8:  GOTO    3462
....................           
....................       if(sum1 > 70) 
035AC:  MOV     934,W4
035AE:  MOV     #46,W3
035B0:  CP      W3,W4
035B2:  BRA     GE,35BC
....................          D1 = 1; 
035B4:  MOV     #1,W4
035B6:  MOV     W4,920
035B8:  GOTO    35CC
....................       else if (sum1 < 30) 
035BC:  MOV     934,W4
035BE:  CP      W4,#1E
035C0:  BRA     GE,35C8
....................          D1 = 0; 
035C2:  CLR     920
035C4:  GOTO    35CC
....................       else 
....................          continue; 
035C8:  GOTO    3462
....................           
....................       if(sum0 > 70) 
035CC:  MOV     936,W4
035CE:  MOV     #46,W3
035D0:  CP      W3,W4
035D2:  BRA     GE,35DC
....................          D0 = 1; 
035D4:  MOV     #1,W4
035D6:  MOV     W4,922
035D8:  GOTO    35EC
....................       else if (sum0 < 30) 
035DC:  MOV     936,W4
035DE:  CP      W4,#1E
035E0:  BRA     GE,35E8
....................          D0 = 0; 
035E2:  CLR     922
035E4:  GOTO    35EC
....................       else 
....................          continue; 
035E8:  GOTO    3462
....................           
....................       check = 0; 
035EC:  BCLR.B  926.0
035EE:  GOTO    3462
....................    } 
....................     
....................    unsigned int byte0=0; 
....................    unsigned int byte1=0; 
035F2:  CLR     938
035F4:  CLR     93A
....................     
....................    byte0=8*D7+4*D6+2*D5+D4; 
035F6:  MOV     914,W5
035F8:  SL      W5,#3,W5
035FA:  MOV     916,W0
035FC:  SL      W0,#2,W0
035FE:  ADD     W0,W5,W5
03600:  MOV     918,W0
03602:  SL      W0,#1,W0
03604:  ADD     W0,W5,W5
03606:  MOV     W5,W0
03608:  ADD     91A,W0
0360A:  MOV     W0,938
....................    byte1=8*D3+4*D2+2*D1+D0; 
0360C:  MOV     91C,W5
0360E:  SL      W5,#3,W5
03610:  MOV     91E,W0
03612:  SL      W0,#2,W0
03614:  ADD     W0,W5,W5
03616:  MOV     920,W0
03618:  SL      W0,#1,W0
0361A:  ADD     W0,W5,W5
0361C:  MOV     W5,W0
0361E:  ADD     922,W0
03620:  MOV     W0,93A
....................    data=byte0*10+byte1; 
03622:  MOV     938,W4
03624:  MUL.UU  W4,#A,W0
03626:  MOV     W0,W5
03628:  MOV     W5,W0
0362A:  ADD     93A,W0
0362C:  MOV     W0,912
....................     
....................    return data; 
0362E:  PUSH    912
03630:  POP     0
03632:  MOV     [--W15],W5
03634:  RETURN  
.................... } 
.................... // Sets position given via parallel port 
.................... void pp_set_pos() 
*
03650:  MOV     W5,[W15++]
.................... { 
....................    delay_ms(pp_rdy_delay); 
03652:  MOV     8FC,W0
03654:  CALL    1586
....................    output_high(PP_RDY); 
03658:  BCLR.B  2D2.5
0365A:  BSET.B  2D6.5
....................  
....................    pp_str_check(); 
0365C:  CALL    3442
....................  
....................    output_low(PP_ACK); 
03660:  BCLR.B  2D2.4
03662:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
03664:  BCLR.B  2D2.5
03666:  BCLR.B  2D6.5
....................    delay_ms(pp_ack_delay); 
03668:  MOV     8FA,W0
0366A:  CALL    1586
....................    output_high(PP_ACK); 
0366E:  BCLR.B  2D2.4
03670:  BSET.B  2D6.4
....................     
....................    unsigned int index=pp_get_BCD_byte(); 
03672:  CALL    344C
03676:  MOV     W0,90A
....................     
....................    delay_ms(pp_rdy_delay); 
03678:  MOV     8FC,W0
0367A:  CALL    1586
....................    output_high(PP_RDY); 
0367E:  BCLR.B  2D2.5
03680:  BSET.B  2D6.5
....................     
....................    pp_str_check(); 
03682:  CALL    3442
....................     
....................    output_low(PP_ACK); 
03686:  BCLR.B  2D2.4
03688:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
0368A:  BCLR.B  2D2.5
0368C:  BCLR.B  2D6.5
....................    delay_ms(pp_ack_delay); 
0368E:  MOV     8FA,W0
03690:  CALL    1586
....................    output_high(PP_ACK); 
03694:  BCLR.B  2D2.4
03696:  BSET.B  2D6.4
....................     
....................    unsigned int pos0=pp_get_BCD_byte(); 
03698:  CALL    344C
0369C:  MOV     W0,90C
....................     
....................    delay_ms(pp_rdy_delay); 
0369E:  MOV     8FC,W0
036A0:  CALL    1586
....................    output_high(PP_RDY); 
036A4:  BCLR.B  2D2.5
036A6:  BSET.B  2D6.5
....................     
....................    pp_str_check(); 
036A8:  CALL    3442
....................  
....................    output_low(PP_ACK); 
036AC:  BCLR.B  2D2.4
036AE:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
036B0:  BCLR.B  2D2.5
036B2:  BCLR.B  2D6.5
....................    delay_ms(pp_ack_delay); 
036B4:  MOV     8FA,W0
036B6:  CALL    1586
....................    output_high(PP_ACK); 
036BA:  BCLR.B  2D2.4
036BC:  BSET.B  2D6.4
....................     
....................    unsigned int pos1=pp_get_BCD_byte(); 
036BE:  CALL    344C
036C2:  MOV     W0,90E
....................  
....................    data_set_pos(index, pos0*100+pos1); 
036C4:  MOV     90C,W4
036C6:  MOV     #64,W3
036C8:  MUL.UU  W4,W3,W0
036CA:  MOV     W0,W5
036CC:  MOV     W5,W0
036CE:  ADD     90E,W0
036D0:  MOV     W0,W5
036D2:  MOV.B   90A,W0L
036D4:  MOV.B   W0L,966
036D6:  MOV     W5,968
036D8:  CALL    3636
....................     
....................    fprintf(RS232,"Position set -> index: %u position: %u\n\r", index, pos0*100+pos1); 
036DC:  MOV     90C,W4
036DE:  MOV     #64,W3
036E0:  MUL.UU  W4,W3,W0
036E2:  MOV     W0,W5
036E4:  MOV     W5,W0
036E6:  ADD     90E,W0
036E8:  MOV     W0,W5
036EA:  MOV     #0,W1
036EC:  MOV     W1,W0
036EE:  CLR.B   1
036F0:  CALL    C72
036F4:  INC     W1,W1
036F6:  BTSC.B  219.1
036F8:  BRA     36F6
036FA:  MOV.B   W0L,21A
036FC:  MOV     #16,W0
036FE:  CPSGT   W1,W0
03700:  BRA     36EC
03702:  MOV     90A,W0
03704:  MOV     #0,W4
03706:  CALL    1596
0370A:  MOV     #19,W1
0370C:  MOV     W1,W0
0370E:  CLR.B   1
03710:  CALL    C72
03714:  INC     W1,W1
03716:  BTSC.B  219.1
03718:  BRA     3716
0371A:  MOV.B   W0L,21A
0371C:  MOV     #23,W0
0371E:  CPSGT   W1,W0
03720:  BRA     370C
03722:  MOV     W5,W0
03724:  MOV     #0,W4
03726:  CALL    1596
0372A:  BTSC.B  219.1
0372C:  BRA     372A
0372E:  MOV.B   #A,W0L
03730:  MOV.B   W0L,21A
03732:  BTSC.B  219.1
03734:  BRA     3732
03736:  MOV.B   #D,W0L
03738:  MOV.B   W0L,21A
....................     
....................    pp_str_low_check(); 
0373A:  CALL    33B6
0373E:  MOV     [--W15],W5
03740:  RETURN  
.................... } 
.................... // Moves to position given via parallel port 
.................... void pp_move_pos(unsigned int input) 
*
037BC:  CALL    344C
037C0:  MOV     W0,90C
.................... { 
....................    unsigned int index=pp_get_BCD_byte();; 
....................    unsigned int position=data_get_pos(index); 
037C2:  MOV.B   90C,W0L
037C4:  MOV.B   W0L,96A
037C6:  CALL    3742
037CA:  MOV     W0,90E
....................     
....................    fprintf(RS232,"Move Position -> index: %u position: %u\n\r", index, position); 
037CC:  MOV     #0,W1
037CE:  MOV     W1,W0
037D0:  CLR.B   1
037D2:  CALL    CA8
037D6:  INC     W1,W1
037D8:  BTSC.B  219.1
037DA:  BRA     37D8
037DC:  MOV.B   W0L,21A
037DE:  MOV     #17,W0
037E0:  CPSGT   W1,W0
037E2:  BRA     37CE
037E4:  MOV     90C,W0
037E6:  MOV     #0,W4
037E8:  CALL    1596
037EC:  MOV     #1A,W1
037EE:  MOV     W1,W0
037F0:  CLR.B   1
037F2:  CALL    CA8
037F6:  INC     W1,W1
037F8:  BTSC.B  219.1
037FA:  BRA     37F8
037FC:  MOV.B   W0L,21A
037FE:  MOV     #24,W0
03800:  CPSGT   W1,W0
03802:  BRA     37EE
03804:  MOV     90E,W0
03806:  MOV     #0,W4
03808:  CALL    1596
0380C:  BTSC.B  219.1
0380E:  BRA     380C
03810:  MOV.B   #A,W0L
03812:  MOV.B   W0L,21A
03814:  BTSC.B  219.1
03816:  BRA     3814
03818:  MOV.B   #D,W0L
0381A:  MOV.B   W0L,21A
....................        
....................    move_pos(position); 
0381C:  PUSH    90E
0381E:  POP     968
03820:  CALL    2DC8
03824:  RETURN  
.................... } 
.................... // Gets command via parallel port when system is idle 
.................... void pp_get_command() 
.................... { 
....................    output_low(PP_ACK); 
03826:  BCLR.B  2D2.4
03828:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
0382A:  BCLR.B  2D2.5
0382C:  BCLR.B  2D6.5
....................    delay_ms(pp_ack_delay); 
0382E:  MOV     8FA,W0
03830:  CALL    1586
....................    output_high(PP_ACK); 
03834:  BCLR.B  2D2.4
03836:  BSET.B  2D6.4
....................        
....................    unsigned int input=pp_get_byte(); 
03838:  CALL    31DA
0383C:  MOV     W0,908
....................  
....................    switch (input) 
0383E:  MOV     908,W0
03840:  XOR     #FE,W0
03842:  BRA     Z,3856
03844:  XOR     #3,W0
03846:  BRA     Z,3874
03848:  XOR     #1,W0
0384A:  BRA     Z,3894
0384C:  XOR     #7,W0
0384E:  BRA     Z,38BC
03850:  XOR     #4,W0
03852:  BRA     Z,38E4
03854:  BRA     3904
....................    { 
....................       case 0x00FE:   fprintf(RS232,"Emergency Stop Command\n\r"); 
03856:  MOV     #0,W1
03858:  MOV     W1,W0
0385A:  CLR.B   1
0385C:  CALL    CE0
03860:  INC     W1,W1
03862:  BTSC.B  219.1
03864:  BRA     3862
03866:  MOV.B   W0L,21A
03868:  MOV     #17,W0
0386A:  CPSGT   W1,W0
0386C:  BRA     3858
....................                       
....................                      reg_pp_stop=1; 
0386E:  BSET.B  8B0.7
....................                      break; 
03870:  GOTO    3910
....................       case 0x00FD:   fprintf(RS232,"Homing Command\n\r"); 
03874:  MOV     #0,W1
03876:  MOV     W1,W0
03878:  CLR.B   1
0387A:  CALL    D06
0387E:  INC     W1,W1
03880:  BTSC.B  219.1
03882:  BRA     3880
03884:  MOV.B   W0L,21A
03886:  MOV     #F,W0
03888:  CPSGT   W1,W0
0388A:  BRA     3876
....................        
....................                      move_home();    
0388C:  CALL    2504
....................                      break; 
03890:  GOTO    3910
....................       case 0x00FC:   fprintf(RS232,"Laser Off Command\n\r"); 
03894:  MOV     #0,W1
03896:  MOV     W1,W0
03898:  CLR.B   1
0389A:  CALL    D24
0389E:  INC     W1,W1
038A0:  BTSC.B  219.1
038A2:  BRA     38A0
038A4:  MOV.B   W0L,21A
038A6:  MOV     #12,W0
038A8:  CPSGT   W1,W0
038AA:  BRA     3896
....................                          
....................                      output_low(LAS_1); 
038AC:  BCLR.B  2E4.6
038AE:  BCLR.B  2E8.6
....................                      output_low(LAS_2); 
038B0:  BCLR.B  2E4.7
038B2:  BCLR.B  2E8.7
....................                      output_low(LAS_3); 
038B4:  BCLR.B  2E5.0
038B6:  BCLR.B  2E9.0
....................                      break; 
038B8:  GOTO    3910
....................       case 0x00FB:   fprintf(RS232,"Laser On Command\n\r"); 
038BC:  MOV     #0,W1
038BE:  MOV     W1,W0
038C0:  CLR.B   1
038C2:  CALL    D44
038C6:  INC     W1,W1
038C8:  BTSC.B  219.1
038CA:  BRA     38C8
038CC:  MOV.B   W0L,21A
038CE:  MOV     #11,W0
038D0:  CPSGT   W1,W0
038D2:  BRA     38BE
....................                       
....................                      output_high(LAS_1); 
038D4:  BCLR.B  2E4.6
038D6:  BSET.B  2E8.6
....................                      output_high(LAS_2); 
038D8:  BCLR.B  2E4.7
038DA:  BSET.B  2E8.7
....................                      output_high(LAS_3); 
038DC:  BCLR.B  2E5.0
038DE:  BSET.B  2E9.0
....................                      break;  
038E0:  GOTO    3910
....................       case 0x00FF:   fprintf(RS232,"Set Position Command\n\r"); 
038E4:  MOV     #0,W1
038E6:  MOV     W1,W0
038E8:  CLR.B   1
038EA:  CALL    D64
038EE:  INC     W1,W1
038F0:  BTSC.B  219.1
038F2:  BRA     38F0
038F4:  MOV.B   W0L,21A
038F6:  MOV     #15,W0
038F8:  CPSGT   W1,W0
038FA:  BRA     38E6
....................                       
....................                      pp_set_pos(); 
038FC:  CALL    3650
....................                      break; 
03900:  GOTO    3910
....................       default:       pp_move_pos(input);  
03904:  PUSH    908
03906:  POP     90A
03908:  CALL    37BC
....................                      break; 
0390C:  GOTO    3910
....................    } 
....................     
....................    delay_ms(pp_rdy_delay); 
03910:  MOV     8FC,W0
03912:  CALL    1586
....................    output_high(PP_RDY); 
03916:  BCLR.B  2D2.5
03918:  BSET.B  2D6.5
0391A:  RETURN  
.................... } 
....................  
.................... // Handles the messages of RS232 connection 
.................... void rs232_message() 
*
03F40:  MOV     W5,[W15++]
03F42:  MOV     W6,[W15++]
.................... { 
....................    char input; 
....................     
....................    input=fgetc(RS232); 
03F44:  BTSS.B  218.0
03F46:  BRA     3F44
03F48:  MOV     21C,W0
03F4A:  MOV.B   W0L,908
....................    switch (input){ 
03F4C:  MOV.B   908,W0L
03F4E:  CLR.B   1
03F50:  XOR     #63,W0
03F52:  BRA     Z,3F9E
03F54:  XOR     #10,W0
03F56:  BRA     Z,416A
03F58:  XOR     #1,W0
03F5A:  BRA     Z,41A2
03F5C:  XOR     #1A,W0
03F5E:  BRA     Z,41DA
03F60:  XOR     #D,W0
03F62:  BRA     Z,4212
03F64:  XOR     #13,W0
03F66:  BRA     Z,424A
03F68:  XOR     #14,W0
03F6A:  BRA     Z,4282
03F6C:  XOR     #16,W0
03F6E:  BRA     Z,42BA
03F70:  XOR     #1D,W0
03F72:  BRA     Z,42F2
03F74:  XOR     #4,W0
03F76:  BRA     Z,42FA
03F78:  XOR     #15,W0
03F7A:  BRA     Z,431A
03F7C:  XOR     #9,W0
03F7E:  BRA     Z,43B0
03F80:  XOR     #1E,W0
03F82:  BRA     Z,4502
03F84:  XOR     #3,W0
03F86:  BRA     Z,45F6
03F88:  XOR     #8,W0
03F8A:  BRA     Z,46E4
03F8C:  XOR     #13,W0
03F8E:  BRA     Z,48E4
03F90:  XOR     #D,W0
03F92:  BRA     Z,491E
03F94:  XOR     #1C,W0
03F96:  BRA     Z,49AE
03F98:  XOR     #7,W0
03F9A:  BRA     Z,4A34
03F9C:  BRA     4A3A
....................       case 'c':   fprintf(RS232,"\n\rCOMMAND LIST\n\r"); 
03F9E:  MOV     #0,W1
03FA0:  MOV     W1,W0
03FA2:  CLR.B   1
03FA4:  CALL    D88
03FA8:  INC     W1,W1
03FAA:  BTSC.B  219.1
03FAC:  BRA     3FAA
03FAE:  MOV.B   W0L,21A
03FB0:  MOV     #F,W0
03FB2:  CPSGT   W1,W0
03FB4:  BRA     3FA0
....................                   fprintf(RS232,"\n\rSet Serial Number\t(s)"); 
03FB6:  MOV     #0,W1
03FB8:  MOV     W1,W0
03FBA:  CLR.B   1
03FBC:  CALL    DA6
03FC0:  INC     W1,W1
03FC2:  BTSC.B  219.1
03FC4:  BRA     3FC2
03FC6:  MOV.B   W0L,21A
03FC8:  MOV     #16,W0
03FCA:  CPSGT   W1,W0
03FCC:  BRA     3FB8
....................                   fprintf(RS232,"\n\rSet Move Range \t\t(r)"); 
03FCE:  MOV     #0,W1
03FD0:  MOV     W1,W0
03FD2:  CLR.B   1
03FD4:  CALL    DCA
03FD8:  INC     W1,W1
03FDA:  BTSC.B  219.1
03FDC:  BRA     3FDA
03FDE:  MOV.B   W0L,21A
03FE0:  MOV     #15,W0
03FE2:  CPSGT   W1,W0
03FE4:  BRA     3FD0
....................                   fprintf(RS232,"\n\rSet Homing Distance \t(h)"); 
03FE6:  MOV     #0,W1
03FE8:  MOV     W1,W0
03FEA:  CLR.B   1
03FEC:  CALL    DEE
03FF0:  INC     W1,W1
03FF2:  BTSC.B  219.1
03FF4:  BRA     3FF2
03FF6:  MOV.B   W0L,21A
03FF8:  MOV     #19,W0
03FFA:  CPSGT   W1,W0
03FFC:  BRA     3FE8
....................                   fprintf(RS232,"\n\rSet End Distance \t(e)"); 
03FFE:  MOV     #0,W1
04000:  MOV     W1,W0
04002:  CLR.B   1
04004:  CALL    E16
04008:  INC     W1,W1
0400A:  BTSC.B  219.1
0400C:  BRA     400A
0400E:  MOV.B   W0L,21A
04010:  MOV     #16,W0
04012:  CPSGT   W1,W0
04014:  BRA     4000
....................                   fprintf(RS232,"\n\rSet Conversion Constant\t(v)"); 
04016:  MOV     #0,W1
04018:  MOV     W1,W0
0401A:  CLR.B   1
0401C:  CALL    E3A
04020:  INC     W1,W1
04022:  BTSC.B  219.1
04024:  BRA     4022
04026:  MOV.B   W0L,21A
04028:  MOV     #1C,W0
0402A:  CPSGT   W1,W0
0402C:  BRA     4018
....................                   fprintf(RS232,"\n\rSet Backlash \t\t(b)"); 
0402E:  MOV     #0,W1
04030:  MOV     W1,W0
04032:  CLR.B   1
04034:  CALL    E64
04038:  INC     W1,W1
0403A:  BTSC.B  219.1
0403C:  BRA     403A
0403E:  MOV.B   W0L,21A
04040:  MOV     #13,W0
04042:  CPSGT   W1,W0
04044:  BRA     4030
....................                   fprintf(RS232,"\n\rSet Communication Type \t(t)"); 
04046:  MOV     #0,W1
04048:  MOV     W1,W0
0404A:  CLR.B   1
0404C:  CALL    E86
04050:  INC     W1,W1
04052:  BTSC.B  219.1
04054:  BRA     4052
04056:  MOV.B   W0L,21A
04058:  MOV     #1C,W0
0405A:  CPSGT   W1,W0
0405C:  BRA     4048
....................                   fprintf(RS232,"\n\rGet System Data \t(i)"); 
0405E:  MOV     #0,W1
04060:  MOV     W1,W0
04062:  CLR.B   1
04064:  CALL    EB0
04068:  INC     W1,W1
0406A:  BTSC.B  219.1
0406C:  BRA     406A
0406E:  MOV.B   W0L,21A
04070:  MOV     #15,W0
04072:  CPSGT   W1,W0
04074:  BRA     4060
....................                   fprintf(RS232,"\n\rGet Position List \t(m)"); 
04076:  MOV     #0,W1
04078:  MOV     W1,W0
0407A:  CLR.B   1
0407C:  CALL    ED4
04080:  INC     W1,W1
04082:  BTSC.B  219.1
04084:  BRA     4082
04086:  MOV.B   W0L,21A
04088:  MOV     #17,W0
0408A:  CPSGT   W1,W0
0408C:  BRA     4078
....................                   fprintf(RS232,"\n\rMove To Position \t(x)"); 
0408E:  MOV     #0,W1
04090:  MOV     W1,W0
04092:  CLR.B   1
04094:  CALL    EFA
04098:  INC     W1,W1
0409A:  BTSC.B  219.1
0409C:  BRA     409A
0409E:  MOV.B   W0L,21A
040A0:  MOV     #16,W0
040A2:  CPSGT   W1,W0
040A4:  BRA     4090
....................                   fprintf(RS232,"\n\rSet Table Data \t\t(q)"); 
040A6:  MOV     #0,W1
040A8:  MOV     W1,W0
040AA:  CLR.B   1
040AC:  CALL    F1E
040B0:  INC     W1,W1
040B2:  BTSC.B  219.1
040B4:  BRA     40B2
040B6:  MOV.B   W0L,21A
040B8:  MOV     #15,W0
040BA:  CPSGT   W1,W0
040BC:  BRA     40A8
....................                   fprintf(RS232,"\n\rTest Run (low res) \t(o)"); 
040BE:  MOV     #0,W1
040C0:  MOV     W1,W0
040C2:  CLR.B   1
040C4:  CALL    F42
040C8:  INC     W1,W1
040CA:  BTSC.B  219.1
040CC:  BRA     40CA
040CE:  MOV.B   W0L,21A
040D0:  MOV     #18,W0
040D2:  CPSGT   W1,W0
040D4:  BRA     40C0
....................                   fprintf(RS232,"\n\rTest Run (high res) \t(l)"); 
040D6:  MOV     #0,W1
040D8:  MOV     W1,W0
040DA:  CLR.B   1
040DC:  CALL    F68
040E0:  INC     W1,W1
040E2:  BTSC.B  219.1
040E4:  BRA     40E2
040E6:  MOV.B   W0L,21A
040E8:  MOV     #19,W0
040EA:  CPSGT   W1,W0
040EC:  BRA     40D8
....................                   fprintf(RS232,"\n\rSet Debug State \t(d)"); 
040EE:  MOV     #0,W1
040F0:  MOV     W1,W0
040F2:  CLR.B   1
040F4:  CALL    F90
040F8:  INC     W1,W1
040FA:  BTSC.B  219.1
040FC:  BRA     40FA
040FE:  MOV.B   W0L,21A
04100:  MOV     #15,W0
04102:  CPSGT   W1,W0
04104:  BRA     40F0
....................                   fprintf(RS232,"\n\rGet Encoder Count \t(w)"); 
04106:  MOV     #0,W1
04108:  MOV     W1,W0
0410A:  CLR.B   1
0410C:  CALL    FB4
04110:  INC     W1,W1
04112:  BTSC.B  219.1
04114:  BRA     4112
04116:  MOV.B   W0L,21A
04118:  MOV     #17,W0
0411A:  CPSGT   W1,W0
0411C:  BRA     4108
....................                   fprintf(RS232,"\n\rStart Memory Test \t(z)"); 
0411E:  MOV     #0,W1
04120:  MOV     W1,W0
04122:  CLR.B   1
04124:  CALL    FDA
04128:  INC     W1,W1
0412A:  BTSC.B  219.1
0412C:  BRA     412A
0412E:  MOV.B   W0L,21A
04130:  MOV     #17,W0
04132:  CPSGT   W1,W0
04134:  BRA     4120
....................                   fprintf(RS232,"\n\rClear Memory \t\t(f)"); 
04136:  MOV     #0,W1
04138:  MOV     W1,W0
0413A:  CLR.B   1
0413C:  CALL    1000
04140:  INC     W1,W1
04142:  BTSC.B  219.1
04144:  BRA     4142
04146:  MOV.B   W0L,21A
04148:  MOV     #13,W0
0414A:  CPSGT   W1,W0
0414C:  BRA     4138
....................                   fprintf(RS232,"\n\n\r"); 
0414E:  BTSC.B  219.1
04150:  BRA     414E
04152:  MOV.B   #A,W0L
04154:  MOV.B   W0L,21A
04156:  BTSC.B  219.1
04158:  BRA     4156
0415A:  MOV.B   #A,W0L
0415C:  MOV.B   W0L,21A
0415E:  BTSC.B  219.1
04160:  BRA     415E
04162:  MOV.B   #D,W0L
04164:  MOV.B   W0L,21A
....................                   break; 
04166:  GOTO    4A3A
....................       case 's':   fprintf(RS232,"\n\rSet Serial Number (13 Characters): "); 
0416A:  MOV     #0,W1
0416C:  MOV     W1,W0
0416E:  CLR.B   1
04170:  CALL    1022
04174:  INC     W1,W1
04176:  BTSC.B  219.1
04178:  BRA     4176
0417A:  MOV.B   W0L,21A
0417C:  MOV     #24,W0
0417E:  CPSGT   W1,W0
04180:  BRA     416C
....................                   data_set_serial_no(); 
04182:  CALL    391C
....................                   fprintf(RS232,"\n\n\r"); 
04186:  BTSC.B  219.1
04188:  BRA     4186
0418A:  MOV.B   #A,W0L
0418C:  MOV.B   W0L,21A
0418E:  BTSC.B  219.1
04190:  BRA     418E
04192:  MOV.B   #A,W0L
04194:  MOV.B   W0L,21A
04196:  BTSC.B  219.1
04198:  BRA     4196
0419A:  MOV.B   #D,W0L
0419C:  MOV.B   W0L,21A
....................                   break; 
0419E:  GOTO    4A3A
....................       case 'r':   fprintf(RS232,"\n\rSet Move Range in mm (xxxx): "); 
041A2:  MOV     #0,W1
041A4:  MOV     W1,W0
041A6:  CLR.B   1
041A8:  CALL    1054
041AC:  INC     W1,W1
041AE:  BTSC.B  219.1
041B0:  BRA     41AE
041B2:  MOV.B   W0L,21A
041B4:  MOV     #1E,W0
041B6:  CPSGT   W1,W0
041B8:  BRA     41A4
....................                   data_set_move_range(); 
041BA:  CALL    3980
....................                   fprintf(RS232,"\n\n\r"); 
041BE:  BTSC.B  219.1
041C0:  BRA     41BE
041C2:  MOV.B   #A,W0L
041C4:  MOV.B   W0L,21A
041C6:  BTSC.B  219.1
041C8:  BRA     41C6
041CA:  MOV.B   #A,W0L
041CC:  MOV.B   W0L,21A
041CE:  BTSC.B  219.1
041D0:  BRA     41CE
041D2:  MOV.B   #D,W0L
041D4:  MOV.B   W0L,21A
....................                   break; 
041D6:  GOTO    4A3A
....................       case 'h':   fprintf(RS232,"\n\rSet Homing Distance in counts (xxxx): "); 
041DA:  MOV     #0,W1
041DC:  MOV     W1,W0
041DE:  CLR.B   1
041E0:  CALL    1080
041E4:  INC     W1,W1
041E6:  BTSC.B  219.1
041E8:  BRA     41E6
041EA:  MOV.B   W0L,21A
041EC:  MOV     #27,W0
041EE:  CPSGT   W1,W0
041F0:  BRA     41DC
....................                   data_set_home_pos(); 
041F2:  CALL    3A56
....................                   fprintf(RS232,"\n\n\r"); 
041F6:  BTSC.B  219.1
041F8:  BRA     41F6
041FA:  MOV.B   #A,W0L
041FC:  MOV.B   W0L,21A
041FE:  BTSC.B  219.1
04200:  BRA     41FE
04202:  MOV.B   #A,W0L
04204:  MOV.B   W0L,21A
04206:  BTSC.B  219.1
04208:  BRA     4206
0420A:  MOV.B   #D,W0L
0420C:  MOV.B   W0L,21A
....................                   break; 
0420E:  GOTO    4A3A
....................       case 'e':   fprintf(RS232,"\n\rSet End Distance in counts (xxxxx): "); 
04212:  MOV     #0,W1
04214:  MOV     W1,W0
04216:  CLR.B   1
04218:  CALL    10B6
0421C:  INC     W1,W1
0421E:  BTSC.B  219.1
04220:  BRA     421E
04222:  MOV.B   W0L,21A
04224:  MOV     #25,W0
04226:  CPSGT   W1,W0
04228:  BRA     4214
....................                   data_set_end_pos(); 
0422A:  CALL    3AEC
....................                   fprintf(RS232,"\n\n\r"); 
0422E:  BTSC.B  219.1
04230:  BRA     422E
04232:  MOV.B   #A,W0L
04234:  MOV.B   W0L,21A
04236:  BTSC.B  219.1
04238:  BRA     4236
0423A:  MOV.B   #A,W0L
0423C:  MOV.B   W0L,21A
0423E:  BTSC.B  219.1
04240:  BRA     423E
04242:  MOV.B   #D,W0L
04244:  MOV.B   W0L,21A
....................                   break; 
04246:  GOTO    4A3A
....................       case 'v':   fprintf(RS232,"\n\rSet Conversion Constant (xxxxx): "); 
0424A:  MOV     #0,W1
0424C:  MOV     W1,W0
0424E:  CLR.B   1
04250:  CALL    10EA
04254:  INC     W1,W1
04256:  BTSC.B  219.1
04258:  BRA     4256
0425A:  MOV.B   W0L,21A
0425C:  MOV     #22,W0
0425E:  CPSGT   W1,W0
04260:  BRA     424C
....................                   data_set_conv_const(); 
04262:  CALL    3B96
....................                   fprintf(RS232,"\n\n\r"); 
04266:  BTSC.B  219.1
04268:  BRA     4266
0426A:  MOV.B   #A,W0L
0426C:  MOV.B   W0L,21A
0426E:  BTSC.B  219.1
04270:  BRA     426E
04272:  MOV.B   #A,W0L
04274:  MOV.B   W0L,21A
04276:  BTSC.B  219.1
04278:  BRA     4276
0427A:  MOV.B   #D,W0L
0427C:  MOV.B   W0L,21A
....................                   break; 
0427E:  GOTO    4A3A
....................       case 'b':   fprintf(RS232,"\n\rSet Backlash (xx): "); 
04282:  MOV     #0,W1
04284:  MOV     W1,W0
04286:  CLR.B   1
04288:  CALL    111A
0428C:  INC     W1,W1
0428E:  BTSC.B  219.1
04290:  BRA     428E
04292:  MOV.B   W0L,21A
04294:  MOV     #14,W0
04296:  CPSGT   W1,W0
04298:  BRA     4284
....................                   data_set_backlash(); 
0429A:  CALL    3CB4
....................                   fprintf(RS232,"\n\n\r"); 
0429E:  BTSC.B  219.1
042A0:  BRA     429E
042A2:  MOV.B   #A,W0L
042A4:  MOV.B   W0L,21A
042A6:  BTSC.B  219.1
042A8:  BRA     42A6
042AA:  MOV.B   #A,W0L
042AC:  MOV.B   W0L,21A
042AE:  BTSC.B  219.1
042B0:  BRA     42AE
042B2:  MOV.B   #D,W0L
042B4:  MOV.B   W0L,21A
....................                   break; 
042B6:  GOTO    4A3A
....................       case 't':   fprintf(RS232,"\n\rSet Communication Type (0: Parallel, 1: RS232"); 
042BA:  MOV     #0,W1
042BC:  MOV     W1,W0
042BE:  CLR.B   1
042C0:  CALL    113C
042C4:  INC     W1,W1
042C6:  BTSC.B  219.1
042C8:  BRA     42C6
042CA:  MOV.B   W0L,21A
042CC:  MOV     #2E,W0
042CE:  CPSGT   W1,W0
042D0:  BRA     42BC
....................                   data_set_comm_type(); 
042D2:  CALL    3D1A
....................                   fprintf(RS232,"\n\n\r"); 
042D6:  BTSC.B  219.1
042D8:  BRA     42D6
042DA:  MOV.B   #A,W0L
042DC:  MOV.B   W0L,21A
042DE:  BTSC.B  219.1
042E0:  BRA     42DE
042E2:  MOV.B   #A,W0L
042E4:  MOV.B   W0L,21A
042E6:  BTSC.B  219.1
042E8:  BRA     42E6
042EA:  MOV.B   #D,W0L
042EC:  MOV.B   W0L,21A
....................                   break; 
042EE:  GOTO    4A3A
....................       case 'i':   data_get_sys_data(); 
042F2:  CALL    3DF2
....................                   break; 
042F6:  GOTO    4A3A
....................       case 'm':   fprintf(RS232,"\n\rGet Position List(0<=X<=9): "); 
042FA:  MOV     #0,W1
042FC:  MOV     W1,W0
042FE:  CLR.B   1
04300:  CALL    1178
04304:  INC     W1,W1
04306:  BTSC.B  219.1
04308:  BRA     4306
0430A:  MOV.B   W0L,21A
0430C:  MOV     #1D,W0
0430E:  CPSGT   W1,W0
04310:  BRA     42FC
....................                   data_get_pos_table(); 
04312:  CALL    3EDC
....................                   break; 
04316:  GOTO    4A3A
....................       case 'x':   fprintf(RS232,"\n\rMove To(0<=X<=9999): "); 
0431A:  MOV     #0,W1
0431C:  MOV     W1,W0
0431E:  CLR.B   1
04320:  CALL    11A4
04324:  INC     W1,W1
04326:  BTSC.B  219.1
04328:  BRA     4326
0432A:  MOV.B   W0L,21A
0432C:  MOV     #16,W0
0432E:  CPSGT   W1,W0
04330:  BRA     431C
....................                   unsigned int i=0; 
....................                   unsigned int input_step[4]; 
....................                   unsigned int step=0; 
04332:  CLR     90A
04334:  CLR     914
....................                   for(i=0;i<4;i++){ 
04336:  CLR     90A
04338:  MOV     90A,W4
0433A:  CP      W4,#4
0433C:  BRA     C,4370
....................                      input_step[i]=(unsigned)(fgetc(RS232)-48); 
0433E:  MOV     90A,W0
04340:  SL      W0,#1,W0
04342:  MOV     #90C,W4
04344:  ADD     W0,W4,W5
04346:  BTSS.B  218.0
04348:  BRA     4346
0434A:  MOV     21C,W0
0434C:  ZE      W0,W0
0434E:  CLR.B   1
04350:  SUB     #30,W0
04352:  MOV     W0,[W5]
....................                      fputc(input_step[i]+48,RS232); 
04354:  MOV     90A,W0
04356:  SL      W0,#1,W0
04358:  MOV     #90C,W4
0435A:  ADD     W0,W4,W0
0435C:  MOV     [W0],W5
0435E:  ADD     #30,W5
04360:  MOV.B   W5L,W0L
04362:  BTSC.B  219.1
04364:  BRA     4362
04366:  MOV.B   W0L,21A
04368:  CLR.B   21B
0436A:  INC     090A
0436C:  GOTO    4338
....................                   } 
....................                   fprintf(RS232,"\n\n\r"); 
04370:  BTSC.B  219.1
04372:  BRA     4370
04374:  MOV.B   #A,W0L
04376:  MOV.B   W0L,21A
04378:  BTSC.B  219.1
0437A:  BRA     4378
0437C:  MOV.B   #A,W0L
0437E:  MOV.B   W0L,21A
04380:  BTSC.B  219.1
04382:  BRA     4380
04384:  MOV.B   #D,W0L
04386:  MOV.B   W0L,21A
....................                    
....................                   step=1000*input_step[0]+100*input_step[1]+10*input_step[2]+1*input_step[3]; 
04388:  MOV     #3E8,W4
0438A:  MOV     90C,W3
0438C:  MUL.UU  W4,W3,W0
0438E:  MOV     W0,W5
04390:  MOV     #64,W4
04392:  MOV     90E,W3
04394:  MUL.UU  W4,W3,W0
04396:  ADD     W0,W5,W5
04398:  MOV     910,W4
0439A:  MUL.UU  W4,#A,W0
0439C:  ADD     W0,W5,W5
0439E:  MOV     W5,W0
043A0:  ADD     912,W0
043A2:  MOV     W0,914
....................                    
....................                   move_pos(step); 
043A4:  PUSH    914
043A6:  POP     968
043A8:  CALL    2DC8
....................                   break; 
043AC:  GOTO    4A3A
....................       case 'q':   fprintf(RS232,"\n\rEnter Table Index (xx): "); 
043B0:  MOV     #0,W1
043B2:  MOV     W1,W0
043B4:  CLR.B   1
043B6:  CALL    11C8
043BA:  INC     W1,W1
043BC:  BTSC.B  219.1
043BE:  BRA     43BC
043C0:  MOV.B   W0L,21A
043C2:  MOV     #19,W0
043C4:  CPSGT   W1,W0
043C6:  BRA     43B2
....................                   unsigned int k=0; 
....................                   unsigned int input_index[2]; 
....................                   unsigned int index=0; 
043C8:  CLR     916
043CA:  CLR     91C
....................                   for(k=0;k<2;k++){ 
043CC:  CLR     916
043CE:  MOV     916,W4
043D0:  CP      W4,#2
043D2:  BRA     C,4406
....................                      input_index[k]=(unsigned)(fgetc(RS232)-48); 
043D4:  MOV     916,W0
043D6:  SL      W0,#1,W0
043D8:  MOV     #918,W4
043DA:  ADD     W0,W4,W5
043DC:  BTSS.B  218.0
043DE:  BRA     43DC
043E0:  MOV     21C,W0
043E2:  ZE      W0,W0
043E4:  CLR.B   1
043E6:  SUB     #30,W0
043E8:  MOV     W0,[W5]
....................                      fputc(input_index[k]+48,RS232); 
043EA:  MOV     916,W0
043EC:  SL      W0,#1,W0
043EE:  MOV     #918,W4
043F0:  ADD     W0,W4,W0
043F2:  MOV     [W0],W5
043F4:  ADD     #30,W5
043F6:  MOV.B   W5L,W0L
043F8:  BTSC.B  219.1
043FA:  BRA     43F8
043FC:  MOV.B   W0L,21A
043FE:  CLR.B   21B
04400:  INC     0916
04402:  GOTO    43CE
....................                   } 
....................                   fprintf(RS232,"\n\n\r"); 
04406:  BTSC.B  219.1
04408:  BRA     4406
0440A:  MOV.B   #A,W0L
0440C:  MOV.B   W0L,21A
0440E:  BTSC.B  219.1
04410:  BRA     440E
04412:  MOV.B   #A,W0L
04414:  MOV.B   W0L,21A
04416:  BTSC.B  219.1
04418:  BRA     4416
0441A:  MOV.B   #D,W0L
0441C:  MOV.B   W0L,21A
....................                    
....................                   index=10*input_index[0]+1*input_index[1]; 
0441E:  MOV     918,W4
04420:  MUL.UU  W4,#A,W0
04422:  MOV     W0,W5
04424:  MOV     W5,W0
04426:  ADD     91A,W0
04428:  MOV     W0,91C
....................                    
....................                   fprintf(RS232,"\n\rIndex: %u", index); 
0442A:  MOV     #0,W1
0442C:  MOV     W1,W0
0442E:  CLR.B   1
04430:  CALL    11F0
04434:  INC     W1,W1
04436:  BTSC.B  219.1
04438:  BRA     4436
0443A:  MOV.B   W0L,21A
0443C:  MOV     #8,W0
0443E:  CPSGT   W1,W0
04440:  BRA     442C
04442:  MOV     91C,W0
04444:  MOV     #0,W4
04446:  CALL    1596
....................                    
....................                   fprintf(RS232,"\n\rEnter Position (xxxx): "); 
0444A:  MOV     #0,W1
0444C:  MOV     W1,W0
0444E:  CLR.B   1
04450:  CALL    1208
04454:  INC     W1,W1
04456:  BTSC.B  219.1
04458:  BRA     4456
0445A:  MOV.B   W0L,21A
0445C:  MOV     #18,W0
0445E:  CPSGT   W1,W0
04460:  BRA     444C
....................                   unsigned int input_pos[2]; 
....................                   unsigned int posi=0; 
04462:  CLR     922
....................                   for(k=0;k<4;k++){ 
04464:  CLR     916
04466:  MOV     916,W4
04468:  CP      W4,#4
0446A:  BRA     C,449E
....................                      input_pos[k]=(unsigned)(fgetc(RS232)-48); 
0446C:  MOV     916,W0
0446E:  SL      W0,#1,W0
04470:  MOV     #91E,W4
04472:  ADD     W0,W4,W5
04474:  BTSS.B  218.0
04476:  BRA     4474
04478:  MOV     21C,W0
0447A:  ZE      W0,W0
0447C:  CLR.B   1
0447E:  SUB     #30,W0
04480:  MOV     W0,[W5]
....................                      fputc(input_pos[k]+48,RS232); 
04482:  MOV     916,W0
04484:  SL      W0,#1,W0
04486:  MOV     #91E,W4
04488:  ADD     W0,W4,W0
0448A:  MOV     [W0],W5
0448C:  ADD     #30,W5
0448E:  MOV.B   W5L,W0L
04490:  BTSC.B  219.1
04492:  BRA     4490
04494:  MOV.B   W0L,21A
04496:  CLR.B   21B
04498:  INC     0916
0449A:  GOTO    4466
....................                   } 
....................                   fprintf(RS232,"\n\n\r"); 
0449E:  BTSC.B  219.1
044A0:  BRA     449E
044A2:  MOV.B   #A,W0L
044A4:  MOV.B   W0L,21A
044A6:  BTSC.B  219.1
044A8:  BRA     44A6
044AA:  MOV.B   #A,W0L
044AC:  MOV.B   W0L,21A
044AE:  BTSC.B  219.1
044B0:  BRA     44AE
044B2:  MOV.B   #D,W0L
044B4:  MOV.B   W0L,21A
....................                    
....................                   posi=1000*input_pos[0]+100*input_pos[1]+10*input_pos[2]+1*input_pos[3]; 
044B6:  MOV     #3E8,W4
044B8:  MOV     91E,W3
044BA:  MUL.UU  W4,W3,W0
044BC:  MOV     W0,W5
044BE:  MOV     #64,W4
044C0:  MOV     920,W3
044C2:  MUL.UU  W4,W3,W0
044C4:  ADD     W0,W5,W5
044C6:  MOV     922,W4
044C8:  MUL.UU  W4,#A,W0
044CA:  ADD     W0,W5,W5
044CC:  MOV     W5,W0
044CE:  ADD     924,W0
044D0:  MOV     W0,922
....................                    
....................                   fprintf(RS232,"\n\rPosition: %u", posi); 
044D2:  MOV     #0,W1
044D4:  MOV     W1,W0
044D6:  CLR.B   1
044D8:  CALL    122E
044DC:  INC     W1,W1
044DE:  BTSC.B  219.1
044E0:  BRA     44DE
044E2:  MOV.B   W0L,21A
044E4:  MOV     #B,W0
044E6:  CPSGT   W1,W0
044E8:  BRA     44D4
044EA:  MOV     922,W0
044EC:  MOV     #0,W4
044EE:  CALL    1596
....................                    
....................                   data_set_pos(index, posi); 
044F2:  MOV.B   91C,W0L
044F4:  MOV.B   W0L,966
044F6:  PUSH    922
044F8:  POP     968
044FA:  CALL    3636
....................                   break; 
044FE:  GOTO    4A3A
....................       case 'o':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
04502:  MOV     #0,W1
04504:  MOV     W1,W0
04506:  CLR.B   1
04508:  CALL    124A
0450C:  INC     W1,W1
0450E:  BTSC.B  219.1
04510:  BRA     450E
04512:  MOV.B   W0L,21A
04514:  MOV     #F,W0
04516:  CPSGT   W1,W0
04518:  BRA     4504
....................                   unsigned int r=0; 
....................                   unsigned int input_speed[4]; 
....................                   unsigned int delay=0; 
0451A:  CLR     924
0451C:  CLR     92E
....................                   for(r=0;r<4;r++){ 
0451E:  CLR     924
04520:  MOV     924,W4
04522:  CP      W4,#4
04524:  BRA     C,4558
....................                      input_speed[r]=(unsigned)(fgetc(RS232)-48); 
04526:  MOV     924,W0
04528:  SL      W0,#1,W0
0452A:  MOV     #926,W4
0452C:  ADD     W0,W4,W5
0452E:  BTSS.B  218.0
04530:  BRA     452E
04532:  MOV     21C,W0
04534:  ZE      W0,W0
04536:  CLR.B   1
04538:  SUB     #30,W0
0453A:  MOV     W0,[W5]
....................                      fputc(input_speed[r]+48,RS232); 
0453C:  MOV     924,W0
0453E:  SL      W0,#1,W0
04540:  MOV     #926,W4
04542:  ADD     W0,W4,W0
04544:  MOV     [W0],W5
04546:  ADD     #30,W5
04548:  MOV.B   W5L,W0L
0454A:  BTSC.B  219.1
0454C:  BRA     454A
0454E:  MOV.B   W0L,21A
04550:  CLR.B   21B
04552:  INC     0924
04554:  GOTO    4520
....................                   } 
....................                   fprintf(RS232,"\n\r"); 
04558:  BTSC.B  219.1
0455A:  BRA     4558
0455C:  MOV.B   #A,W0L
0455E:  MOV.B   W0L,21A
04560:  BTSC.B  219.1
04562:  BRA     4560
04564:  MOV.B   #D,W0L
04566:  MOV.B   W0L,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
04568:  MOV     #3E8,W4
0456A:  MOV     926,W3
0456C:  MUL.UU  W4,W3,W0
0456E:  MOV     W0,W5
04570:  MOV     #64,W4
04572:  MOV     928,W3
04574:  MUL.UU  W4,W3,W0
04576:  ADD     W0,W5,W5
04578:  MOV     92A,W4
0457A:  MUL.UU  W4,#A,W0
0457C:  ADD     W0,W5,W5
0457E:  MOV     W5,W0
04580:  ADD     92C,W0
04582:  MOV     W0,92E
....................        
....................                   unsigned int m; 
....................                   unsigned int pos_cal=md_min_distance; 
....................                   unsigned int num=(md_move_range-md_min_distance)/40+1; 
04584:  PUSH    8C8
04586:  POP     932
04588:  MOV     8BE,W4
0458A:  MOV     8C8,W3
0458C:  SUB     W4,W3,W5
0458E:  MOV     W5,W4
04590:  MOV     #28,W3
04592:  REPEAT  #11
04594:  DIV.U   W4,W3
04596:  MOV     W0,W5
04598:  ADD     W5,#1,W5
0459A:  MOV     W5,934
....................                    
....................                   for(m=0; m<num; m++) 
0459C:  CLR     930
0459E:  MOV     930,W0
045A0:  MOV     934,W4
045A2:  CP      W4,W0
045A4:  BRA     LEU,45C2
....................                   { 
....................                      move_pos(pos_cal+m*40); 
045A6:  MOV     930,W4
045A8:  MOV     #28,W3
045AA:  MUL.UU  W4,W3,W0
045AC:  MOV     932,W4
045AE:  ADD     W0,W4,W5
045B0:  MOV     W5,968
045B2:  CALL    2DC8
....................                      delay_ms(delay); 
045B6:  MOV     92E,W0
045B8:  CALL    1586
045BC:  INC     0930
045BE:  GOTO    459E
....................                   } 
....................                    
....................                   pos_cal=pos_cal+(num-1)*40; 
045C2:  MOV     934,W4
045C4:  SUB     W4,#1,W5
045C6:  MOV     #28,W4
045C8:  MUL.UU  W5,W4,W0
045CA:  ADD     932
....................                    
....................                   for(m=0; m<num; m++) 
045CC:  CLR     930
045CE:  MOV     930,W0
045D0:  MOV     934,W4
045D2:  CP      W4,W0
045D4:  BRA     LEU,45F2
....................                   { 
....................                      move_pos(pos_cal-m*40); 
045D6:  MOV     930,W4
045D8:  MOV     #28,W3
045DA:  MUL.UU  W4,W3,W0
045DC:  MOV     932,W4
045DE:  SUB     W4,W0,W5
045E0:  MOV     W5,968
045E2:  CALL    2DC8
....................                      delay_ms(delay); 
045E6:  MOV     92E,W0
045E8:  CALL    1586
045EC:  INC     0930
045EE:  GOTO    45CE
....................                   } 
....................                   break; 
045F2:  GOTO    4A3A
....................       case 'l':   fprintf(RS232,"\n\rSpeed (xxxx): "); 
045F6:  MOV     #0,W1
045F8:  MOV     W1,W0
045FA:  CLR.B   1
045FC:  CALL    124A
04600:  INC     W1,W1
04602:  BTSC.B  219.1
04604:  BRA     4602
04606:  MOV.B   W0L,21A
04608:  MOV     #F,W0
0460A:  CPSGT   W1,W0
0460C:  BRA     45F8
....................                   unsigned int p=0; 
0460E:  CLR     936
....................                   for(p=0;p<4;p++){ 
04610:  CLR     936
04612:  MOV     936,W4
04614:  CP      W4,#4
04616:  BRA     C,464A
....................                      input_speed[p]=(unsigned)(fgetc(RS232)-48); 
04618:  MOV     936,W0
0461A:  SL      W0,#1,W0
0461C:  MOV     #926,W4
0461E:  ADD     W0,W4,W5
04620:  BTSS.B  218.0
04622:  BRA     4620
04624:  MOV     21C,W0
04626:  ZE      W0,W0
04628:  CLR.B   1
0462A:  SUB     #30,W0
0462C:  MOV     W0,[W5]
....................                      fputc(input_speed[p]+48,RS232); 
0462E:  MOV     936,W0
04630:  SL      W0,#1,W0
04632:  MOV     #926,W4
04634:  ADD     W0,W4,W0
04636:  MOV     [W0],W5
04638:  ADD     #30,W5
0463A:  MOV.B   W5L,W0L
0463C:  BTSC.B  219.1
0463E:  BRA     463C
04640:  MOV.B   W0L,21A
04642:  CLR.B   21B
04644:  INC     0936
04646:  GOTO    4612
....................                   } 
....................                   fprintf(RS232,"\n\r"); 
0464A:  BTSC.B  219.1
0464C:  BRA     464A
0464E:  MOV.B   #A,W0L
04650:  MOV.B   W0L,21A
04652:  BTSC.B  219.1
04654:  BRA     4652
04656:  MOV.B   #D,W0L
04658:  MOV.B   W0L,21A
....................                    
....................                   delay=1000*input_speed[0]+100*input_speed[1]+10*input_speed[2]+1*input_speed[3]; 
0465A:  MOV     #3E8,W4
0465C:  MOV     926,W3
0465E:  MUL.UU  W4,W3,W0
04660:  MOV     W0,W5
04662:  MOV     #64,W4
04664:  MOV     928,W3
04666:  MUL.UU  W4,W3,W0
04668:  ADD     W0,W5,W5
0466A:  MOV     92A,W4
0466C:  MUL.UU  W4,#A,W0
0466E:  ADD     W0,W5,W5
04670:  MOV     W5,W0
04672:  ADD     92C,W0
04674:  MOV     W0,92E
....................        
....................                   unsigned int l; 
....................                   unsigned int pos_cal_2=md_min_distance; 
....................                   unsigned int num_2=(md_move_range-md_min_distance)/10+1; 
04676:  PUSH    8C8
04678:  POP     93A
0467A:  MOV     8BE,W4
0467C:  MOV     8C8,W3
0467E:  SUB     W4,W3,W5
04680:  MOV     W5,W4
04682:  MOV     #A,W3
04684:  REPEAT  #11
04686:  DIV.U   W4,W3
04688:  MOV     W0,W5
0468A:  ADD     W5,#1,W5
0468C:  MOV     W5,93C
....................                    
....................                   for(l=0; l<num_2; l++) 
0468E:  CLR     938
04690:  MOV     938,W0
04692:  MOV     93C,W4
04694:  CP      W4,W0
04696:  BRA     LEU,46B2
....................                   { 
....................                      move_pos(pos_cal_2+l*10); 
04698:  MOV     938,W4
0469A:  MUL.UU  W4,#A,W0
0469C:  MOV     93A,W4
0469E:  ADD     W0,W4,W5
046A0:  MOV     W5,968
046A2:  CALL    2DC8
....................                      delay_ms(delay); 
046A6:  MOV     92E,W0
046A8:  CALL    1586
046AC:  INC     0938
046AE:  GOTO    4690
....................                   } 
....................                    
....................                   pos_cal_2=pos_cal_2+(num_2-1)*10; 
046B2:  MOV     93C,W4
046B4:  SUB     W4,#1,W5
046B6:  MOV     W5,W4
046B8:  MUL.UU  W4,#A,W0
046BA:  ADD     93A
....................                    
....................                   for(l=0; l<num_2; l++) 
046BC:  CLR     938
046BE:  MOV     938,W0
046C0:  MOV     93C,W4
046C2:  CP      W4,W0
046C4:  BRA     LEU,46E0
....................                   { 
....................                      move_pos(pos_cal_2-l*10); 
046C6:  MOV     938,W4
046C8:  MUL.UU  W4,#A,W0
046CA:  MOV     93A,W4
046CC:  SUB     W4,W0,W5
046CE:  MOV     W5,968
046D0:  CALL    2DC8
....................                      delay_ms(delay); 
046D4:  MOV     92E,W0
046D6:  CALL    1586
046DA:  INC     0938
046DC:  GOTO    46BE
....................                   } 
....................                   break; 
046E0:  GOTO    4A3A
....................       case 'd':   fprintf(RS232,"\n\rSet debug state\n\r"); 
046E4:  MOV     #0,W1
046E6:  MOV     W1,W0
046E8:  CLR.B   1
046EA:  CALL    1268
046EE:  INC     W1,W1
046F0:  BTSC.B  219.1
046F2:  BRA     46F0
046F4:  MOV.B   W0L,21A
046F6:  MOV     #12,W0
046F8:  CPSGT   W1,W0
046FA:  BRA     46E6
....................                   fprintf(RS232,"Digital potentiometer (a)(0 or 1): \n\r"); 
046FC:  MOV     #0,W1
046FE:  MOV     W1,W0
04700:  CLR.B   1
04702:  CALL    1288
04706:  INC     W1,W1
04708:  BTSC.B  219.1
0470A:  BRA     4708
0470C:  MOV.B   W0L,21A
0470E:  MOV     #24,W0
04710:  CPSGT   W1,W0
04712:  BRA     46FE
....................                   fprintf(RS232,"Parallel port         (b)(0 or 1): \n\r"); 
04714:  MOV     #0,W1
04716:  MOV     W1,W0
04718:  CLR.B   1
0471A:  CALL    12BA
0471E:  INC     W1,W1
04720:  BTSC.B  219.1
04722:  BRA     4720
04724:  MOV.B   W0L,21A
04726:  MOV     #24,W0
04728:  CPSGT   W1,W0
0472A:  BRA     4716
....................                   fprintf(RS232,"FRAM                  (c)(0 or 1): \n\r"); 
0472C:  MOV     #0,W1
0472E:  MOV     W1,W0
04730:  CLR.B   1
04732:  CALL    12EC
04736:  INC     W1,W1
04738:  BTSC.B  219.1
0473A:  BRA     4738
0473C:  MOV.B   W0L,21A
0473E:  MOV     #24,W0
04740:  CPSGT   W1,W0
04742:  BRA     472E
....................                   fprintf(RS232,"Motor driver          (d)(0 or 1): \n\r"); 
04744:  MOV     #0,W1
04746:  MOV     W1,W0
04748:  CLR.B   1
0474A:  CALL    131E
0474E:  INC     W1,W1
04750:  BTSC.B  219.1
04752:  BRA     4750
04754:  MOV.B   W0L,21A
04756:  MOV     #24,W0
04758:  CPSGT   W1,W0
0475A:  BRA     4746
....................                   fprintf(RS232,"Encoder               (e)(0 or 1): \n\r"); 
0475C:  MOV     #0,W1
0475E:  MOV     W1,W0
04760:  CLR.B   1
04762:  CALL    1350
04766:  INC     W1,W1
04768:  BTSC.B  219.1
0476A:  BRA     4768
0476C:  MOV.B   W0L,21A
0476E:  MOV     #24,W0
04770:  CPSGT   W1,W0
04772:  BRA     475E
....................                   fprintf(RS232,"PWM Module            (f)(0 or 1): \n\r"); 
04774:  MOV     #0,W1
04776:  MOV     W1,W0
04778:  CLR.B   1
0477A:  CALL    1382
0477E:  INC     W1,W1
04780:  BTSC.B  219.1
04782:  BRA     4780
04784:  MOV.B   W0L,21A
04786:  MOV     #24,W0
04788:  CPSGT   W1,W0
0478A:  BRA     4776
....................                   fprintf(RS232,"All Modes             (g)(0 or 1): \n\r"); 
0478C:  MOV     #0,W1
0478E:  MOV     W1,W0
04790:  CLR.B   1
04792:  CALL    13B4
04796:  INC     W1,W1
04798:  BTSC.B  219.1
0479A:  BRA     4798
0479C:  MOV.B   W0L,21A
0479E:  MOV     #24,W0
047A0:  CPSGT   W1,W0
047A2:  BRA     478E
....................                   fprintf(RS232,"Selection (xx): "); 
047A4:  MOV     #0,W1
047A6:  MOV     W1,W0
047A8:  CLR.B   1
047AA:  CALL    13E6
047AE:  INC     W1,W1
047B0:  BTSC.B  219.1
047B2:  BRA     47B0
047B4:  MOV.B   W0L,21A
047B6:  MOV     #F,W0
047B8:  CPSGT   W1,W0
047BA:  BRA     47A6
....................                    
....................                   int1 value=0; 
....................                   unsigned int f=0; 
....................                   char input_ds[2]; 
047BC:  BCLR.B  909.0
047BE:  CLR     93E
....................                   for(f=0;f<2;f++){ 
047C0:  CLR     93E
047C2:  MOV     93E,W4
047C4:  CP      W4,#2
047C6:  BRA     C,47EE
....................                      input_ds[f]=fgetc(RS232); 
047C8:  MOV     #940,W4
047CA:  MOV     93E,W3
047CC:  ADD     W3,W4,W5
047CE:  BTSS.B  218.0
047D0:  BRA     47CE
047D2:  MOV     21C,W0
047D4:  MOV.B   W0L,[W5]
....................                      fputc(input_ds[f],RS232); 
047D6:  MOV     #940,W4
047D8:  MOV     93E,W3
047DA:  ADD     W3,W4,W0
047DC:  MOV.B   [W0],W5L
047DE:  MOV.B   W5L,W0L
047E0:  BTSC.B  219.1
047E2:  BRA     47E0
047E4:  MOV.B   W0L,21A
047E6:  CLR.B   21B
047E8:  INC     093E
047EA:  GOTO    47C2
....................                   } 
....................                   fprintf(RS232,"\n\n\r"); 
047EE:  BTSC.B  219.1
047F0:  BRA     47EE
047F2:  MOV.B   #A,W0L
047F4:  MOV.B   W0L,21A
047F6:  BTSC.B  219.1
047F8:  BRA     47F6
047FA:  MOV.B   #A,W0L
047FC:  MOV.B   W0L,21A
047FE:  BTSC.B  219.1
04800:  BRA     47FE
04802:  MOV.B   #D,W0L
04804:  MOV.B   W0L,21A
....................                    
....................                   if(input_ds[1]=='0') 
04806:  MOV     940,W4
04808:  LSR     W4,#8,W4
0480A:  XOR.B   #30,W4L
0480C:  BRA     NZ,4814
....................                      value=0; 
0480E:  BCLR.B  909.0
04810:  GOTO    483E
....................                   else if(input_ds[1]=='1') 
04814:  MOV     940,W4
04816:  LSR     W4,#8,W4
04818:  XOR.B   #31,W4L
0481A:  BRA     NZ,4822
....................                      value=1; 
0481C:  BSET.B  909.0
0481E:  GOTO    483E
....................                   else 
....................                   { 
....................                      fprintf(RS232,"Invalid Entry\n\r"); 
04822:  MOV     #0,W1
04824:  MOV     W1,W0
04826:  CLR.B   1
04828:  CALL    1404
0482C:  INC     W1,W1
0482E:  BTSC.B  219.1
04830:  BRA     482E
04832:  MOV.B   W0L,21A
04834:  MOV     #E,W0
04836:  CPSGT   W1,W0
04838:  BRA     4824
....................                      break; 
0483A:  GOTO    4A3A
....................                   } 
....................  
....................                   switch (input_ds[0]){ 
0483E:  MOV.B   940,W0L
04840:  CLR.B   1
04842:  XOR     #61,W0
04844:  BRA     Z,4860
04846:  XOR     #3,W0
04848:  BRA     Z,486A
0484A:  XOR     #1,W0
0484C:  BRA     Z,4874
0484E:  XOR     #7,W0
04850:  BRA     Z,487E
04852:  XOR     #1,W0
04854:  BRA     Z,4888
04856:  XOR     #3,W0
04858:  BRA     Z,4892
0485A:  XOR     #1,W0
0485C:  BRA     Z,489C
0485E:  BRA     48C4
....................                      case 'a':   debug_mode_dp = value; 
04860:  BCLR.B  8B0.0
04862:  BTSC.B  909.0
04864:  BSET.B  8B0.0
....................                                  break; 
04866:  GOTO    48E0
....................                      case 'b':   debug_mode_pp = value; 
0486A:  BCLR.B  8B0.1
0486C:  BTSC.B  909.0
0486E:  BSET.B  8B0.1
....................                                  break; 
04870:  GOTO    48E0
....................                      case 'c':   debug_mode_fr = value; 
04874:  BCLR.B  8B0.2
04876:  BTSC.B  909.0
04878:  BSET.B  8B0.2
....................                                  break; 
0487A:  GOTO    48E0
....................                      case 'd':   debug_mode_md = value; 
0487E:  BCLR.B  8B0.3
04880:  BTSC.B  909.0
04882:  BSET.B  8B0.3
....................                                  break; 
04884:  GOTO    48E0
....................                      case 'e':   debug_mode_qei = value; 
04888:  BCLR.B  8B0.5
0488A:  BTSC.B  909.0
0488C:  BSET.B  8B0.5
....................                                  break; 
0488E:  GOTO    48E0
....................                      case 'f':   debug_mode_pwm = value; 
04892:  BCLR.B  8B0.4
04894:  BTSC.B  909.0
04896:  BSET.B  8B0.4
....................                                  break;           
04898:  GOTO    48E0
....................                      case 'g':   debug_mode_dp = value; 
0489C:  BCLR.B  8B0.0
0489E:  BTSC.B  909.0
048A0:  BSET.B  8B0.0
....................                                  debug_mode_pp = value; 
048A2:  BCLR.B  8B0.1
048A4:  BTSC.B  909.0
048A6:  BSET.B  8B0.1
....................                                  debug_mode_fr = value; 
048A8:  BCLR.B  8B0.2
048AA:  BTSC.B  909.0
048AC:  BSET.B  8B0.2
....................                                  debug_mode_md = value; 
048AE:  BCLR.B  8B0.3
048B0:  BTSC.B  909.0
048B2:  BSET.B  8B0.3
....................                                  debug_mode_qei = value; 
048B4:  BCLR.B  8B0.5
048B6:  BTSC.B  909.0
048B8:  BSET.B  8B0.5
....................                                  debug_mode_pwm = value; 
048BA:  BCLR.B  8B0.4
048BC:  BTSC.B  909.0
048BE:  BSET.B  8B0.4
....................                                  break; 
048C0:  GOTO    48E0
....................                      default:    fprintf(RS232,"Invalid Entry\n\r"); 
048C4:  MOV     #0,W1
048C6:  MOV     W1,W0
048C8:  CLR.B   1
048CA:  CALL    1404
048CE:  INC     W1,W1
048D0:  BTSC.B  219.1
048D2:  BRA     48D0
048D4:  MOV.B   W0L,21A
048D6:  MOV     #E,W0
048D8:  CPSGT   W1,W0
048DA:  BRA     48C6
....................                                  break; 
048DC:  GOTO    48E0
....................                   } 
....................                   break; 
048E0:  GOTO    4A3A
....................       case 'w':   fprintf(RS232,"\n\rEncoder count %4u\n\r",qei_get_count()); 
048E4:  CALL    2262
048E8:  MOV     W0,W5
048EA:  MOV     #0,W1
048EC:  MOV     W1,W0
048EE:  CLR.B   1
048F0:  CALL    1420
048F4:  INC     W1,W1
048F6:  BTSC.B  219.1
048F8:  BRA     48F6
048FA:  MOV.B   W0L,21A
048FC:  MOV     #F,W0
048FE:  CPSGT   W1,W0
04900:  BRA     48EC
04902:  MOV     W5,W0
04904:  MOV     #4,W4
04906:  CALL    1596
0490A:  BTSC.B  219.1
0490C:  BRA     490A
0490E:  MOV.B   #A,W0L
04910:  MOV.B   W0L,21A
04912:  BTSC.B  219.1
04914:  BRA     4912
04916:  MOV.B   #D,W0L
04918:  MOV.B   W0L,21A
....................                   break; 
0491A:  GOTO    4A3A
....................       case 'z':   fprintf(RS232,"\n\rStart Memory Test (Yes -> 1, No -> 0): "); 
0491E:  MOV     #0,W1
04920:  MOV     W1,W0
04922:  CLR.B   1
04924:  CALL    1442
04928:  INC     W1,W1
0492A:  BTSC.B  219.1
0492C:  BRA     492A
0492E:  MOV.B   W0L,21A
04930:  MOV     #28,W0
04932:  CPSGT   W1,W0
04934:  BRA     4920
....................                   unsigned int input_mem_test=(unsigned)(fgetc(RS232)-48); 
04936:  BTSS.B  218.0
04938:  BRA     4936
0493A:  MOV     21C,W0
0493C:  ZE      W0,W0
0493E:  CLR.B   1
04940:  SUB     #30,W0
04942:  MOV     W0,942
....................                   fputc(input_mem_test+48,RS232); 
04944:  MOV     #30,W4
04946:  MOV     942,W3
04948:  ADD     W3,W4,W5
0494A:  MOV.B   W5L,W0L
0494C:  BTSC.B  219.1
0494E:  BRA     494C
04950:  MOV.B   W0L,21A
04952:  CLR.B   21B
....................                   
....................                   unsigned int8 mem=0; 
04954:  CLR.B   944
....................                    
....................                   if(input_mem_test == 1) 
04956:  MOV     942,W4
04958:  CP      W4,#1
0495A:  BRA     NZ,49AA
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
0495C:  CLR.B   944
0495E:  MOV     944,W4
04960:  MOV     #64,W3
04962:  CP.B    W3L,W4L
04964:  BRA     LEU,497E
....................                         data_set_pos(mem, mem+1); 
04966:  MOV     944,W4
04968:  CLR.B   9
0496A:  ADD     W4,#1,W4
0496C:  MOV     W4,W5
0496E:  MOV.B   944,W0L
04970:  MOV.B   W0L,966
04972:  MOV     W5,968
04974:  CALL    3636
04978:  INC.B   0944
0497A:  GOTO    495E
....................                          
....................                      fprintf(RS232,"\n\r"); 
0497E:  BTSC.B  219.1
04980:  BRA     497E
04982:  MOV.B   #A,W0L
04984:  MOV.B   W0L,21A
04986:  BTSC.B  219.1
04988:  BRA     4986
0498A:  MOV.B   #D,W0L
0498C:  MOV.B   W0L,21A
....................                       
....................                      debug_mode_fr=1; 
0498E:  BSET.B  8B0.2
....................                      for(mem=0; mem<100; mem++) 
04990:  CLR.B   944
04992:  MOV     944,W4
04994:  MOV     #64,W3
04996:  CP.B    W3L,W4L
04998:  BRA     LEU,49A8
....................                         data_get_pos(mem); 
0499A:  MOV.B   944,W0L
0499C:  MOV.B   W0L,96A
0499E:  CALL    3742
049A2:  INC.B   0944
049A4:  GOTO    4992
....................                      debug_mode_fr=0; 
049A8:  BCLR.B  8B0.2
....................                   } 
....................                   break; 
049AA:  GOTO    4A3A
....................       case 'f':   fprintf(RS232,"\n\rClear Memory (Yes -> 1, No -> 0): "); 
049AE:  MOV     #0,W1
049B0:  MOV     W1,W0
049B2:  CLR.B   1
049B4:  CALL    147A
049B8:  INC     W1,W1
049BA:  BTSC.B  219.1
049BC:  BRA     49BA
049BE:  MOV.B   W0L,21A
049C0:  MOV     #23,W0
049C2:  CPSGT   W1,W0
049C4:  BRA     49B0
....................                   input_mem_test=(unsigned)(fgetc(RS232)-48); 
049C6:  BTSS.B  218.0
049C8:  BRA     49C6
049CA:  MOV     21C,W0
049CC:  ZE      W0,W0
049CE:  CLR.B   1
049D0:  SUB     #30,W0
049D2:  MOV     W0,942
....................                   fputc(input_mem_test+48,RS232); 
049D4:  MOV     #30,W4
049D6:  MOV     942,W3
049D8:  ADD     W3,W4,W5
049DA:  MOV.B   W5L,W0L
049DC:  BTSC.B  219.1
049DE:  BRA     49DC
049E0:  MOV.B   W0L,21A
049E2:  CLR.B   21B
....................                    
....................                   if(input_mem_test == 1) 
049E4:  MOV     942,W4
049E6:  CP      W4,#1
049E8:  BRA     NZ,4A30
....................                   { 
....................                      for(mem=0; mem<100; mem++) 
049EA:  CLR.B   944
049EC:  MOV     944,W4
049EE:  MOV     #64,W3
049F0:  CP.B    W3L,W4L
049F2:  BRA     LEU,4A04
....................                         data_set_pos(mem, 0); 
049F4:  MOV.B   944,W0L
049F6:  MOV.B   W0L,966
049F8:  CLR     968
049FA:  CALL    3636
049FE:  INC.B   0944
04A00:  GOTO    49EC
....................                          
....................                      fprintf(RS232,"\n\r"); 
04A04:  BTSC.B  219.1
04A06:  BRA     4A04
04A08:  MOV.B   #A,W0L
04A0A:  MOV.B   W0L,21A
04A0C:  BTSC.B  219.1
04A0E:  BRA     4A0C
04A10:  MOV.B   #D,W0L
04A12:  MOV.B   W0L,21A
....................                       
....................                      debug_mode_fr=1; 
04A14:  BSET.B  8B0.2
....................                      for(mem=0; mem<100; mem++) 
04A16:  CLR.B   944
04A18:  MOV     944,W4
04A1A:  MOV     #64,W3
04A1C:  CP.B    W3L,W4L
04A1E:  BRA     LEU,4A2E
....................                         data_get_pos(mem); 
04A20:  MOV.B   944,W0L
04A22:  MOV.B   W0L,96A
04A24:  CALL    3742
04A28:  INC.B   0944
04A2A:  GOTO    4A18
....................                      debug_mode_fr=0; 
04A2E:  BCLR.B  8B0.2
....................                   } 
....................                   break; 
04A30:  GOTO    4A3A
....................       case 'a':   reset_cpu(); 
04A34:  RESET   
....................                   break; 
04A36:  GOTO    4A3A
....................    } 
....................     
....................    return; 
04A3A:  MOV     [--W15],W6
04A3C:  MOV     [--W15],W5
04A3E:  RETURN  
.................... } 
....................  
.................... // Limit switch signal interrupt 
.................... #INT_EXT1 
.................... void isr_md_limit() 
*
01542:  PUSH    42
01544:  PUSH    36
01546:  PUSH    32
01548:  MOV     W0,[W15++]
0154A:  MOV     #2,W0
0154C:  REPEAT  #C
0154E:  MOV     [W0++],[W15++]
.................... { 
....................    reg_md_limit = 1; 
01550:  BSET.B  8FE.4
.................... } 
.................... // RS232 receive byte interrupt 
01552:  BCLR.B  86.0
01554:  MOV     #1A,W0
01556:  REPEAT  #C
01558:  MOV     [--W15],[W0--]
0155A:  MOV     [--W15],W0
0155C:  POP     32
0155E:  POP     36
01560:  POP     42
01562:  RETFIE  
.................... #INT_RDA2 
.................... void isr_rs232_message() 
01564:  PUSH    42
01566:  PUSH    36
01568:  PUSH    32
0156A:  MOV     W0,[W15++]
0156C:  MOV     #2,W0
0156E:  REPEAT  #C
01570:  MOV     [W0++],[W15++]
.................... { 
....................    // Receive the RS232 message 
....................    reg_rs232_message = 1;   
01572:  BSET.B  8FE.2
01574:  BCLR.B  87.0
01576:  MOV     #1A,W0
01578:  REPEAT  #C
0157A:  MOV     [--W15],[W0--]
0157C:  MOV     [--W15],W0
0157E:  POP     32
01580:  POP     36
01582:  POP     42
01584:  RETFIE  
.................... }  
.................... // Clears RS232 interrupt flags 
.................... void rs232_clear() 
.................... { 
....................    UART_IFS0_U1RXIF = 0; 
....................    UART_IFS0_U1TXIF = 0; 
....................    reg_rs232_message = 0; 
.................... } 
....................  
.................... // Main method 
.................... void main() 
*
04A40:  BSET.B  81.7
04A42:  MOV     #8000,W4
04A44:  MOV     W4,216
04A46:  MOV     #400,W4
04A48:  MOV     W4,218
04A4A:  MOV     #2,W4
04A4C:  MOV     W4,21E
04A4E:  BCLR.B  8B0.0
04A50:  BCLR.B  8B0.1
04A52:  BCLR.B  8B0.2
04A54:  BCLR.B  8B0.3
04A56:  BCLR.B  8B0.4
04A58:  BCLR.B  8B0.5
04A5A:  MOV     #20,W4
04A5C:  MOV     W4,8B2
04A5E:  MOV     #3FF,W4
04A60:  MOV     W4,8B4
04A62:  MOV     #323,W4
04A64:  MOV     W4,8B6
04A66:  MOV     #38,W4
04A68:  MOV     W4,8B8
04A6A:  MOV     #1C,W4
04A6C:  MOV     W4,8BA
04A6E:  CLR     8BC
04A70:  MOV     #190,W4
04A72:  MOV     W4,8BE
04A74:  MOV     #2D,W4
04A76:  MOV     W4,8C0
04A78:  MOV     #3E8,W4
04A7A:  MOV     W4,8C2
04A7C:  MOV     #32,W4
04A7E:  MOV     W4,8C4
04A80:  MOV     #64,W4
04A82:  MOV     W4,8C6
04A84:  MOV     #46,W4
04A86:  MOV     W4,8C8
04A88:  CLR     8CA
04A8A:  MOV     #BB8,W4
04A8C:  MOV     W4,8CC
04A8E:  MOV     #BB8,W4
04A90:  MOV     W4,8CE
04A92:  MOV     #64,W4
04A94:  MOV     W4,8D0
04A96:  CLR.B   8B1
04A98:  CLR     8D2
04A9A:  CLR     8D4
04A9C:  CLR     8D6
04A9E:  CLR     8D8
04AA0:  CLR     8DA
04AA2:  CLR     8DC
04AA4:  CLR     8DE
04AA6:  CLR     8E0
04AA8:  MOV     #1F4,W4
04AAA:  MOV     W4,8E2
04AAC:  CLR     8E4
04AAE:  MOV     #D,W4
04AB0:  MOV     W4,8E6
04AB2:  MOV     #F,W4
04AB4:  MOV     W4,8E8
04AB6:  MOV     #11,W4
04AB8:  MOV     W4,8EA
04ABA:  MOV     #13,W4
04ABC:  MOV     W4,8EC
04ABE:  MOV     #15,W4
04AC0:  MOV     W4,8EE
04AC2:  MOV     #17,W4
04AC4:  MOV     W4,8F0
04AC6:  MOV     #18,W4
04AC8:  MOV     W4,8F2
04ACA:  MOV     #1A,W4
04ACC:  MOV     W4,8F4
04ACE:  MOV     #3E8,W4
04AD0:  MOV     W4,8F6
04AD2:  MOV     #1,W4
04AD4:  MOV     W4,8F8
04AD6:  MOV     #A,W4
04AD8:  MOV     W4,8FA
04ADA:  MOV     #A,W4
04ADC:  MOV     W4,8FC
04ADE:  BCLR.B  8B0.6
04AE0:  BCLR.B  8B0.7
04AE2:  BCLR.B  8FE.0
04AE4:  BCLR.B  8FE.1
04AE6:  BCLR.B  8FE.2
04AE8:  BCLR.B  8FE.3
04AEA:  BCLR.B  8FE.4
04AEC:  MOV     #58,W4
04AEE:  MOV     W4,900
04AF0:  SETM    2A8
04AF2:  MOV     #2780,W15
04AF4:  MOV     #27FF,W0
04AF6:  MOV     W0,20
04AF8:  NOP     
04AFA:  BRA     4B90
04AFC:  DATA    C0,06,08
04AFE:  DATA    00,00,00
04B00:  DATA    4B,F0,3F
04B02:  DATA    5C,0A,58
04B04:  DATA    F6,3B,8F
04B06:  DATA    00,C0,3C
04B08:  DATA    8B,28,AC
04B0A:  DATA    3C,BE,F6
04B0C:  DATA    3F,D2,D5
04B0E:  DATA    44,16,8C
04B10:  DATA    15,D7,BF
04B12:  DATA    69,00,5A
04B14:  DATA    2E,1B,87
04B16:  DATA    99,3F,9A
04B18:  DATA    5F,AD,4B
04B1A:  DATA    91,E4,01
04B1C:  DATA    C0,5D,11
04B1E:  DATA    2F,92,E4
04B20:  DATA    81,FB,3F
04B22:  DATA    38,DA,91
04B24:  DATA    80,9D,C5
04B26:  DATA    E0,BF,6F
04B28:  DATA    12,C0,B4
04B2A:  DATA    C3,09,AB
04B2C:  DATA    3F,6B,C1
04B2E:  DATA    03,4E,C1
04B30:  DATA    B5,45,BF
04B32:  DATA    F7,40,05
04B34:  DATA    FF,00,5A
04B36:  DATA    EF,3F,F3
04B38:  DATA    A3,E2,F7
04B3A:  DATA    D7,FF,01
04B3C:  DATA    40,C0,B4
04B3E:  DATA    FF,05,3C
04B40:  DATA    58,FC,3F
04B42:  DATA    3B,D3,C0
04B44:  DATA    B5,BA,8C
04B46:  DATA    E2,3F,39
04B48:  DATA    D3,C7,3D
04B4A:  DATA    41,79,B2
04B4C:  DATA    3F,87,0D
04B4E:  DATA    3C,50,D0
04B50:  DATA    AF,62,3F
04B52:  DATA    30,4B,8D
04B54:  DATA    A2,82,AA
04B56:  DATA    04,40,09
04B58:  DATA    A0,40,4A
04B5A:  DATA    05,76,03
04B5C:  DATA    40,EC,9E
04B5E:  DATA    37,88,A6
04B60:  DATA    44,F0,3F
04B62:  DATA    8F,12,8D
04B64:  DATA    29,9A,5B
04B66:  DATA    C7,3F,0E
04B68:  DATA    E0,80,7C
04B6A:  DATA    A1,D8,86
04B6C:  DATA    3F,29,4B
04B6E:  DATA    FB,95,C2
04B70:  DATA    37,1A,3F
04B72:  DATA    00,00,00
04B74:  INC     W2,W2
04B76:  CP      W2,#1
04B78:  BRA     NZ,4B82
04B7A:  TBLRDL  [W1],W3
04B7C:  TBLRDH  [W1++],W4
04B7E:  MOV.B   6,W0L
04B80:  RETURN  
04B82:  CP      W2,#2
04B84:  BRA     NZ,4B8A
04B86:  MOV.B   7,W0L
04B88:  RETURN  
04B8A:  MOV.B   8,W0L
04B8C:  CLR     W2
04B8E:  RETURN  
04B90:  MOV     #0,W6
04B92:  MOV     #0,W0
04B94:  MOV     W0,32
04B96:  MOV     #4AFC,W0
04B98:  MOV     W0,W1
04B9A:  CLR     W2
04B9C:  CALL    4B74
04BA0:  MOV.B   W0L,B
04BA2:  CALL    4B74
04BA6:  MOV.B   W0L,A
04BA8:  CP0     W5
04BAA:  BRA     Z,4BDE
04BAC:  BTSS    W5.F
04BAE:  BRA     4BBE
04BB0:  CALL    4B74
04BB4:  MOV.B   W0L,D
04BB6:  CALL    4B74
04BBA:  MOV.B   W0L,C
04BBC:  BCLR    W5.F
04BBE:  BTSS    W5.E
04BC0:  BRA     4BD2
04BC2:  BCLR    W5.E
04BC4:  DEC     W5,W5
04BC6:  CALL    4B74
04BCA:  MOV.B   W0L,W7L
04BCC:  REPEAT  W5
04BCE:  MOV.B   W7L,[W6++]
04BD0:  BRA     4B9C
04BD2:  CALL    4B74
04BD6:  MOV.B   W0L,[W6++]
04BD8:  DEC     W5,W5
04BDA:  BRA     NZ,4BD2
04BDC:  BRA     4B9C
.................... { 
....................    // Set I/O states of the ports 
....................    //           FEDCBA9876543210 
....................    set_tris_b(0b1111111111111010); 
04BDE:  MOV     #FFFA,W4
04BE0:  MOV     W4,2C6
....................    set_tris_c(0b1111111111111111); 
04BE2:  SETM    2CC
....................    set_tris_d(0b1111111100001111); 
04BE4:  MOV     #FF0F,W4
04BE6:  MOV     W4,2D2
....................    set_tris_e(0b1111111100011110); 
04BE8:  MOV     #FF1E,W4
04BEA:  MOV     W4,2D8
....................    set_tris_f(0b1111111110010100); 
04BEC:  MOV     #FF94,W4
04BEE:  MOV     W4,2DE
....................    set_tris_g(0b1111111000110111); 
04BF0:  MOV     #FE37,W4
04BF2:  MOV     W4,2E4
....................     
....................    // Set parallel port pins 
....................    output_low(PP_ACK); 
04BF4:  BCLR.B  2D2.4
04BF6:  BCLR.B  2D6.4
....................    output_low(PP_RDY); 
04BF8:  BCLR.B  2D2.5
04BFA:  BCLR.B  2D6.5
....................     
....................    // Turn on debug led 
....................    output_high(LED); 
04BFC:  BCLR.B  2C6.0
04BFE:  BSET.B  2CA.0
....................     
....................    //Turn on lasers 
....................    output_high(LAS_1); 
04C00:  BCLR.B  2E4.6
04C02:  BSET.B  2E8.6
....................    output_high(LAS_2); 
04C04:  BCLR.B  2E4.7
04C06:  BSET.B  2E8.7
....................    output_high(LAS_3); 
04C08:  BCLR.B  2E5.0
04C0A:  BSET.B  2E9.0
....................  
....................    // Set A/D converter to read motor torque control voltage 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
04C0C:  MOV     #1F80,W4
04C0E:  MOV     W4,2A4
04C10:  MOV     #80E0,W4
04C12:  MOV     W4,2A0
....................    setup_adc_ports(sAN1); 
04C14:  MOV     #FFFD,W4
04C16:  MOV     W4,2A8
04C18:  CLR     2A2
....................    set_adc_channel(1); 
04C1A:  MOV     #1,W4
04C1C:  MOV     W4,2A6
....................     
....................    delay_ms(500); 
04C1E:  MOV     #1F4,W0
04C20:  CALL    1586
....................    fprintf(RS232,"\n\r"); 
04C24:  BTSC.B  219.1
04C26:  BRA     4C24
04C28:  MOV.B   #A,W0L
04C2A:  MOV.B   W0L,21A
04C2C:  BTSC.B  219.1
04C2E:  BRA     4C2C
04C30:  MOV.B   #D,W0L
04C32:  MOV.B   W0L,21A
....................    fprintf(RS232,"______________________________________________________________\n\r"); 
04C34:  MOV.B   #3E,W5L
04C36:  MOV     #5F,W0
04C38:  BTSC.B  219.1
04C3A:  BRA     4C38
04C3C:  MOV.B   W0L,21A
04C3E:  DEC.B   000A
04C40:  BTSS.B  42.1
04C42:  BRA     4C36
04C44:  BTSC.B  219.1
04C46:  BRA     4C44
04C48:  MOV.B   #A,W0L
04C4A:  MOV.B   W0L,21A
04C4C:  BTSC.B  219.1
04C4E:  BRA     4C4C
04C50:  MOV.B   #D,W0L
04C52:  MOV.B   W0L,21A
....................    fprintf(RS232,"\n\n\rMODESIS LASER POSITIONING SYSTEM\n\n\r"); 
04C54:  MOV     #0,W1
04C56:  MOV     W1,W0
04C58:  CLR.B   1
04C5A:  CALL    14AC
04C5E:  INC     W1,W1
04C60:  BTSC.B  219.1
04C62:  BRA     4C60
04C64:  MOV.B   W0L,21A
04C66:  MOV     #25,W0
04C68:  CPSGT   W1,W0
04C6A:  BRA     4C56
....................    fprintf(RS232,"\n\n\rCode Version V2.1 Without Interrupt\n\n\r"); 
04C6C:  MOV     #0,W1
04C6E:  MOV     W1,W0
04C70:  CLR.B   1
04C72:  CALL    14E0
04C76:  INC     W1,W1
04C78:  BTSC.B  219.1
04C7A:  BRA     4C78
04C7C:  MOV.B   W0L,21A
04C7E:  MOV     #28,W0
04C80:  CPSGT   W1,W0
04C82:  BRA     4C6E
....................    fprintf(RS232,"Press 'c' for command list\n\n\r"); 
04C84:  MOV     #0,W1
04C86:  MOV     W1,W0
04C88:  CLR.B   1
04C8A:  CALL    1518
04C8E:  INC     W1,W1
04C90:  BTSC.B  219.1
04C92:  BRA     4C90
04C94:  MOV.B   W0L,21A
04C96:  MOV     #1C,W0
04C98:  CPSGT   W1,W0
04C9A:  BRA     4C86
....................    data_get_reset_state(); 
04C9C:  CALL    1648
....................  
....................    // Enable limit switch interrupt 
....................    ext_int_edge(1, L_TO_H); 
04CA0:  BCLR.B  82.1
....................    enable_interrupts(INT_EXT1); 
04CA2:  BSET.B  8E.0
....................  
....................    // Initialize components 
....................    qei_init();                            // Initialize quadrature encoder  
04CA4:  CALL    194E
....................    pwm_init();                            // Initialize PWM module 
04CA8:  CALL    19B2
....................    dp_init();                             // Initialize digital potentiometer 
04CAC:  CALL    19F0
....................    md_init();                             // Initialize motor driver 
04CB0:  CALL    1EDE
....................    fr_init();                             // Initialize FRAM 
04CB4:  CALL    1F00
....................    move_init();                           // Initializes the system for movement 
04CB8:  CALL    305C
....................     
....................    // Enable RS232 receive byte interrupt 
....................    enable_interrupts(INT_RDA2); 
04CBC:  BSET.B  8F.0
....................     
....................    reg_comm_type = data_get_comm_type();  // Set communication type 
04CBE:  CALL    30F6
04CC2:  BCLR.B  8B0.6
04CC4:  BTSC.B  0.0
04CC6:  BSET.B  8B0.6
....................     
....................    switch (reg_comm_type) 
04CC8:  CLR.B   W0
04CCA:  BTSC.B  8B0.6
04CCC:  INC     W0,W0
04CCE:  CLR.B   1
04CD0:  XOR     #0,W0
04CD2:  BRA     Z,4CDA
04CD4:  XOR     #1,W0
04CD6:  BRA     Z,4CE6
04CD8:  BRA     4CF2
....................    { 
....................       case 0   :  output_high(PP_ACK); 
04CDA:  BCLR.B  2D2.4
04CDC:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04CDE:  BCLR.B  2D2.5
04CE0:  BSET.B  2D6.5
....................                   break; 
04CE2:  GOTO    4D08
....................       case 1   :  output_low(PP_ACK); 
04CE6:  BCLR.B  2D2.4
04CE8:  BCLR.B  2D6.4
....................                   output_low(PP_RDY); 
04CEA:  BCLR.B  2D2.5
04CEC:  BCLR.B  2D6.5
....................                   break; 
04CEE:  GOTO    4D08
....................       default:    output_high(PP_ACK); 
04CF2:  BCLR.B  2D2.4
04CF4:  BSET.B  2D6.4
....................                   output_high(PP_RDY); 
04CF6:  BCLR.B  2D2.5
04CF8:  BSET.B  2D6.5
....................                   fr_write_byte(fr_comm_type, 0); 
04CFA:  CLR.B   984
04CFC:  PUSH    8F0
04CFE:  POP     982
04D00:  CALL    2590
....................                   break; 
04D04:  GOTO    4D08
....................    } 
....................     
....................    while(true) 
....................    { 
....................       if(reg_md_limit) 
04D08:  BTSS.B  8FE.4
04D0A:  BRA     4D22
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04D0C:  BCLR.B  8F.0
....................          // Disable limit switch interrupt 
....................          disable_interrupts(INT_EXT1); 
04D0E:  BCLR.B  8E.0
....................           
....................          reg_md_limit=0; 
04D10:  BCLR.B  8FE.4
....................          move_from_limit(); 
04D12:  CALL    316C
....................  
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
04D16:  REPEAT  #3
04D18:  MOV     21C,W0
04D1A:  BCLR.B  87.0
....................          enable_interrupts(INT_RDA2); 
04D1C:  BSET.B  8F.0
....................          // Enable limit switch interrupt 
....................          clear_interrupt(INT_EXT1); 
04D1E:  BCLR.B  86.0
....................          enable_interrupts(INT_EXT1); 
04D20:  BSET.B  8E.0
....................       } 
....................       if(input(PP_STR) == 0) 
04D22:  BSET.B  2D3.1
04D24:  BTSC.B  2D5.1
04D26:  BRA     4D62
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04D28:  BCLR.B  8F.0
....................          unsigned int i; 
....................          int sum = 0; 
04D2A:  CLR     904
....................           
....................          for(i=0; i<1000; i++) 
04D2C:  CLR     902
04D2E:  MOV     902,W4
04D30:  MOV     #3E8,W3
04D32:  CP      W3,W4
04D34:  BRA     LEU,4D4E
....................          { 
....................             delay_us(pp_str_delay); 
04D36:  MOV     8F8,W0
04D38:  CALL    21E4
....................             if(input(PP_STR) == 0) 
04D3C:  BSET.B  2D3.1
04D3E:  BTSC.B  2D5.1
04D40:  BRA     4D48
....................                sum += 1; 
04D42:  MOV     904,W4
04D44:  ADD     W4,#1,W4
04D46:  MOV     W4,904
04D48:  INC     0902
04D4A:  GOTO    4D2E
....................          } 
....................          if(sum > 700){ 
04D4E:  MOV     904,W4
04D50:  MOV     #2BC,W3
04D52:  CP      W3,W4
04D54:  BRA     GE,4D5A
....................             pp_get_command(); 
04D56:  CALL    3826
....................          } 
....................          //fprintf(RS232,"sum: %u\n\r",sum); 
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
04D5A:  REPEAT  #3
04D5C:  MOV     21C,W0
04D5E:  BCLR.B  87.0
....................          enable_interrupts(INT_RDA2); 
04D60:  BSET.B  8F.0
....................       } 
....................       if(reg_rs232_message) 
04D62:  BTSS.B  8FE.2
04D64:  BRA     4D76
....................       { 
....................          // Disable RS232 receive byte interrupt 
....................          disable_interrupts(INT_RDA2); 
04D66:  BCLR.B  8F.0
....................           
....................          reg_rs232_message = 0; 
04D68:  BCLR.B  8FE.2
....................          rs232_message(); 
04D6A:  CALL    3F40
....................           
....................          // Enable RS232 receive byte interrupt 
....................          clear_interrupt(INT_RDA2); 
04D6E:  REPEAT  #3
04D70:  MOV     21C,W0
04D72:  BCLR.B  87.0
....................          enable_interrupts(INT_RDA2); 
04D74:  BSET.B  8F.0
....................       } 
04D76:  GOTO    4D08
....................    } 
.................... } 
04D7A:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 8100   FRC NOCKSFSM
          H: FF00  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: FF00  
   Word  3L: 8733   PUT64 BORRES NOBROWNOUT LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: FF00  
   Word  4L: 310F   NOWRTB NOBSS NOEBS NORBS
          H: FF00  
   Word  5L: 310F   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  6L: 0005   NOWRT PROTECT
          H: FF00  
   Word  7L: C003   ICSP1 NODEBUG
          H: FF00   NODEBUG
